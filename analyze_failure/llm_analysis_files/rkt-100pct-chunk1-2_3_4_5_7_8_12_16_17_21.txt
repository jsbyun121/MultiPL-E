As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 2 (RKT) - HumanEval_2_truncate_number
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-within (candidate 3.5) 0.5 0.001)
    (check-within (candidate 1.25) 0.25 0.001)
    (check-within (candidate 123.0) 0.0 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5

;; Given a positive floating point number, it can be decomposed into
;; an integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define int-part (floor number))
  (- number int-part))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-within (candidate 3.5) 0.5 0.001)
    (check-within (candidate 1.25) 0.25 0.001)
    (check-within (candidate 123.0) 0.0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183816
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5

;; Given a positive floating point number, it can be decomposed into
;; an integer part (largest integer smaller than given number) and
;; decimals (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (- number (floor number)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-within (candidate 3.5) 0.5 0.001)
    (check-within (candidate 1.25) 0.25 0.001)
    (check-within (candidate 123.0) 0.0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183816
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5

;; Given a positive floating point number, it can be decomposed into
;; an integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (- number (floor number)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-within (candidate 3.5) 0.5 0.001)
    (check-within (candidate 1.25) 0.25 0.001)
    (check-within (candidate 123.0) 0.0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183816
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5

;; Given a positive floating point number, it can be decomposed into
;; an integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (- number (floor number)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-within (candidate 3.5) 0.5 0.001)
    (check-within (candidate 1.25) 0.25 0.001)
    (check-within (candidate 123.0) 0.0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183816
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 3 (RKT) - HumanEval_3_below_zero
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; You're given a list of deposit and withdrawal operations on a bank account that starts with
;; zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
;; at that point function should return #t. Otherwise it should return #f.
;; >>> (below_zero (list 1 2 3))
;; #f
;; >>> (below_zero (list 1 2 -4 5))
;; #t

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate below_zero))
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list 1 2 -3 1 2 -3)) #f 0.001)
    (check-within (candidate (list 1 2 -4 5 6)) #t 0.001)
    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -4)) #f 0.001)
    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -5)) #t 0.001)
    (check-within (candidate (list 1 -2 2 -2 5 -5 4 -4)) #t 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; You're given a list of deposit and withdrawal operations on a bank account that starts with
;; zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
;; at that point function should return #t. Otherwise it should return #f.
;; >>> (below_zero (list 1 2 3))
;; #f
;; >>> (below_zero (list 1 2 -4 5))
;; #t

;; You're given a list of deposit and withdrawal operations on a bank account that starts with
;; zero balance. Your task is to detect if at any point the balance of account fallls below zero,
;; and at that point function should return #t. Otherwise it should return #f.
;; >>> (below_zero (list 1 2 3))
;; #f
;; >>> (below_zero (list 1 2 -4 5))
;; #t
(define (below_zero operations)
  ;; Recursive helper that keeps the current balance.
  (let loop ((ops operations) (balance 0))
    (cond
      [(empty? ops) #f]                                   ; no more operations → never fell below zero
      [(< (+ balance (first ops)) 0) #t]                  ; next operation would make balance negative
      [else (loop (rest ops) (+ balance (first ops)))]))) ; continue with updated balance
(require rackunit)

(define (test-humaneval) 

  (let (( candidate below_zero))
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list 1 2 -3 1 2 -3)) #f 0.001)
    (check-within (candidate (list 1 2 -4 5 6)) #t 0.001)
    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -4)) #f 0.001)
    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -5)) #t 0.001)
    (check-within (candidate (list 1 -2 2 -2 5 -5 4 -4)) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183817
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; You're given a list of deposit and withdrawal operations on a bank account that starts with
;; zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
;; at that point function should return #t. Otherwise it should return #f.
;; >>> (below_zero (list 1 2 3))
;; #f
;; >>> (below_zero (list 1 2 -4 5))
;; #t

;; You're given a list of deposit and withdrawal operations on a bank account that starts with
;; zero balance. Your task is to detect if at any point the balance of account falls below zero,
;; and at that point function should return #t. Otherwise it should return #f.
;; >>> (below_zero (list 1 2 3))
;; #f
;; >>> (below_zero (list 1 2 -4 5))
;; #t
(define (below_zero operations)
  (define (loop ops bal)
    (cond
      [(null? ops) #f]                                 ; finished without going negative
      [else
       (let ([new-bal (+ bal (car ops))])
         (if (< new-bal 0)
             #t                ; fell below zero
             (loop (cdr ops) new-bal)))]))
  (loop operations 0))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate below_zero))
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list 1 2 -3 1 2 -3)) #f 0.001)
    (check-within (candidate (list 1 2 -4 5 6)) #t 0.001)
    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -4)) #f 0.001)
    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -5)) #t 0.001)
    (check-within (candidate (list 1 -2 2 -2 5 -5 4 -4)) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183817
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; You're given a list of deposit and withdrawal operations on a bank account that starts with
;; zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
;; at that point function should return #t. Otherwise it should return #f.
;; >>> (below_zero (list 1 2 3))
;; #f
;; >>> (below_zero (list 1 2 -4 5))
;; #t

;; You're given a list of deposit and withdrawal operations on a bank account that starts with
;; zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
;; at that point function should return #t. Otherwise it should return #f.
;; >>> (below_zero (list 1 2 3))
;; #f
;; >>> (below_zero (list 1 2 -4 5))
;; #t
(define (below_zero operations)
  (let loop ((ops operations) (balance 0))
    (cond
      [(empty? ops) #f]
      [else
       (let ((new-bal (+ balance (first ops))))
         (if (< new-bal 0)
             #t
             (loop (rest ops) new-bal)))]))
)
(require rackunit)

(define (test-humaneval) 

  (let (( candidate below_zero))
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list 1 2 -3 1 2 -3)) #f 0.001)
    (check-within (candidate (list 1 2 -4 5 6)) #t 0.001)
    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -4)) #f 0.001)
    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -5)) #t 0.001)
    (check-within (candidate (list 1 -2 2 -2 5 -5 4 -4)) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183817
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; You're given a list of deposit and withdrawal operations on a bank account that starts with
;; zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
;; at that point function should return #t. Otherwise it should return #f.
;; >>> (below_zero (list 1 2 3))
;; #f
;; >>> (below_zero (list 1 2 -4 5))
;; #t

;; You're given a list of deposit and withdrawal operations on a bank account that starts with
;; zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
;; at that point function should return #t. Otherwise it should return #f.
;; >>> (below_zero (list 1 2 3))
;; #f
;; >>> (below_zero (list 1 2 -4 5))
;; #t
(define (below_zero operations)
  (define (loop ops bal)
    (cond
      [(null? ops) #f]                                   ; no more operations, never went below zero
      [(< (+ bal (car ops)) 0) #t]                       ; balance would drop below zero
      [else (loop (cdr ops) (+ bal (car ops)))]))        ; continue with updated balance
  (loop operations 0))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate below_zero))
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list 1 2 -3 1 2 -3)) #f 0.001)
    (check-within (candidate (list 1 2 -4 5 6)) #t 0.001)
    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -4)) #f 0.001)
    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -5)) #t 0.001)
    (check-within (candidate (list 1 -2 2 -2 5 -5 4 -4)) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183817
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 4 (RKT) - HumanEval_4_mean_absolute_deviation
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-within (candidate (list 1.0 2.0)) 0.5 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0)) 1.0 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (if (null? numbers)
      0
      (let* ((n (length numbers))
             (mean (/ (apply + numbers) n))
             (sum-abs (apply + (map (lambda (x) (abs (- x mean))) numbers))))
        (/ sum-abs n))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-within (candidate (list 1.0 2.0)) 0.5 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0)) 1.0 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183818
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (if (null? numbers)
      0
      (let* ([n (length numbers)]
             [mean (/ (apply + numbers) n)]
             [sum-abs (apply + (map (lambda (x) (abs (- x mean))) numbers))])
        (/ sum-abs n))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-within (candidate (list 1.0 2.0)) 0.5 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0)) 1.0 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183818
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (let* ([n (length numbers)]
         [sum (apply + numbers)]
         [mean (if (= n 0) 0 (/ sum n))])
    (if (= n 0)
        0
        (/ (apply + (map (lambda (x) (abs (- x mean))) numbers))
           n))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-within (candidate (list 1.0 2.0)) 0.5 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0)) 1.0 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183818
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (cond
    [(empty? numbers) 0] ; handle empty list gracefully
    [else
     (let* ([n (length numbers)]
            [mean (/ (apply + numbers) n)]
            [abs-diffs (map (lambda (x) (abs (- x mean))) numbers)])
       (/ (apply + abs-diffs) n))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-within (candidate (list 1.0 2.0)) 0.5 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0)) 1.0 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183818
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 5 (RKT) - HumanEval_5_intersperse
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
;; >>> (intersperse (list ) 4)
;; (list )
;; >>> (intersperse (list 1 2 3) 4)
;; (list 1 4 2 4 3)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersperse))
    (check-within (candidate (list ) 7) (list ) 0.001)
    (check-within (candidate (list 5 6 3 2) 8) (list 5 8 6 8 3 8 2) 0.001)
    (check-within (candidate (list 2 2 2) 2) (list 2 2 2 2 2) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
;; >>> (intersperse (list ) 4)
;; (list )
;; >>> (intersperse (list 1 2 3) 4)
;; (list 1 4 2 4 3)

;; Insert a number 'delimeter' between every two consecutive elements of input list `numbers`
;; >>> (intersperse (list ) 4)
;; (list )
;; >>> (intersperse (list 1 2 3) 4)
;; (list 1 4 2 4 3)
(define (intersperse numbers delimeter)
  (cond
    [(empty? numbers) empty]                     ; empty list → empty list
    [(empty? (cdr numbers)) numbers]             ; single element → unchanged
    [else
     (cons (car numbers)
           (cons delimeter
                 (intersperse (cdr numbers) delimeter)))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersperse))
    (check-within (candidate (list ) 7) (list ) 0.001)
    (check-within (candidate (list 5 6 3 2) 8) (list 5 8 6 8 3 8 2) 0.001)
    (check-within (candidate (list 2 2 2) 2) (list 2 2 2 2 2) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183819
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
;; >>> (intersperse (list ) 4)
;; (list )
;; >>> (intersperse (list 1 2 3) 4)
;; (list 1 4 2 4 3)

;; Insert a number 'delimeter' between every two consecutive elements of input list `numbers`
;; >>> (intersperse (list ) 4)
;; (list )
;; >>> (intersperse (list 1 2 3) 4)
;; (list 1 4 2 4 3)
(define (intersperse numbers delimeter)
  (cond
    [(null? numbers) '()]                      ; empty list → empty list
    [(null? (cdr numbers)) numbers]            ; single element → unchanged
    [else
     (cons (car numbers)
           (cons delimeter
                 (intersperse (cdr numbers) delimeter)))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersperse))
    (check-within (candidate (list ) 7) (list ) 0.001)
    (check-within (candidate (list 5 6 3 2) 8) (list 5 8 6 8 3 8 2) 0.001)
    (check-within (candidate (list 2 2 2) 2) (list 2 2 2 2 2) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183819
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
;; >>> (intersperse (list ) 4)
;; (list )
;; >>> (intersperse (list 1 2 3) 4)
;; (list 1 4 2 4 3)

;; Insert a number 'delimeter' between every two consecutive elements of input list `numbers`
;; >>> (intersperse (list ) 4)
;; (list )
;; >>> (intersperse (list 1 2 3) 4)
;; (list 1 4 2 4 3)
(define (intersperse numbers delimeter)
  (cond
    [(null? numbers) '()]                               ; empty list
    [(null? (rest numbers)) numbers]                    ; single element
    [else
     (cons (first numbers)
           (cons delimeter (intersperse (rest numbers) delimeter)))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersperse))
    (check-within (candidate (list ) 7) (list ) 0.001)
    (check-within (candidate (list 5 6 3 2) 8) (list 5 8 6 8 3 8 2) 0.001)
    (check-within (candidate (list 2 2 2) 2) (list 2 2 2 2 2) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183819
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
;; >>> (intersperse (list ) 4)
;; (list )
;; >>> (intersperse (list 1 2 3) 4)
;; (list 1 4 2 4 3)

;; Insert a number 'delimiter' between every two consecutive elements of input list `numbers`
;; >>> (intersperse (list ) 4)
;; (list )
;; >>> (intersperse (list 1 2 3) 4)
;; (list 1 4 2 4 3)
(define (intersperse numbers delimiter)
  (cond
    [(empty? numbers) '()]                     ; empty list stays empty
    [(empty? (cdr numbers)) numbers]           ; single element stays as is
    [else
     (cons (first numbers)                    ; prepend the first element
           (cons delimiter                       ; then the delimiter
                 (intersperse (cdr numbers) delimiter)))])) ; recurse on the rest
(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersperse))
    (check-within (candidate (list ) 7) (list ) 0.001)
    (check-within (candidate (list 5 6 3 2) 8) (list 5 8 6 8 3 8 2) 0.001)
    (check-within (candidate (list 2 2 2) 2) (list 2 2 2 2 2) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183819
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 7 (RKT) - HumanEval_7_filter_by_substring
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Filter an input list of strings only for ones that contain given substring
;; >>> (filter_by_substring (list ) "a")
;; (list )
;; >>> (filter_by_substring (list "abc" "bacd" "cde" "array") "a")
;; (list "abc" "bacd" "array")

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_substring))
    (check-within (candidate (list ) "john") (list ) 0.001)
    (check-within (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx") 0.001)
    (check-within (candidate (list "xxx" "asd" "aaaxxy" "john doe" "xxxAAA" "xxx") "xx") (list "xxx" "aaaxxy" "xxxAAA" "xxx") 0.001)
    (check-within (candidate (list "grunt" "trumpet" "prune" "gruesome") "run") (list "grunt" "prune") 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Filter an input list of strings only for ones that contain given substring
;; >>> (filter_by_substring (list ) "a")
;; (list )
;; >>> (filter_by_substring (list "abc" "bacd" "cde" "array") "a")
;; (list "abc" "bacd" "array")

;; Filter an input list of strings only for ones that contain given substring
;; >>> (filter_by_substring (list ) "a")
;; (list )
;; >>> (filter_by_substring (list "abc" "bacd" "cde" "array") "a")
;; (list "abc" "bacd" "array")
(define (filter_by_substring strings substring)
  (filter (lambda (s) (string-contains? s substring)) strings))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_substring))
    (check-within (candidate (list ) "john") (list ) 0.001)
    (check-within (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx") 0.001)
    (check-within (candidate (list "xxx" "asd" "aaaxxy" "john doe" "xxxAAA" "xxx") "xx") (list "xxx" "aaaxxy" "xxxAAA" "xxx") 0.001)
    (check-within (candidate (list "grunt" "trumpet" "prune" "gruesome") "run") (list "grunt" "prune") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183821
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Filter an input list of strings only for ones that contain given substring
;; >>> (filter_by_substring (list ) "a")
;; (list )
;; >>> (filter_by_substring (list "abc" "bacd" "cde" "array") "a")
;; (list "abc" "bacd" "array")

(require racket/string)

;; Filter an input list of strings only for ones that contain given substring
;; >>> (filter_by_substring (list ) "a")
;; (list )
;; >>> (filter_by_substring (list "abc" "bacd" "cde" "array") "a")
;; (list "abc" "bacd" "array")
(define (filter_by_substring strings substring)
  (filter (λ (s) (string-contains? s substring)) strings))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_substring))
    (check-within (candidate (list ) "john") (list ) 0.001)
    (check-within (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx") 0.001)
    (check-within (candidate (list "xxx" "asd" "aaaxxy" "john doe" "xxxAAA" "xxx") "xx") (list "xxx" "aaaxxy" "xxxAAA" "xxx") 0.001)
    (check-within (candidate (list "grunt" "trumpet" "prune" "gruesome") "run") (list "grunt" "prune") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183821
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Filter an input list of strings only for ones that contain given substring
;; >>> (filter_by_substring (list ) "a")
;; (list )
;; >>> (filter_by_substring (list "abc" "bacd" "cde" "array") "a")
;; (list "abc" "bacd" "array")

;; Filter an input list of strings only for ones that contain given substring
;; >>> (filter_by_substring (list ) "a")
;; (list )
;; >>> (filter_by_substring (list "abc" "bacd" "cde" "array") "a")
;; (list "abc" "bacd" "array")
(define (filter_by_substring strings substring)
  (filter (λ (s) (string-contains? s substring)) strings))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_substring))
    (check-within (candidate (list ) "john") (list ) 0.001)
    (check-within (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx") 0.001)
    (check-within (candidate (list "xxx" "asd" "aaaxxy" "john doe" "xxxAAA" "xxx") "xx") (list "xxx" "aaaxxy" "xxxAAA" "xxx") 0.001)
    (check-within (candidate (list "grunt" "trumpet" "prune" "gruesome") "run") (list "grunt" "prune") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183821
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Filter an input list of strings only for ones that contain given substring
;; >>> (filter_by_substring (list ) "a")
;; (list )
;; >>> (filter_by_substring (list "abc" "bacd" "cde" "array") "a")
;; (list "abc" "bacd" "array")

;; Filter an input list of strings only for ones that contain given substring
;; >>> (filter_by_substring (list ) "a")
;; (list )
;; >>> (filter_by_substring (list "abc" "bacd" "cde" "array") "a")
;; (list "abc" "bacd" "array")
(define (filter_by_substring strings substring)
  (filter (lambda (s) (string-contains? s substring)) strings))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_substring))
    (check-within (candidate (list ) "john") (list ) 0.001)
    (check-within (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx") 0.001)
    (check-within (candidate (list "xxx" "asd" "aaaxxy" "john doe" "xxxAAA" "xxx") "xx") (list "xxx" "aaaxxy" "xxxAAA" "xxx") 0.001)
    (check-within (candidate (list "grunt" "trumpet" "prune" "gruesome") "run") (list "grunt" "prune") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183821
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 8 (RKT) - HumanEval_8_sum_product
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; For a given list of integers, return a list consisting of a sum and a product of all the integers in a list.
;; Empty sum should be equal to 0 and empty product should be equal to 1.
;; >>> (sum_product (list ))
;; (list 0 1)
;; >>> (sum_product (list 1 2 3 4))
;; (list 10 24)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_product))
    (check-within (candidate (list )) (list 0 1) 0.001)
    (check-within (candidate (list 1 1 1)) (list 3 1) 0.001)
    (check-within (candidate (list 100 0)) (list 100 0) 0.001)
    (check-within (candidate (list 3 5 7)) (list 15 105) 0.001)
    (check-within (candidate (list 10)) (list 10 10) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; For a given list of integers, return a list consisting of a sum and a product of all the integers in a list.
;; Empty sum should be equal to 0 and empty product should be equal to 1.
;; >>> (sum_product (list ))
;; (list 0 1)
;; >>> (sum_product (list 1 2 3 4))
;; (list 10 24)

;; For a given list of integers, return a list consisting of a sum and a product of all the integers in a list.
;; Empty sum should be equal to 0 and empty product should be equal to 1.
;; >>> (sum_product (list ))
;; (list 0 1)
;; >>> (sum_product (list 1 2 3 4))
;; (list 10 24)
(define (sum_product numbers)
  (define (helper lst sum prod)
    (if (null? lst)
        (list sum prod)
        (helper (cdr lst)
                (+ sum (car lst))
                (* prod (car lst)))))
  (helper numbers 0 1))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_product))
    (check-within (candidate (list )) (list 0 1) 0.001)
    (check-within (candidate (list 1 1 1)) (list 3 1) 0.001)
    (check-within (candidate (list 100 0)) (list 100 0) 0.001)
    (check-within (candidate (list 3 5 7)) (list 15 105) 0.001)
    (check-within (candidate (list 10)) (list 10 10) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183822
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; For a given list of integers, return a list consisting of a sum and a product of all the integers in a list.
;; Empty sum should be equal to 0 and empty product should be equal to 1.
;; >>> (sum_product (list ))
;; (list 0 1)
;; >>> (sum_product (list 1 2 3 4))
;; (list 10 24)

;; For a given list of integers, return a list consisting of a sum and a product of all the integers in a list.
;; Empty sum should be equal to 0 and empty product should be equal to 1.
;; >>> (sum_product (list ))
;; (list 0 1)
;; >>> (sum_product (list 1 2 3 4))
;; (list 10 24)

(define (sum_product numbers)
  (list (foldl + 0 numbers)
        (foldl * 1 numbers)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_product))
    (check-within (candidate (list )) (list 0 1) 0.001)
    (check-within (candidate (list 1 1 1)) (list 3 1) 0.001)
    (check-within (candidate (list 100 0)) (list 100 0) 0.001)
    (check-within (candidate (list 3 5 7)) (list 15 105) 0.001)
    (check-within (candidate (list 10)) (list 10 10) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183822
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; For a given list of integers, return a list consisting of a sum and a product of all the integers in a list.
;; Empty sum should be equal to 0 and empty product should be equal to 1.
;; >>> (sum_product (list ))
;; (list 0 1)
;; >>> (sum_product (list 1 2 3 4))
;; (list 10 24)

;; For a given list of integers, return a list consisting of a sum and a product of all the integers in a list.
;; Empty sum should be equal to 0 and empty product should be equal to 1.
;; >>> (sum_product (list ))
;; (list 0 1)
;; >>> (sum_product (list 1 2 3 4))
;; (list 10 24)
(define (sum_product numbers)
  (list (apply + numbers)   ; sum (empty list => 0)
        (apply * numbers))) ; product (empty list => 1)
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_product))
    (check-within (candidate (list )) (list 0 1) 0.001)
    (check-within (candidate (list 1 1 1)) (list 3 1) 0.001)
    (check-within (candidate (list 100 0)) (list 100 0) 0.001)
    (check-within (candidate (list 3 5 7)) (list 15 105) 0.001)
    (check-within (candidate (list 10)) (list 10 10) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183822
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; For a given list of integers, return a list consisting of a sum and a product of all the integers in a list.
;; Empty sum should be equal to 0 and empty product should be equal to 1.
;; >>> (sum_product (list ))
;; (list 0 1)
;; >>> (sum_product (list 1 2 3 4))
;; (list 10 24)
(define (sum_product numbers)
  (list (foldl + 0 numbers)
        (foldl * 1 numbers)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_product))
    (check-within (candidate (list )) (list 0 1) 0.001)
    (check-within (candidate (list 1 1 1)) (list 3 1) 0.001)
    (check-within (candidate (list 100 0)) (list 100 0) 0.001)
    (check-within (candidate (list 3 5 7)) (list 15 105) 0.001)
    (check-within (candidate (list 10)) (list 10 10) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183822
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 12 (RKT) - HumanEval_12_longest
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Out of list of strings, return the longest one. Return the first one in case of multiple
;; strings of the same length. Return #f in case the input list is empty.
;; >>> (longest (list ))
;; #f
;; >>> (longest (list "a" "b" "c"))
;; "a"
;; >>> (longest (list "a" "bb" "ccc"))
;; "ccc"

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate longest))
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list "x" "y" "z")) "x" 0.001)
    (check-within (candidate (list "x" "yyy" "zzzz" "www" "kkkk" "abc")) "zzzz" 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Out of list of strings, return the longest one. Return the first one in case of multiple
;; strings of the same length. Return #f in case the input list is empty.
;; >>> (longest (list ))
;; #f
;; >>> (longest (list "a" "b" "c"))
;; "a"
;; >>> (longest (list "a" "bb" "ccc"))
;; "ccc"
(define (longest strings)
  (foldl (lambda (s best)
           (if (or (eq? best #f)
                   (> (string-length s) (string-length best)))
               s
               best))
         #f
         strings))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate longest))
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list "x" "y" "z")) "x" 0.001)
    (check-within (candidate (list "x" "yyy" "zzzz" "www" "kkkk" "abc")) "zzzz" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183826
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Out of list of strings, return the longest one. Return the first one in case of multiple
;; strings of the same length. Return #f in case the input list is empty.
;; >>> (longest (list ))
;; #f
;; >>> (longest (list "a" "b" "c"))
;; "a"
;; >>> (longest (list "a" "bb" "ccc"))
;; "ccc"

;; Out of list of strings, return the longest one. Return the first one in case of multiple
;; strings of the same length. Return #f in case the input list is empty.
;; >>> (longest (list ))
;; #f
;; >>> (longest (list "a" "b" "c"))
;; "a"
;; >>> (longest (list "a" "bb" "ccc"))
;; "ccc"

(define (longest strings)
  (cond
    [(null? strings) #f]                     ; empty list → #f
    [(null? (cdr strings)) (car strings)]    ; single element → that element
    [else
     (let ([rest-longest (longest (cdr strings))])
       (if (>= (string-length (car strings))
               (string-length rest-longest))
           (car strings)
           rest-longest))]))

;; Alternative implementation using foldl
#;(define (longest strings)
  (foldl
   (lambda (s acc)
     (cond
       [(false? acc) s]                         ; start with first element
       [(> (string-length s) (string-length acc)) s]
       [else acc]))
   #f
   strings))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate longest))
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list "x" "y" "z")) "x" 0.001)
    (check-within (candidate (list "x" "yyy" "zzzz" "www" "kkkk" "abc")) "zzzz" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183826
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Out of list of strings, return the longest one. Return the first one in case of multiple
;; strings of the same length. Return #f in case the input list is empty.
;; >>> (longest (list ))
;; #f
;; >>> (longest (list "a" "b" "c"))
;; "a"
;; >>> (longest (list "a" "bb" "ccc"))
;; "ccc"

;; Out of list of strings, return the longest one. Return the first one in case of multiple
;; strings of the same length. Return #f in case the input list is empty.
;; >>> (longest (list ))
;; #f
;; >>> (longest (list "a" "b" "c"))
;; "a"
;; >>> (longest (list "a" "bb" "ccc"))
;; "ccc"
(define (longest strings)
  (cond
    [(null? strings) #f]
    [else
     (let loop ([rest strings] [best (car strings)])
       (if (null? rest)
           best
           (let ([current (car rest)])
             (if (> (string-length current) (string-length best))
                 (loop (cdr rest) current)
                 (loop (cdr rest) best)))))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate longest))
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list "x" "y" "z")) "x" 0.001)
    (check-within (candidate (list "x" "yyy" "zzzz" "www" "kkkk" "abc")) "zzzz" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183826
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Out of list of strings, return the longest one. Return the first one in case of multiple
;; strings of the same length. Return #f in case the input list is empty.
;; >>> (longest (list ))
;; #f
;; >>> (longest (list "a" "b" "c"))
;; "a"
;; >>> (longest (list "a" "bb" "ccc"))
;; "ccc"

;; Out of list of strings, return the longest one. Return the first one in case of multiple
;; strings of the same length. Return #f in case the input list is empty.
;; >>> (longest (list ))
;; #f
;; >>> (longest (list "a" "b" "c"))
;; "a"
;; >>> (longest (list "a" "bb" "ccc"))
;; "ccc"

(define (longest strings)
  (if (null? strings)
      #f
      ;; foldl keeps the first string that has the greatest length
      (foldl (lambda (s best)
               (if (> (string-length s) (string-length best))
                   s
                   best))
             (car strings)
             (cdr strings))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate longest))
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list "x" "y" "z")) "x" 0.001)
    (check-within (candidate (list "x" "yyy" "zzzz" "www" "kkkk" "abc")) "zzzz" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183826
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 16 (RKT) - HumanEval_16_count_distinct_characters
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given a string, find out how many distinct characters (regardless of case) does it consist of
;; >>> (count_distinct_characters "xyzXYZ")
;; 3
;; >>> (count_distinct_characters "Jerry")
;; 4

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_distinct_characters))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "abcde") 5 0.001)
    (check-within (candidate "abcdecadeCADE") 5 0.001)
    (check-within (candidate "aaaaAAAAaaaa") 1 0.001)
    (check-within (candidate "Jerry jERRY JeRRRY") 5 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given a string, find out how many distinct characters (regardless of case) does it consist of
;; >>> (count_distinct_characters "xyzXYZ")
;; 3
;; >>> (count_distinct_characters "Jerry")
;; 4
(require racket/set)

;; Given a string, find out how many distinct characters (regardless of case) does it consist of
;; >>> (count_distinct_characters "xyzXYZ")
;; 3
;; >>> (count_distinct_characters "Jerry")
;; 4
(define (count_distinct_characters string)
  (let* ([chars (string->list string)]
         [lower (map char-downcase chars)]
         [s (list->set lower)])
    (set-count s)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_distinct_characters))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "abcde") 5 0.001)
    (check-within (candidate "abcdecadeCADE") 5 0.001)
    (check-within (candidate "aaaaAAAAaaaa") 1 0.001)
    (check-within (candidate "Jerry jERRY JeRRRY") 5 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183829
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given a string, find out how many distinct characters (regardless of case) does it consist of
;; >>> (count_distinct_characters "xyzXYZ")
;; 3
;; >>> (count_distinct_characters "Jerry")
;; 4

(require racket/set)

;; Given a string, find out how many distinct characters (regardless of case) does it consist of
;; >>> (count_distinct_characters "xyzXYZ")
;; 3
;; >>> (count_distinct_characters "Jerry")
;; 4
(define (count_distinct_characters string)
  ;; Convert the string to a list of characters
  (define chars (string->list string))
  ;; Normalise all characters to a single case (upper‑case here)
  (define upper-chars (map char-upcase chars))
  ;; Create a set of the normalised characters to eliminate duplicates
  (define unique-set (list->set upper-chars))
  ;; The number of distinct characters is the size of that set
  (set-count unique-set))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_distinct_characters))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "abcde") 5 0.001)
    (check-within (candidate "abcdecadeCADE") 5 0.001)
    (check-within (candidate "aaaaAAAAaaaa") 1 0.001)
    (check-within (candidate "Jerry jERRY JeRRRY") 5 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183829
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given a string, find out how many distinct characters (regardless of case) does it consist of
;; >>> (count_distinct_characters "xyzXYZ")
;; 3
;; >>> (count_distinct_characters "Jerry")
;; 4

;; Given a string, find out how many distinct characters (regardless of case) does it consist of
;; >>> (count_distinct_characters "xyzXYZ")
;; 3
;; >>> (count_distinct_characters "Jerry")
;; 4
(define (count_distinct_characters string)
  (length (remove-duplicates (string->list (string-downcase string)))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_distinct_characters))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "abcde") 5 0.001)
    (check-within (candidate "abcdecadeCADE") 5 0.001)
    (check-within (candidate "aaaaAAAAaaaa") 1 0.001)
    (check-within (candidate "Jerry jERRY JeRRRY") 5 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183829
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given a string, find out how many distinct characters (regardless of case) does it consist of
;; >>> (count_distinct_characters "xyzXYZ")
;; 3
;; >>> (count_distinct_characters "Jerry")
;; 4

(require racket/list)

;; Given a string, find out how many distinct characters (regardless of case) does it consist of
;; >>> (count_distinct_characters "xyzXYZ")
;; 3
;; >>> (count_distinct_characters "Jerry")
;; 4
(define (count_distinct_characters string)
  (length (remove-duplicates (string->list (string-downcase string)))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_distinct_characters))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "abcde") 5 0.001)
    (check-within (candidate "abcdecadeCADE") 5 0.001)
    (check-within (candidate "aaaaAAAAaaaa") 1 0.001)
    (check-within (candidate "Jerry jERRY JeRRRY") 5 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183829
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 17 (RKT) - HumanEval_17_parse_music
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-within (candidate "") (list ) 0.001)
    (check-within (candidate "o o o o") (list 4 4 4 4) 0.001)
    (check-within (candidate ".| .| .| .|") (list 1 1 1 1) 0.001)
    (check-within (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4) 0.001)
    (check-within (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)

(define (parse_music music_string)
  ;; Split the string on any amount of whitespace
  (define tokens (string-split music_string))

  ;; Translate a single token into its beat count
  (define (token->beats t)
    (cond
      [(string=? t "o")   4]
      [(string=? t "o|")  2]
      [(string=? t ".|")  1]
      [else (error "Unknown musical token:" t)]))

  ;; Map each token to its beat count
  (map token->beats tokens))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-within (candidate "") (list ) 0.001)
    (check-within (candidate "o o o o") (list 4 4 4 4) 0.001)
    (check-within (candidate ".| .| .| .|") (list 1 1 1 1) 0.001)
    (check-within (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4) 0.001)
    (check-within (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183830
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)

(require racket/string)

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; note last.
;; Here is a legend:
;; 'o'  - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quarter note, lasts one beat
;;
;; Example:
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)

(define (parse_music music-string)
  (define tokens (string-split music-string))          ; split on whitespace
  (map (lambda (t)
         (cond [(string=? t "o")  4]
               [(string=? t "o|") 2]
               [(string=? t ".|") 1]
               [else (error "Unknown token" t)]))
       tokens))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-within (candidate "") (list ) 0.001)
    (check-within (candidate "o o o o") (list 4 4 4 4) 0.001)
    (check-within (candidate ".| .| .| .|") (list 1 1 1 1) 0.001)
    (check-within (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4) 0.001)
    (check-within (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183830
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; note last.
;; Here is a legend:
;; 'o'  - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quarter note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)

(define (parse_music music-string)
  ;; Split the string on whitespace to get individual note tokens
  (define tokens (string-split music-string))

  ;; Helper that turns a token into its beat count
  (define (token->beats token)
    (cond
      [(string=? token "o")  4]   ; whole note
      [(string=? token "o|") 2]   ; half note
      [(string=? token ".|") 1]   ; quarter note
      [else (error "Unknown note token" token)]))

  ;; Map each token to its beat count
  (map token->beats tokens))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-within (candidate "") (list ) 0.001)
    (check-within (candidate "o o o o") (list 4 4 4 4) 0.001)
    (check-within (candidate ".| .| .| .|") (list 1 1 1 1) 0.001)
    (check-within (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4) 0.001)
    (check-within (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183830
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)

(require racket/string)

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; note last.
;; Here is a legend:
;; 'o'  - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quarter note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)

(define (parse_music music-string)
  ;; Split the input on whitespace to get individual note tokens
  (define tokens (string-split music-string))
  ;; Map each token to its corresponding beat count
  (map
   (lambda (token)
     (cond
       [(string=? token "o")  4]
       [(string=? token "o|") 2]
       [(string=? token ".|") 1]
       [else (error 'parse_music "Unknown note token" token)]))
   tokens))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-within (candidate "") (list ) 0.001)
    (check-within (candidate "o o o o") (list 4 4 4 4) 0.001)
    (check-within (candidate ".| .| .| .|") (list 1 1 1 1) 0.001)
    (check-within (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4) 0.001)
    (check-within (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183830
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 21 (RKT) - HumanEval_21_rescale_to_unit
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given list of numbers (of at least two elements), apply a linear transform to that list,
;; such that the smallest number will become 0 and the largest will become 1
;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0 5.0))
;; (list 0.0 0.25 0.5 0.75 1.0)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rescale_to_unit))
    (check-within (candidate (list 2.0 49.9)) (list 0.0 1.0) 0.001)
    (check-within (candidate (list 100.0 49.9)) (list 1.0 0.0) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0) 0.001)
    (check-within (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)
    (check-within (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given list of numbers (of at least two elements), apply a linear transform to that list,
;; such that the smallest number will become 0 and the largest will become 1
;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0 5.0))
;; (list 0.0 0.25 0.5 0.75 1.0)

;; Given list of numbers (of at least two elements), apply a linear transform to that list,
;; such that the smallest number will become 0 and the largest will become 1
;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0 5.0))
;; (list 0.0 0.25 0.5 0.75 1.0)
(define (rescale_to_unit numbers)
  (let* ([min-val (apply min numbers)]
         [max-val (apply max numbers)]
         [range (- max-val min-val)])
    (if (= range 0)
        ;; If all numbers are identical, map them all to 0.0
        (map (λ (x) 0.0) numbers)
        (map (λ (x) (/ (- x min-val) range)) numbers))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rescale_to_unit))
    (check-within (candidate (list 2.0 49.9)) (list 0.0 1.0) 0.001)
    (check-within (candidate (list 100.0 49.9)) (list 1.0 0.0) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0) 0.001)
    (check-within (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)
    (check-within (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183834
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given list of numbers (of at least two elements), apply a linear transform to that list,
;; such that the smallest number will become 0 and the largest will become 1
;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0 5.0))
;; (list 0.0 0.25 0.5 0.75 1.0)

;; Given list of numbers (of at least two elements), apply a linear transform to that list,
;; such that the smallest number will become 0 and the largest will become 1
;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0 5.0))
;; (list 0.0 0.25 0.5 0.75 1.0)
(define (rescale_to_unit numbers)
  (let* ([mn (apply min numbers)]
         [mx (apply max numbers)]
         [range (- mx mn)])
    ;; Avoid division by zero if all numbers are equal; in that case return zeros.
    (if (zero? range)
        (make-list (length numbers) 0.0)
        (map (λ (n) (/ (- n mn) range)) numbers))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rescale_to_unit))
    (check-within (candidate (list 2.0 49.9)) (list 0.0 1.0) 0.001)
    (check-within (candidate (list 100.0 49.9)) (list 1.0 0.0) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0) 0.001)
    (check-within (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)
    (check-within (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183834
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given list of numbers (of at least two elements), apply a linear transform to that list,
;; such that the smallest number will become 0 and the largest will become 1
;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0 5.0))
;; (list 0.0 0.25 0.5 0.75 1.0)

;; Given list of numbers (of at least two elements), apply a linear transform to that list,
;; such that the smallest number will become 0 and the largest will become 1
;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0 5.0))
;; (list 0.0 0.25 0.5 0.75 1.0)
(define (rescale_to_unit numbers)
  (let* ((min-val (apply min numbers))
         (max-val (apply max numbers))
         (range   (- max-val min-val)))
    (if (zero? range)
        ;; All numbers are equal – map everything to 0.0
        (make-list (length numbers) 0.0)
        (map (lambda (x) (/ (- x min-val) range)) numbers))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rescale_to_unit))
    (check-within (candidate (list 2.0 49.9)) (list 0.0 1.0) 0.001)
    (check-within (candidate (list 100.0 49.9)) (list 1.0 0.0) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0) 0.001)
    (check-within (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)
    (check-within (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183834
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given list of numbers (of at least two elements), apply a linear transform to that list,
;; such that the smallest number will become 0 and the largest will become 1
;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0 5.0))
;; (list 0.0 0.25 0.5 0.75 1.0)

;; Given list of numbers (of at least two elements), apply a linear transform to that list,
;; such that the smallest number will become 0 and the largest will become 1
;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0 5.0))
;; (list 0.0 0.25 0.5 0.75 1.0)
(define (rescale_to_unit numbers)
  ;; Find the minimum and maximum values in the list
  (let* ([min-val (apply min numbers)]
         [max-val (apply max numbers)]
         [range (- max-val min-val)])
    ;; Map each element to the [0,1] interval
    (map (λ (x)
           (if (zero? range)      ; all elements equal – avoid division by zero
               0.0
               (/ (- x min-val) range)))
         numbers)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rescale_to_unit))
    (check-within (candidate (list 2.0 49.9)) (list 0.0 1.0) 0.001)
    (check-within (candidate (list 100.0 49.9)) (list 1.0 0.0) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0) 0.001)
    (check-within (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)
    (check-within (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183834
STDOUT: (empty)
STDERR: (empty)
--------------------
