As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 60 (R) - HumanEval_60_sum_to_n
================================================================================

PROMPT:
----------------------------------------
# sum_to_n is a function that sums numbers from 1 to n.
# >>> sum_to_n(30)
# 465
# >>> sum_to_n(100)
# 5050
# >>> sum_to_n(5)
# 15
# >>> sum_to_n(10)
# 55
# >>> sum_to_n(1)
# 1

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- sum_to_n
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(6), 21)))
    stopifnot(isTRUE(all.equal(candidate(11), 66)))
    stopifnot(isTRUE(all.equal(candidate(30), 465)))
    stopifnot(isTRUE(all.equal(candidate(100), 5050)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# sum_to_n is a function that sums numbers from 1 to n.
# >>> sum_to_n(30)
# 465
# >>> sum_to_n(100)
# 5050
# >>> sum_to_n(5)
# 15
# >>> sum_to_n(10)
# 55
# >>> sum_to_n(1)
# 1
# sum_to_n is a function that sums numbers from 1 to n.
# >>> sum_to_n(30)
# 465
# >>> sum_to_n(100)
# 5050
# >>> sum_to_n(5)
# 15
# >>> sum_to_n(10)
# 55
# >>> sum_to_n(1)
# 1
sum_to_n <- function(n) {
  # Use the arithmetic series formula: sum = n * (n + 1) / 2
  n * (n + 1) / 2
}
test_humaneval <- function() {
    candidate <- sum_to_n
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(6), 21)))
    stopifnot(isTRUE(all.equal(candidate(11), 66)))
    stopifnot(isTRUE(all.equal(candidate(30), 465)))
    stopifnot(isTRUE(all.equal(candidate(100), 5050)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183761
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# sum_to_n is a function that sums numbers from 1 to n.
# >>> sum_to_n(30)
# 465
# >>> sum_to_n(100)
# 5050
# >>> sum_to_n(5)
# 15
# >>> sum_to_n(10)
# 55
# >>> sum_to_n(1)
# 1
sum_to_n <- function(n) {
  # Validate input
  if (!is.numeric(n) || length(n) != 1) {
    stop("n must be a single numeric value")
  }
  if (n < 1) {
    stop("n must be greater than or equal to 1")
  }
  
  # Sum of the first n natural numbers using the arithmetic series formula
  n * (n + 1) / 2
}
test_humaneval <- function() {
    candidate <- sum_to_n
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(6), 21)))
    stopifnot(isTRUE(all.equal(candidate(11), 66)))
    stopifnot(isTRUE(all.equal(candidate(30), 465)))
    stopifnot(isTRUE(all.equal(candidate(100), 5050)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183761
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# sum_to_n is a function that sums numbers from 1 to n.
# >>> sum_to_n(30)
# 465
# >>> sum_to_n(100)
# 5050
# >>> sum_to_n(5)
# 15
# >>> sum_to_n(10)
# 55
# >>> sum_to_n(1)
# 1
sum_to_n <- function(n) {
  # Return the sum of all integers from 1 to n
  return(n * (n + 1) / 2)
}
test_humaneval <- function() {
    candidate <- sum_to_n
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(6), 21)))
    stopifnot(isTRUE(all.equal(candidate(11), 66)))
    stopifnot(isTRUE(all.equal(candidate(30), 465)))
    stopifnot(isTRUE(all.equal(candidate(100), 5050)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183761
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# sum_to_n is a function that sums numbers from 1 to n.
# >>> sum_to_n(30)
# 465
# >>> sum_to_n(100)
# 5050
# >>> sum_to_n(5)
# 15
# >>> sum_to_n(10)
# 55
# >>> sum_to_n(1)
# 1
# sum_to_n is a function that sums numbers from 1 to n.
# >>> sum_to_n(30)
# 465
# >>> sum_to_n(100)
# 5050
# >>> sum_to_n(5)
# 15
# >>> sum_to_n(10)
# 55
# >>> sum_to_n(1)
# 1
sum_to_n <- function(n) {
  # Validate input: ensure n is numeric and non-negative integer
  if (!is.numeric(n) || length(n) != 1 || is.na(n)) {
    stop("n must be a single numeric value")
  }
  if (n < 0) {
    stop("n must be non-negative")
  }
  # Use the arithmetic series sum formula
  return(n * (n + 1) / 2)
}
test_humaneval <- function() {
    candidate <- sum_to_n
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(6), 21)))
    stopifnot(isTRUE(all.equal(candidate(11), 66)))
    stopifnot(isTRUE(all.equal(candidate(30), 465)))
    stopifnot(isTRUE(all.equal(candidate(100), 5050)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183761
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 61 (R) - HumanEval_61_correct_bracketing
================================================================================

PROMPT:
----------------------------------------
# brackets is a string of "(" and ")".
# return TRUE if every opening bracket has a corresponding closing bracket.
# >>> correct_bracketing('(')
# FALSE
# >>> correct_bracketing('()')
# TRUE
# >>> correct_bracketing('(()())')
# TRUE
# >>> correct_bracketing(')(()')
# FALSE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- correct_bracketing
    stopifnot(isTRUE(all.equal(candidate('()'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('(()())'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())()'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('()()((()()())())(()()(()))'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('((()())))'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(')(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('('), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('(((('), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(')'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())())(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())()))()'), FALSE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# brackets is a string of "(" and ")".
# return TRUE if every opening bracket has a corresponding closing bracket.
# >>> correct_bracketing('(')
# FALSE
# >>> correct_bracketing('()')
# TRUE
# >>> correct_bracketing('(()())')
# TRUE
# >>> correct_bracketing(')(()')
# FALSE
correct_bracketing <- function(brackets) {
  # Convert the string into a vector of single characters
  chars <- strsplit(brackets, "")[[1]]
  balance <- 0
  
  for (ch in chars) {
    if (ch == "(") {
      balance <- balance + 1
    } else if (ch == ")") {
      balance <- balance - 1
      # If we ever have more closing brackets than opening ones, it's invalid
      if (balance < 0) {
        return(FALSE)
      }
    }
    # Any other characters are ignored
  }
  
  # The string is correctly bracketed only if the balance is zero at the end
  return(balance == 0)
}
test_humaneval <- function() {
    candidate <- correct_bracketing
    stopifnot(isTRUE(all.equal(candidate('()'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('(()())'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())()'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('()()((()()())())(()()(()))'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('((()())))'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(')(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('('), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('(((('), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(')'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())())(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())()))()'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183762
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# brackets is a string of "(" and ")".
# return TRUE if every opening bracket has a corresponding closing bracket.
# >>> correct_bracketing('(')
# FALSE
# >>> correct_bracketing('()')
# TRUE
# >>> correct_bracketing('(()())')
# TRUE
# >>> correct_bracketing(')(()')
# FALSE
correct_bracketing <- function(brackets) {
  # If the input is empty, we consider it correctly bracketed
  if (nchar(brackets) == 0) return(TRUE)

  # Split the string into individual characters
  chars <- strsplit(brackets, "")[[1]]
  counter <- 0

  for (ch in chars) {
    if (ch == "(") {
      counter <- counter + 1
    } else if (ch == ")") {
      counter <- counter - 1
    } else {
      # If any other character appears, ignore it or treat as invalid.
      # For safety, we can skip it. Here we simply ignore.
      next
    }

    # If at any point we have more closing brackets than opening ones
    if (counter < 0) {
      return(FALSE)
    }
  }

  # After processing all characters, the counter should be zero
  return(counter == 0)
}
test_humaneval <- function() {
    candidate <- correct_bracketing
    stopifnot(isTRUE(all.equal(candidate('()'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('(()())'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())()'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('()()((()()())())(()()(()))'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('((()())))'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(')(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('('), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('(((('), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(')'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())())(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())()))()'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183762
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# brackets is a string of "(" and ")".
# return TRUE if every opening bracket has a corresponding closing bracket.
# >>> correct_bracketing('(')
# FALSE
# >>> correct_bracketing('()')
# TRUE
# >>> correct_bracketing('(()())')
# TRUE
# >>> correct_bracketing(')(()')
# FALSE
correct_bracketing <- function(brackets) {
  # Empty string is considered correctly bracketed
  if (nchar(brackets) == 0) return(TRUE)
  
  # Split the string into individual characters
  chars <- strsplit(brackets, "")[[1]]
  balance <- 0
  
  for (ch in chars) {
    if (ch == "(") {
      balance <- balance + 1
    } else if (ch == ")") {
      balance <- balance - 1
    } else {
      # If any other character appears, consider it invalid
      return(FALSE)
    }
    
    # If at any point we have more closing than opening brackets
    if (balance < 0) {
      return(FALSE)
    }
  }
  
  # All opening brackets must be closed
  return(balance == 0)
}
test_humaneval <- function() {
    candidate <- correct_bracketing
    stopifnot(isTRUE(all.equal(candidate('()'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('(()())'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())()'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('()()((()()())())(()()(()))'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('((()())))'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(')(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('('), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('(((('), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(')'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())())(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())()))()'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183762
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# brackets is a string of "(" and ")".
# return TRUE if every opening bracket has a corresponding closing bracket.
# >>> correct_bracketing('(')
# FALSE
# >>> correct_bracketing('()')
# TRUE
# >>> correct_bracketing('(()())')
# TRUE
# >>> correct_bracketing(')(()')
# FALSE
correct_bracketing <- function(brackets) {
  # Counter for open brackets
  count <- 0
  
  # Iterate over each character in the string
  for (c in strsplit(brackets, "")[[1]]) {
    if (c == "(") {
      count <- count + 1
    } else if (c == ")") {
      count <- count - 1
      # If we close more brackets than we opened, it's unbalanced
      if (count < 0) {
        return(FALSE)
      }
    }
  }
  
  # Balanced only if all open brackets have been closed
  return(count == 0)
}
test_humaneval <- function() {
    candidate <- correct_bracketing
    stopifnot(isTRUE(all.equal(candidate('()'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('(()())'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())()'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('()()((()()())())(()()(()))'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('((()())))'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(')(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('('), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('(((('), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(')'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())())(()'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('()()(()())()))()'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183762
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 63 (R) - HumanEval_63_fibfib
================================================================================

PROMPT:
----------------------------------------
# The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
# fibfib(0) == 0
# fibfib(1) == 0
# fibfib(2) == 1
# fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
# Please write a function to efficiently compute the n-th element of the fibfib number sequence.
# >>> fibfib(1)
# 0
# >>> fibfib(5)
# 4
# >>> fibfib(8)
# 24

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- fibfib
    stopifnot(isTRUE(all.equal(candidate(2), 1)))
    stopifnot(isTRUE(all.equal(candidate(1), 0)))
    stopifnot(isTRUE(all.equal(candidate(5), 4)))
    stopifnot(isTRUE(all.equal(candidate(8), 24)))
    stopifnot(isTRUE(all.equal(candidate(10), 81)))
    stopifnot(isTRUE(all.equal(candidate(12), 274)))
    stopifnot(isTRUE(all.equal(candidate(14), 927)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
# fibfib(0) == 0
# fibfib(1) == 0
# fibfib(2) == 1
# fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
# Please write a function to efficiently compute the n-th element of the fibfib number sequence.
# >>> fibfib(1)
# 0
# >>> fibfib(5)
# 4
# >>> fibfib(8)
# 24
fibfib <- function(n) {
  # Validate input
  if (!is.numeric(n) || length(n) != 1 || n < 0 || floor(n) != n) {
    stop("n must be a non‑negative integer")
  }
  
  # Base cases
  if (n == 0 || n == 1) {
    return(0L)
  }
  if (n == 2) {
    return(1L)
  }
  
  # Iterative computation using only the last three values
  a <- 0L   # fibfib(n-3)
  b <- 0L   # fibfib(n-2)
  c <- 1L   # fibfib(n-1)
  
  for (i in 3:n) {
    d <- a + b + c   # fibfib(i)
    a <- b
    b <- c
    c <- d
  }
  
  return(c)
}
test_humaneval <- function() {
    candidate <- fibfib
    stopifnot(isTRUE(all.equal(candidate(2), 1)))
    stopifnot(isTRUE(all.equal(candidate(1), 0)))
    stopifnot(isTRUE(all.equal(candidate(5), 4)))
    stopifnot(isTRUE(all.equal(candidate(8), 24)))
    stopifnot(isTRUE(all.equal(candidate(10), 81)))
    stopifnot(isTRUE(all.equal(candidate(12), 274)))
    stopifnot(isTRUE(all.equal(candidate(14), 927)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183763
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
# fibfib(0) == 0
# fibfib(1) == 0
# fibfib(2) == 1
# fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
# Please write a function to efficiently compute the n-th element of the fibfib number sequence.
# >>> fibfib(1)
# 0
# >>> fibfib(5)
# 4
# >>> fibfib(8)
# 24
fibfib <- function(n) {
  # Validate input
  if (!is.numeric(n) || length(n) != 1 || n < 0 || n != floor(n)) {
    stop("n must be a non‑negative integer")
  }
  
  # Base cases
  if (n == 0 || n == 1) return(0)
  if (n == 2) return(1)
  
  # Iteratively compute the sequence
  a <- 0   # fibfib(n-3)
  b <- 0   # fibfib(n-2)
  c <- 1   # fibfib(n-1)
  
  for (i in 3:n) {
    d <- a + b + c   # fibfib(i)
    a <- b
    b <- c
    c <- d
  }
  
  return(c)
}
test_humaneval <- function() {
    candidate <- fibfib
    stopifnot(isTRUE(all.equal(candidate(2), 1)))
    stopifnot(isTRUE(all.equal(candidate(1), 0)))
    stopifnot(isTRUE(all.equal(candidate(5), 4)))
    stopifnot(isTRUE(all.equal(candidate(8), 24)))
    stopifnot(isTRUE(all.equal(candidate(10), 81)))
    stopifnot(isTRUE(all.equal(candidate(12), 274)))
    stopifnot(isTRUE(all.equal(candidate(14), 927)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183763
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
# fibfib(0) == 0
# fibfib(1) == 0
# fibfib(2) == 1
# fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
# Please write a function to efficiently compute the n-th element of the fibfib number sequence.
# >>> fibfib(1)
# 0
# >>> fibfib(5)
# 4
# >>> fibfib(8)
# 24
fibfib <- function(n) {
  # Validate input
  if (!is.numeric(n) || length(n) != 1 || n < 0 || floor(n) != n) {
    stop("n must be a non‑negative integer")
  }
  
  # Base cases
  if (n == 0 || n == 1) return(0)
  if (n == 2) return(1)
  
  # Iterative computation (dynamic programming)
  a <- 0  # fibfib(0)
  b <- 0  # fibfib(1)
  c <- 1  # fibfib(2)
  
  for (i in 3:n) {
    d <- a + b + c
    a <- b
    b <- c
    c <- d
  }
  
  return(c)
}
test_humaneval <- function() {
    candidate <- fibfib
    stopifnot(isTRUE(all.equal(candidate(2), 1)))
    stopifnot(isTRUE(all.equal(candidate(1), 0)))
    stopifnot(isTRUE(all.equal(candidate(5), 4)))
    stopifnot(isTRUE(all.equal(candidate(8), 24)))
    stopifnot(isTRUE(all.equal(candidate(10), 81)))
    stopifnot(isTRUE(all.equal(candidate(12), 274)))
    stopifnot(isTRUE(all.equal(candidate(14), 927)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183763
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
# fibfib(0) == 0
# fibfib(1) == 0
# fibfib(2) == 1
# fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
# Please write a function to efficiently compute the n-th element of the fibfib number sequence.
# >>> fibfib(1)
# 0
# >>> fibfib(5)
# 4
# >>> fibfib(8)
# 24
# Efficiently compute the n‑th element of the fibfib sequence.
# The recurrence is:
#   fibfib(0) = 0
#   fibfib(1) = 0
#   fibfib(2) = 1
#   fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)   for n ≥ 3
#
# We use an iterative approach that runs in O(n) time and O(1) memory
# (by keeping only the last three values).

fibfib <- function(n) {
  if (!is.numeric(n) || length(n) != 1 || n < 0 || floor(n) != n) {
    stop("n must be a non‑negative integer")
  }
  
  # Base cases
  if (n == 0 || n == 1) return(0)
  if (n == 2) return(1)
  
  # Keep only the last three values
  a <- 0   # fibfib(0)
  b <- 0   # fibfib(1)
  c <- 1   # fibfib(2)
  
  for (i in 3L:n) {
    # Next value is the sum of the previous three
    next_val <- a + b + c
    # Shift the window
    a <- b
    b <- c
    c <- next_val
  }
  
  return(c)
}

# Examples
#> fibfib(1)
# [1] 0
#> fibfib(5)
# [1] 4
#> fibfib(8)
# [1] 24
test_humaneval <- function() {
    candidate <- fibfib
    stopifnot(isTRUE(all.equal(candidate(2), 1)))
    stopifnot(isTRUE(all.equal(candidate(1), 0)))
    stopifnot(isTRUE(all.equal(candidate(5), 4)))
    stopifnot(isTRUE(all.equal(candidate(8), 24)))
    stopifnot(isTRUE(all.equal(candidate(10), 81)))
    stopifnot(isTRUE(all.equal(candidate(12), 274)))
    stopifnot(isTRUE(all.equal(candidate(14), 927)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183763
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 64 (R) - HumanEval_64_vowels_count
================================================================================

PROMPT:
----------------------------------------
# Write a function vowels_count which takes a string representing
# a word as input and returns the number of vowels in the string.
# Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
# vowel, but only when it is at the end of the given word.
# Example:
# >>> vowels_count('abcde')
# 2
# >>> vowels_count('ACEDY')
# 3

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- vowels_count
    stopifnot(isTRUE(all.equal(candidate('abcde'), 2)))
    stopifnot(isTRUE(all.equal(candidate('Alone'), 3)))
    stopifnot(isTRUE(all.equal(candidate('key'), 2)))
    stopifnot(isTRUE(all.equal(candidate('bye'), 1)))
    stopifnot(isTRUE(all.equal(candidate('keY'), 2)))
    stopifnot(isTRUE(all.equal(candidate('bYe'), 1)))
    stopifnot(isTRUE(all.equal(candidate('ACEDY'), 3)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Write a function vowels_count which takes a string representing
# a word as input and returns the number of vowels in the string.
# Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
# vowel, but only when it is at the end of the given word.
# Example:
# >>> vowels_count('abcde')
# 2
# >>> vowels_count('ACEDY')
# 3
vowels_count <- function(s) {
  # Handle empty input
  if (nchar(s) == 0) return(0)
  
  # Convert to lower case for case‑insensitive matching
  s_low <- tolower(s)
  
  # Split into individual characters
  chars <- strsplit(s_low, "")[[1]]
  
  # Count standard vowels
  vowel_set <- c("a", "e", "i", "o", "u")
  count <- sum(chars %in% vowel_set)
  
  # Add 'y' if it is the last character
  if (grepl("y$", s_low)) {
    count <- count + 1
  }
  
  return(count)
}
test_humaneval <- function() {
    candidate <- vowels_count
    stopifnot(isTRUE(all.equal(candidate('abcde'), 2)))
    stopifnot(isTRUE(all.equal(candidate('Alone'), 3)))
    stopifnot(isTRUE(all.equal(candidate('key'), 2)))
    stopifnot(isTRUE(all.equal(candidate('bye'), 1)))
    stopifnot(isTRUE(all.equal(candidate('keY'), 2)))
    stopifnot(isTRUE(all.equal(candidate('bYe'), 1)))
    stopifnot(isTRUE(all.equal(candidate('ACEDY'), 3)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183763
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Write a function vowels_count which takes a string representing
# a word as input and returns the number of vowels in the string.
# Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
# vowel, but only when it is at the end of the given word.
# Example:
# >>> vowels_count('abcde')
# 2
# >>> vowels_count('ACEDY')
# 3
# Write a function vowels_count which takes a string representing
# a word as input and returns the number of vowels in the string.
# Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
# vowel, but only when it is at the end of the given word.
# Example:
# >>> vowels_count('abcde')
# 2
# >>> vowels_count('ACEDY')
# 3

vowels_count <- function(s) {
  # Ensure a single string is provided
  if (!is.character(s) || length(s) != 1) {
    stop("Input must be a single string")
  }
  
  # Convert to lowercase for case‑insensitive matching
  s_lower <- tolower(s)
  
  # Split into individual characters
  chars <- strsplit(s_lower, "")[[1]]
  
  # Handle empty string
  if (length(chars) == 0) {
    return(0L)
  }
  
  # Define the vowel set (excluding 'y')
  vowel_set <- c('a', 'e', 'i', 'o', 'u')
  
  # Count the standard vowels
  count <- sum(chars %in% vowel_set)
  
  # Add 'y' if it appears at the end of the word
  if (tail(chars, n = 1) == 'y') {
    count <- count + 1L
  }
  
  return(as.integer(count))
}
test_humaneval <- function() {
    candidate <- vowels_count
    stopifnot(isTRUE(all.equal(candidate('abcde'), 2)))
    stopifnot(isTRUE(all.equal(candidate('Alone'), 3)))
    stopifnot(isTRUE(all.equal(candidate('key'), 2)))
    stopifnot(isTRUE(all.equal(candidate('bye'), 1)))
    stopifnot(isTRUE(all.equal(candidate('keY'), 2)))
    stopifnot(isTRUE(all.equal(candidate('bYe'), 1)))
    stopifnot(isTRUE(all.equal(candidate('ACEDY'), 3)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183763
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Write a function vowels_count which takes a string representing
# a word as input and returns the number of vowels in the string.
# Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
# vowel, but only when it is at the end of the given word.
# Example:
# >>> vowels_count('abcde')
# 2
# >>> vowels_count('ACEDY')
# 3
# Write a function vowels_count which takes a string representing
# a word as input and returns the number of vowels in the string.
# Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
# vowel, but only when it is at the end of the given word.
# Example:
# >>> vowels_count('abcde')
# 2
# >>> vowels_count('ACEDY')
# 3
vowels_count <- function(s) {
  # Handle NULL or non‑character input gracefully
  if (is.null(s) || !is.character(s)) {
    stop("Input must be a non‑NULL character string")
  }
  
  # Empty string → 0 vowels
  if (nchar(s) == 0) return(0L)
  
  # Convert to lower case for case‑insensitive comparison
  s_lower <- tolower(s)
  chars <- strsplit(s_lower, NULL)[[1]]
  
  # Count standard vowels
  vowel_set <- c("a", "e", "i", "o", "u")
  count <- sum(chars %in% vowel_set)
  
  # Add 'y' if it appears at the end of the original string
  last_char <- tolower(substr(s, nchar(s), nchar(s)))
  if (last_char == "y") {
    count <- count + 1L
  }
  
  return(count)
}
test_humaneval <- function() {
    candidate <- vowels_count
    stopifnot(isTRUE(all.equal(candidate('abcde'), 2)))
    stopifnot(isTRUE(all.equal(candidate('Alone'), 3)))
    stopifnot(isTRUE(all.equal(candidate('key'), 2)))
    stopifnot(isTRUE(all.equal(candidate('bye'), 1)))
    stopifnot(isTRUE(all.equal(candidate('keY'), 2)))
    stopifnot(isTRUE(all.equal(candidate('bYe'), 1)))
    stopifnot(isTRUE(all.equal(candidate('ACEDY'), 3)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183763
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Write a function vowels_count which takes a string representing
# a word as input and returns the number of vowels in the string.
# Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
# vowel, but only when it is at the end of the given word.
# Example:
# >>> vowels_count('abcde')
# 2
# >>> vowels_count('ACEDY')
# 3
vowels_count <- function(s) {
  # Convert to lower case for case‑insensitive comparison
  s_lower <- tolower(s)
  
  # Return 0 for empty input
  if (nchar(s_lower) == 0) return(0)
  
  # Split string into individual characters
  chars <- strsplit(s_lower, NULL)[[1]]
  
  # Count standard vowels (a, e, i, o, u)
  vowel_set <- c("a", "e", "i", "o", "u")
  count <- sum(chars %in% vowel_set)
  
  # Add 1 if the last character is 'y'
  if (substr(s_lower, nchar(s_lower), nchar(s_lower)) == "y") {
    count <- count + 1
  }
  
  return(count)
}
test_humaneval <- function() {
    candidate <- vowels_count
    stopifnot(isTRUE(all.equal(candidate('abcde'), 2)))
    stopifnot(isTRUE(all.equal(candidate('Alone'), 3)))
    stopifnot(isTRUE(all.equal(candidate('key'), 2)))
    stopifnot(isTRUE(all.equal(candidate('bye'), 1)))
    stopifnot(isTRUE(all.equal(candidate('keY'), 2)))
    stopifnot(isTRUE(all.equal(candidate('bYe'), 1)))
    stopifnot(isTRUE(all.equal(candidate('ACEDY'), 3)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183763
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 67 (R) - HumanEval_67_fruit_distribution
================================================================================

PROMPT:
----------------------------------------
# In this task, you will be given a string that represents a number of apples and oranges 
# that are distributed in a basket of fruit this basket contains 
# apples, oranges, and mango fruits. Given the string that represents the total number of 
# the oranges and apples and an integer that represent the total number of the fruits 
# in the basket return the number of the mango fruits in the basket.
# for examble:
# >>> fruit_distribution('5 apples and 6 oranges', 19)
# 8
# >>> fruit_distribution('0 apples and 1 oranges', 3)
# 2
# >>> fruit_distribution('2 apples and 3 oranges', 100)
# 95
# >>> fruit_distribution('100 apples and 1 oranges', 120)
# 19

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- fruit_distribution
    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 19), 8)))
    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 21), 10)))
    stopifnot(isTRUE(all.equal(candidate('0 apples and 1 oranges', 3), 2)))
    stopifnot(isTRUE(all.equal(candidate('1 apples and 0 oranges', 3), 2)))
    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 100), 95)))
    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 5), 0)))
    stopifnot(isTRUE(all.equal(candidate('1 apples and 100 oranges', 120), 19)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# In this task, you will be given a string that represents a number of apples and oranges 
# that are distributed in a basket of fruit this basket contains 
# apples, oranges, and mango fruits. Given the string that represents the total number of 
# the oranges and apples and an integer that represent the total number of the fruits 
# in the basket return the number of the mango fruits in the basket.
# for examble:
# >>> fruit_distribution('5 apples and 6 oranges', 19)
# 8
# >>> fruit_distribution('0 apples and 1 oranges', 3)
# 2
# >>> fruit_distribution('2 apples and 3 oranges', 100)
# 95
# >>> fruit_distribution('100 apples and 1 oranges', 120)
# 19
fruit_distribution <- function(s, n) {
  # Extract all numeric values from the string
  nums <- as.numeric(unlist(regmatches(s, gregexpr("\\d+", s))))
  
  # Expect at least two numbers: apples and oranges
  if (length(nums) < 2) {
    stop("Input string must contain at least two numbers (apples and oranges).")
  }
  
  apples  <- nums[1]
  oranges <- nums[2]
  
  # Compute mango count
  mango <- n - apples - oranges
  
  # Ensure we don't return a negative number
  if (mango < 0) mango <- 0
  
  return(mango)
}
test_humaneval <- function() {
    candidate <- fruit_distribution
    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 19), 8)))
    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 21), 10)))
    stopifnot(isTRUE(all.equal(candidate('0 apples and 1 oranges', 3), 2)))
    stopifnot(isTRUE(all.equal(candidate('1 apples and 0 oranges', 3), 2)))
    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 100), 95)))
    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 5), 0)))
    stopifnot(isTRUE(all.equal(candidate('1 apples and 100 oranges', 120), 19)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183765
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# In this task, you will be given a string that represents a number of apples and oranges 
# that are distributed in a basket of fruit this basket contains 
# apples, oranges, and mango fruits. Given the string that represents the total number of 
# the oranges and apples and an integer that represent the total number of the fruits 
# in the basket return the number of the mango fruits in the basket.
# for examble:
# >>> fruit_distribution('5 apples and 6 oranges', 19)
# 8
# >>> fruit_distribution('0 apples and 1 oranges', 3)
# 2
# >>> fruit_distribution('2 apples and 3 oranges', 100)
# 95
# >>> fruit_distribution('100 apples and 1 oranges', 120)
# 19
fruit_distribution <- function(s, n) {
  # Extract all integers from the string
  nums <- as.integer(unlist(regmatches(s, gregexpr("\\d+", s))))
  
  # Ensure we have at least two numbers (apples and oranges)
  if (length(nums) < 2) {
    stop("Input string must contain two numbers (apples and oranges).")
  }
  
  apples  <- nums[1]
  oranges <- nums[2]
  
  # Compute the number of mangoes
  mangoes <- n - (apples + oranges)
  
  return(mangoes)
}
test_humaneval <- function() {
    candidate <- fruit_distribution
    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 19), 8)))
    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 21), 10)))
    stopifnot(isTRUE(all.equal(candidate('0 apples and 1 oranges', 3), 2)))
    stopifnot(isTRUE(all.equal(candidate('1 apples and 0 oranges', 3), 2)))
    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 100), 95)))
    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 5), 0)))
    stopifnot(isTRUE(all.equal(candidate('1 apples and 100 oranges', 120), 19)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183765
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# In this task, you will be given a string that represents a number of apples and oranges 
# that are distributed in a basket of fruit this basket contains 
# apples, oranges, and mango fruits. Given the string that represents the total number of 
# the oranges and apples and an integer that represent the total number of the fruits 
# in the basket return the number of the mango fruits in the basket.
# for examble:
# >>> fruit_distribution('5 apples and 6 oranges', 19)
# 8
# >>> fruit_distribution('0 apples and 1 oranges', 3)
# 2
# >>> fruit_distribution('2 apples and 3 oranges', 100)
# 95
# >>> fruit_distribution('100 apples and 1 oranges', 120)
# 19
fruit_distribution <- function(s, n) {
  # Extract all numbers from the string
  nums <- as.integer(unlist(regmatches(s, gregexpr("\\d+", s))))
  
  # Ensure we have at least two numbers (apples and oranges)
  if (length(nums) < 2) {
    stop("Input string must contain numbers for apples and oranges.")
  }
  
  # Sum the apples and oranges
  apples_oranges <- sum(nums[1:2])
  
  # Compute the number of mangoes
  mangoes <- n - apples_oranges
  
  # Return the result as an integer
  return(mangoes)
}
test_humaneval <- function() {
    candidate <- fruit_distribution
    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 19), 8)))
    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 21), 10)))
    stopifnot(isTRUE(all.equal(candidate('0 apples and 1 oranges', 3), 2)))
    stopifnot(isTRUE(all.equal(candidate('1 apples and 0 oranges', 3), 2)))
    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 100), 95)))
    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 5), 0)))
    stopifnot(isTRUE(all.equal(candidate('1 apples and 100 oranges', 120), 19)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183765
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# In this task, you will be given a string that represents a number of apples and oranges 
# that are distributed in a basket of fruit this basket contains 
# apples, oranges, and mango fruits. Given the string that represents the total number of 
# the oranges and apples and an integer that represent the total number of the fruits 
# in the basket return the number of the mango fruits in the basket.
# for examble:
# >>> fruit_distribution('5 apples and 6 oranges', 19)
# 8
# >>> fruit_distribution('0 apples and 1 oranges', 3)
# 2
# >>> fruit_distribution('2 apples and 3 oranges', 100)
# 95
# >>> fruit_distribution('100 apples and 1 oranges', 120)
# 19
fruit_distribution <- function(s, n) {
  # Extract all numbers from the string
  nums <- regmatches(s, gregexpr("[0-9]+", s))[[1]]
  
  # Convert to integers: first is apples, second is oranges
  apples  <- as.integer(nums[1])
  oranges <- as.integer(nums[2])
  
  # Calculate mangoes
  mangoes <- n - apples - oranges
  
  return(mangoes)
}
test_humaneval <- function() {
    candidate <- fruit_distribution
    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 19), 8)))
    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 21), 10)))
    stopifnot(isTRUE(all.equal(candidate('0 apples and 1 oranges', 3), 2)))
    stopifnot(isTRUE(all.equal(candidate('1 apples and 0 oranges', 3), 2)))
    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 100), 95)))
    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 5), 0)))
    stopifnot(isTRUE(all.equal(candidate('1 apples and 100 oranges', 120), 19)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183765
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 69 (R) - HumanEval_69_search
================================================================================

PROMPT:
----------------------------------------
# You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
# zero, and has a frequency greater than or equal to the value of the integer itself. 
# The frequency of an integer is the number of times it appears in the list.
# If no such a value exist, return -1.
# Examples:
# >>> search(c(4, 1, 2, 2, 3, 1))
# 2
# >>> search(c(1, 2, 2, 3, 3, 3, 4, 4, 4))
# 3
# >>> search(c(5, 5, 4, 4, 4))
# -1

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- search
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 4, 1, 4, 4)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 3)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 8, 8, 8, 8, 8, 8)), 8)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 3, 2, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 8, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 3, 6, 5, 6, 4)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 9, 10, 1, 3)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(10)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 10, 10, 9, 2)), -1)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
# zero, and has a frequency greater than or equal to the value of the integer itself. 
# The frequency of an integer is the number of times it appears in the list.
# If no such a value exist, return -1.
# Examples:
# >>> search(c(4, 1, 2, 2, 3, 1))
# 2
# >>> search(c(1, 2, 2, 3, 3, 3, 4, 4, 4))
# 3
# >>> search(c(5, 5, 4, 4, 4))
# -1
search <- function(lst) {
  # Count frequencies of each distinct integer
  freq_table <- table(lst)
  
  # Convert names (which are character) to integers
  values  <- as.integer(names(freq_table))
  counts  <- as.integer(freq_table)
  
  # Keep only those values whose frequency is at least the value itself
  valid_values <- values[counts >= values]
  
  # Return the greatest valid value, or -1 if none exist
  if (length(valid_values) == 0) {
    return(-1)
  } else {
    return(max(valid_values))
  }
}
test_humaneval <- function() {
    candidate <- search
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 4, 1, 4, 4)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 3)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 8, 8, 8, 8, 8, 8)), 8)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 3, 2, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 8, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 3, 6, 5, 6, 4)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 9, 10, 1, 3)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(10)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 10, 10, 9, 2)), -1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183766
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
# zero, and has a frequency greater than or equal to the value of the integer itself. 
# The frequency of an integer is the number of times it appears in the list.
# If no such a value exist, return -1.
# Examples:
# >>> search(c(4, 1, 2, 2, 3, 1))
# 2
# >>> search(c(1, 2, 2, 3, 3, 3, 4, 4, 4))
# 3
# >>> search(c(5, 5, 4, 4, 4))
# -1
search <- function(lst) {
  # Count the frequency of each integer in the list
  freq_tbl <- table(lst)
  
  # Convert the names (values) and frequencies to integers
  vals   <- as.integer(names(freq_tbl))
  freq   <- as.integer(freq_tbl)
  
  # Identify which values satisfy freq >= value
  sat    <- freq >= vals
  
  # If none satisfy the condition, return -1
  if (!any(sat)) {
    return(-1)
  }
  
  # Return the greatest value that satisfies the condition
  return(max(vals[sat]))
}
test_humaneval <- function() {
    candidate <- search
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 4, 1, 4, 4)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 3)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 8, 8, 8, 8, 8, 8)), 8)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 3, 2, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 8, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 3, 6, 5, 6, 4)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 9, 10, 1, 3)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(10)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 10, 10, 9, 2)), -1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183766
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
# zero, and has a frequency greater than or equal to the value of the integer itself. 
# The frequency of an integer is the number of times it appears in the list.
# If no such a value exist, return -1.
# Examples:
# >>> search(c(4, 1, 2, 2, 3, 1))
# 2
# >>> search(c(1, 2, 2, 3, 3, 3, 4, 4, 4))
# 3
# >>> search(c(5, 5, 4, 4, 4))
# -1
search <- function(lst) {
  # Count the frequency of each integer
  freq <- table(lst)

  # Convert the names of the table to integer values
  values <- as.integer(names(freq))

  # Find the values that satisfy the condition: frequency >= value
  valid <- values[freq >= values]

  # Return the greatest such value or -1 if none exist
  if (length(valid) == 0) {
    return(-1)
  } else {
    return(max(valid))
  }
}
test_humaneval <- function() {
    candidate <- search
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 4, 1, 4, 4)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 3)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 8, 8, 8, 8, 8, 8)), 8)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 3, 2, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 8, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 3, 6, 5, 6, 4)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 9, 10, 1, 3)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(10)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 10, 10, 9, 2)), -1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183766
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
# zero, and has a frequency greater than or equal to the value of the integer itself. 
# The frequency of an integer is the number of times it appears in the list.
# If no such a value exist, return -1.
# Examples:
# >>> search(c(4, 1, 2, 2, 3, 1))
# 2
# >>> search(c(1, 2, 2, 3, 3, 3, 4, 4, 4))
# 3
# >>> search(c(5, 5, 4, 4, 4))
# -1
search <- function(lst) {
  # Compute frequency of each integer
  freq <- table(lst)
  
  # Convert the names of the table (the integers) to numeric
  values <- as.integer(names(freq))
  
  # Identify integers whose frequency is at least as large as the integer itself
  valid <- values[freq >= values]
  
  # Return the greatest such integer, or -1 if none exist
  if (length(valid) == 0) {
    return(-1)
  } else {
    return(max(valid))
  }
}
test_humaneval <- function() {
    candidate <- search
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 4, 1, 4, 4)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 3)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 8, 8, 8, 8, 8, 8)), 8)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 3, 2, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 8, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 3, 6, 5, 6, 4)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 9, 10, 1, 3)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(10)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 10, 10, 9, 2)), -1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183766
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 71 (R) - HumanEval_71_triangle_area
================================================================================

PROMPT:
----------------------------------------
# Given the lengths of the three sides of a triangle. Return the area of
# the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
# Otherwise return -1
# Three sides make a valid triangle when the sum of any two sides is greater 
# than the third side.
# Example:
# >>> triangle_area(3, 4, 5)
# 6.0
# >>> triangle_area(1, 2, 10)
# -1

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- triangle_area
    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), 6.0)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 10), -1)))
    stopifnot(isTRUE(all.equal(candidate(4, 8, 5), 8.18)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), 1.73)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), -1)))
    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), 16.25)))
    stopifnot(isTRUE(all.equal(candidate(2, 6, 3), -1)))
    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), 0.43)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), -1)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given the lengths of the three sides of a triangle. Return the area of
# the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
# Otherwise return -1
# Three sides make a valid triangle when the sum of any two sides is greater 
# than the third side.
# Example:
# >>> triangle_area(3, 4, 5)
# 6.0
# >>> triangle_area(1, 2, 10)
# -1
triangle_area <- function(a, b, c) {
  # Check if all sides are positive numbers
  if (any(c(a, b, c) <= 0)) return(-1)
  
  # Triangle inequality check
  if (!(a + b > c && a + c > b && b + c > a)) {
    return(-1)
  }
  
  # Heron's formula
  s <- (a + b + c) / 2
  area <- sqrt(s * (s - a) * (s - b) * (s - c))
  
  # Round to 2 decimal places
  return(round(area, 2))
}
test_humaneval <- function() {
    candidate <- triangle_area
    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), 6.0)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 10), -1)))
    stopifnot(isTRUE(all.equal(candidate(4, 8, 5), 8.18)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), 1.73)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), -1)))
    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), 16.25)))
    stopifnot(isTRUE(all.equal(candidate(2, 6, 3), -1)))
    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), 0.43)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), -1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183767
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given the lengths of the three sides of a triangle. Return the area of
# the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
# Otherwise return -1
# Three sides make a valid triangle when the sum of any two sides is greater 
# than the third side.
# Example:
# >>> triangle_area(3, 4, 5)
# 6.0
# >>> triangle_area(1, 2, 10)
# -1
triangle_area <- function(a, b, c) {
  # Check for a valid triangle: sum of any two sides must be greater than the third
  if ( (a + b <= c) || (a + c <= b) || (b + c <= a) ) {
    return(-1)
  }
  
  # Heron's formula
  s <- (a + b + c) / 2
  area <- sqrt(s * (s - a) * (s - b) * (s - c))
  
  # Round to 2 decimal places
  return(round(area, 2))
}
test_humaneval <- function() {
    candidate <- triangle_area
    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), 6.0)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 10), -1)))
    stopifnot(isTRUE(all.equal(candidate(4, 8, 5), 8.18)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), 1.73)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), -1)))
    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), 16.25)))
    stopifnot(isTRUE(all.equal(candidate(2, 6, 3), -1)))
    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), 0.43)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), -1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183767
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given the lengths of the three sides of a triangle. Return the area of
# the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
# Otherwise return -1
# Three sides make a valid triangle when the sum of any two sides is greater 
# than the third side.
# Example:
# >>> triangle_area(3, 4, 5)
# 6.0
# >>> triangle_area(1, 2, 10)
# -1
triangle_area <- function(a, b, c) {
  # Check for valid triangle using the triangle inequality
  if (a + b <= c || a + c <= b || b + c <= a) {
    return(-1)
  }
  
  # Heron's formula to compute area
  s <- (a + b + c) / 2
  area <- sqrt(s * (s - a) * (s - b) * (s - c))
  
  # Round to 2 decimal places
  return(round(area, 2))
}
test_humaneval <- function() {
    candidate <- triangle_area
    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), 6.0)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 10), -1)))
    stopifnot(isTRUE(all.equal(candidate(4, 8, 5), 8.18)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), 1.73)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), -1)))
    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), 16.25)))
    stopifnot(isTRUE(all.equal(candidate(2, 6, 3), -1)))
    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), 0.43)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), -1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183767
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given the lengths of the three sides of a triangle. Return the area of
# the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
# Otherwise return -1
# Three sides make a valid triangle when the sum of any two sides is greater 
# than the third side.
# Example:
# >>> triangle_area(3, 4, 5)
# 6.0
# >>> triangle_area(1, 2, 10)
# -1
triangle_area <- function(a, b, c) {
  # Check for valid triangle using the triangle inequality
  if (a + b <= c || a + c <= b || b + c <= a) {
    return(-1)
  }
  
  # Heron's formula for the area
  s <- (a + b + c) / 2
  area <- sqrt(s * (s - a) * (s - b) * (s - c))
  
  # Round the result to two decimal places
  return(round(area, 2))
}
test_humaneval <- function() {
    candidate <- triangle_area
    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), 6.0)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 10), -1)))
    stopifnot(isTRUE(all.equal(candidate(4, 8, 5), 8.18)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), 1.73)))
    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), -1)))
    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), 16.25)))
    stopifnot(isTRUE(all.equal(candidate(2, 6, 3), -1)))
    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), 0.43)))
    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), -1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183767
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 72 (R) - HumanEval_72_will_it_fly
================================================================================

PROMPT:
----------------------------------------
# Write a function that returns TRUE if the object q will fly, and FALSE otherwise.
# The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
# Example:
# >>> will_it_fly(c(1, 2), 5)
# FALSE
# # 1+2 is less than the maximum possible weight, but it's unbalanced.
# >>> will_it_fly(c(3, 2, 3), 1)
# FALSE
# # it's balanced, but 3+2+3 is more than the maximum possible weight.
# >>> will_it_fly(c(3, 2, 3), 9)
# TRUE
# # 3+2+3 is less than the maximum possible weight, and it's balanced.
# >>> will_it_fly(c(3), 5)
# TRUE
# # 3 is less than the maximum possible weight, and it's balanced.

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- will_it_fly
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 9), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2), 5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(3), 5), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 1), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), 6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(5), 5), TRUE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Write a function that returns TRUE if the object q will fly, and FALSE otherwise.
# The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
# Example:
# >>> will_it_fly(c(1, 2), 5)
# FALSE
# # 1+2 is less than the maximum possible weight, but it's unbalanced.
# >>> will_it_fly(c(3, 2, 3), 1)
# FALSE
# # it's balanced, but 3+2+3 is more than the maximum possible weight.
# >>> will_it_fly(c(3, 2, 3), 9)
# TRUE
# # 3+2+3 is less than the maximum possible weight, and it's balanced.
# >>> will_it_fly(c(3), 5)
# TRUE
# # 3 is less than the maximum possible weight, and it's balanced.
# Write a function that returns TRUE if the object q will fly, and FALSE otherwise.
# The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements
# is less than or equal the maximum possible weight w.
will_it_fly <- function(q, w) {
  # Check if q is palindromic (balanced)
  balanced <- all(q == rev(q))
  
  # Check if the total weight is within the allowed maximum
  within_weight <- sum(q) <= w
  
  # The object will fly only if both conditions are met
  return(balanced && within_weight)
}
test_humaneval <- function() {
    candidate <- will_it_fly
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 9), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2), 5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(3), 5), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 1), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), 6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(5), 5), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183767
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Write a function that returns TRUE if the object q will fly, and FALSE otherwise.
# The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
# Example:
# >>> will_it_fly(c(1, 2), 5)
# FALSE
# # 1+2 is less than the maximum possible weight, but it's unbalanced.
# >>> will_it_fly(c(3, 2, 3), 1)
# FALSE
# # it's balanced, but 3+2+3 is more than the maximum possible weight.
# >>> will_it_fly(c(3, 2, 3), 9)
# TRUE
# # 3+2+3 is less than the maximum possible weight, and it's balanced.
# >>> will_it_fly(c(3), 5)
# TRUE
# # 3 is less than the maximum possible weight, and it's balanced.
# Write a function that returns TRUE if the object q will fly, and FALSE otherwise.
# The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
# Example:
# >>> will_it_fly(c(1, 2), 5)
# FALSE
# # 1+2 is less than the maximum possible weight, but it's unbalanced.
# >>> will_it_fly(c(3, 2, 3), 1)
# FALSE
# # it's balanced, but 3+2+3 is more than the maximum possible weight.
# >>> will_it_fly(c(3, 2, 3), 9)
# TRUE
# # 3+2+3 is less than the maximum possible weight, and it's balanced.
# >>> will_it_fly(c(3), 5)
# TRUE
# # 3 is less than the maximum possible weight, and it's balanced.

will_it_fly <- function(q, w) {
  # Check if q is a palindrome
  is_palindrome <- identical(q, rev(q))
  
  # Compute the sum of elements
  total_weight <- sum(q, na.rm = TRUE)
  
  # Return TRUE only if both conditions are met
  return(is_palindrome && total_weight <= w)
}
test_humaneval <- function() {
    candidate <- will_it_fly
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 9), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2), 5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(3), 5), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 1), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), 6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(5), 5), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183767
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Write a function that returns TRUE if the object q will fly, and FALSE otherwise.
# The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
# Example:
# >>> will_it_fly(c(1, 2), 5)
# FALSE
# # 1+2 is less than the maximum possible weight, but it's unbalanced.
# >>> will_it_fly(c(3, 2, 3), 1)
# FALSE
# # it's balanced, but 3+2+3 is more than the maximum possible weight.
# >>> will_it_fly(c(3, 2, 3), 9)
# TRUE
# # 3+2+3 is less than the maximum possible weight, and it's balanced.
# >>> will_it_fly(c(3), 5)
# TRUE
# # 3 is less than the maximum possible weight, and it's balanced.
# Write a function that returns TRUE if the object q will fly, and FALSE otherwise.
# The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
# Example:
# >>> will_it_fly(c(1, 2), 5)
# FALSE
# # 1+2 is less than the maximum possible weight, but it's unbalanced.
# >>> will_it_fly(c(3, 2, 3), 1)
# FALSE
# # it's balanced, but 3+2+3 is more than the maximum possible weight.
# >>> will_it_fly(c(3, 2, 3), 9)
# TRUE
# # 3+2+3 is less than the maximum possible weight, and it's balanced.
# >>> will_it_fly(c(3), 5)
# TRUE
# # 3 is less than the maximum possible weight, and it's balanced.

will_it_fly <- function(q, w) {
  # Check if q is a palindrome
  is_palindrome <- all(q == rev(q))
  
  # Check if the sum of elements is within the weight limit
  within_weight <- sum(q) <= w
  
  # The object will fly only if both conditions are satisfied
  return(is_palindrome && within_weight)
}
test_humaneval <- function() {
    candidate <- will_it_fly
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 9), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2), 5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(3), 5), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 1), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), 6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(5), 5), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183767
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Write a function that returns TRUE if the object q will fly, and FALSE otherwise.
# The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
# Example:
# >>> will_it_fly(c(1, 2), 5)
# FALSE
# # 1+2 is less than the maximum possible weight, but it's unbalanced.
# >>> will_it_fly(c(3, 2, 3), 1)
# FALSE
# # it's balanced, but 3+2+3 is more than the maximum possible weight.
# >>> will_it_fly(c(3, 2, 3), 9)
# TRUE
# # 3+2+3 is less than the maximum possible weight, and it's balanced.
# >>> will_it_fly(c(3), 5)
# TRUE
# # 3 is less than the maximum possible weight, and it's balanced.
# Write a function that returns TRUE if the object q will fly, and FALSE otherwise.
# The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.

will_it_fly <- function(q, w) {
  # Check if q is a palindrome
  is_palindrome <- all(q == rev(q))
  
  # Check if the sum of elements is within the weight limit
  within_weight <- sum(q) <= w
  
  # Return TRUE only if both conditions are satisfied
  return(is_palindrome && within_weight)
}
test_humaneval <- function() {
    candidate <- will_it_fly
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 9), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2), 5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(3), 5), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 1), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), 6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(5), 5), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183767
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 73 (R) - HumanEval_73_smallest_change
================================================================================

PROMPT:
----------------------------------------
# Given a vector arr of integers, find the minimum number of elements that
# need to be changed to make the vector palindromic. A palindromic vector is a vector that
# is read the same backwards and forwards. In one change, you can change one element to any other element.
# For example:
# >>> smallest_change(c(1, 2, 3, 5, 4, 7, 9, 6))
# 4
# >>> smallest_change(c(1, 2, 3, 4, 3, 2, 2))
# 1
# >>> smallest_change(c(1, 2, 3, 2, 1))
# 0

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- smallest_change
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5, 4, 7, 9, 6)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 3, 2, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 4, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 1, 3)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given a vector arr of integers, find the minimum number of elements that
# need to be changed to make the vector palindromic. A palindromic vector is a vector that
# is read the same backwards and forwards. In one change, you can change one element to any other element.
# For example:
# >>> smallest_change(c(1, 2, 3, 5, 4, 7, 9, 6))
# 4
# >>> smallest_change(c(1, 2, 3, 4, 3, 2, 2))
# 1
# >>> smallest_change(c(1, 2, 3, 2, 1))
# 0
smallest_change <- function(arr) {
  n <- length(arr)
  # If the array has 0 or 1 element, it's already a palindrome
  if (n <= 1) return(0)
  
  # Count mismatched pairs
  half <- floor(n / 2)
  changes <- sum(arr[1:half] != arr[(n):(n - half + 1)])
  
  return(as.integer(changes))
}
test_humaneval <- function() {
    candidate <- smallest_change
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5, 4, 7, 9, 6)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 3, 2, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 4, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 1, 3)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183768
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given a vector arr of integers, find the minimum number of elements that
# need to be changed to make the vector palindromic. A palindromic vector is a vector that
# is read the same backwards and forwards. In one change, you can change one element to any other element.
# For example:
# >>> smallest_change(c(1, 2, 3, 5, 4, 7, 9, 6))
# 4
# >>> smallest_change(c(1, 2, 3, 4, 3, 2, 2))
# 1
# >>> smallest_change(c(1, 2, 3, 2, 1))
# 0
# Given a vector arr of integers, find the minimum number of elements that
# need to be changed to make the vector palindromic. A palindromic vector is a vector that
# is read the same backwards and forwards. In one change, you can change one element to any other element.
# For example:
# >>> smallest_change(c(1, 2, 3, 5, 4, 7, 9, 6))
# 4
# >>> smallest_change(c(1, 2, 3, 4, 3, 2, 2))
# 1
# >>> smallest_change(c(1, 2, 3, 2, 1))
# 0
smallest_change <- function(arr) {
  n <- length(arr)
  if (n <= 1) return(0)
  # Count mismatched symmetric pairs
  half <- floor(n / 2)
  sum(arr[1:half] != arr[(n: (n - half + 1))])
}
test_humaneval <- function() {
    candidate <- smallest_change
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5, 4, 7, 9, 6)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 3, 2, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 4, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 1, 3)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183768
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given a vector arr of integers, find the minimum number of elements that
# need to be changed to make the vector palindromic. A palindromic vector is a vector that
# is read the same backwards and forwards. In one change, you can change one element to any other element.
# For example:
# >>> smallest_change(c(1, 2, 3, 5, 4, 7, 9, 6))
# 4
# >>> smallest_change(c(1, 2, 3, 4, 3, 2, 2))
# 1
# >>> smallest_change(c(1, 2, 3, 2, 1))
# 0
# Find the minimum number of changes needed to make a vector palindromic.
# A change consists of replacing one element by any other value.
smallest_change <- function(arr) {
  n <- length(arr)
  if (n <= 1) return(0)          # already palindromic
  
  changes <- 0
  half   <- floor(n / 2)          # number of symmetric pairs
  
  for (i in seq_len(half)) {
    if (arr[i] != arr[n - i + 1]) {
      changes <- changes + 1
    }
  }
  
  return(changes)
}
test_humaneval <- function() {
    candidate <- smallest_change
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5, 4, 7, 9, 6)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 3, 2, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 4, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 1, 3)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183768
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given a vector arr of integers, find the minimum number of elements that
# need to be changed to make the vector palindromic. A palindromic vector is a vector that
# is read the same backwards and forwards. In one change, you can change one element to any other element.
# For example:
# >>> smallest_change(c(1, 2, 3, 5, 4, 7, 9, 6))
# 4
# >>> smallest_change(c(1, 2, 3, 4, 3, 2, 2))
# 1
# >>> smallest_change(c(1, 2, 3, 2, 1))
# 0
smallest_change <- function(arr) {
  n <- length(arr)
  if (n <= 1) return(0)
  
  mismatches <- 0
  half <- floor(n / 2)
  
  for (i in seq_len(half)) {
    if (arr[i] != arr[n - i + 1]) {
      mismatches <- mismatches + 1
    }
  }
  
  return(mismatches)
}
test_humaneval <- function() {
    candidate <- smallest_change
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5, 4, 7, 9, 6)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 3, 2, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 4, 2)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 1, 3)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183768
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 74 (R) - HumanEval_74_total_match
================================================================================

PROMPT:
----------------------------------------
# Write a function that accepts two lists of strings and returns the list that has 
# total number of chars in the all strings of the list less than the other list.
# if the two lists have the same number of chars, return the first list.
# Examples
# >>> total_match(c(), c())
# c()
# >>> total_match(c('hi', 'admin'), c('hI', 'Hi'))
# c('hI', 'Hi')
# >>> total_match(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project'))
# c('hi', 'admin')
# >>> total_match(c('hi', 'admin'), c('hI', 'hi', 'hi'))
# c('hI', 'hi', 'hi')
# >>> total_match(c('4'), c('1', '2', '3', '4', '5'))
# c('4')

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- total_match
    stopifnot(isTRUE(all.equal(candidate(c(), c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi')), c('hi', 'hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project')), c('hi', 'admin'))))
    stopifnot(isTRUE(all.equal(candidate(c('4'), c('1', '2', '3', '4', '5')), c('4'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'Hi')), c('hI', 'Hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hi')), c('hI', 'hi', 'hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hii')), c('hi', 'admin'))))
    stopifnot(isTRUE(all.equal(candidate(c(), c('this')), c())))
    stopifnot(isTRUE(all.equal(candidate(c('this'), c()), c())))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Write a function that accepts two lists of strings and returns the list that has 
# total number of chars in the all strings of the list less than the other list.
# if the two lists have the same number of chars, return the first list.
# Examples
# >>> total_match(c(), c())
# c()
# >>> total_match(c('hi', 'admin'), c('hI', 'Hi'))
# c('hI', 'Hi')
# >>> total_match(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project'))
# c('hi', 'admin')
# >>> total_match(c('hi', 'admin'), c('hI', 'hi', 'hi'))
# c('hI', 'hi', 'hi')
# >>> total_match(c('4'), c('1', '2', '3', '4', '5'))
# c('4')
total_match <- function(lst1, lst2) {
  # Calculate total number of characters in each list
  total1 <- sum(nchar(lst1))
  total2 <- sum(nchar(lst2))
  
  # Return the list with fewer total characters; if equal, return the first list
  if (total1 <= total2) {
    return(lst1)
  } else {
    return(lst2)
  }
}
test_humaneval <- function() {
    candidate <- total_match
    stopifnot(isTRUE(all.equal(candidate(c(), c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi')), c('hi', 'hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project')), c('hi', 'admin'))))
    stopifnot(isTRUE(all.equal(candidate(c('4'), c('1', '2', '3', '4', '5')), c('4'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'Hi')), c('hI', 'Hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hi')), c('hI', 'hi', 'hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hii')), c('hi', 'admin'))))
    stopifnot(isTRUE(all.equal(candidate(c(), c('this')), c())))
    stopifnot(isTRUE(all.equal(candidate(c('this'), c()), c())))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183768
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Write a function that accepts two lists of strings and returns the list that has 
# total number of chars in the all strings of the list less than the other list.
# if the two lists have the same number of chars, return the first list.
# Examples
# >>> total_match(c(), c())
# c()
# >>> total_match(c('hi', 'admin'), c('hI', 'Hi'))
# c('hI', 'Hi')
# >>> total_match(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project'))
# c('hi', 'admin')
# >>> total_match(c('hi', 'admin'), c('hI', 'hi', 'hi'))
# c('hI', 'hi', 'hi')
# >>> total_match(c('4'), c('1', '2', '3', '4', '5'))
# c('4')
# Write a function that accepts two lists of strings and returns the list that has 
# total number of chars in the all strings of the list less than the other list.
# if the two lists have the same number of chars, return the first list.
# Examples
# >>> total_match(c(), c())
# c()
# >>> total_match(c('hi', 'admin'), c('hI', 'Hi'))
# c('hI', 'Hi')
# >>> total_match(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project'))
# c('hi', 'admin')
# >>> total_match(c('hi', 'admin'), c('hI', 'hi', 'hi'))
# c('hI', 'hi', 'hi')
# >>> total_match(c('4'), c('1', '2', '3', '4', '5'))
# c('4')
total_match <- function(lst1, lst2) {
  # Compute total number of characters in each list
  sum1 <- sum(nchar(lst1))
  sum2 <- sum(nchar(lst2))
  
  # Return the list with the smaller total, or the first if equal
  if (sum1 <= sum2) {
    return(lst1)
  } else {
    return(lst2)
  }
}
test_humaneval <- function() {
    candidate <- total_match
    stopifnot(isTRUE(all.equal(candidate(c(), c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi')), c('hi', 'hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project')), c('hi', 'admin'))))
    stopifnot(isTRUE(all.equal(candidate(c('4'), c('1', '2', '3', '4', '5')), c('4'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'Hi')), c('hI', 'Hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hi')), c('hI', 'hi', 'hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hii')), c('hi', 'admin'))))
    stopifnot(isTRUE(all.equal(candidate(c(), c('this')), c())))
    stopifnot(isTRUE(all.equal(candidate(c('this'), c()), c())))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183768
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Write a function that accepts two lists of strings and returns the list that has 
# total number of chars in the all strings of the list less than the other list.
# if the two lists have the same number of chars, return the first list.
# Examples
# >>> total_match(c(), c())
# c()
# >>> total_match(c('hi', 'admin'), c('hI', 'Hi'))
# c('hI', 'Hi')
# >>> total_match(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project'))
# c('hi', 'admin')
# >>> total_match(c('hi', 'admin'), c('hI', 'hi', 'hi'))
# c('hI', 'hi', 'hi')
# >>> total_match(c('4'), c('1', '2', '3', '4', '5'))
# c('4')
total_match <- function(lst1, lst2) {
  # Compute total number of characters in each list
  total1 <- sum(nchar(lst1))
  total2 <- sum(nchar(lst2))
  
  # Return the list with the smaller total, or lst1 if equal
  if (total1 <= total2) {
    return(lst1)
  } else {
    return(lst2)
  }
}
test_humaneval <- function() {
    candidate <- total_match
    stopifnot(isTRUE(all.equal(candidate(c(), c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi')), c('hi', 'hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project')), c('hi', 'admin'))))
    stopifnot(isTRUE(all.equal(candidate(c('4'), c('1', '2', '3', '4', '5')), c('4'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'Hi')), c('hI', 'Hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hi')), c('hI', 'hi', 'hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hii')), c('hi', 'admin'))))
    stopifnot(isTRUE(all.equal(candidate(c(), c('this')), c())))
    stopifnot(isTRUE(all.equal(candidate(c('this'), c()), c())))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183768
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Write a function that accepts two lists of strings and returns the list that has 
# total number of chars in the all strings of the list less than the other list.
# if the two lists have the same number of chars, return the first list.
# Examples
# >>> total_match(c(), c())
# c()
# >>> total_match(c('hi', 'admin'), c('hI', 'Hi'))
# c('hI', 'Hi')
# >>> total_match(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project'))
# c('hi', 'admin')
# >>> total_match(c('hi', 'admin'), c('hI', 'hi', 'hi'))
# c('hI', 'hi', 'hi')
# >>> total_match(c('4'), c('1', '2', '3', '4', '5'))
# c('4')
total_match <- function(lst1, lst2) {
  # Compute total number of characters in each list
  len1 <- sum(nchar(lst1))
  len2 <- sum(nchar(lst2))
  
  # Return the list with fewer total characters.
  # If equal, return the first list.
  if (len1 <= len2) {
    lst1
  } else {
    lst2
  }
}
test_humaneval <- function() {
    candidate <- total_match
    stopifnot(isTRUE(all.equal(candidate(c(), c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi')), c('hi', 'hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project')), c('hi', 'admin'))))
    stopifnot(isTRUE(all.equal(candidate(c('4'), c('1', '2', '3', '4', '5')), c('4'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'Hi')), c('hI', 'Hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hi')), c('hI', 'hi', 'hi'))))
    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hii')), c('hi', 'admin'))))
    stopifnot(isTRUE(all.equal(candidate(c(), c('this')), c())))
    stopifnot(isTRUE(all.equal(candidate(c('this'), c()), c())))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183768
STDOUT: (empty)
STDERR: (empty)
--------------------
