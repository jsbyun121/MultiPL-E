As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3â€“7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 118 (LUA) - HumanEval_118_get_closest_vowel
================================================================================

PROMPT:
----------------------------------------
-- You are given a word. Your task is to find the closest vowel that stands between 
-- two consonants from the right side of the word (case sensitive).
-- Vowels in the beginning and ending doesn't count. Return empty string if you didn't
-- find any vowel met the above condition. 
-- You may assume that the given string contains English letter only.
-- Example:
-- >>> get_closest_vowel('yogurt')
-- 'u'
-- >>> get_closest_vowel('FULL')
-- 'U'
-- >>> get_closest_vowel('quick')
-- ''
-- >>> get_closest_vowel('ab')
-- ''

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = get_closest_vowel
    lu.assertEquals(candidate('yogurt'), 'u')
    lu.assertEquals(candidate('full'), 'u')
    lu.assertEquals(candidate('easy'), '')
    lu.assertEquals(candidate('eAsy'), '')
    lu.assertEquals(candidate('ali'), '')
    lu.assertEquals(candidate('bad'), 'a')
    lu.assertEquals(candidate('most'), 'o')
    lu.assertEquals(candidate('ab'), '')
    lu.assertEquals(candidate('ba'), '')
    lu.assertEquals(candidate('quick'), '')
    lu.assertEquals(candidate('anime'), 'i')
    lu.assertEquals(candidate('Asia'), '')
    lu.assertEquals(candidate('Above'), 'o')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You are given a word. Your task is to find the closest vowel that stands between 
-- two consonants from the right side of the word (case sensitive).
-- Vowels in the beginning and ending doesn't count. Return empty string if you didn't
-- find any vowel met the above condition. 
-- You may assume that the given string contains English letter only.
-- Example:
-- >>> get_closest_vowel('yogurt')
-- 'u'
-- >>> get_closest_vowel('FULL')
-- 'U'
-- >>> get_closest_vowel('quick')
-- ''
-- >>> get_closest_vowel('ab')
-- ''
local function get_closest_vowel(word)
  local len = #word
  if len < 3 then return "" end

  local vowels = "aeiouAEIOU"

  local function isVowel(ch)
    return vowels:find(ch, 1, true) ~= nil
  end

  for i = len - 1, 2, -1 do
    local c = word:sub(i, i)
    if isVowel(c) then
      local left  = word:sub(i - 1, i - 1)
      local right = word:sub(i + 1, i + 1)
      if not isVowel(left) and not isVowel(right) then
        return c
      end
    end
  end

  return ""
end
lu = require('luaunit')

function test_humaneval()
local candidate = get_closest_vowel
    lu.assertEquals(candidate('yogurt'), 'u')
    lu.assertEquals(candidate('full'), 'u')
    lu.assertEquals(candidate('easy'), '')
    lu.assertEquals(candidate('eAsy'), '')
    lu.assertEquals(candidate('ali'), '')
    lu.assertEquals(candidate('bad'), 'a')
    lu.assertEquals(candidate('most'), 'o')
    lu.assertEquals(candidate('ab'), '')
    lu.assertEquals(candidate('ba'), '')
    lu.assertEquals(candidate('quick'), '')
    lu.assertEquals(candidate('anime'), 'i')
    lu.assertEquals(candidate('Asia'), '')
    lu.assertEquals(candidate('Above'), 'o')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154477
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You are given a word. Your task is to find the closest vowel that stands between 
-- two consonants from the right side of the word (case sensitive).
-- Vowels in the beginning and ending doesn't count. Return empty string if you didn't
-- find any vowel met the above condition. 
-- You may assume that the given string contains English letter only.
-- Example:
-- >>> get_closest_vowel('yogurt')
-- 'u'
-- >>> get_closest_vowel('FULL')
-- 'U'
-- >>> get_closest_vowel('quick')
-- ''
-- >>> get_closest_vowel('ab')
-- ''
-- Find the closest vowel that is surrounded by two consonants, starting from the right side.
-- Vowels at the start or end of the word are ignored. If no such vowel exists, return an empty string.
local function get_closest_vowel(word)
    local len = #word
    if len < 3 then
        return ""
    end

    -- Helper to determine if a character is a vowel
    local function is_vowel(ch)
        return ch:match("[aeiouAEIOU]") ~= nil
    end

    -- Scan from right to left, skipping the first and last character
    for i = len - 1, 2, -1 do
        local ch = word:sub(i, i)
        if is_vowel(ch) then
            local left = word:sub(i - 1, i - 1)
            local right = word:sub(i + 1, i + 1)
            if not is_vowel(left) and not is_vowel(right) then
                return ch
            end
        end
    end

    return ""
end
lu = require('luaunit')

function test_humaneval()
local candidate = get_closest_vowel
    lu.assertEquals(candidate('yogurt'), 'u')
    lu.assertEquals(candidate('full'), 'u')
    lu.assertEquals(candidate('easy'), '')
    lu.assertEquals(candidate('eAsy'), '')
    lu.assertEquals(candidate('ali'), '')
    lu.assertEquals(candidate('bad'), 'a')
    lu.assertEquals(candidate('most'), 'o')
    lu.assertEquals(candidate('ab'), '')
    lu.assertEquals(candidate('ba'), '')
    lu.assertEquals(candidate('quick'), '')
    lu.assertEquals(candidate('anime'), 'i')
    lu.assertEquals(candidate('Asia'), '')
    lu.assertEquals(candidate('Above'), 'o')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154477
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You are given a word. Your task is to find the closest vowel that stands between 
-- two consonants from the right side of the word (case sensitive).
-- Vowels in the beginning and ending doesn't count. Return empty string if you didn't
-- find any vowel met the above condition. 
-- You may assume that the given string contains English letter only.
-- Example:
-- >>> get_closest_vowel('yogurt')
-- 'u'
-- >>> get_closest_vowel('FULL')
-- 'U'
-- >>> get_closest_vowel('quick')
-- ''
-- >>> get_closest_vowel('ab')
-- ''
-- Returns the closest vowel that is surrounded by two consonants,
-- searching from the right side of the word.
-- Vowels at the start or end of the word are ignored.
-- If no such vowel exists, an empty string is returned.
local function get_closest_vowel(word)
    -- Helper to decide if a character is a vowel
    local function is_vowel(ch)
        -- The string.find with plain search (third argument true)
        -- ensures we only look for an exact match, not a pattern.
        return 'aeiouAEIOU':find(ch, 1, true) ~= nil
    end

    local len = #word
    -- Scan from right to left
    for i = len, 1, -1 do
        local ch = word:sub(i, i)
        -- Skip vowels that are at the very start or end
        if i > 1 and i < len and is_vowel(ch) then
            local left  = word:sub(i - 1, i - 1)
            local right = word:sub(i + 1, i + 1)
            -- The neighbors must be consonants (i.e., not vowels)
            if not is_vowel(left) and not is_vowel(right) then
                return ch
            end
        end
    end

    return ''  -- No qualifying vowel found
end
lu = require('luaunit')

function test_humaneval()
local candidate = get_closest_vowel
    lu.assertEquals(candidate('yogurt'), 'u')
    lu.assertEquals(candidate('full'), 'u')
    lu.assertEquals(candidate('easy'), '')
    lu.assertEquals(candidate('eAsy'), '')
    lu.assertEquals(candidate('ali'), '')
    lu.assertEquals(candidate('bad'), 'a')
    lu.assertEquals(candidate('most'), 'o')
    lu.assertEquals(candidate('ab'), '')
    lu.assertEquals(candidate('ba'), '')
    lu.assertEquals(candidate('quick'), '')
    lu.assertEquals(candidate('anime'), 'i')
    lu.assertEquals(candidate('Asia'), '')
    lu.assertEquals(candidate('Above'), 'o')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755154477
STDOUT: (empty)
STDERR:
lua: /tmp/tmpntbefbnj.lua:24: 'end' expected (to close 'function' at line 21) near ':'
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You are given a word. Your task is to find the closest vowel that stands between 
-- two consonants from the right side of the word (case sensitive).
-- Vowels in the beginning and ending doesn't count. Return empty string if you didn't
-- find any vowel met the above condition. 
-- You may assume that the given string contains English letter only.
-- Example:
-- >>> get_closest_vowel('yogurt')
-- 'u'
-- >>> get_closest_vowel('FULL')
-- 'U'
-- >>> get_closest_vowel('quick')
-- ''
-- >>> get_closest_vowel('ab')
-- ''
-- Find the closest vowel that is sandwiched between two consonants,
-- scanning from the right side of the word.
local function get_closest_vowel(word)
    local vowels = "aeiouAEIOU"

    local function is_vowel(ch)
        return string.find(vowels, ch, 1, true) ~= nil
    end

    local n = #word
    if n < 3 then
        return ""          -- too short to have a vowel between two consonants
    end

    -- Scan from right to left, ignoring the first and last character
    for i = n - 1, 2, -1 do
        local mid = string.sub(word, i, i)
        if is_vowel(mid) then
            local left  = string.sub(word, i - 1, i - 1)
            local right = string.sub(word, i + 1, i + 1)
            if not is_vowel(left) and not is_vowel(right) then
                return mid   -- first (closest to the right) qualifying vowel
            end
        end
    end

    return ""  -- no vowel satisfies the condition
end
lu = require('luaunit')

function test_humaneval()
local candidate = get_closest_vowel
    lu.assertEquals(candidate('yogurt'), 'u')
    lu.assertEquals(candidate('full'), 'u')
    lu.assertEquals(candidate('easy'), '')
    lu.assertEquals(candidate('eAsy'), '')
    lu.assertEquals(candidate('ali'), '')
    lu.assertEquals(candidate('bad'), 'a')
    lu.assertEquals(candidate('most'), 'o')
    lu.assertEquals(candidate('ab'), '')
    lu.assertEquals(candidate('ba'), '')
    lu.assertEquals(candidate('quick'), '')
    lu.assertEquals(candidate('anime'), 'i')
    lu.assertEquals(candidate('Asia'), '')
    lu.assertEquals(candidate('Above'), 'o')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154477
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 120 (LUA) - HumanEval_120_maximum
================================================================================

PROMPT:
----------------------------------------
-- Given a table arr of integers and a positive integer k, return a sorted table 
-- of length k with the maximum k numbers in arr.
-- Example 1:
-- >>> maximum({-3, -4, 5}, 3)
-- {-4, -3, 5}
-- Example 2:
-- >>> maximum({4, -4, 4}, 2)
-- {4, 4}
-- Example 3:
-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)
-- {2}
-- Note:
--     1. The length of the table will be in the range of [1, 1000].
--     2. The elements in the table will be in the range of [-1000, 1000].
--     3. 0 <= k <= len(arr)

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = maximum
    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})
    lu.assertEquals(candidate({4, -4, 4}, 2), {4, 4})
    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1), {2})
    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20, 123})
    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})
    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3, 5, 15})
    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})
    lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})
    lu.assertEquals(candidate({4, -4}, 2), {-4, 4})
    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})
    lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a table arr of integers and a positive integer k, return a sorted table 
-- of length k with the maximum k numbers in arr.
-- Example 1:
-- >>> maximum({-3, -4, 5}, 3)
-- {-4, -3, 5}
-- Example 2:
-- >>> maximum({4, -4, 4}, 2)
-- {4, 4}
-- Example 3:
-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)
-- {2}
-- Note:
--     1. The length of the table will be in the range of [1, 1000].
--     2. The elements in the table will be in the range of [-1000, 1000].
--     3. 0 <= k <= len(arr)
-- Return the sorted table of the k largest numbers from `arr`.
-- If k is 0, an empty table is returned.
local function maximum(arr, k)
    -- Edge case: nothing to return
    if k == 0 then
        return {}
    end

    -- Make a copy of the original array to avoid sideâ€‘effects
    local copy = {unpack(arr)}

    -- Sort the copy in descending order to bring the largest values to the front
    table.sort(copy, function(a, b) return a > b end)

    -- Take the first k elements (the k largest)
    local result = {}
    for i = 1, k do
        result[i] = copy[i]
    end

    -- Finally sort the result in ascending order as required
    table.sort(result)

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = maximum
    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})
    lu.assertEquals(candidate({4, -4, 4}, 2), {4, 4})
    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1), {2})
    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20, 123})
    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})
    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3, 5, 15})
    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})
    lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})
    lu.assertEquals(candidate({4, -4}, 2), {-4, 4})
    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})
    lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755154478
STDOUT:
E
Failed tests:
-------------
1) test_humaneval
/tmp/tmpitmeyqix.lua:25: attempt to call a nil value (global 'unpack')
stack traceback:
	/tmp/tmpitmeyqix.lua:45: in function 'test_humaneval'

Ran 1 tests in 0.002 seconds, 0 successes, 1 error
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a table arr of integers and a positive integer k, return a sorted table 
-- of length k with the maximum k numbers in arr.
-- Example 1:
-- >>> maximum({-3, -4, 5}, 3)
-- {-4, -3, 5}
-- Example 2:
-- >>> maximum({4, -4, 4}, 2)
-- {4, 4}
-- Example 3:
-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)
-- {2}
-- Note:
--     1. The length of the table will be in the range of [1, 1000].
--     2. The elements in the table will be in the range of [-1000, 1000].
--     3. 0 <= k <= len(arr)
-- Return a sorted table of length `k` containing the largest `k` numbers from `arr`.
-- The returned table is sorted in ascending order.
local function maximum(arr, k)
    -- Handle the trivial case
    if k == 0 then
        return {}
    end

    -- Make a shallow copy of the input array so we don't mutate it
    local copy = {}
    for i = 1, #arr do
        copy[i] = arr[i]
    end

    -- Sort the copy in descending order to bring the largest elements to the front
    table.sort(copy, function(a, b) return a > b end)

    -- Pick the first `k` elements
    local result = {}
    for i = 1, k do
        result[i] = copy[i]
    end

    -- Finally sort the result in ascending order as required
    table.sort(result)

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = maximum
    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})
    lu.assertEquals(candidate({4, -4, 4}, 2), {4, 4})
    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1), {2})
    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20, 123})
    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})
    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3, 5, 15})
    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})
    lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})
    lu.assertEquals(candidate({4, -4}, 2), {-4, 4})
    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})
    lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154478
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a table arr of integers and a positive integer k, return a sorted table 
-- of length k with the maximum k numbers in arr.
-- Example 1:
-- >>> maximum({-3, -4, 5}, 3)
-- {-4, -3, 5}
-- Example 2:
-- >>> maximum({4, -4, 4}, 2)
-- {4, 4}
-- Example 3:
-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)
-- {2}
-- Note:
--     1. The length of the table will be in the range of [1, 1000].
--     2. The elements in the table will be in the range of [-1000, 1000].
--     3. 0 <= k <= len(arr)
-- Returns a sorted table containing the maximum `k` numbers from `arr`.
-- The returned table is sorted in ascending order.
local function maximum(arr, k)
    -- If k is 0, return an empty table immediately.
    if k == 0 then
        return {}
    end

    -- Make a copy of the original array to avoid mutating it.
    local sorted = {}
    for _, v in ipairs(arr) do
        table.insert(sorted, v)
    end

    -- Sort the copy in ascending order.
    table.sort(sorted)

    local n = #sorted
    local result = {}

    -- Extract the last `k` elements (the largest ones) and keep them sorted.
    for i = 1, k do
        result[i] = sorted[n - k + i]
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = maximum
    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})
    lu.assertEquals(candidate({4, -4, 4}, 2), {4, 4})
    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1), {2})
    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20, 123})
    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})
    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3, 5, 15})
    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})
    lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})
    lu.assertEquals(candidate({4, -4}, 2), {-4, 4})
    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})
    lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154478
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a table arr of integers and a positive integer k, return a sorted table 
-- of length k with the maximum k numbers in arr.
-- Example 1:
-- >>> maximum({-3, -4, 5}, 3)
-- {-4, -3, 5}
-- Example 2:
-- >>> maximum({4, -4, 4}, 2)
-- {4, 4}
-- Example 3:
-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)
-- {2}
-- Note:
--     1. The length of the table will be in the range of [1, 1000].
--     2. The elements in the table will be in the range of [-1000, 1000].
--     3. 0 <= k <= len(arr)
-- Returns a sorted table of length `k` containing the maximum `k` numbers from `arr`.
-- The result is sorted in ascending order.
local function maximum(arr, k)
    local n = #arr
    if k <= 0 then
        return {}
    end

    -- Make a shallow copy so we don't modify the original table
    local copy = {table.unpack(arr)}

    -- Sort the copy in descending order to bring the largest elements to the front
    table.sort(copy, function(a, b) return a > b end)

    -- Take the first `k` elements (the largest ones)
    local result = {}
    for i = 1, k do
        result[i] = copy[i]
    end

    -- Sort the result in ascending order as required
    table.sort(result)

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = maximum
    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})
    lu.assertEquals(candidate({4, -4, 4}, 2), {4, 4})
    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1), {2})
    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20, 123})
    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})
    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3, 5, 15})
    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})
    lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})
    lu.assertEquals(candidate({4, -4}, 2), {-4, 4})
    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})
    lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154478
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 122 (LUA) - HumanEval_122_add_elements
================================================================================

PROMPT:
----------------------------------------
-- Given a non-empty table of integers arr and an integer k, return
-- the sum of the elements with at most two digits from the first k elements of arr.
-- Example:
-- >>> add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)
-- 24
-- Constraints:
--     1. 1 <= len(arr) <= 100
--     2. 1 <= k <= len(arr)

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = add_elements
    lu.assertEquals(candidate({1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), -4)
    lu.assertEquals(candidate({111, 121, 3, 4000, 5, 6}, 2), 0)
    lu.assertEquals(candidate({11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), 125)
    lu.assertEquals(candidate({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), 24)
    lu.assertEquals(candidate({1}, 1), 1)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a non-empty table of integers arr and an integer k, return
-- the sum of the elements with at most two digits from the first k elements of arr.
-- Example:
-- >>> add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)
-- 24
-- Constraints:
--     1. 1 <= len(arr) <= 100
--     2. 1 <= k <= len(arr)
local function add_elements(arr, k)
    local sum = 0
    local limit = math.min(k, #arr)  -- safeguard if k > length
    for i = 1, limit do
        local val = arr[i]
        -- Count digits of the absolute value
        if math.abs(val) < 100 then
            sum = sum + val
        end
    end
    return sum
end
lu = require('luaunit')

function test_humaneval()
local candidate = add_elements
    lu.assertEquals(candidate({1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), -4)
    lu.assertEquals(candidate({111, 121, 3, 4000, 5, 6}, 2), 0)
    lu.assertEquals(candidate({11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), 125)
    lu.assertEquals(candidate({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), 24)
    lu.assertEquals(candidate({1}, 1), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154478
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a non-empty table of integers arr and an integer k, return
-- the sum of the elements with at most two digits from the first k elements of arr.
-- Example:
-- >>> add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)
-- 24
-- Constraints:
--     1. 1 <= len(arr) <= 100
--     2. 1 <= k <= len(arr)
-- Sum of elements with at most two digits from the first k elements of arr
local function add_elements(arr, k)
    local sum = 0
    for i = 1, k do
        local val = arr[i]
        -- Count digits by absolute value
        if math.abs(val) <= 99 then
            sum = sum + val
        end
    end
    return sum
end
lu = require('luaunit')

function test_humaneval()
local candidate = add_elements
    lu.assertEquals(candidate({1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), -4)
    lu.assertEquals(candidate({111, 121, 3, 4000, 5, 6}, 2), 0)
    lu.assertEquals(candidate({11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), 125)
    lu.assertEquals(candidate({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), 24)
    lu.assertEquals(candidate({1}, 1), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154478
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a non-empty table of integers arr and an integer k, return
-- the sum of the elements with at most two digits from the first k elements of arr.
-- Example:
-- >>> add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)
-- 24
-- Constraints:
--     1. 1 <= len(arr) <= 100
--     2. 1 <= k <= len(arr)
-- Sum the elements with at most two digits from the first `k` elements of `arr`.
-- An integer has at most two digits if its absolute value is â‰¤ 99.
--
-- @param arr table of integers (nonâ€‘empty)
-- @param k  integer, 1 â‰¤ k â‰¤ #arr
-- @return   integer, the sum of qualifying elements
local function add_elements(arr, k)
    local sum = 0
    for i = 1, k do
        local val = arr[i]
        if math.abs(val) <= 99 then
            sum = sum + val
        end
    end
    return sum
end
lu = require('luaunit')

function test_humaneval()
local candidate = add_elements
    lu.assertEquals(candidate({1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), -4)
    lu.assertEquals(candidate({111, 121, 3, 4000, 5, 6}, 2), 0)
    lu.assertEquals(candidate({11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), 125)
    lu.assertEquals(candidate({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), 24)
    lu.assertEquals(candidate({1}, 1), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154478
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a non-empty table of integers arr and an integer k, return
-- the sum of the elements with at most two digits from the first k elements of arr.
-- Example:
-- >>> add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)
-- 24
-- Constraints:
--     1. 1 <= len(arr) <= 100
--     2. 1 <= k <= len(arr)
-- Returns the sum of the elements with at most two digits
-- from the first `k` elements of the array `arr`.
--
-- The function iterates over the first `k` elements, counts the
-- number of decimal digits of each element (using absolute value),
-- and adds it to the running total if the digit count is 1 or 2.
--
-- Example:
--   add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)  --> 24
--
-- Parameters:
--   arr - a nonâ€‘empty table of integers
--   k   - the number of initial elements to consider (1 â‰¤ k â‰¤ #arr)
--
-- Returns:
--   The sum of all elements among the first `k` that have at most
--   two decimal digits.
local function add_elements(arr, k)
    local sum = 0

    for i = 1, k do
        local n = arr[i]
        local absVal = math.abs(n)

        -- Count digits; treat 0 as one digit
        local digits
        if absVal == 0 then
            digits = 1
        else
            digits = 0
            while absVal > 0 do
                digits = digits + 1
                absVal = math.floor(absVal / 10)
            end
        end

        if digits <= 2 then
            sum = sum + n
        end
    end

    return sum
end

return add_elements
lu = require('luaunit')

function test_humaneval()
local candidate = add_elements
    lu.assertEquals(candidate({1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), -4)
    lu.assertEquals(candidate({111, 121, 3, 4000, 5, 6}, 2), 0)
    lu.assertEquals(candidate({11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), 125)
    lu.assertEquals(candidate({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), 24)
    lu.assertEquals(candidate({1}, 1), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755154478
STDOUT: (empty)
STDERR:
lua: /tmp/tmp0wfsr1c_.lua:54: <eof> expected near 'lu'
--------------------

================================================================================
PROBLEM 124 (LUA) - HumanEval_124_valid_date
================================================================================

PROMPT:
----------------------------------------
-- You have to write a function which validates a given date string and
-- returns true if the date is valid otherwise false.
-- The date is valid if all of the following rules are satisfied:
-- 1. The date string is not empty.
-- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
-- 3. The months should not be less than 1 or higher than 12.
-- 4. The date should be in the format: mm-dd-yyyy
-- >>> valid_date('03-11-2000')
-- true
-- >>> valid_date('15-01-2012')
-- false
-- >>> valid_date('04-0-2040')
-- false
-- >>> valid_date('06-04-2020')
-- true
-- >>> valid_date('06/04/2020')
-- false

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = valid_date
    lu.assertEquals(candidate('03-11-2000'), true)
    lu.assertEquals(candidate('15-01-2012'), false)
    lu.assertEquals(candidate('04-0-2040'), false)
    lu.assertEquals(candidate('06-04-2020'), true)
    lu.assertEquals(candidate('01-01-2007'), true)
    lu.assertEquals(candidate('03-32-2011'), false)
    lu.assertEquals(candidate(''), false)
    lu.assertEquals(candidate('04-31-3000'), false)
    lu.assertEquals(candidate('06-06-2005'), true)
    lu.assertEquals(candidate('21-31-2000'), false)
    lu.assertEquals(candidate('04-12-2003'), true)
    lu.assertEquals(candidate('04122003'), false)
    lu.assertEquals(candidate('20030412'), false)
    lu.assertEquals(candidate('2003-04'), false)
    lu.assertEquals(candidate('2003-04-12'), false)
    lu.assertEquals(candidate('04-2003'), false)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You have to write a function which validates a given date string and
-- returns true if the date is valid otherwise false.
-- The date is valid if all of the following rules are satisfied:
-- 1. The date string is not empty.
-- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
-- 3. The months should not be less than 1 or higher than 12.
-- 4. The date should be in the format: mm-dd-yyyy
-- >>> valid_date('03-11-2000')
-- true
-- >>> valid_date('15-01-2012')
-- false
-- >>> valid_date('04-0-2040')
-- false
-- >>> valid_date('06-04-2020')
-- true
-- >>> valid_date('06/04/2020')
-- false
-- Validate a date string in the format mm-dd-yyyy
-- Returns true if the date is valid, otherwise false
local function valid_date(date)
  -- 1. The date string must not be empty
  if not date or date == "" then
    return false
  end

  -- 4. The date must match mm-dd-yyyy (two digits for month and day, four for year)
  local m, d, y = date:match("^(%d%d)-(%d%d)-(%d%d%d%d)$")
  if not (m and d and y) then
    return false
  end

  local month = tonumber(m)
  local day   = tonumber(d)
  -- year is not validated beyond the format, but we convert it to a number
  local year  = tonumber(y)

  -- 3. Validate month range
  if month < 1 or month > 12 then
    return false
  end

  -- 2. Validate day range based on month
  if day < 1 then
    return false
  end

  local max_day
  if month == 2 then
    max_day = 29   -- February can have up to 29 days
  elseif month == 4 or month == 6 or month == 9 or month == 11 then
    max_day = 30   -- April, June, September, November
  else
    max_day = 31   -- All other months
  end

  if day > max_day then
    return false
  end

  -- All checks passed
  return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = valid_date
    lu.assertEquals(candidate('03-11-2000'), true)
    lu.assertEquals(candidate('15-01-2012'), false)
    lu.assertEquals(candidate('04-0-2040'), false)
    lu.assertEquals(candidate('06-04-2020'), true)
    lu.assertEquals(candidate('01-01-2007'), true)
    lu.assertEquals(candidate('03-32-2011'), false)
    lu.assertEquals(candidate(''), false)
    lu.assertEquals(candidate('04-31-3000'), false)
    lu.assertEquals(candidate('06-06-2005'), true)
    lu.assertEquals(candidate('21-31-2000'), false)
    lu.assertEquals(candidate('04-12-2003'), true)
    lu.assertEquals(candidate('04122003'), false)
    lu.assertEquals(candidate('20030412'), false)
    lu.assertEquals(candidate('2003-04'), false)
    lu.assertEquals(candidate('2003-04-12'), false)
    lu.assertEquals(candidate('04-2003'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154478
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You have to write a function which validates a given date string and
-- returns true if the date is valid otherwise false.
-- The date is valid if all of the following rules are satisfied:
-- 1. The date string is not empty.
-- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
-- 3. The months should not be less than 1 or higher than 12.
-- 4. The date should be in the format: mm-dd-yyyy
-- >>> valid_date('03-11-2000')
-- true
-- >>> valid_date('15-01-2012')
-- false
-- >>> valid_date('04-0-2040')
-- false
-- >>> valid_date('06-04-2020')
-- true
-- >>> valid_date('06/04/2020')
-- false
-- Validates a date string in the format mm-dd-yyyy
-- Returns true if the date is valid, otherwise false
local function valid_date(date)
  -- 1. The date string is not empty.
  if not date or date == '' then
    return false
  end

  -- 4. The date should be in the format: mm-dd-yyyy
  --   (two digits for month, two for day, four for year)
  local mm, dd, yyyy = date:match('^(%d%d)%-(%d%d)%-(%d%d%d%d)$')
  if not mm or not dd or not yyyy then
    return false
  end

  local month = tonumber(mm)
  local day   = tonumber(dd)

  -- 3. The months should not be less than 1 or higher than 12.
  if month < 1 or month > 12 then
    return false
  end

  -- 2. Validate the number of days for each month
  if day < 1 then
    return false
  end

  if month == 2 then
    -- February: 1-29 days (leap year not considered)
    if day > 29 then
      return false
    end
  elseif month == 4 or month == 6 or month == 9 or month == 11 then
    -- April, June, September, November: 1-30 days
    if day > 30 then
      return false
    end
  else
    -- All other months: 1-31 days
    if day > 31 then
      return false
    end
  end

  return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = valid_date
    lu.assertEquals(candidate('03-11-2000'), true)
    lu.assertEquals(candidate('15-01-2012'), false)
    lu.assertEquals(candidate('04-0-2040'), false)
    lu.assertEquals(candidate('06-04-2020'), true)
    lu.assertEquals(candidate('01-01-2007'), true)
    lu.assertEquals(candidate('03-32-2011'), false)
    lu.assertEquals(candidate(''), false)
    lu.assertEquals(candidate('04-31-3000'), false)
    lu.assertEquals(candidate('06-06-2005'), true)
    lu.assertEquals(candidate('21-31-2000'), false)
    lu.assertEquals(candidate('04-12-2003'), true)
    lu.assertEquals(candidate('04122003'), false)
    lu.assertEquals(candidate('20030412'), false)
    lu.assertEquals(candidate('2003-04'), false)
    lu.assertEquals(candidate('2003-04-12'), false)
    lu.assertEquals(candidate('04-2003'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154478
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You have to write a function which validates a given date string and
-- returns true if the date is valid otherwise false.
-- The date is valid if all of the following rules are satisfied:
-- 1. The date string is not empty.
-- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
-- 3. The months should not be less than 1 or higher than 12.
-- 4. The date should be in the format: mm-dd-yyyy
-- >>> valid_date('03-11-2000')
-- true
-- >>> valid_date('15-01-2012')
-- false
-- >>> valid_date('04-0-2040')
-- false
-- >>> valid_date('06-04-2020')
-- true
-- >>> valid_date('06/04/2020')
-- false
-- Validates a date string in the format mm-dd-yyyy.
-- Returns true if the date is valid, otherwise false.
local function valid_date(date)
    -- Rule 1: The date string must not be empty
    if not date or date == "" then
        return false
    end

    -- Rule 4: The date must match the pattern mm-dd-yyyy
    local monthStr, dayStr, yearStr = date:match("^([0-9]{2})-([0-9]{2})-([0-9]{4})$")
    if not monthStr or not dayStr or not yearStr then
        return false
    end

    -- Convert to numbers
    local month = tonumber(monthStr)
    local day   = tonumber(dayStr)
    local year  = tonumber(yearStr)  -- year is not validated beyond being four digits

    -- Rule 3: Month must be between 1 and 12
    if month < 1 or month > 12 then
        return false
    end

    -- Determine the maximum days for the given month
    local maxDays
    if month == 2 then
        maxDays = 29  -- February (no leap year check)
    elseif month == 4 or month == 6 or month == 9 or month == 11 then
        maxDays = 30
    else
        maxDays = 31
    end

    -- Rule 2: Day must be within the allowed range for the month
    if day < 1 or day > maxDays then
        return false
    end

    -- All checks passed
    return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = valid_date
    lu.assertEquals(candidate('03-11-2000'), true)
    lu.assertEquals(candidate('15-01-2012'), false)
    lu.assertEquals(candidate('04-0-2040'), false)
    lu.assertEquals(candidate('06-04-2020'), true)
    lu.assertEquals(candidate('01-01-2007'), true)
    lu.assertEquals(candidate('03-32-2011'), false)
    lu.assertEquals(candidate(''), false)
    lu.assertEquals(candidate('04-31-3000'), false)
    lu.assertEquals(candidate('06-06-2005'), true)
    lu.assertEquals(candidate('21-31-2000'), false)
    lu.assertEquals(candidate('04-12-2003'), true)
    lu.assertEquals(candidate('04122003'), false)
    lu.assertEquals(candidate('20030412'), false)
    lu.assertEquals(candidate('2003-04'), false)
    lu.assertEquals(candidate('2003-04-12'), false)
    lu.assertEquals(candidate('04-2003'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755154478
STDOUT:
F
Failed tests:
-------------
1) test_humaneval
/tmp/tmp5cckcltp.lua:64: expected: true, actual: false
stack traceback:
	/tmp/tmp5cckcltp.lua:64: in function 'test_humaneval'

Ran 1 tests in 0.002 seconds, 0 successes, 1 failure
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You have to write a function which validates a given date string and
-- returns true if the date is valid otherwise false.
-- The date is valid if all of the following rules are satisfied:
-- 1. The date string is not empty.
-- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
-- 3. The months should not be less than 1 or higher than 12.
-- 4. The date should be in the format: mm-dd-yyyy
-- >>> valid_date('03-11-2000')
-- true
-- >>> valid_date('15-01-2012')
-- false
-- >>> valid_date('04-0-2040')
-- false
-- >>> valid_date('06-04-2020')
-- true
-- >>> valid_date('06/04/2020')
-- false
local function valid_date(date)
  -- Rule 1: string must not be empty
  if not date or date == "" then
    return false
  end

  -- Rule 4: format must be mm-dd-yyyy with two digits for month and day
  local mm, dd, yyyy = date:match("^(%d%d)%-(%d%d)%-(%d%d%d%d)$")
  if not mm or not dd or not yyyy then
    return false
  end

  local month = tonumber(mm)
  local day   = tonumber(dd)

  -- Rule 3: month must be between 1 and 12
  if month < 1 or month > 12 then
    return false
  end

  -- Rule 2: day must be within the valid range for the month
  if day < 1 then
    return false
  end

  if month == 2 then
    if day > 29 then return false end          -- February
  elseif month == 4 or month == 6 or month == 9 or month == 11 then
    if day > 30 then return false end          -- Apr, Jun, Sep, Nov
  else
    if day > 31 then return false end          -- All other months
  end

  return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = valid_date
    lu.assertEquals(candidate('03-11-2000'), true)
    lu.assertEquals(candidate('15-01-2012'), false)
    lu.assertEquals(candidate('04-0-2040'), false)
    lu.assertEquals(candidate('06-04-2020'), true)
    lu.assertEquals(candidate('01-01-2007'), true)
    lu.assertEquals(candidate('03-32-2011'), false)
    lu.assertEquals(candidate(''), false)
    lu.assertEquals(candidate('04-31-3000'), false)
    lu.assertEquals(candidate('06-06-2005'), true)
    lu.assertEquals(candidate('21-31-2000'), false)
    lu.assertEquals(candidate('04-12-2003'), true)
    lu.assertEquals(candidate('04122003'), false)
    lu.assertEquals(candidate('20030412'), false)
    lu.assertEquals(candidate('2003-04'), false)
    lu.assertEquals(candidate('2003-04-12'), false)
    lu.assertEquals(candidate('04-2003'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154478
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 135 (LUA) - HumanEval_135_can_arrange
================================================================================

PROMPT:
----------------------------------------
-- Create a function which returns the largest index of an element which
-- is not greater than or equal to the element immediately preceding it. If
-- no such element exists then return -1. The given table will not contain
-- duplicate values.
-- Examples:
-- >>> can_arrange({1, 2, 4, 3, 5})
-- 3
-- >>> can_arrange({1, 2, 3})
-- -1

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = can_arrange
    lu.assertEquals(candidate({1, 2, 4, 3, 5}), 3)
    lu.assertEquals(candidate({1, 2, 4, 5}), -1)
    lu.assertEquals(candidate({1, 4, 2, 5, 6, 7, 8, 9, 10}), 2)
    lu.assertEquals(candidate({4, 8, 5, 7, 3}), 4)
    lu.assertEquals(candidate({}), -1)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Create a function which returns the largest index of an element which
-- is not greater than or equal to the element immediately preceding it. If
-- no such element exists then return -1. The given table will not contain
-- duplicate values.
-- Examples:
-- >>> can_arrange({1, 2, 4, 3, 5})
-- 3
-- >>> can_arrange({1, 2, 3})
-- -1
-- Find the largest index i such that arr[i] < arr[i-1].
-- If no such index exists, return -1.
local function can_arrange(arr)
    -- Need at least two elements to compare
    if #arr < 2 then
        return -1
    end

    -- Scan from the end to find the first (largest) index satisfying the condition
    for i = #arr, 2, -1 do
        if arr[i] < arr[i - 1] then
            return i
        end
    end

    return -1
end
lu = require('luaunit')

function test_humaneval()
local candidate = can_arrange
    lu.assertEquals(candidate({1, 2, 4, 3, 5}), 3)
    lu.assertEquals(candidate({1, 2, 4, 5}), -1)
    lu.assertEquals(candidate({1, 4, 2, 5, 6, 7, 8, 9, 10}), 2)
    lu.assertEquals(candidate({4, 8, 5, 7, 3}), 4)
    lu.assertEquals(candidate({}), -1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755154479
STDOUT:
F
Failed tests:
-------------
1) test_humaneval
/tmp/tmpxunrlg22.lua:31: expected: 3, actual: 4
stack traceback:
	/tmp/tmpxunrlg22.lua:31: in function 'test_humaneval'

Ran 1 tests in 0.002 seconds, 0 successes, 1 failure
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Create a function which returns the largest index of an element which
-- is not greater than or equal to the element immediately preceding it. If
-- no such element exists then return -1. The given table will not contain
-- duplicate values.
-- Examples:
-- >>> can_arrange({1, 2, 4, 3, 5})
-- 3
-- >>> can_arrange({1, 2, 3})
-- -1
-- Return the largest 0â€‘based index `i` such that `arr[i] < arr[i-1]`.
-- If no such index exists, return -1.
local function can_arrange(arr)
    local n = #arr
    if n < 2 then
        return -1
    end

    local maxIdx = -1
    for i = 2, n do
        if arr[i] < arr[i - 1] then
            -- Convert Lua's 1â€‘based index to 0â€‘based
            local zeroBasedIdx = i - 1
            if zeroBasedIdx > maxIdx then
                maxIdx = zeroBasedIdx
            end
        end
    end
    return maxIdx
end
lu = require('luaunit')

function test_humaneval()
local candidate = can_arrange
    lu.assertEquals(candidate({1, 2, 4, 3, 5}), 3)
    lu.assertEquals(candidate({1, 2, 4, 5}), -1)
    lu.assertEquals(candidate({1, 4, 2, 5, 6, 7, 8, 9, 10}), 2)
    lu.assertEquals(candidate({4, 8, 5, 7, 3}), 4)
    lu.assertEquals(candidate({}), -1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154479
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Create a function which returns the largest index of an element which
-- is not greater than or equal to the element immediately preceding it. If
-- no such element exists then return -1. The given table will not contain
-- duplicate values.
-- Examples:
-- >>> can_arrange({1, 2, 4, 3, 5})
-- 3
-- >>> can_arrange({1, 2, 3})
-- -1
-- Create a function which returns the largest index of an element which
-- is not greater than or equal to the element immediately preceding it.
-- If no such element exists then return -1. The given table will not contain
-- duplicate values.
-- Examples:
-- >>> can_arrange({1, 2, 4, 3, 5})
-- 3
-- >>> can_arrange({1, 2, 3})
-- -1
local function can_arrange(arr)
    local n = #arr
    local res = -1  -- default if no decreasing pair is found
    for i = 2, n do
        if arr[i] < arr[i-1] then
            -- convert Lua's 1â€‘based index to 0â€‘based as required by the examples
            res = i - 1
        end
    end
    return res
end
lu = require('luaunit')

function test_humaneval()
local candidate = can_arrange
    lu.assertEquals(candidate({1, 2, 4, 3, 5}), 3)
    lu.assertEquals(candidate({1, 2, 4, 5}), -1)
    lu.assertEquals(candidate({1, 4, 2, 5, 6, 7, 8, 9, 10}), 2)
    lu.assertEquals(candidate({4, 8, 5, 7, 3}), 4)
    lu.assertEquals(candidate({}), -1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154479
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Create a function which returns the largest index of an element which
-- is not greater than or equal to the element immediately preceding it. If
-- no such element exists then return -1. The given table will not contain
-- duplicate values.
-- Examples:
-- >>> can_arrange({1, 2, 4, 3, 5})
-- 3
-- >>> can_arrange({1, 2, 3})
-- -1
-- Returns the largest index (0â€‘based) of an element that is strictly less
-- than its immediate predecessor. If no such element exists, returns -1.
--
-- Example:
--   can_arrange({1, 2, 4, 3, 5})  --> 3   (index of the value 3)
--   can_arrange({1, 2, 3})        --> -1
local function can_arrange(arr)
    -- Guard against nil or too short tables
    if not arr or #arr < 2 then
        return -1
    end

    local lastIndex = -1
    for i = 2, #arr do
        if arr[i] < arr[i - 1] then
            -- Convert Lua 1â€‘based index to 0â€‘based
            lastIndex = i - 1
        end
    end

    return lastIndex
end
lu = require('luaunit')

function test_humaneval()
local candidate = can_arrange
    lu.assertEquals(candidate({1, 2, 4, 3, 5}), 3)
    lu.assertEquals(candidate({1, 2, 4, 5}), -1)
    lu.assertEquals(candidate({1, 4, 2, 5, 6, 7, 8, 9, 10}), 2)
    lu.assertEquals(candidate({4, 8, 5, 7, 3}), 4)
    lu.assertEquals(candidate({}), -1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154479
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 137 (LUA) - HumanEval_137_compare_one
================================================================================

PROMPT:
----------------------------------------
-- Create a function that takes integers, floats, or strings representing
-- real numbers, and returns the larger variable in its given variable type.
-- Return nil if the values are equal.
-- Note: If a real number is represented as a string, the floating point might be . or ,
-- >>> compare_one(1, 2.5)
-- 2.5
-- >>> compare_one(1, '2,3')
-- '2,3'
-- >>> compare_one('5,1', '6')
-- '6'
-- >>> compare_one('1', 1)
-- None

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = compare_one
    lu.assertEquals(candidate(1, 2), 2)
    lu.assertEquals(candidate(1, 2.5), 2.5)
    lu.assertEquals(candidate(2, 3), 3)
    lu.assertEquals(candidate(5, 6), 6)
    lu.assertEquals(candidate(1, '2,3'), '2,3')
    lu.assertEquals(candidate('5,1', '6'), '6')
    lu.assertEquals(candidate('1', '2'), '2')
    lu.assertEquals(candidate('1', 1), None)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Create a function that takes integers, floats, or strings representing
-- real numbers, and returns the larger variable in its given variable type.
-- Return nil if the values are equal.
-- Note: If a real number is represented as a string, the floating point might be . or ,
-- >>> compare_one(1, 2.5)
-- 2.5
-- >>> compare_one(1, '2,3')
-- '2,3'
-- >>> compare_one('5,1', '6')
-- '6'
-- >>> compare_one('1', 1)
-- None
-- Returns the larger of `a` or `b`, preserving the original type.
-- If the numeric values are equal, returns nil.
local function compare_one(a, b)
    -- Helper to convert a value to a number for comparison
    local function to_number(x)
        if type(x) == "string" then
            -- Accept both '.' and ',' as decimal separators
            local s = x:gsub(",", ".")
            return tonumber(s)
        elseif type(x) == "number" then
            return x
        else
            return nil
        end
    end

    local a_num = to_number(a)
    local b_num = to_number(b)

    if a_num == nil or b_num == nil then
        return nil  -- cannot compare
    end

    if a_num > b_num then
        return a
    elseif b_num > a_num then
        return b
    else
        return nil  -- equal values
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = compare_one
    lu.assertEquals(candidate(1, 2), 2)
    lu.assertEquals(candidate(1, 2.5), 2.5)
    lu.assertEquals(candidate(2, 3), 3)
    lu.assertEquals(candidate(5, 6), 6)
    lu.assertEquals(candidate(1, '2,3'), '2,3')
    lu.assertEquals(candidate('5,1', '6'), '6')
    lu.assertEquals(candidate('1', '2'), '2')
    lu.assertEquals(candidate('1', 1), None)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Create a function that takes integers, floats, or strings representing
-- real numbers, and returns the larger variable in its given variable type.
-- Return nil if the values are equal.
-- Note: If a real number is represented as a string, the floating point might be . or ,
-- >>> compare_one(1, 2.5)
-- 2.5
-- >>> compare_one(1, '2,3')
-- '2,3'
-- >>> compare_one('5,1', '6')
-- '6'
-- >>> compare_one('1', 1)
-- None
local function compare_one(a, b)
    -- Convert a value to a numeric form, handling both Lua numbers and
    -- strings that may use either '.' or ',' as the decimal separator.
    local function to_num(x)
        if type(x) == "string" then
            local s = x:gsub(",", ".")
            return tonumber(s)
        else
            return x
        end
    end

    local num_a = to_num(a)
    local num_b = to_num(b)

    -- If either conversion failed, we cannot compare reliably.
    if num_a == nil or num_b == nil then
        return nil
    end

    if num_a == num_b then
        return nil
    elseif num_a > num_b then
        return a
    else
        return b
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = compare_one
    lu.assertEquals(candidate(1, 2), 2)
    lu.assertEquals(candidate(1, 2.5), 2.5)
    lu.assertEquals(candidate(2, 3), 3)
    lu.assertEquals(candidate(5, 6), 6)
    lu.assertEquals(candidate(1, '2,3'), '2,3')
    lu.assertEquals(candidate('5,1', '6'), '6')
    lu.assertEquals(candidate('1', '2'), '2')
    lu.assertEquals(candidate('1', 1), None)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Create a function that takes integers, floats, or strings representing
-- real numbers, and returns the larger variable in its given variable type.
-- Return nil if the values are equal.
-- Note: If a real number is represented as a string, the floating point might be . or ,
-- >>> compare_one(1, 2.5)
-- 2.5
-- >>> compare_one(1, '2,3')
-- '2,3'
-- >>> compare_one('5,1', '6')
-- '6'
-- >>> compare_one('1', 1)
-- None
-- Create a function that takes integers, floats, or strings representing
-- real numbers, and returns the larger variable in its given variable type.
-- Return nil if the values are equal.
-- Note: If a real number is represented as a string, the floating point might be . or ,
-- >>> compare_one(1, 2.5)
-- 2.5
-- >>> compare_one(1, '2,3')
-- '2,3'
-- >>> compare_one('5,1', '6')
-- '6'
-- >>> compare_one('1', 1)
-- nil
local function compare_one(a, b)
    -- Helper to convert a value to a numeric representation
    local function to_number(v)
        if type(v) == "string" then
            -- Replace comma decimal separator with dot
            local cleaned = v:gsub(",", ".")
            return tonumber(cleaned)
        elseif type(v) == "number" then
            return v
        else
            return nil  -- Unsupported type
        end
    end

    local num_a = to_number(a)
    local num_b = to_number(b)

    -- If conversion failed for any argument, treat as nil (no comparison)
    if not num_a or not num_b then
        return nil
    end

    if num_a > num_b then
        return a
    elseif num_b > num_a then
        return b
    else
        return nil
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = compare_one
    lu.assertEquals(candidate(1, 2), 2)
    lu.assertEquals(candidate(1, 2.5), 2.5)
    lu.assertEquals(candidate(2, 3), 3)
    lu.assertEquals(candidate(5, 6), 6)
    lu.assertEquals(candidate(1, '2,3'), '2,3')
    lu.assertEquals(candidate('5,1', '6'), '6')
    lu.assertEquals(candidate('1', '2'), '2')
    lu.assertEquals(candidate('1', 1), None)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Create a function that takes integers, floats, or strings representing
-- real numbers, and returns the larger variable in its given variable type.
-- Return nil if the values are equal.
-- Note: If a real number is represented as a string, the floating point might be . or ,
-- >>> compare_one(1, 2.5)
-- 2.5
-- >>> compare_one(1, '2,3')
-- '2,3'
-- >>> compare_one('5,1', '6')
-- '6'
-- >>> compare_one('1', 1)
-- None
local function compare_one(a, b)
  -- Helper to convert a value to a number for comparison
  local function to_number(v)
    if type(v) == "number" then
      return v
    elseif type(v) == "string" then
      -- Replace comma with dot for decimal separator
      local num = tonumber(v) or tonumber(v:gsub(",", "."))
      return num
    end
    return nil
  end

  local val_a = to_number(a)
  local val_b = to_number(b)

  -- If conversion failed for either input, treat as nil (should not happen per spec)
  if val_a == nil or val_b == nil then
    return nil
  end

  if val_a > val_b then
    return a
  elseif val_b > val_a then
    return b
  else
    return nil  -- equal
  end
end
lu = require('luaunit')

function test_humaneval()
local candidate = compare_one
    lu.assertEquals(candidate(1, 2), 2)
    lu.assertEquals(candidate(1, 2.5), 2.5)
    lu.assertEquals(candidate(2, 3), 3)
    lu.assertEquals(candidate(5, 6), 6)
    lu.assertEquals(candidate(1, '2,3'), '2,3')
    lu.assertEquals(candidate('5,1', '6'), '6')
    lu.assertEquals(candidate('1', '2'), '2')
    lu.assertEquals(candidate('1', 1), None)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755154480
STDOUT:
E
Failed tests:
-------------
1) test_humaneval
/tmp/tmpz_xave3k.lua:20: bad argument #2 to 'tonumber' (base out of range)
stack traceback:
	/tmp/tmpz_xave3k.lua:20: in local 'to_number'
	/tmp/tmpz_xave3k.lua:27: in local 'candidate'
	/tmp/tmpz_xave3k.lua:50: in function 'test_humaneval'

Ran 1 tests in 0.002 seconds, 0 successes, 1 error
STDERR: (empty)
--------------------

================================================================================
PROBLEM 144 (LUA) - HumanEval_144_simplify
================================================================================

PROMPT:
----------------------------------------
-- Your task is to implement a function that will simplify the expression
-- x * n. The function returns true if x * n evaluates to a whole number and false
-- otherwise. Both x and n, are string representation of a fraction, and have the following format,
-- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
-- You can assume that x, and n are valid fractions, and do not have zero as denominator.
-- >>> simplify('1/5', '5/1')
-- true
-- >>> simplify('1/6', '2/1')
-- false
-- >>> simplify('7/10', '10/2')
-- false

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = simplify
    lu.assertEquals(candidate('1/5', '5/1'), true)
    lu.assertEquals(candidate('1/6', '2/1'), false)
    lu.assertEquals(candidate('5/1', '3/1'), true)
    lu.assertEquals(candidate('7/10', '10/2'), false)
    lu.assertEquals(candidate('2/10', '50/10'), true)
    lu.assertEquals(candidate('7/2', '4/2'), true)
    lu.assertEquals(candidate('11/6', '6/1'), true)
    lu.assertEquals(candidate('2/3', '5/2'), false)
    lu.assertEquals(candidate('5/2', '3/5'), false)
    lu.assertEquals(candidate('2/4', '8/4'), true)
    lu.assertEquals(candidate('2/4', '4/2'), true)
    lu.assertEquals(candidate('1/5', '5/1'), true)
    lu.assertEquals(candidate('1/5', '1/5'), false)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Your task is to implement a function that will simplify the expression
-- x * n. The function returns true if x * n evaluates to a whole number and false
-- otherwise. Both x and n, are string representation of a fraction, and have the following format,
-- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
-- You can assume that x, and n are valid fractions, and do not have zero as denominator.
-- >>> simplify('1/5', '5/1')
-- true
-- >>> simplify('1/6', '2/1')
-- false
-- >>> simplify('7/10', '10/2')
-- false
local function simplify(x, n)
  -- Helper to parse a fraction string "numerator/denominator"
  local function parse(frac)
    local num, den = frac:match("(%d+)/(%d+)")
    return tonumber(num), tonumber(den)
  end

  local a, b = parse(x)   -- x = a / b
  local c, d = parse(n)   -- n = c / d

  local numerator   = a * c
  local denominator = b * d

  -- The product is an integer if the denominator divides the numerator
  return numerator % denominator == 0
end
lu = require('luaunit')

function test_humaneval()
local candidate = simplify
    lu.assertEquals(candidate('1/5', '5/1'), true)
    lu.assertEquals(candidate('1/6', '2/1'), false)
    lu.assertEquals(candidate('5/1', '3/1'), true)
    lu.assertEquals(candidate('7/10', '10/2'), false)
    lu.assertEquals(candidate('2/10', '50/10'), true)
    lu.assertEquals(candidate('7/2', '4/2'), true)
    lu.assertEquals(candidate('11/6', '6/1'), true)
    lu.assertEquals(candidate('2/3', '5/2'), false)
    lu.assertEquals(candidate('5/2', '3/5'), false)
    lu.assertEquals(candidate('2/4', '8/4'), true)
    lu.assertEquals(candidate('2/4', '4/2'), true)
    lu.assertEquals(candidate('1/5', '5/1'), true)
    lu.assertEquals(candidate('1/5', '1/5'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Your task is to implement a function that will simplify the expression
-- x * n. The function returns true if x * n evaluates to a whole number and false
-- otherwise. Both x and n, are string representation of a fraction, and have the following format,
-- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
-- You can assume that x, and n are valid fractions, and do not have zero as denominator.
-- >>> simplify('1/5', '5/1')
-- true
-- >>> simplify('1/6', '2/1')
-- false
-- >>> simplify('7/10', '10/2')
-- false
-- Simplify the product of two fractions and check if it is a whole number.
-- Returns true if the product is an integer, false otherwise.
local function simplify(x, n)
    -- Helper to parse a fraction string "num/den" into two numbers.
    local function parse(frac)
        local num, den = frac:match("(%d+)/(%d+)")
        return tonumber(num), tonumber(den)
    end

    local num1, den1 = parse(x)
    local num2, den2 = parse(n)

    -- Multiply the fractions.
    local numerator   = num1 * num2
    local denominator = den1 * den2

    -- The product is a whole number if the denominator divides the numerator.
    return numerator % denominator == 0
end

-- Example usage:
-- print(simplify('1/5', '5/1'))  --> true
-- print(simplify('1/6', '2/1'))  --> false
-- print(simplify('7/10', '10/2')) --> false
lu = require('luaunit')

function test_humaneval()
local candidate = simplify
    lu.assertEquals(candidate('1/5', '5/1'), true)
    lu.assertEquals(candidate('1/6', '2/1'), false)
    lu.assertEquals(candidate('5/1', '3/1'), true)
    lu.assertEquals(candidate('7/10', '10/2'), false)
    lu.assertEquals(candidate('2/10', '50/10'), true)
    lu.assertEquals(candidate('7/2', '4/2'), true)
    lu.assertEquals(candidate('11/6', '6/1'), true)
    lu.assertEquals(candidate('2/3', '5/2'), false)
    lu.assertEquals(candidate('5/2', '3/5'), false)
    lu.assertEquals(candidate('2/4', '8/4'), true)
    lu.assertEquals(candidate('2/4', '4/2'), true)
    lu.assertEquals(candidate('1/5', '5/1'), true)
    lu.assertEquals(candidate('1/5', '1/5'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Your task is to implement a function that will simplify the expression
-- x * n. The function returns true if x * n evaluates to a whole number and false
-- otherwise. Both x and n, are string representation of a fraction, and have the following format,
-- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
-- You can assume that x, and n are valid fractions, and do not have zero as denominator.
-- >>> simplify('1/5', '5/1')
-- true
-- >>> simplify('1/6', '2/1')
-- false
-- >>> simplify('7/10', '10/2')
-- false
local function simplify(x, n)
  -- Extract numerator and denominator from each fraction string
  local x_num, x_den = x:match("(%d+)/(.-)")
  local n_num, n_den = n:match("(%d+)/(.-)")

  -- Convert captured strings to numbers
  x_num, x_den, n_num, n_den = tonumber(x_num), tonumber(x_den), tonumber(n_num), tonumber(n_den)

  -- Compute the product
  local product_num = x_num * n_num
  local product_den = x_den * n_den

  -- Return true if the product is a whole number
  return product_num % product_den == 0
end
lu = require('luaunit')

function test_humaneval()
local candidate = simplify
    lu.assertEquals(candidate('1/5', '5/1'), true)
    lu.assertEquals(candidate('1/6', '2/1'), false)
    lu.assertEquals(candidate('5/1', '3/1'), true)
    lu.assertEquals(candidate('7/10', '10/2'), false)
    lu.assertEquals(candidate('2/10', '50/10'), true)
    lu.assertEquals(candidate('7/2', '4/2'), true)
    lu.assertEquals(candidate('11/6', '6/1'), true)
    lu.assertEquals(candidate('2/3', '5/2'), false)
    lu.assertEquals(candidate('5/2', '3/5'), false)
    lu.assertEquals(candidate('2/4', '8/4'), true)
    lu.assertEquals(candidate('2/4', '4/2'), true)
    lu.assertEquals(candidate('1/5', '5/1'), true)
    lu.assertEquals(candidate('1/5', '1/5'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755154481
STDOUT:
E
Failed tests:
-------------
1) test_humaneval
/tmp/tmpz2rvygzg.lua:22: attempt to perform arithmetic on a nil value (local 'x_den')
stack traceback:
	/tmp/tmpz2rvygzg.lua:31: in function 'test_humaneval'

Ran 1 tests in 0.001 seconds, 0 successes, 1 error
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Your task is to implement a function that will simplify the expression
-- x * n. The function returns true if x * n evaluates to a whole number and false
-- otherwise. Both x and n, are string representation of a fraction, and have the following format,
-- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
-- You can assume that x, and n are valid fractions, and do not have zero as denominator.
-- >>> simplify('1/5', '5/1')
-- true
-- >>> simplify('1/6', '2/1')
-- false
-- >>> simplify('7/10', '10/2')
-- false
-- Simplify the product of two fractions.
-- Returns true if the product is a whole number, false otherwise.
local function simplify(x, n)
  -- Helper to parse a fraction string "num/den" into numbers.
  local function parse(frac)
    local num, den = frac:match("^(%d+)/(%d+)$")
    return tonumber(num), tonumber(den)
  end

  local a, b = parse(x)   -- a/b
  local c, d = parse(n)   -- c/d

  local numerator   = a * c
  local denominator = b * d

  return numerator % denominator == 0
end
lu = require('luaunit')

function test_humaneval()
local candidate = simplify
    lu.assertEquals(candidate('1/5', '5/1'), true)
    lu.assertEquals(candidate('1/6', '2/1'), false)
    lu.assertEquals(candidate('5/1', '3/1'), true)
    lu.assertEquals(candidate('7/10', '10/2'), false)
    lu.assertEquals(candidate('2/10', '50/10'), true)
    lu.assertEquals(candidate('7/2', '4/2'), true)
    lu.assertEquals(candidate('11/6', '6/1'), true)
    lu.assertEquals(candidate('2/3', '5/2'), false)
    lu.assertEquals(candidate('5/2', '3/5'), false)
    lu.assertEquals(candidate('2/4', '8/4'), true)
    lu.assertEquals(candidate('2/4', '4/2'), true)
    lu.assertEquals(candidate('1/5', '5/1'), true)
    lu.assertEquals(candidate('1/5', '1/5'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 153 (LUA) - HumanEval_153_Strongest_Extension
================================================================================

PROMPT:
----------------------------------------
-- You will be given the name of a class (a string) and a table of extensions.
-- The extensions are to be used to load additional classes to the class. The
-- strength of the extension is as follows: Let CAP be the number of the uppercase
-- letters in the extension's name, and let SM be the number of lowercase letters 
-- in the extension's name, the strength is given by the fraction CAP - SM. 
-- You should find the strongest extension and return a string in this 
-- format: ClassName.StrongestExtensionName.
-- If there are two or more extensions with the same strength, you should
-- choose the one that comes first in the table.
-- For example, if you are given "Slices" as the class and a table of the
-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
-- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
-- (its strength is -1).
-- Example:
-- >>> Strongest_Extension('my_class', {'AA', 'Be', 'CC'})
-- 'my_class.AA'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = Strongest_Extension
    lu.assertEquals(candidate('Watashi', {'tEN', 'niNE', 'eIGHt8OKe'}), 'Watashi.eIGHt8OKe')
    lu.assertEquals(candidate('Boku123', {'nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg'}), 'Boku123.YEs.WeCaNe')
    lu.assertEquals(candidate('__YESIMHERE', {'t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321'}), '__YESIMHERE.NuLl__')
    lu.assertEquals(candidate('K', {'Ta', 'TAR', 't234An', 'cosSo'}), 'K.TAR')
    lu.assertEquals(candidate('__HAHA', {'Tab', '123', '781345', '-_-'}), '__HAHA.123')
    lu.assertEquals(candidate('YameRore', {'HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-'}), 'YameRore.okIWILL123')
    lu.assertEquals(candidate('finNNalLLly', {'Die', 'NowW', 'Wow', 'WoW'}), 'finNNalLLly.WoW')
    lu.assertEquals(candidate('_', {'Bb', '91245'}), '_.Bb')
    lu.assertEquals(candidate('Sp', {'671235', 'Bb'}), 'Sp.671235')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You will be given the name of a class (a string) and a table of extensions.
-- The extensions are to be used to load additional classes to the class. The
-- strength of the extension is as follows: Let CAP be the number of the uppercase
-- letters in the extension's name, and let SM be the number of lowercase letters 
-- in the extension's name, the strength is given by the fraction CAP - SM. 
-- You should find the strongest extension and return a string in this 
-- format: ClassName.StrongestExtensionName.
-- If there are two or more extensions with the same strength, you should
-- choose the one that comes first in the table.
-- For example, if you are given "Slices" as the class and a table of the
-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
-- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
-- (its strength is -1).
-- Example:
-- >>> Strongest_Extension('my_class', {'AA', 'Be', 'CC'})
-- 'my_class.AA'
-- Strongest_Extension.lua
-- Find the extension with the highest strength (CAP - SM) and return
-- the fully qualified name: ClassName.ExtensionName.
--
-- Parameters:
--   class_name  (string) â€“ the base class name.
--   extensions  (table)  â€“ a list (array) of extension names (strings).
--
-- Returns:
--   string â€“ "ClassName.StrongestExtensionName".
--
-- Strength calculation:
--   CAP = number of uppercase letters in the extension name.
--   SM  = number of lowercase letters in the extension name.
--   strength = CAP - SM.
--
-- If multiple extensions tie for the highest strength, the first one
-- encountered in the table is chosen.

local function Strongest_Extension(class_name, extensions)
  local best_ext   = nil   -- the best extension found so far
  local best_score = nil   -- its strength

  for _, ext in ipairs(extensions) do
    -- Count uppercase and lowercase letters
    local cap = 0
    local sm  = 0
    for _, ch in ext:gmatch(".") do
      if ch:match("%u") then
        cap = cap + 1
      elseif ch:match("%l") then
        sm = sm + 1
      end
    end

    local score = cap - sm

    -- First extension or a strictly better score
    if best_ext == nil or score > best_score then
      best_ext   = ext
      best_score = score
    end
    -- If score == best_score we keep the earlier one (do nothing)
  end

  -- Construct the fullyâ€‘qualified name
  return class_name .. "." .. best_ext
end

return Strongest_Extension
lu = require('luaunit')

function test_humaneval()
local candidate = Strongest_Extension
    lu.assertEquals(candidate('Watashi', {'tEN', 'niNE', 'eIGHt8OKe'}), 'Watashi.eIGHt8OKe')
    lu.assertEquals(candidate('Boku123', {'nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg'}), 'Boku123.YEs.WeCaNe')
    lu.assertEquals(candidate('__YESIMHERE', {'t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321'}), '__YESIMHERE.NuLl__')
    lu.assertEquals(candidate('K', {'Ta', 'TAR', 't234An', 'cosSo'}), 'K.TAR')
    lu.assertEquals(candidate('__HAHA', {'Tab', '123', '781345', '-_-'}), '__HAHA.123')
    lu.assertEquals(candidate('YameRore', {'HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-'}), 'YameRore.okIWILL123')
    lu.assertEquals(candidate('finNNalLLly', {'Die', 'NowW', 'Wow', 'WoW'}), 'finNNalLLly.WoW')
    lu.assertEquals(candidate('_', {'Bb', '91245'}), '_.Bb')
    lu.assertEquals(candidate('Sp', {'671235', 'Bb'}), 'Sp.671235')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755154482
STDOUT: (empty)
STDERR:
lua: /tmp/tmppjuwewq9.lua:67: <eof> expected near 'lu'
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You will be given the name of a class (a string) and a table of extensions.
-- The extensions are to be used to load additional classes to the class. The
-- strength of the extension is as follows: Let CAP be the number of the uppercase
-- letters in the extension's name, and let SM be the number of lowercase letters 
-- in the extension's name, the strength is given by the fraction CAP - SM. 
-- You should find the strongest extension and return a string in this 
-- format: ClassName.StrongestExtensionName.
-- If there are two or more extensions with the same strength, you should
-- choose the one that comes first in the table.
-- For example, if you are given "Slices" as the class and a table of the
-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
-- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
-- (its strength is -1).
-- Example:
-- >>> Strongest_Extension('my_class', {'AA', 'Be', 'CC'})
-- 'my_class.AA'
-- Find the strongest extension for a given class name
-- Strength = (#uppercase letters) â€“ (#lowercase letters)
-- In case of a tie, the first extension in the table wins.
local function Strongest_Extension(class_name, extensions)
  local best_ext   = nil
  local best_strength = -math.huge  -- start lower than any possible strength

  for _, ext in ipairs(extensions) do
    local cap = 0   -- uppercase count
    local sm  = 0   -- lowercase count

    for i = 1, #ext do
      local ch = ext:sub(i, i)
      if ch:match("%u") then
        cap = cap + 1
      elseif ch:match("%l") then
        sm = sm + 1
      end
    end

    local strength = cap - sm
    if strength > best_strength then
      best_strength = strength
      best_ext = ext
    end
  end

  return class_name .. '.' .. best_ext
end
lu = require('luaunit')

function test_humaneval()
local candidate = Strongest_Extension
    lu.assertEquals(candidate('Watashi', {'tEN', 'niNE', 'eIGHt8OKe'}), 'Watashi.eIGHt8OKe')
    lu.assertEquals(candidate('Boku123', {'nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg'}), 'Boku123.YEs.WeCaNe')
    lu.assertEquals(candidate('__YESIMHERE', {'t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321'}), '__YESIMHERE.NuLl__')
    lu.assertEquals(candidate('K', {'Ta', 'TAR', 't234An', 'cosSo'}), 'K.TAR')
    lu.assertEquals(candidate('__HAHA', {'Tab', '123', '781345', '-_-'}), '__HAHA.123')
    lu.assertEquals(candidate('YameRore', {'HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-'}), 'YameRore.okIWILL123')
    lu.assertEquals(candidate('finNNalLLly', {'Die', 'NowW', 'Wow', 'WoW'}), 'finNNalLLly.WoW')
    lu.assertEquals(candidate('_', {'Bb', '91245'}), '_.Bb')
    lu.assertEquals(candidate('Sp', {'671235', 'Bb'}), 'Sp.671235')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You will be given the name of a class (a string) and a table of extensions.
-- The extensions are to be used to load additional classes to the class. The
-- strength of the extension is as follows: Let CAP be the number of the uppercase
-- letters in the extension's name, and let SM be the number of lowercase letters 
-- in the extension's name, the strength is given by the fraction CAP - SM. 
-- You should find the strongest extension and return a string in this 
-- format: ClassName.StrongestExtensionName.
-- If there are two or more extensions with the same strength, you should
-- choose the one that comes first in the table.
-- For example, if you are given "Slices" as the class and a table of the
-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
-- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
-- (its strength is -1).
-- Example:
-- >>> Strongest_Extension('my_class', {'AA', 'Be', 'CC'})
-- 'my_class.AA'
-- Computes the strongest extension for a given class.
-- The strength of an extension is CAP - SM, where
--   CAP = number of uppercase letters in the extension name
--   SM  = number of lowercase letters in the extension name
-- The extension with the highest strength is chosen.
-- If multiple extensions share the same strength, the first one in the table wins.
--
-- @param class_name string  The base class name
-- @param extensions table   A table containing extension names (strings)
-- @return string  The resulting class name in the format "ClassName.ExtensionName"

local function Strongest_Extension(class_name, extensions)
    local best_extension = nil
    local best_strength = nil  -- nil indicates that no extension has been processed yet

    for _, ext in ipairs(extensions) do
        -- Count uppercase and lowercase letters
        local _, cap = ext:gsub("%u", "")   -- number of uppercase letters
        local _, sm  = ext:gsub("%l", "")   -- number of lowercase letters
        local strength = cap - sm

        if best_strength == nil or strength > best_strength then
            best_strength = strength
            best_extension = ext
        end
        -- If strength == best_strength we keep the earlier one (do nothing)
    end

    -- If there were no extensions, just return the class name itself
    if not best_extension then
        return class_name
    end

    return class_name .. "." .. best_extension
end
lu = require('luaunit')

function test_humaneval()
local candidate = Strongest_Extension
    lu.assertEquals(candidate('Watashi', {'tEN', 'niNE', 'eIGHt8OKe'}), 'Watashi.eIGHt8OKe')
    lu.assertEquals(candidate('Boku123', {'nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg'}), 'Boku123.YEs.WeCaNe')
    lu.assertEquals(candidate('__YESIMHERE', {'t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321'}), '__YESIMHERE.NuLl__')
    lu.assertEquals(candidate('K', {'Ta', 'TAR', 't234An', 'cosSo'}), 'K.TAR')
    lu.assertEquals(candidate('__HAHA', {'Tab', '123', '781345', '-_-'}), '__HAHA.123')
    lu.assertEquals(candidate('YameRore', {'HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-'}), 'YameRore.okIWILL123')
    lu.assertEquals(candidate('finNNalLLly', {'Die', 'NowW', 'Wow', 'WoW'}), 'finNNalLLly.WoW')
    lu.assertEquals(candidate('_', {'Bb', '91245'}), '_.Bb')
    lu.assertEquals(candidate('Sp', {'671235', 'Bb'}), 'Sp.671235')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You will be given the name of a class (a string) and a table of extensions.
-- The extensions are to be used to load additional classes to the class. The
-- strength of the extension is as follows: Let CAP be the number of the uppercase
-- letters in the extension's name, and let SM be the number of lowercase letters 
-- in the extension's name, the strength is given by the fraction CAP - SM. 
-- You should find the strongest extension and return a string in this 
-- format: ClassName.StrongestExtensionName.
-- If there are two or more extensions with the same strength, you should
-- choose the one that comes first in the table.
-- For example, if you are given "Slices" as the class and a table of the
-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
-- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
-- (its strength is -1).
-- Example:
-- >>> Strongest_Extension('my_class', {'AA', 'Be', 'CC'})
-- 'my_class.AA'
-- Returns the strongest extension for a given class name.
-- The strength of an extension is calculated as:
--   strength = (#uppercase letters) - (#lowercase letters)
-- If multiple extensions have the same strength, the first one in the
-- provided table wins.
local function Strongest_Extension(class_name, extensions)
    local best_ext   = nil
    local best_str   = -math.huge  -- effectively negative infinity

    for _, ext in ipairs(extensions) do
        -- Count uppercase and lowercase letters
        local cap = select(2, ext:gsub("%u", ""))
        local sm  = select(2, ext:gsub("%l", ""))
        local strength = cap - sm

        if strength > best_str then
            best_str   = strength
            best_ext   = ext
        end
        -- If strength == best_str, we keep the earlier extension (do nothing)
    end

    return class_name .. "." .. best_ext
end
lu = require('luaunit')

function test_humaneval()
local candidate = Strongest_Extension
    lu.assertEquals(candidate('Watashi', {'tEN', 'niNE', 'eIGHt8OKe'}), 'Watashi.eIGHt8OKe')
    lu.assertEquals(candidate('Boku123', {'nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg'}), 'Boku123.YEs.WeCaNe')
    lu.assertEquals(candidate('__YESIMHERE', {'t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321'}), '__YESIMHERE.NuLl__')
    lu.assertEquals(candidate('K', {'Ta', 'TAR', 't234An', 'cosSo'}), 'K.TAR')
    lu.assertEquals(candidate('__HAHA', {'Tab', '123', '781345', '-_-'}), '__HAHA.123')
    lu.assertEquals(candidate('YameRore', {'HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-'}), 'YameRore.okIWILL123')
    lu.assertEquals(candidate('finNNalLLly', {'Die', 'NowW', 'Wow', 'WoW'}), 'finNNalLLly.WoW')
    lu.assertEquals(candidate('_', {'Bb', '91245'}), '_.Bb')
    lu.assertEquals(candidate('Sp', {'671235', 'Bb'}), 'Sp.671235')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 163 (LUA) - HumanEval_163_generate_integers
================================================================================

PROMPT:
----------------------------------------
-- Given two positive integers a and b, return the even digits between a
-- and b, in ascending order.
-- For example:
-- >>> generate_integers(2, 8)
-- {2, 4, 6, 8}
-- >>> generate_integers(8, 2)
-- {2, 4, 6, 8}
-- >>> generate_integers(10, 14)
-- {}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = generate_integers
    lu.assertEquals(candidate(2, 10), {2, 4, 6, 8})
    lu.assertEquals(candidate(10, 2), {2, 4, 6, 8})
    lu.assertEquals(candidate(132, 2), {2, 4, 6, 8})
    lu.assertEquals(candidate(17, 89), {})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given two positive integers a and b, return the even digits between a
-- and b, in ascending order.
-- For example:
-- >>> generate_integers(2, 8)
-- {2, 4, 6, 8}
-- >>> generate_integers(8, 2)
-- {2, 4, 6, 8}
-- >>> generate_integers(10, 14)
-- {}
-- Generate the set of even digits that lie between two positive integers a and b.
-- The digits considered are 0 through 9. The function returns a table that
-- behaves like a set: the keys are the even digits and the values are true.
--
-- Examples:
--   generate_integers(2, 8)  --> { [2]=true, [4]=true, [6]=true, [8]=true }
--   generate_integers(8, 2)  --> { [2]=true, [4]=true, [6]=true, [8]=true }
--   generate_integers(10, 14)--> {}
local function generate_integers(a, b)
    local lo = math.min(a, b)
    local hi = math.max(a, b)

    local result = {}
    for d = 0, 9 do
        if d >= lo and d <= hi and d % 2 == 0 then
            result[d] = true
        end
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = generate_integers
    lu.assertEquals(candidate(2, 10), {2, 4, 6, 8})
    lu.assertEquals(candidate(10, 2), {2, 4, 6, 8})
    lu.assertEquals(candidate(132, 2), {2, 4, 6, 8})
    lu.assertEquals(candidate(17, 89), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755154484
STDOUT:
F
Failed tests:
-------------
1) test_humaneval
/tmp/tmp59bgrhb_.lua:35: expected: {2, 4, 6, 8}
actual: {2=true, 4=true, 6=true, 8=true}
stack traceback:
	/tmp/tmp59bgrhb_.lua:35: in function 'test_humaneval'

Ran 1 tests in 0.002 seconds, 0 successes, 1 failure
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given two positive integers a and b, return the even digits between a
-- and b, in ascending order.
-- For example:
-- >>> generate_integers(2, 8)
-- {2, 4, 6, 8}
-- >>> generate_integers(8, 2)
-- {2, 4, 6, 8}
-- >>> generate_integers(10, 14)
-- {}
local function generate_integers(a, b)
  -- Work with the range in ascending order
  local lower = math.min(a, b)
  local upper = math.max(a, b)

  local result = {}
  -- Only digits 0â€‘9 can be considered
  for d = 0, 9 do
    if d % 2 == 0 and d >= lower and d <= upper then
      table.insert(result, d)
    end
  end

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = generate_integers
    lu.assertEquals(candidate(2, 10), {2, 4, 6, 8})
    lu.assertEquals(candidate(10, 2), {2, 4, 6, 8})
    lu.assertEquals(candidate(132, 2), {2, 4, 6, 8})
    lu.assertEquals(candidate(17, 89), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154484
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given two positive integers a and b, return the even digits between a
-- and b, in ascending order.
-- For example:
-- >>> generate_integers(2, 8)
-- {2, 4, 6, 8}
-- >>> generate_integers(8, 2)
-- {2, 4, 6, 8}
-- >>> generate_integers(10, 14)
-- {}
local function generate_integers(a, b)
  local lower = math.min(a, b)
  local upper = math.max(a, b)
  local result = {}

  for i = lower, upper do
    if i % 2 == 0 and i < 10 then
      table.insert(result, i)
    end
  end

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = generate_integers
    lu.assertEquals(candidate(2, 10), {2, 4, 6, 8})
    lu.assertEquals(candidate(10, 2), {2, 4, 6, 8})
    lu.assertEquals(candidate(132, 2), {2, 4, 6, 8})
    lu.assertEquals(candidate(17, 89), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154484
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given two positive integers a and b, return the even digits between a
-- and b, in ascending order.
-- For example:
-- >>> generate_integers(2, 8)
-- {2, 4, 6, 8}
-- >>> generate_integers(8, 2)
-- {2, 4, 6, 8}
-- >>> generate_integers(10, 14)
-- {}
-- Return a list of the even singleâ€‘digit integers that lie between a and b
-- (inclusive).  The order of the returned numbers is ascending.
-- If a > b the arguments are swapped.  If no such numbers exist an empty
-- table is returned.
local function generate_integers(a, b)
    -- Ensure a <= b
    if a > b then
        a, b = b, a
    end

    local result = {}

    -- Iterate over the range and collect even digits (0â€‘9)
    for n = a, b do
        if n % 2 == 0 and n < 10 then
            table.insert(result, n)
        end
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = generate_integers
    lu.assertEquals(candidate(2, 10), {2, 4, 6, 8})
    lu.assertEquals(candidate(10, 2), {2, 4, 6, 8})
    lu.assertEquals(candidate(132, 2), {2, 4, 6, 8})
    lu.assertEquals(candidate(17, 89), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154484
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------
