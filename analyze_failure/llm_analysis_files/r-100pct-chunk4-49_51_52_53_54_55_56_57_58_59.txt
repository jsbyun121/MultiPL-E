As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 49 (R) - HumanEval_49_modp
================================================================================

PROMPT:
----------------------------------------
# Return 2^n modulo p (be aware of numerics).
# >>> modp(3, 5)
# 3
# >>> modp(1101, 101)
# 2
# >>> modp(0, 101)
# 1
# >>> modp(3, 11)
# 8
# >>> modp(100, 101)
# 1

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- modp
    stopifnot(isTRUE(all.equal(candidate(3, 5), 3)))
    stopifnot(isTRUE(all.equal(candidate(1101, 101), 2)))
    stopifnot(isTRUE(all.equal(candidate(0, 101), 1)))
    stopifnot(isTRUE(all.equal(candidate(3, 11), 8)))
    stopifnot(isTRUE(all.equal(candidate(100, 101), 1)))
    stopifnot(isTRUE(all.equal(candidate(30, 5), 4)))
    stopifnot(isTRUE(all.equal(candidate(31, 5), 3)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Return 2^n modulo p (be aware of numerics).
# >>> modp(3, 5)
# 3
# >>> modp(1101, 101)
# 2
# >>> modp(0, 101)
# 1
# >>> modp(3, 11)
# 8
# >>> modp(100, 101)
# 1
# Return 2^n modulo p (be aware of numerics).
# >>> modp(3, 5)
# [1] 3
# >>> modp(1101, 101)
# [1] 2
# >>> modp(0, 101)
# [1] 1
# >>> modp(3, 11)
# [1] 8
# >>> modp(100, 101)
# [1] 1
modp <- function(n, p) {
  # Ensure we work with integers
  n <- as.integer(n)
  p <- as.integer(p)

  result <- 1L          # accumulator for the answer
  base   <- 2L %% p     # current power of 2, reduced modulo p

  # Binary exponentiation loop
  while (n > 0L) {
    # If the current bit of n is 1, multiply the accumulator
    if (bitwAnd(n, 1L) == 1L) {
      result <- (result * base) %% p
    }
    # Square the base for the next bit
    base <- (base * base) %% p
    # Shift n right by one bit
    n <- bitwShiftR(n, 1L)
  }

  return(result)
}
test_humaneval <- function() {
    candidate <- modp
    stopifnot(isTRUE(all.equal(candidate(3, 5), 3)))
    stopifnot(isTRUE(all.equal(candidate(1101, 101), 2)))
    stopifnot(isTRUE(all.equal(candidate(0, 101), 1)))
    stopifnot(isTRUE(all.equal(candidate(3, 11), 8)))
    stopifnot(isTRUE(all.equal(candidate(100, 101), 1)))
    stopifnot(isTRUE(all.equal(candidate(30, 5), 4)))
    stopifnot(isTRUE(all.equal(candidate(31, 5), 3)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183756
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Return 2^n modulo p (be aware of numerics).
# >>> modp(3, 5)
# 3
# >>> modp(1101, 101)
# 2
# >>> modp(0, 101)
# 1
# >>> modp(3, 11)
# 8
# >>> modp(100, 101)
# 1
# Return 2^n modulo p (be aware of numerics).
# >>> modp(3, 5)
# 3
# >>> modp(1101, 101)
# 2
# >>> modp(0, 101)
# 1
# >>> modp(3, 11)
# 8
# >>> modp(100, 101)
# 1
modp <- function(n, p) {
  # Handle trivial case
  if (n == 0) {
    return(1 %% p)
  }

  result <- 1
  base   <- 2 %% p
  exp    <- n

  while (exp > 0) {
    if (exp %% 2 == 1) {
      result <- (result * base) %% p
    }
    base <- (base * base) %% p
    exp  <- exp %/% 2
  }

  return(result)
}
test_humaneval <- function() {
    candidate <- modp
    stopifnot(isTRUE(all.equal(candidate(3, 5), 3)))
    stopifnot(isTRUE(all.equal(candidate(1101, 101), 2)))
    stopifnot(isTRUE(all.equal(candidate(0, 101), 1)))
    stopifnot(isTRUE(all.equal(candidate(3, 11), 8)))
    stopifnot(isTRUE(all.equal(candidate(100, 101), 1)))
    stopifnot(isTRUE(all.equal(candidate(30, 5), 4)))
    stopifnot(isTRUE(all.equal(candidate(31, 5), 3)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183756
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Return 2^n modulo p (be aware of numerics).
# >>> modp(3, 5)
# 3
# >>> modp(1101, 101)
# 2
# >>> modp(0, 101)
# 1
# >>> modp(3, 11)
# 8
# >>> modp(100, 101)
# 1
# Return 2^n modulo p (be aware of numerics).
# >>> modp(3, 5)
# 3
# >>> modp(1101, 101)
# 2
# >>> modp(0, 101)
# 1
# >>> modp(3, 11)
# 8
# >>> modp(100, 101)
# 1
modp <- function(n, p) {
  # Ensure n is a non‑negative integer
  if (n < 0) stop("n must be non‑negative")
  n <- as.integer(n)
  p <- as.integer(p)
  if (p <= 0) stop("p must be positive")
  
  result <- 1L
  base   <- 2L %% p
  
  while (n > 0L) {
    if (n %% 2L == 1L) {
      result <- (result * base) %% p
    }
    base <- (base * base) %% p
    n <- n %/% 2L
  }
  return(as.integer(result))
}
test_humaneval <- function() {
    candidate <- modp
    stopifnot(isTRUE(all.equal(candidate(3, 5), 3)))
    stopifnot(isTRUE(all.equal(candidate(1101, 101), 2)))
    stopifnot(isTRUE(all.equal(candidate(0, 101), 1)))
    stopifnot(isTRUE(all.equal(candidate(3, 11), 8)))
    stopifnot(isTRUE(all.equal(candidate(100, 101), 1)))
    stopifnot(isTRUE(all.equal(candidate(30, 5), 4)))
    stopifnot(isTRUE(all.equal(candidate(31, 5), 3)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183756
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Return 2^n modulo p (be aware of numerics).
# >>> modp(3, 5)
# 3
# >>> modp(1101, 101)
# 2
# >>> modp(0, 101)
# 1
# >>> modp(3, 11)
# 8
# >>> modp(100, 101)
# 1
# Return 2^n modulo p (be aware of numerics).
# >>> modp(3, 5)
# 3
# >>> modp(1101, 101)
# 2
# >>> modp(0, 101)
# 1
# >>> modp(3, 11)
# 8
# >>> modp(100, 101)
# 1
modp <- function(n, p) {
  # Ensure integer inputs
  n <- as.integer(n)
  p <- as.integer(p)
  
  # Edge case: modulus 1 → always 0
  if (p == 1) return(0L)
  
  result <- 1L
  base   <- 2L %% p
  
  while (n > 0L) {
    if (n %% 2L == 1L) {
      result <- (result * base) %% p
    }
    base <- (base * base) %% p
    n <- n %/% 2L
  }
  return(result)
}
test_humaneval <- function() {
    candidate <- modp
    stopifnot(isTRUE(all.equal(candidate(3, 5), 3)))
    stopifnot(isTRUE(all.equal(candidate(1101, 101), 2)))
    stopifnot(isTRUE(all.equal(candidate(0, 101), 1)))
    stopifnot(isTRUE(all.equal(candidate(3, 11), 8)))
    stopifnot(isTRUE(all.equal(candidate(100, 101), 1)))
    stopifnot(isTRUE(all.equal(candidate(30, 5), 4)))
    stopifnot(isTRUE(all.equal(candidate(31, 5), 3)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183756
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 51 (R) - HumanEval_51_remove_vowels
================================================================================

PROMPT:
----------------------------------------
# remove_vowels is a function that takes string and returns string without vowels.
# >>> remove_vowels('')
# ''
# >>> remove_vowels('abcdef')
# 'bcdf'
# >>> remove_vowels('aaaaa')
# ''
# >>> remove_vowels('aaBAA')
# 'B'
# >>> remove_vowels('zbcd')
# 'zbcd'

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- remove_vowels
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('abcdef\nghijklm'), 'bcdf\nghjklm')))
    stopifnot(isTRUE(all.equal(candidate('fedcba'), 'fdcb')))
    stopifnot(isTRUE(all.equal(candidate('eeeee'), '')))
    stopifnot(isTRUE(all.equal(candidate('acBAA'), 'cB')))
    stopifnot(isTRUE(all.equal(candidate('EcBOO'), 'cB')))
    stopifnot(isTRUE(all.equal(candidate('ybcd'), 'ybcd')))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# remove_vowels is a function that takes string and returns string without vowels.
# >>> remove_vowels('')
# ''
# >>> remove_vowels('abcdef')
# 'bcdf'
# >>> remove_vowels('aaaaa')
# ''
# >>> remove_vowels('aaBAA')
# 'B'
# >>> remove_vowels('zbcd')
# 'zbcd'
remove_vowels <- function(text) {
  # Remove all vowels (both lower‑case and upper‑case) from the input string
  gsub("[aeiouAEIOU]", "", text)
}
test_humaneval <- function() {
    candidate <- remove_vowels
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('abcdef\nghijklm'), 'bcdf\nghjklm')))
    stopifnot(isTRUE(all.equal(candidate('fedcba'), 'fdcb')))
    stopifnot(isTRUE(all.equal(candidate('eeeee'), '')))
    stopifnot(isTRUE(all.equal(candidate('acBAA'), 'cB')))
    stopifnot(isTRUE(all.equal(candidate('EcBOO'), 'cB')))
    stopifnot(isTRUE(all.equal(candidate('ybcd'), 'ybcd')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183757
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# remove_vowels is a function that takes string and returns string without vowels.
# >>> remove_vowels('')
# ''
# >>> remove_vowels('abcdef')
# 'bcdf'
# >>> remove_vowels('aaaaa')
# ''
# >>> remove_vowels('aaBAA')
# 'B'
# >>> remove_vowels('zbcd')
# 'zbcd'
# remove_vowels is a function that takes string and returns string without vowels.
# >>> remove_vowels('')
# ''
# >>> remove_vowels('abcdef')
# 'bcdf'
# >>> remove_vowels('aaaaa')
# ''
# >>> remove_vowels('aaBAA')
# 'B'
# >>> remove_vowels('zbcd')
# 'zbcd'
remove_vowels <- function(text) {
  # Use a regular expression to strip all vowels (both lower‑ and upper‑case)
  gsub("[aeiouAEIOU]", "", text)
}
test_humaneval <- function() {
    candidate <- remove_vowels
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('abcdef\nghijklm'), 'bcdf\nghjklm')))
    stopifnot(isTRUE(all.equal(candidate('fedcba'), 'fdcb')))
    stopifnot(isTRUE(all.equal(candidate('eeeee'), '')))
    stopifnot(isTRUE(all.equal(candidate('acBAA'), 'cB')))
    stopifnot(isTRUE(all.equal(candidate('EcBOO'), 'cB')))
    stopifnot(isTRUE(all.equal(candidate('ybcd'), 'ybcd')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183757
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# remove_vowels is a function that takes string and returns string without vowels.
# >>> remove_vowels('')
# ''
# >>> remove_vowels('abcdef')
# 'bcdf'
# >>> remove_vowels('aaaaa')
# ''
# >>> remove_vowels('aaBAA')
# 'B'
# >>> remove_vowels('zbcd')
# 'zbcd'
remove_vowels <- function(text) {
  # Remove all vowels (a, e, i, o, u) regardless of case
  gsub("[aeiouAEIOU]", "", text)
}
test_humaneval <- function() {
    candidate <- remove_vowels
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('abcdef\nghijklm'), 'bcdf\nghjklm')))
    stopifnot(isTRUE(all.equal(candidate('fedcba'), 'fdcb')))
    stopifnot(isTRUE(all.equal(candidate('eeeee'), '')))
    stopifnot(isTRUE(all.equal(candidate('acBAA'), 'cB')))
    stopifnot(isTRUE(all.equal(candidate('EcBOO'), 'cB')))
    stopifnot(isTRUE(all.equal(candidate('ybcd'), 'ybcd')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183757
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# remove_vowels is a function that takes string and returns string without vowels.
# >>> remove_vowels('')
# ''
# >>> remove_vowels('abcdef')
# 'bcdf'
# >>> remove_vowels('aaaaa')
# ''
# >>> remove_vowels('aaBAA')
# 'B'
# >>> remove_vowels('zbcd')
# 'zbcd'
# remove_vowels is a function that takes string and returns string without vowels.
# >>> remove_vowels('')
# ''
# >>> remove_vowels('abcdef')
# 'bcdf'
# >>> remove_vowels('aaaaa')
# ''
# >>> remove_vowels('aaBAA')
# 'B'
# >>> remove_vowels('zbcd')
# 'zbcd'
remove_vowels <- function(text) {
  # Use a regular expression to remove all vowels (case‑insensitive)
  gsub("[aeiouAEIOU]", "", text)
}
test_humaneval <- function() {
    candidate <- remove_vowels
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('abcdef\nghijklm'), 'bcdf\nghjklm')))
    stopifnot(isTRUE(all.equal(candidate('fedcba'), 'fdcb')))
    stopifnot(isTRUE(all.equal(candidate('eeeee'), '')))
    stopifnot(isTRUE(all.equal(candidate('acBAA'), 'cB')))
    stopifnot(isTRUE(all.equal(candidate('EcBOO'), 'cB')))
    stopifnot(isTRUE(all.equal(candidate('ybcd'), 'ybcd')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183757
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 52 (R) - HumanEval_52_below_threshold
================================================================================

PROMPT:
----------------------------------------
# Return TRUE if all numbers in the list l are below threshold t.
# >>> below_threshold(c(1, 2, 4, 10), 100)
# TRUE
# >>> below_threshold(c(1, 20, 4, 10), 5)
# FALSE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- below_threshold
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10), 100), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 21), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 22), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 11), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 10), FALSE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Return TRUE if all numbers in the list l are below threshold t.
# >>> below_threshold(c(1, 2, 4, 10), 100)
# TRUE
# >>> below_threshold(c(1, 20, 4, 10), 5)
# FALSE
# Return TRUE if all numbers in the list l are below threshold t.
# >>> below_threshold(c(1, 2, 4, 10), 100)
# TRUE
# >>> below_threshold(c(1, 20, 4, 10), 5)
# FALSE
below_threshold <- function(l, t) {
  # Check that every element in l is strictly less than t
  all(l < t)
}
test_humaneval <- function() {
    candidate <- below_threshold
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10), 100), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 21), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 22), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 11), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 10), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183757
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Return TRUE if all numbers in the list l are below threshold t.
# >>> below_threshold(c(1, 2, 4, 10), 100)
# TRUE
# >>> below_threshold(c(1, 20, 4, 10), 5)
# FALSE
below_threshold <- function(l, t) {
  # Return TRUE if every element in l is strictly less than t
  all(l < t)
}
test_humaneval <- function() {
    candidate <- below_threshold
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10), 100), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 21), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 22), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 11), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 10), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183757
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Return TRUE if all numbers in the list l are below threshold t.
# >>> below_threshold(c(1, 2, 4, 10), 100)
# TRUE
# >>> below_threshold(c(1, 20, 4, 10), 5)
# FALSE
below_threshold <- function(l, t) {
  # Return TRUE if every element in l is strictly less than t
  all(l < t)
}
test_humaneval <- function() {
    candidate <- below_threshold
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10), 100), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 21), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 22), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 11), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 10), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183757
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Return TRUE if all numbers in the list l are below threshold t.
# >>> below_threshold(c(1, 2, 4, 10), 100)
# TRUE
# >>> below_threshold(c(1, 20, 4, 10), 5)
# FALSE
below_threshold <- function(l, t) {
  all(l < t)
}
test_humaneval <- function() {
    candidate <- below_threshold
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10), 100), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 21), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 22), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 11), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 10), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183757
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 53 (R) - HumanEval_53_add
================================================================================

PROMPT:
----------------------------------------
# Add two numbers x and y
# >>> add(2, 3)
# 5
# >>> add(5, 7)
# 12

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- add
    stopifnot(isTRUE(all.equal(candidate(0, 1), 1)))
    stopifnot(isTRUE(all.equal(candidate(1, 0), 1)))
    stopifnot(isTRUE(all.equal(candidate(2, 3), 5)))
    stopifnot(isTRUE(all.equal(candidate(5, 7), 12)))
    stopifnot(isTRUE(all.equal(candidate(7, 5), 12)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Add two numbers x and y
# >>> add(2, 3)
# 5
# >>> add(5, 7)
# 12
add <- function(x, y) {
  x + y
}
test_humaneval <- function() {
    candidate <- add
    stopifnot(isTRUE(all.equal(candidate(0, 1), 1)))
    stopifnot(isTRUE(all.equal(candidate(1, 0), 1)))
    stopifnot(isTRUE(all.equal(candidate(2, 3), 5)))
    stopifnot(isTRUE(all.equal(candidate(5, 7), 12)))
    stopifnot(isTRUE(all.equal(candidate(7, 5), 12)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183758
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Add two numbers x and y
# >>> add(2, 3)
# 5
# >>> add(5, 7)
# 12
# Add two numbers x and y
# >>> add(2, 3)
# 5
# >>> add(5, 7)
# 12
add <- function(x, y) {
  x + y
}
test_humaneval <- function() {
    candidate <- add
    stopifnot(isTRUE(all.equal(candidate(0, 1), 1)))
    stopifnot(isTRUE(all.equal(candidate(1, 0), 1)))
    stopifnot(isTRUE(all.equal(candidate(2, 3), 5)))
    stopifnot(isTRUE(all.equal(candidate(5, 7), 12)))
    stopifnot(isTRUE(all.equal(candidate(7, 5), 12)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183758
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Add two numbers x and y
# >>> add(2, 3)
# 5
# >>> add(5, 7)
# 12
# Add two numbers x and y
# >>> add(2, 3)
# 5
# >>> add(5, 7)
# 12
add <- function(x, y) {
  x + y
}
test_humaneval <- function() {
    candidate <- add
    stopifnot(isTRUE(all.equal(candidate(0, 1), 1)))
    stopifnot(isTRUE(all.equal(candidate(1, 0), 1)))
    stopifnot(isTRUE(all.equal(candidate(2, 3), 5)))
    stopifnot(isTRUE(all.equal(candidate(5, 7), 12)))
    stopifnot(isTRUE(all.equal(candidate(7, 5), 12)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183758
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Add two numbers x and y
# >>> add(2, 3)
# 5
# >>> add(5, 7)
# 12
# Add two numbers x and y
# >>> add(2, 3)
# 5
# >>> add(5, 7)
# 12
add <- function(x, y) {
  # Ensure both arguments are numeric
  if (!is.numeric(x) || !is.numeric(y)) {
    stop("Both arguments must be numeric")
  }
  # Return the sum
  x + y
}
test_humaneval <- function() {
    candidate <- add
    stopifnot(isTRUE(all.equal(candidate(0, 1), 1)))
    stopifnot(isTRUE(all.equal(candidate(1, 0), 1)))
    stopifnot(isTRUE(all.equal(candidate(2, 3), 5)))
    stopifnot(isTRUE(all.equal(candidate(5, 7), 12)))
    stopifnot(isTRUE(all.equal(candidate(7, 5), 12)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183758
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 54 (R) - HumanEval_54_same_chars
================================================================================

PROMPT:
----------------------------------------
# Check if two words have the same characters.
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
# TRUE
# >>> same_chars('abcd', 'dddddddabc')
# TRUE
# >>> same_chars('dddddddabc', 'abcd')
# TRUE
# >>> same_chars('eabcd', 'dddddddabc')
# FALSE
# >>> same_chars('abcd', 'dddddddabce')
# FALSE
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
# FALSE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- same_chars
    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabc'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('dddddddabc', 'abcd'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('eabcd', 'dddddddabc'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabcf'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aabb', 'aaccc'), FALSE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Check if two words have the same characters.
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
# TRUE
# >>> same_chars('abcd', 'dddddddabc')
# TRUE
# >>> same_chars('dddddddabc', 'abcd')
# TRUE
# >>> same_chars('eabcd', 'dddddddabc')
# FALSE
# >>> same_chars('abcd', 'dddddddabce')
# FALSE
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
# FALSE
same_chars <- function(s0, s1) {
  # Split strings into individual characters
  chars0 <- unique(strsplit(s0, NULL)[[1]])
  chars1 <- unique(strsplit(s1, NULL)[[1]])
  
  # Check if the two character sets are equal
  setequal(chars0, chars1)
}
test_humaneval <- function() {
    candidate <- same_chars
    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabc'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('dddddddabc', 'abcd'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('eabcd', 'dddddddabc'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabcf'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aabb', 'aaccc'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183758
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Check if two words have the same characters.
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
# TRUE
# >>> same_chars('abcd', 'dddddddabc')
# TRUE
# >>> same_chars('dddddddabc', 'abcd')
# TRUE
# >>> same_chars('eabcd', 'dddddddabc')
# FALSE
# >>> same_chars('abcd', 'dddddddabce')
# FALSE
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
# FALSE
# Check if two words have the same characters.
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
# TRUE
# >>> same_chars('abcd', 'dddddddabc')
# TRUE
# >>> same_chars('dddddddabc', 'abcd')
# TRUE
# >>> same_chars('eabcd', 'dddddddabc')
# FALSE
# >>> same_chars('abcd', 'dddddddabce')
# FALSE
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
# FALSE
same_chars <- function(s0, s1) {
  # Split each string into individual characters
  chars0 <- unique(strsplit(s0, "")[[1]])
  chars1 <- unique(strsplit(s1, "")[[1]])
  
  # If the number of unique characters differs, they can't be the same
  if (length(chars0) != length(chars1)) {
    return(FALSE)
  }
  
  # Check that each set is a subset of the other
  all(chars0 %in% chars1) && all(chars1 %in% chars0)
}
test_humaneval <- function() {
    candidate <- same_chars
    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabc'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('dddddddabc', 'abcd'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('eabcd', 'dddddddabc'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabcf'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aabb', 'aaccc'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183758
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Check if two words have the same characters.
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
# TRUE
# >>> same_chars('abcd', 'dddddddabc')
# TRUE
# >>> same_chars('dddddddabc', 'abcd')
# TRUE
# >>> same_chars('eabcd', 'dddddddabc')
# FALSE
# >>> same_chars('abcd', 'dddddddabce')
# FALSE
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
# FALSE
# Check if two words have the same characters.
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
# TRUE
# >>> same_chars('abcd', 'dddddddabc')
# TRUE
# >>> same_chars('dddddddabc', 'abcd')
# TRUE
# >>> same_chars('eabcd', 'dddddddabc')
# FALSE
# >>> same_chars('abcd', 'dddddddabce')
# FALSE
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
# FALSE
same_chars <- function(s0, s1) {
  # Split each string into individual characters
  chars0 <- unique(strsplit(s0, "")[[1]])
  chars1 <- unique(strsplit(s1, "")[[1]])
  
  # Compare the two sets of unique characters
  setequal(chars0, chars1)
}
test_humaneval <- function() {
    candidate <- same_chars
    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabc'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('dddddddabc', 'abcd'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('eabcd', 'dddddddabc'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabcf'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aabb', 'aaccc'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183758
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Check if two words have the same characters.
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
# TRUE
# >>> same_chars('abcd', 'dddddddabc')
# TRUE
# >>> same_chars('dddddddabc', 'abcd')
# TRUE
# >>> same_chars('eabcd', 'dddddddabc')
# FALSE
# >>> same_chars('abcd', 'dddddddabce')
# FALSE
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
# FALSE
# Check if two words have the same characters.
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
# TRUE
# >>> same_chars('abcd', 'dddddddabc')
# TRUE
# >>> same_chars('dddddddabc', 'abcd')
# TRUE
# >>> same_chars('eabcd', 'dddddddabc')
# FALSE
# >>> same_chars('abcd', 'dddddddabce')
# FALSE
# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
# FALSE
same_chars <- function(s0, s1) {
  # Split each string into individual characters, keep only unique ones
  chars0 <- unique(strsplit(s0, "")[[1]])
  chars1 <- unique(strsplit(s1, "")[[1]])
  
  # Compare the sorted unique character sets
  identical(sort(chars0), sort(chars1))
}
test_humaneval <- function() {
    candidate <- same_chars
    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabc'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('dddddddabc', 'abcd'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('eabcd', 'dddddddabc'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabcf'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aabb', 'aaccc'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183758
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 55 (R) - HumanEval_55_fib
================================================================================

PROMPT:
----------------------------------------
# Return n-th Fibonacci number.
# >>> fib(10)
# 55
# >>> fib(1)
# 1
# >>> fib(8)
# 21

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- fib
    stopifnot(isTRUE(all.equal(candidate(10), 55)))
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(8), 21)))
    stopifnot(isTRUE(all.equal(candidate(11), 89)))
    stopifnot(isTRUE(all.equal(candidate(12), 144)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Return n-th Fibonacci number.
# >>> fib(10)
# 55
# >>> fib(1)
# 1
# >>> fib(8)
# 21
# Return n-th Fibonacci number.
# >>> fib(10)
# 55
# >>> fib(1)
# 1
# >>> fib(8)
# 21
fib <- function(n) {
  # Basic input validation
  if (!is.numeric(n) || length(n) != 1 || n < 1) {
    stop("n must be a positive integer")
  }
  n <- as.integer(n)

  # Handle the first two Fibonacci numbers
  if (n <= 2) {
    return(1)
  }

  # Iteratively compute the sequence
  a <- 1   # F(1)
  b <- 1   # F(2)
  for (i in 3:n) {
    c <- a + b
    a <- b
    b <- c
  }
  return(b)
}
test_humaneval <- function() {
    candidate <- fib
    stopifnot(isTRUE(all.equal(candidate(10), 55)))
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(8), 21)))
    stopifnot(isTRUE(all.equal(candidate(11), 89)))
    stopifnot(isTRUE(all.equal(candidate(12), 144)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183759
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Return n-th Fibonacci number.
# >>> fib(10)
# 55
# >>> fib(1)
# 1
# >>> fib(8)
# 21
# Return n-th Fibonacci number.
# >>> fib(10)
# 55
# >>> fib(1)
# 1
# >>> fib(8)
# 21
fib <- function(n) {
  # Validate input
  if (!is.numeric(n) || length(n) != 1 || n <= 0) {
    stop("n must be a positive integer")
  }
  n <- as.integer(n)

  # Base cases
  if (n <= 2) return(1)

  # Iterative computation
  a <- 1   # F(1)
  b <- 1   # F(2)
  for (i in 3:n) {
    c <- a + b
    a <- b
    b <- c
  }
  return(b)
}
test_humaneval <- function() {
    candidate <- fib
    stopifnot(isTRUE(all.equal(candidate(10), 55)))
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(8), 21)))
    stopifnot(isTRUE(all.equal(candidate(11), 89)))
    stopifnot(isTRUE(all.equal(candidate(12), 144)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183759
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Return n-th Fibonacci number.
# >>> fib(10)
# 55
# >>> fib(1)
# 1
# >>> fib(8)
# 21
# Return n-th Fibonacci number.
# >>> fib(10)
# 55
# >>> fib(1)
# 1
# >>> fib(8)
# 21
fib <- function(n) {
  # Basic input validation
  if (!is.numeric(n) || length(n) != 1 || n < 1 || n != floor(n)) {
    stop("n must be a positive integer")
  }
  
  # Handle the first two Fibonacci numbers
  if (n <= 2) {
    return(1)
  }
  
  # Iteratively compute the sequence
  a <- 1   # F(1)
  b <- 1   # F(2)
  for (i in 3:n) {
    c <- a + b
    a <- b
    b <- c
  }
  
  return(b)
}
test_humaneval <- function() {
    candidate <- fib
    stopifnot(isTRUE(all.equal(candidate(10), 55)))
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(8), 21)))
    stopifnot(isTRUE(all.equal(candidate(11), 89)))
    stopifnot(isTRUE(all.equal(candidate(12), 144)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183759
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Return n-th Fibonacci number.
# >>> fib(10)
# 55
# >>> fib(1)
# 1
# >>> fib(8)
# 21
fib <- function(n) {
  if (!is.numeric(n) || n <= 0 || floor(n) != n) {
    stop("n must be a positive integer")
  }
  if (n == 1 || n == 2) {
    return(1)
  }
  a <- 1
  b <- 1
  for (i in 3:n) {
    temp <- a + b
    a <- b
    b <- temp
  }
  return(b)
}
test_humaneval <- function() {
    candidate <- fib
    stopifnot(isTRUE(all.equal(candidate(10), 55)))
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(8), 21)))
    stopifnot(isTRUE(all.equal(candidate(11), 89)))
    stopifnot(isTRUE(all.equal(candidate(12), 144)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183759
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 56 (R) - HumanEval_56_correct_bracketing
================================================================================

PROMPT:
----------------------------------------
# brackets is a string of "<" and ">".
# return TRUE if every opening bracket has a corresponding closing bracket.
# >>> correct_bracketing('<')
# FALSE
# >>> correct_bracketing('<>')
# TRUE
# >>> correct_bracketing('<<><>>')
# TRUE
# >>> correct_bracketing('><<>')
# FALSE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- correct_bracketing
    stopifnot(isTRUE(all.equal(candidate('<>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<<><>>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<<><><>><>><<><><<>>>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<<<><>>>>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('><<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<<<<'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>><<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>>><>'), FALSE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# brackets is a string of "<" and ">".
# return TRUE if every opening bracket has a corresponding closing bracket.
# >>> correct_bracketing('<')
# FALSE
# >>> correct_bracketing('<>')
# TRUE
# >>> correct_bracketing('<<><>>')
# TRUE
# >>> correct_bracketing('><<>')
# FALSE
correct_bracketing <- function(brackets) {
  # Counter for the difference between opening and closing brackets
  count <- 0
  
  # Iterate over each character in the string
  for (ch in strsplit(brackets, "")[[1]]) {
    if (ch == "<") {
      count <- count + 1
    } else if (ch == ">") {
      count <- count - 1
      # If we have more closing than opening at any point, it's invalid
      if (count < 0) return(FALSE)
    }
  }
  
  # After processing all characters, we must have balanced brackets
  return(count == 0)
}
test_humaneval <- function() {
    candidate <- correct_bracketing
    stopifnot(isTRUE(all.equal(candidate('<>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<<><>>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<<><><>><>><<><><<>>>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<<<><>>>>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('><<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<<<<'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>><<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>>><>'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183759
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# brackets is a string of "<" and ">".
# return TRUE if every opening bracket has a corresponding closing bracket.
# >>> correct_bracketing('<')
# FALSE
# >>> correct_bracketing('<>')
# TRUE
# >>> correct_bracketing('<<><>>')
# TRUE
# >>> correct_bracketing('><<>')
# FALSE
# Return TRUE if every opening bracket '<' has a corresponding closing bracket '>'
# and the brackets are properly nested.
correct_bracketing <- function(brackets) {
  # Count of unmatched opening brackets
  open_count <- 0
  
  # Split the string into individual characters
  chars <- strsplit(brackets, "")[[1]]
  
  for (ch in chars) {
    if (ch == "<") {
      open_count <- open_count + 1
    } else if (ch == ">") {
      open_count <- open_count - 1
      # If we close more brackets than we have opened, it's invalid
      if (open_count < 0) {
        return(FALSE)
      }
    } else {
      # Any other character makes the string invalid
      return(FALSE)
    }
  }
  
  # All brackets must be matched
  return(open_count == 0)
}
test_humaneval <- function() {
    candidate <- correct_bracketing
    stopifnot(isTRUE(all.equal(candidate('<>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<<><>>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<<><><>><>><<><><<>>>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<<<><>>>>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('><<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<<<<'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>><<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>>><>'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183759
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# brackets is a string of "<" and ">".
# return TRUE if every opening bracket has a corresponding closing bracket.
# >>> correct_bracketing('<')
# FALSE
# >>> correct_bracketing('<>')
# TRUE
# >>> correct_bracketing('<<><>>')
# TRUE
# >>> correct_bracketing('><<>')
# FALSE
correct_bracketing <- function(brackets) {
  # Empty string is trivially balanced
  if (nchar(brackets) == 0) return(TRUE)

  # Split the string into individual characters
  chars <- strsplit(brackets, "")[[1]]
  balance <- 0

  for (c in chars) {
    if (c == "<") {
      balance <- balance + 1
    } else if (c == ">") {
      balance <- balance - 1
    } else {
      stop("Invalid character in input: only '<' and '>' are allowed")
    }

    # If at any point we have more closing than opening, it's unbalanced
    if (balance < 0) return(FALSE)
  }

  # Balanced only if all openings have been closed
  return(balance == 0)
}
test_humaneval <- function() {
    candidate <- correct_bracketing
    stopifnot(isTRUE(all.equal(candidate('<>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<<><>>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<<><><>><>><<><><<>>>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<<<><>>>>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('><<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<<<<'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>><<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>>><>'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183759
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# brackets is a string of "<" and ">".
# return TRUE if every opening bracket has a corresponding closing bracket.
# >>> correct_bracketing('<')
# FALSE
# >>> correct_bracketing('<>')
# TRUE
# >>> correct_bracketing('<<><>>')
# TRUE
# >>> correct_bracketing('><<>')
# FALSE
correct_bracketing <- function(brackets) {
  # counter of unmatched opening brackets
  count <- 0
  
  # iterate over each character
  for (ch in strsplit(brackets, "")[[1]]) {
    if (ch == "<") {
      count <- count + 1
    } else if (ch == ">") {
      count <- count - 1
    } else {
      # if any other character appears, we treat it as invalid
      return(FALSE)
    }
    
    # a closing bracket without a matching opening bracket
    if (count < 0) {
      return(FALSE)
    }
  }
  
  # all opening brackets must have been matched
  return(count == 0)
}
test_humaneval <- function() {
    candidate <- correct_bracketing
    stopifnot(isTRUE(all.equal(candidate('<>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<<><>>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<<><><>><>><<><><<>>>'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('<<<><>>>>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('><<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<<<<'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>><<>'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>>><>'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183759
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 57 (R) - HumanEval_57_monotonic
================================================================================

PROMPT:
----------------------------------------
# Return TRUE is list elements are monotonically increasing or decreasing.
# >>> monotonic(c(1, 2, 4, 20))
# TRUE
# >>> monotonic(c(1, 20, 4, 10))
# FALSE
# >>> monotonic(c(4, 1, 0, -10))
# TRUE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- monotonic
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 20)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 0, -10)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 1, 0)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 5, 60)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 60)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 9, 9, 9)), TRUE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Return TRUE is list elements are monotonically increasing or decreasing.
# >>> monotonic(c(1, 2, 4, 20))
# TRUE
# >>> monotonic(c(1, 20, 4, 10))
# FALSE
# >>> monotonic(c(4, 1, 0, -10))
# TRUE
# Return TRUE is list elements are monotonically increasing or decreasing.
# >>> monotonic(c(1, 2, 4, 20))
# TRUE
# >>> monotonic(c(1, 20, 4, 10))
# FALSE
# >>> monotonic(c(4, 1, 0, -10))
# TRUE
monotonic <- function(l) {
  # Empty or single‑element vectors are trivially monotonic
  if (length(l) <= 1) return(TRUE)

  # Compute successive differences
  d <- diff(l)

  # Check for non‑decreasing and non‑increasing patterns
  is_increasing <- all(d >= 0)
  is_decreasing <- all(d <= 0)

  # Return TRUE if either pattern holds
  is_increasing || is_decreasing
}
test_humaneval <- function() {
    candidate <- monotonic
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 20)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 0, -10)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 1, 0)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 5, 60)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 60)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 9, 9, 9)), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183760
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Return TRUE is list elements are monotonically increasing or decreasing.
# >>> monotonic(c(1, 2, 4, 20))
# TRUE
# >>> monotonic(c(1, 20, 4, 10))
# FALSE
# >>> monotonic(c(4, 1, 0, -10))
# TRUE
# Return TRUE if the elements of a vector are monotonically increasing or decreasing.
# >>> monotonic(c(1, 2, 4, 20))
# TRUE
# >>> monotonic(c(1, 20, 4, 10))
# FALSE
# >>> monotonic(c(4, 1, 0, -10))
# TRUE
monotonic <- function(l) {
  # For a single element (or empty) we consider it trivially monotonic
  if (length(l) <= 1) {
    return(TRUE)
  }
  
  # Compute successive differences
  diffs <- diff(l)
  
  # If all differences are non‑negative or all are non‑positive, the sequence is monotonic
  all(diffs >= 0) || all(diffs <= 0)
}
test_humaneval <- function() {
    candidate <- monotonic
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 20)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 0, -10)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 1, 0)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 5, 60)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 60)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 9, 9, 9)), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183760
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Return TRUE is list elements are monotonically increasing or decreasing.
# >>> monotonic(c(1, 2, 4, 20))
# TRUE
# >>> monotonic(c(1, 20, 4, 10))
# FALSE
# >>> monotonic(c(4, 1, 0, -10))
# TRUE
# Return TRUE is list elements are monotonically increasing or decreasing.
# >>> monotonic(c(1, 2, 4, 20))
# TRUE
# >>> monotonic(c(1, 20, 4, 10))
# FALSE
# >>> monotonic(c(4, 1, 0, -10))
# TRUE
monotonic <- function(l) {
  if (length(l) <= 1) return(TRUE)
  d <- diff(l)
  if (all(d >= 0) || all(d <= 0)) return(TRUE)
  FALSE
}
test_humaneval <- function() {
    candidate <- monotonic
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 20)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 0, -10)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 1, 0)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 5, 60)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 60)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 9, 9, 9)), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183760
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Return TRUE is list elements are monotonically increasing or decreasing.
# >>> monotonic(c(1, 2, 4, 20))
# TRUE
# >>> monotonic(c(1, 20, 4, 10))
# FALSE
# >>> monotonic(c(4, 1, 0, -10))
# TRUE
# Return TRUE if list elements are monotonically increasing or decreasing.
# >>> monotonic(c(1, 2, 4, 20))
# TRUE
# >>> monotonic(c(1, 20, 4, 10))
# FALSE
# >>> monotonic(c(4, 1, 0, -10))
# TRUE
monotonic <- function(l) {
  # A single element or empty vector is trivially monotonic
  if (length(l) <= 1) return(TRUE)
  
  # Compute successive differences
  d <- diff(l)
  
  # Check if all differences are non‑negative (increasing)
  # or all differences are non‑positive (decreasing)
  all(d >= 0) || all(d <= 0)
}
test_humaneval <- function() {
    candidate <- monotonic
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 20)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 0, -10)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 1, 0)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 5, 60)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 60)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(9, 9, 9, 9)), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183760
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 58 (R) - HumanEval_58_common
================================================================================

PROMPT:
----------------------------------------
# Return sorted unique common elements for two lists.
# >>> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))
# c(1, 5, 653)
# >>> common(c(5, 3, 2, 8), c(3, 2))
# c(2, 3)

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- common
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), c(1, 5, 653))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 2, 8), c(3, 2)), c(2, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c(3, 2, 4)), c(2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c()), c())))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Return sorted unique common elements for two lists.
# >>> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))
# c(1, 5, 653)
# >>> common(c(5, 3, 2, 8), c(3, 2))
# c(2, 3)
# Return sorted unique common elements for two lists.
# >>> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))
# c(1, 5, 653)
# >>> common(c(5, 3, 2, 8), c(3, 2))
# c(2, 3)
common <- function(l1, l2) {
  # Find the intersection, keep only unique values, and sort them
  sort(unique(intersect(l1, l2)))
}
test_humaneval <- function() {
    candidate <- common
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), c(1, 5, 653))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 2, 8), c(3, 2)), c(2, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c(3, 2, 4)), c(2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c()), c())))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183760
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Return sorted unique common elements for two lists.
# >>> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))
# c(1, 5, 653)
# >>> common(c(5, 3, 2, 8), c(3, 2))
# c(2, 3)
# Return sorted unique common elements for two lists.
# >>> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))
# c(1, 5, 653)
# >>> common(c(5, 3, 2, 8), c(3, 2))
# c(2, 3)
common <- function(l1, l2) {
  sort(intersect(l1, l2))
}
test_humaneval <- function() {
    candidate <- common
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), c(1, 5, 653))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 2, 8), c(3, 2)), c(2, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c(3, 2, 4)), c(2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c()), c())))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183760
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Return sorted unique common elements for two lists.
# >>> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))
# c(1, 5, 653)
# >>> common(c(5, 3, 2, 8), c(3, 2))
# c(2, 3)
# Return sorted unique common elements for two lists.
# >>> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))
# c(1, 5, 653)
# >>> common(c(5, 3, 2, 8), c(3, 2))
# c(2, 3)
common <- function(l1, l2) {
  # Find the intersection of the two vectors and sort the result
  sort(intersect(l1, l2))
}
test_humaneval <- function() {
    candidate <- common
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), c(1, 5, 653))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 2, 8), c(3, 2)), c(2, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c(3, 2, 4)), c(2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c()), c())))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183760
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Return sorted unique common elements for two lists.
# >>> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))
# c(1, 5, 653)
# >>> common(c(5, 3, 2, 8), c(3, 2))
# c(2, 3)
# Return sorted unique common elements for two lists.
# >>> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))
# c(1, 5, 653)
# >>> common(c(5, 3, 2, 8), c(3, 2))
# c(2, 3)
common <- function(l1, l2) {
  # Find the intersection, remove duplicates, and sort the result
  sort(unique(intersect(l1, l2)))
}
test_humaneval <- function() {
    candidate <- common
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), c(1, 5, 653))))
    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 2, 8), c(3, 2)), c(2, 3))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c(3, 2, 4)), c(2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c()), c())))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183760
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 59 (R) - HumanEval_59_largest_prime_factor
================================================================================

PROMPT:
----------------------------------------
# Return the largest prime factor of n. Assume n > 1 and is not a prime.
# >>> largest_prime_factor(13195)
# 29
# >>> largest_prime_factor(2048)
# 2

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- largest_prime_factor
    stopifnot(isTRUE(all.equal(candidate(15), 5)))
    stopifnot(isTRUE(all.equal(candidate(27), 3)))
    stopifnot(isTRUE(all.equal(candidate(63), 7)))
    stopifnot(isTRUE(all.equal(candidate(330), 11)))
    stopifnot(isTRUE(all.equal(candidate(13195), 29)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Return the largest prime factor of n. Assume n > 1 and is not a prime.
# >>> largest_prime_factor(13195)
# 29
# >>> largest_prime_factor(2048)
# 2
largest_prime_factor <- function(n) {
  # Start with the smallest prime factor
  factor <- 2
  largest <- 1
  
  # Reduce n by dividing out its prime factors
  while (n > 1 && factor * factor <= n) {
    if (n %% factor == 0) {
      largest <- factor
      while (n %% factor == 0) {
        n <- n / factor
      }
    }
    factor <- factor + 1
  }
  
  # If n is now greater than 1, it itself is a prime factor
  if (n > 1) {
    largest <- n
  }
  
  return(largest)
}
test_humaneval <- function() {
    candidate <- largest_prime_factor
    stopifnot(isTRUE(all.equal(candidate(15), 5)))
    stopifnot(isTRUE(all.equal(candidate(27), 3)))
    stopifnot(isTRUE(all.equal(candidate(63), 7)))
    stopifnot(isTRUE(all.equal(candidate(330), 11)))
    stopifnot(isTRUE(all.equal(candidate(13195), 29)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183761
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Return the largest prime factor of n. Assume n > 1 and is not a prime.
# >>> largest_prime_factor(13195)
# 29
# >>> largest_prime_factor(2048)
# 2
largest_prime_factor <- function(n) {
  # Handle the trivial factor 2 first
  last_factor <- 1
  while (n %% 2 == 0) {
    last_factor <- 2
    n <- n / 2
  }
  
  # Check odd factors starting from 3
  i <- 3
  while (i * i <= n) {
    while (n %% i == 0) {
      last_factor <- i
      n <- n / i
    }
    i <- i + 2
  }
  
  # If n is now greater than 1, it itself is a prime factor
  if (n > 1) {
    last_factor <- n
  }
  
  return(last_factor)
}
test_humaneval <- function() {
    candidate <- largest_prime_factor
    stopifnot(isTRUE(all.equal(candidate(15), 5)))
    stopifnot(isTRUE(all.equal(candidate(27), 3)))
    stopifnot(isTRUE(all.equal(candidate(63), 7)))
    stopifnot(isTRUE(all.equal(candidate(330), 11)))
    stopifnot(isTRUE(all.equal(candidate(13195), 29)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183761
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Return the largest prime factor of n. Assume n > 1 and is not a prime.
# >>> largest_prime_factor(13195)
# 29
# >>> largest_prime_factor(2048)
# 2
# Return the largest prime factor of n. Assume n > 1 and is not a prime.
# >>> largest_prime_factor(13195)
# 29
# >>> largest_prime_factor(2048)
# 2
largest_prime_factor <- function(n) {
  if (n <= 1) stop("n must be greater than 1")
  
  largest_factor <- 1
  
  # Handle factor 2 separately
  while (n %% 2 == 0) {
    largest_factor <- 2
    n <- n %/% 2
  }
  
  # Check odd factors starting from 3
  i <- 3
  while (i * i <= n) {
    while (n %% i == 0) {
      largest_factor <- i
      n <- n %/% i
    }
    i <- i + 2
  }
  
  # If n is now greater than 1, it is a prime factor
  if (n > 1) {
    largest_factor <- n
  }
  
  return(as.integer(largest_factor))
}
test_humaneval <- function() {
    candidate <- largest_prime_factor
    stopifnot(isTRUE(all.equal(candidate(15), 5)))
    stopifnot(isTRUE(all.equal(candidate(27), 3)))
    stopifnot(isTRUE(all.equal(candidate(63), 7)))
    stopifnot(isTRUE(all.equal(candidate(330), 11)))
    stopifnot(isTRUE(all.equal(candidate(13195), 29)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183761
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Return the largest prime factor of n. Assume n > 1 and is not a prime.
# >>> largest_prime_factor(13195)
# 29
# >>> largest_prime_factor(2048)
# 2
largest_prime_factor <- function(n) {
  # Start with the smallest prime factor
  factor <- 2
  # Keep track of the largest factor found
  largest <- 1
  
  # While n is even, divide it out
  while (n %% 2 == 0) {
    largest <- 2
    n <- n / 2
  }
  
  # Now n is odd; test odd divisors only
  i <- 3
  while (i * i <= n) {
    while (n %% i == 0) {
      largest <- i
      n <- n / i
    }
    i <- i + 2
  }
  
  # If n is now greater than 1, it itself is a prime factor
  if (n > 1) {
    largest <- n
  }
  
  return(as.integer(largest))
}
test_humaneval <- function() {
    candidate <- largest_prime_factor
    stopifnot(isTRUE(all.equal(candidate(15), 5)))
    stopifnot(isTRUE(all.equal(candidate(27), 3)))
    stopifnot(isTRUE(all.equal(candidate(63), 7)))
    stopifnot(isTRUE(all.equal(candidate(330), 11)))
    stopifnot(isTRUE(all.equal(candidate(13195), 29)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183761
STDOUT: (empty)
STDERR: (empty)
--------------------
