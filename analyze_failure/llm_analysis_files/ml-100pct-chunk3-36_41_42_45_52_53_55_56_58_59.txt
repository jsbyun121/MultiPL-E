As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 36 (ML) - HumanEval_36_fizz_buzz
================================================================================

PROMPT:
----------------------------------------
(**Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
 * >>> fizz_buzz 50
 * 0
 * >>> fizz_buzz 78
 * 2
 * >>> fizz_buzz 79
 * 3
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = fizz_buzz in
  (assert ((candidate 50) = 0));
  (assert ((candidate 78) = 2));
  (assert ((candidate 79) = 3));
  (assert ((candidate 100) = 3));
  (assert ((candidate 200) = 6));
  (assert ((candidate 4000) = 192));
  (assert ((candidate 10000) = 639));
  (assert ((candidate 100000) = 8026));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
 * >>> fizz_buzz 50
 * 0
 * >>> fizz_buzz 78
 * 2
 * >>> fizz_buzz 79
 * 3
*)
(** Count the occurrences of digit 7 in a non‑negative integer. *)
let rec count7s (x : int) (acc : int) : int =
  if x = 0 then acc
  else
    let digit = x mod 10 in
    let acc' = if digit = 7 then acc + 1 else acc in
    count7s (x / 10) acc'

(** Return the number of times the digit 7 appears in integers less than n
    which are divisible by 11 or 13. *)
let fizz_buzz (n : int) : int =
  (* Guard against non‑positive n *)
  if n <= 0 then 0
  else
    let rec loop i acc =
      if i >= n then acc
      else
        let acc' =
          if i mod 11 = 0 || i mod 13 = 0 then acc + count7s i 0
          else acc
        in
        loop (i + 1) acc'
    in
    loop 0 0

let assertions =
 let candidate = fizz_buzz in
  (assert ((candidate 50) = 0));
  (assert ((candidate 78) = 2));
  (assert ((candidate 79) = 3));
  (assert ((candidate 100) = 3));
  (assert ((candidate 200) = 6));
  (assert ((candidate 4000) = 192));
  (assert ((candidate 10000) = 639));
  (assert ((candidate 100000) = 8026));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
 * >>> fizz_buzz 50
 * 0
 * >>> fizz_buzz 78
 * 2
 * >>> fizz_buzz 79
 * 3
*)
(** Return the number of times the digit 7 appears in integers less than n
    which are divisible by 11 or 13. *)
let fizz_buzz (n : int) : int =
  (* Count how many 7's are in the decimal representation of x *)
  let rec count_sevens x acc =
    if x = 0 then acc
    else
      let digit = x mod 10 in
      let acc' = if digit = 7 then acc + 1 else acc in
      count_sevens (x / 10) acc'
  in

  (* Iterate over all numbers from 1 up to n-1 *)
  let rec loop i acc =
    if i >= n then acc
    else
      let acc' =
        if i mod 11 = 0 || i mod 13 = 0 then
          acc + count_sevens i 0
        else acc
      in
      loop (i + 1) acc'
  in
  loop 1 0

let assertions =
 let candidate = fizz_buzz in
  (assert ((candidate 50) = 0));
  (assert ((candidate 78) = 2));
  (assert ((candidate 79) = 3));
  (assert ((candidate 100) = 3));
  (assert ((candidate 200) = 6));
  (assert ((candidate 4000) = 192));
  (assert ((candidate 10000) = 639));
  (assert ((candidate 100000) = 8026));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
 * >>> fizz_buzz 50
 * 0
 * >>> fizz_buzz 78
 * 2
 * >>> fizz_buzz 79
 * 3
*)
(* Count how many times the digit '7' appears in all integers less than n
   that are divisible by 11 or 13. *)
let fizz_buzz (n : int) : int =
  let count_sevens_in_int i =
    let s = string_of_int i in
    let rec aux idx acc =
      if idx = String.length s then acc
      else
        let acc' = if s.[idx] = '7' then acc + 1 else acc in
        aux (idx + 1) acc'
    in
    aux 0 0
  in
  let rec loop i acc =
    if i >= n then acc
    else
      let acc' =
        if i mod 11 = 0 || i mod 13 = 0 then acc + count_sevens_in_int i
        else acc
      in
      loop (i + 1) acc'
  in
  loop 1 0

let assertions =
 let candidate = fizz_buzz in
  (assert ((candidate 50) = 0));
  (assert ((candidate 78) = 2));
  (assert ((candidate 79) = 3));
  (assert ((candidate 100) = 3));
  (assert ((candidate 200) = 6));
  (assert ((candidate 4000) = 192));
  (assert ((candidate 10000) = 639));
  (assert ((candidate 100000) = 8026));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
 * >>> fizz_buzz 50
 * 0
 * >>> fizz_buzz 78
 * 2
 * >>> fizz_buzz 79
 * 3
*)
(* Count the number of times the digit 7 appears in all integers less than n
   that are divisible by 11 or 13. *)
let fizz_buzz (n : int) : int =
  let rec loop i acc =
    if i >= n then acc
    else if i mod 11 = 0 || i mod 13 = 0 then
      let s = string_of_int i in
      let count7 =
        String.fold_left (fun c ch -> if ch = '7' then c + 1 else c) 0 s
      in
      loop (i + 1) (acc + count7)
    else
      loop (i + 1) acc
  in
  loop 0 0

let assertions =
 let candidate = fizz_buzz in
  (assert ((candidate 50) = 0));
  (assert ((candidate 78) = 2));
  (assert ((candidate 79) = 3));
  (assert ((candidate 100) = 3));
  (assert ((candidate 200) = 6));
  (assert ((candidate 4000) = 192));
  (assert ((candidate 10000) = 639));
  (assert ((candidate 100000) = 8026));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 41 (ML) - HumanEval_41_car_race_collision
================================================================================

PROMPT:
----------------------------------------
(**Imagine a road that's a perfectly straight infinitely long line.
 * n cars are driving left to right;  simultaneously, a different set of n cars
 * are driving right to left.   The two sets of cars start out being very far from
 * each other.  All cars move in the same speed.  Two cars are said to collide
 * when a car that's moving left to right hits a car that's moving right to left.
 * However, the cars are infinitely sturdy and strong; as a result, they continue moving
 * in their trajectory as if they did not collide.
 * This function outputs the number of such collisions.
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = car_race_collision in
  (assert ((candidate 2) = 4));
  (assert ((candidate 3) = 9));
  (assert ((candidate 4) = 16));
  (assert ((candidate 8) = 64));
  (assert ((candidate 10) = 100));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Imagine a road that's a perfectly straight infinitely long line.
 * n cars are driving left to right;  simultaneously, a different set of n cars
 * are driving right to left.   The two sets of cars start out being very far from
 * each other.  All cars move in the same speed.  Two cars are said to collide
 * when a car that's moving left to right hits a car that's moving right to left.
 * However, the cars are infinitely sturdy and strong; as a result, they continue moving
 * in their trajectory as if they did not collide.
 * This function outputs the number of such collisions.
*)
(* car_race_collision.ml *)

(* The number of collisions is simply the number of pairs of cars
   moving in opposite directions. Since there are n cars on each side
   and each left‑to‑right car collides with every right‑to‑left car,
   the total is n * n. *)
let car_race_collision (n : int) : int =
  n * n

let assertions =
 let candidate = car_race_collision in
  (assert ((candidate 2) = 4));
  (assert ((candidate 3) = 9));
  (assert ((candidate 4) = 16));
  (assert ((candidate 8) = 64));
  (assert ((candidate 10) = 100));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Imagine a road that's a perfectly straight infinitely long line.
 * n cars are driving left to right;  simultaneously, a different set of n cars
 * are driving right to left.   The two sets of cars start out being very far from
 * each other.  All cars move in the same speed.  Two cars are said to collide
 * when a car that's moving left to right hits a car that's moving right to left.
 * However, the cars are infinitely sturdy and strong; as a result, they continue moving
 * in their trajectory as if they did not collide.
 * This function outputs the number of such collisions.
*)
(* 
   Each left‑to‑right car will meet every right‑to‑left car exactly once,
   because all cars travel at the same speed and start far apart.
   Therefore the total number of collisions is simply n * n.
*)
let car_race_collision (n : int) : int =
  n * n

let assertions =
 let candidate = car_race_collision in
  (assert ((candidate 2) = 4));
  (assert ((candidate 3) = 9));
  (assert ((candidate 4) = 16));
  (assert ((candidate 8) = 64));
  (assert ((candidate 10) = 100));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Imagine a road that's a perfectly straight infinitely long line.
 * n cars are driving left to right;  simultaneously, a different set of n cars
 * are driving right to left.   The two sets of cars start out being very far from
 * each other.  All cars move in the same speed.  Two cars are said to collide
 * when a car that's moving left to right hits a car that's moving right to left.
 * However, the cars are infinitely sturdy and strong; as a result, they continue moving
 * in their trajectory as if they did not collide.
 * This function outputs the number of such collisions.
*)
let car_race_collision (n : int) : int =
  n * n

let assertions =
 let candidate = car_race_collision in
  (assert ((candidate 2) = 4));
  (assert ((candidate 3) = 9));
  (assert ((candidate 4) = 16));
  (assert ((candidate 8) = 64));
  (assert ((candidate 10) = 100));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Imagine a road that's a perfectly straight infinitely long line.
 * n cars are driving left to right;  simultaneously, a different set of n cars
 * are driving right to left.   The two sets of cars start out being very far from
 * each other.  All cars move in the same speed.  Two cars are said to collide
 * when a car that's moving left to right hits a car that's moving right to left.
 * However, the cars are infinitely sturdy and strong; as a result, they continue moving
 * in their trajectory as if they did not collide.
 * This function outputs the number of such collisions.
*)
let car_race_collision (n : int) : int =
  (* Each of the n left‑to‑right cars collides with each of the n right‑to‑left cars *)
  n * n

let assertions =
 let candidate = car_race_collision in
  (assert ((candidate 2) = 4));
  (assert ((candidate 3) = 9));
  (assert ((candidate 4) = 16));
  (assert ((candidate 8) = 64));
  (assert ((candidate 10) = 100));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 42 (ML) - HumanEval_42_incr_list
================================================================================

PROMPT:
----------------------------------------
(**Return list with elements incremented by 1.
 * >>> incr_list [1; 2; 3]
 * [2; 3; 4]
 * >>> incr_list [5; 3; 5; 2; 3; 3; 9; 0; 123]
 * [6; 4; 6; 3; 4; 4; 10; 1; 124]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = incr_list in
  (assert ((candidate []) = []));
  (assert ((candidate [3; 2; 1]) = [4; 3; 2]));
  (assert ((candidate [5; 2; 5; 2; 3; 3; 9; 0; 123]) = [6; 3; 6; 3; 4; 4; 10; 1; 124]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Return list with elements incremented by 1.
 * >>> incr_list [1; 2; 3]
 * [2; 3; 4]
 * >>> incr_list [5; 3; 5; 2; 3; 3; 9; 0; 123]
 * [6; 4; 6; 3; 4; 4; 10; 1; 124]
*)
let incr_list (l : int list) : int list =
  List.map (fun x -> x + 1) l

let assertions =
 let candidate = incr_list in
  (assert ((candidate []) = []));
  (assert ((candidate [3; 2; 1]) = [4; 3; 2]));
  (assert ((candidate [5; 2; 5; 2; 3; 3; 9; 0; 123]) = [6; 3; 6; 3; 4; 4; 10; 1; 124]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Return list with elements incremented by 1.
 * >>> incr_list [1; 2; 3]
 * [2; 3; 4]
 * >>> incr_list [5; 3; 5; 2; 3; 3; 9; 0; 123]
 * [6; 4; 6; 3; 4; 4; 10; 1; 124]
*)
let incr_list (l : int list) : int list =
  List.map (fun x -> x + 1) l

let assertions =
 let candidate = incr_list in
  (assert ((candidate []) = []));
  (assert ((candidate [3; 2; 1]) = [4; 3; 2]));
  (assert ((candidate [5; 2; 5; 2; 3; 3; 9; 0; 123]) = [6; 3; 6; 3; 4; 4; 10; 1; 124]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Return list with elements incremented by 1.
 * >>> incr_list [1; 2; 3]
 * [2; 3; 4]
 * >>> incr_list [5; 3; 5; 2; 3; 3; 9; 0; 123]
 * [6; 4; 6; 3; 4; 4; 10; 1; 124]
*)
let incr_list (l : int list) : int list =
  List.map (fun x -> x + 1) l

let assertions =
 let candidate = incr_list in
  (assert ((candidate []) = []));
  (assert ((candidate [3; 2; 1]) = [4; 3; 2]));
  (assert ((candidate [5; 2; 5; 2; 3; 3; 9; 0; 123]) = [6; 3; 6; 3; 4; 4; 10; 1; 124]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Return list with elements incremented by 1.
 * >>> incr_list [1; 2; 3]
 * [2; 3; 4]
 * >>> incr_list [5; 3; 5; 2; 3; 3; 9; 0; 123]
 * [6; 4; 6; 3; 4; 4; 10; 1; 124]
*)
let incr_list (l : int list) : int list =
  List.map (fun x -> x + 1) l

let assertions =
 let candidate = incr_list in
  (assert ((candidate []) = []));
  (assert ((candidate [3; 2; 1]) = [4; 3; 2]));
  (assert ((candidate [5; 2; 5; 2; 3; 3; 9; 0; 123]) = [6; 3; 6; 3; 4; 4; 10; 1; 124]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 45 (ML) - HumanEval_45_triangle_area
================================================================================

PROMPT:
----------------------------------------
(**Given length of a side and high return area for a triangle.
 * >>> triangle_area 5 3
 * 7.5
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = triangle_area in
  (assert ((candidate 5 3) = 7.5));
  (assert ((candidate 2 2) = 2.0));
  (assert ((candidate 10 8) = 40.0));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given length of a side and high return area for a triangle.
 * >>> triangle_area 5 3
 * 7.5
*)
(* Calculate the area of a triangle given its base (a) and height (h) *)
let triangle_area (a : int) (h : int) : float =
  0.5 *. (float_of_int a *. float_of_int h)

let assertions =
 let candidate = triangle_area in
  (assert ((candidate 5 3) = 7.5));
  (assert ((candidate 2 2) = 2.0));
  (assert ((candidate 10 8) = 40.0));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183715
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given length of a side and high return area for a triangle.
 * >>> triangle_area 5 3
 * 7.5
*)
(* Calculate the area of a triangle given its base (a) and height (h) *)
let triangle_area (a : int) (h : int) : float =
  (float_of_int a *. float_of_int h) /. 2.0

let assertions =
 let candidate = triangle_area in
  (assert ((candidate 5 3) = 7.5));
  (assert ((candidate 2 2) = 2.0));
  (assert ((candidate 10 8) = 40.0));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183715
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given length of a side and high return area for a triangle.
 * >>> triangle_area 5 3
 * 7.5
*)
(** Given length of a side and height, return the area of a triangle.
 *  >>> triangle_area 5 3
 *  7.5
 *)
let triangle_area (a : int) (h : int) : float =
  0.5 *. (float_of_int a) *. (float_of_int h)

let assertions =
 let candidate = triangle_area in
  (assert ((candidate 5 3) = 7.5));
  (assert ((candidate 2 2) = 2.0));
  (assert ((candidate 10 8) = 40.0));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183715
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given length of a side and high return area for a triangle.
 * >>> triangle_area 5 3
 * 7.5
*)
(* Calculates the area of a triangle given the base `a` and the height `h`. *)
let triangle_area (a : int) (h : int) : float =
  (float_of_int a *. float_of_int h) /. 2.0

let assertions =
 let candidate = triangle_area in
  (assert ((candidate 5 3) = 7.5));
  (assert ((candidate 2 2) = 2.0));
  (assert ((candidate 10 8) = 40.0));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183715
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 52 (ML) - HumanEval_52_below_threshold
================================================================================

PROMPT:
----------------------------------------
(**Return true if all numbers in the list l are below threshold t.
 * >>> below_threshold [1; 2; 4; 10] 100
 * true
 * >>> below_threshold [1; 20; 4; 10] 5
 * false
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = below_threshold in
  (assert ((candidate [1; 2; 4; 10] 100) = true));
  (assert ((candidate [1; 20; 4; 10] 5) = false));
  (assert ((candidate [1; 20; 4; 10] 21) = true));
  (assert ((candidate [1; 20; 4; 10] 22) = true));
  (assert ((candidate [1; 8; 4; 10] 11) = true));
  (assert ((candidate [1; 8; 4; 10] 10) = false));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Return true if all numbers in the list l are below threshold t.
 * >>> below_threshold [1; 2; 4; 10] 100
 * true
 * >>> below_threshold [1; 20; 4; 10] 5
 * false
*)
(** Return true if all numbers in the list l are below threshold t. *)
let below_threshold (l : int list) (t : int) : bool =
  List.for_all (fun x -> x < t) l

let assertions =
 let candidate = below_threshold in
  (assert ((candidate [1; 2; 4; 10] 100) = true));
  (assert ((candidate [1; 20; 4; 10] 5) = false));
  (assert ((candidate [1; 20; 4; 10] 21) = true));
  (assert ((candidate [1; 20; 4; 10] 22) = true));
  (assert ((candidate [1; 8; 4; 10] 11) = true));
  (assert ((candidate [1; 8; 4; 10] 10) = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Return true if all numbers in the list l are below threshold t.
 * >>> below_threshold [1; 2; 4; 10] 100
 * true
 * >>> below_threshold [1; 20; 4; 10] 5
 * false
*)
(** Return true if all numbers in the list `l` are below threshold `t`. *)
let below_threshold (l : int list) (t : int) : bool =
  List.for_all (fun x -> x < t) l

let assertions =
 let candidate = below_threshold in
  (assert ((candidate [1; 2; 4; 10] 100) = true));
  (assert ((candidate [1; 20; 4; 10] 5) = false));
  (assert ((candidate [1; 20; 4; 10] 21) = true));
  (assert ((candidate [1; 20; 4; 10] 22) = true));
  (assert ((candidate [1; 8; 4; 10] 11) = true));
  (assert ((candidate [1; 8; 4; 10] 10) = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Return true if all numbers in the list l are below threshold t.
 * >>> below_threshold [1; 2; 4; 10] 100
 * true
 * >>> below_threshold [1; 20; 4; 10] 5
 * false
*)
(** Return true if all numbers in the list `l` are below threshold `t`.
 *  >>> below_threshold [1; 2; 4; 10] 100
 *  true
 *  >>> below_threshold [1; 20; 4; 10] 5
 *  false
 *)
let below_threshold (l : int list) (t : int) : bool =
  List.for_all (fun x -> x < t) l

let assertions =
 let candidate = below_threshold in
  (assert ((candidate [1; 2; 4; 10] 100) = true));
  (assert ((candidate [1; 20; 4; 10] 5) = false));
  (assert ((candidate [1; 20; 4; 10] 21) = true));
  (assert ((candidate [1; 20; 4; 10] 22) = true));
  (assert ((candidate [1; 8; 4; 10] 11) = true));
  (assert ((candidate [1; 8; 4; 10] 10) = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Return true if all numbers in the list l are below threshold t.
 * >>> below_threshold [1; 2; 4; 10] 100
 * true
 * >>> below_threshold [1; 20; 4; 10] 5
 * false
*)
let below_threshold (l : int list) (t : int) : bool =
  List.for_all (fun x -> x < t) l

let assertions =
 let candidate = below_threshold in
  (assert ((candidate [1; 2; 4; 10] 100) = true));
  (assert ((candidate [1; 20; 4; 10] 5) = false));
  (assert ((candidate [1; 20; 4; 10] 21) = true));
  (assert ((candidate [1; 20; 4; 10] 22) = true));
  (assert ((candidate [1; 8; 4; 10] 11) = true));
  (assert ((candidate [1; 8; 4; 10] 10) = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 53 (ML) - HumanEval_53_add
================================================================================

PROMPT:
----------------------------------------
(**Add two numbers x and y
 * >>> add 2 3
 * 5
 * >>> add 5 7
 * 12
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = add in
  (assert ((candidate 0 1) = 1));
  (assert ((candidate 1 0) = 1));
  (assert ((candidate 2 3) = 5));
  (assert ((candidate 5 7) = 12));
  (assert ((candidate 7 5) = 12));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Add two numbers x and y
 * >>> add 2 3
 * 5
 * >>> add 5 7
 * 12
*)
let add (x : int) (y : int) : int =
  x + y

let assertions =
 let candidate = add in
  (assert ((candidate 0 1) = 1));
  (assert ((candidate 1 0) = 1));
  (assert ((candidate 2 3) = 5));
  (assert ((candidate 5 7) = 12));
  (assert ((candidate 7 5) = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Add two numbers x and y
 * >>> add 2 3
 * 5
 * >>> add 5 7
 * 12
*)
let add (x : int) (y : int) : int = x + y

let assertions =
 let candidate = add in
  (assert ((candidate 0 1) = 1));
  (assert ((candidate 1 0) = 1));
  (assert ((candidate 2 3) = 5));
  (assert ((candidate 5 7) = 12));
  (assert ((candidate 7 5) = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Add two numbers x and y
 * >>> add 2 3
 * 5
 * >>> add 5 7
 * 12
*)
(** Add two numbers x and y
 *  >>> add 2 3
 *  5
 *  >>> add 5 7
 *  12
*)
let add (x : int) (y : int) : int =
  x + y

let assertions =
 let candidate = add in
  (assert ((candidate 0 1) = 1));
  (assert ((candidate 1 0) = 1));
  (assert ((candidate 2 3) = 5));
  (assert ((candidate 5 7) = 12));
  (assert ((candidate 7 5) = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Add two numbers x and y
 * >>> add 2 3
 * 5
 * >>> add 5 7
 * 12
*)
let add (x : int) (y : int) : int =
  x + y

let assertions =
 let candidate = add in
  (assert ((candidate 0 1) = 1));
  (assert ((candidate 1 0) = 1));
  (assert ((candidate 2 3) = 5));
  (assert ((candidate 5 7) = 12));
  (assert ((candidate 7 5) = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 55 (ML) - HumanEval_55_fib
================================================================================

PROMPT:
----------------------------------------
(**Return n-th Fibonacci number.
 * >>> fib 10
 * 55
 * >>> fib 1
 * 1
 * >>> fib 8
 * 21
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = fib in
  (assert ((candidate 10) = 55));
  (assert ((candidate 1) = 1));
  (assert ((candidate 8) = 21));
  (assert ((candidate 11) = 89));
  (assert ((candidate 12) = 144));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Return n-th Fibonacci number.
 * >>> fib 10
 * 55
 * >>> fib 1
 * 1
 * >>> fib 8
 * 21
*)
let fib (n : int) : int =
  let rec aux n =
    if n <= 1 then n
    else aux (n - 1) + aux (n - 2)
  in
  aux n

let assertions =
 let candidate = fib in
  (assert ((candidate 10) = 55));
  (assert ((candidate 1) = 1));
  (assert ((candidate 8) = 21));
  (assert ((candidate 11) = 89));
  (assert ((candidate 12) = 144));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Return n-th Fibonacci number.
 * >>> fib 10
 * 55
 * >>> fib 1
 * 1
 * >>> fib 8
 * 21
*)
let rec fib (n : int) : int =
  if n <= 2 then 1
  else fib (n - 1) + fib (n - 2)

let assertions =
 let candidate = fib in
  (assert ((candidate 10) = 55));
  (assert ((candidate 1) = 1));
  (assert ((candidate 8) = 21));
  (assert ((candidate 11) = 89));
  (assert ((candidate 12) = 144));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Return n-th Fibonacci number.
 * >>> fib 10
 * 55
 * >>> fib 1
 * 1
 * >>> fib 8
 * 21
*)
let fib (n : int) : int =
  (* Iterative tail‑recursive implementation *)
  let rec loop i a b =
    if i = n then a
    else loop (i + 1) b (a + b)
  in
  loop 0 0 1

let assertions =
 let candidate = fib in
  (assert ((candidate 10) = 55));
  (assert ((candidate 1) = 1));
  (assert ((candidate 8) = 21));
  (assert ((candidate 11) = 89));
  (assert ((candidate 12) = 144));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Return n-th Fibonacci number.
 * >>> fib 10
 * 55
 * >>> fib 1
 * 1
 * >>> fib 8
 * 21
*)
(** Return n-th Fibonacci number.
 *  >>> fib 10
 *  55
 *  >>> fib 1
 *  1
 *  >>> fib 8
 *  21
*)
let fib (n : int) : int =
  (* Tail‑recursive helper: i is the current position,
     a is fib(i), and b is fib(i+1). *)
  let rec aux i a b =
    if i = n then a
    else aux (i + 1) b (a + b)
  in
  (* Treat n <= 0 as 0 for safety; otherwise start at position 1. *)
  if n <= 0 then 0
  else aux 1 1 1

let assertions =
 let candidate = fib in
  (assert ((candidate 10) = 55));
  (assert ((candidate 1) = 1));
  (assert ((candidate 8) = 21));
  (assert ((candidate 11) = 89));
  (assert ((candidate 12) = 144));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 56 (ML) - HumanEval_56_correct_bracketing
================================================================================

PROMPT:
----------------------------------------
(**brackets is a string of "<" and ">".
 * return true if every opening bracket has a corresponding closing bracket.
 * >>> correct_bracketing "<"
 * false
 * >>> correct_bracketing "<>"
 * true
 * >>> correct_bracketing "<<><>>"
 * true
 * >>> correct_bracketing "><<>"
 * false
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = correct_bracketing in
  (assert ((candidate "<>") = true));
  (assert ((candidate "<<><>>") = true));
  (assert ((candidate "<><><<><>><>") = true));
  (assert ((candidate "<><><<<><><>><>><<><><<>>>") = true));
  (assert ((candidate "<<<><>>>>") = false));
  (assert ((candidate "><<>") = false));
  (assert ((candidate "<") = false));
  (assert ((candidate "<<<<") = false));
  (assert ((candidate ">") = false));
  (assert ((candidate "<<>") = false));
  (assert ((candidate "<><><<><>><>><<>") = false));
  (assert ((candidate "<><><<><>><>>><>") = false));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**brackets is a string of "<" and ">".
 * return true if every opening bracket has a corresponding closing bracket.
 * >>> correct_bracketing "<"
 * false
 * >>> correct_bracketing "<>"
 * true
 * >>> correct_bracketing "<<><>>"
 * true
 * >>> correct_bracketing "><<>"
 * false
*)
(* Return true iff every opening "<" has a matching closing ">" *)
let correct_bracketing (brackets : string) : bool =
  let rec aux i count =
    if i = String.length brackets then count = 0
    else
      let count' =
        match brackets.[i] with
        | '<' -> count + 1
        | '>' -> count - 1
        | _   -> count   (* not expected, but harmless *)
      in
      (* If we ever go negative, there's an unmatched closing bracket *)
      if count' < 0 then false
      else aux (i + 1) count'
  in
  aux 0 0

let assertions =
 let candidate = correct_bracketing in
  (assert ((candidate "<>") = true));
  (assert ((candidate "<<><>>") = true));
  (assert ((candidate "<><><<><>><>") = true));
  (assert ((candidate "<><><<<><><>><>><<><><<>>>") = true));
  (assert ((candidate "<<<><>>>>") = false));
  (assert ((candidate "><<>") = false));
  (assert ((candidate "<") = false));
  (assert ((candidate "<<<<") = false));
  (assert ((candidate ">") = false));
  (assert ((candidate "<<>") = false));
  (assert ((candidate "<><><<><>><>><<>") = false));
  (assert ((candidate "<><><<><>><>>><>") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**brackets is a string of "<" and ">".
 * return true if every opening bracket has a corresponding closing bracket.
 * >>> correct_bracketing "<"
 * false
 * >>> correct_bracketing "<>"
 * true
 * >>> correct_bracketing "<<><>>"
 * true
 * >>> correct_bracketing "><<>"
 * false
*)
(** Brackets is a string of "<" and ">".
 *  Return true if every opening bracket has a corresponding closing bracket.
 *  >>> correct_bracketing "<"
 *  false
 *  >>> correct_bracketing "<>"
 *  true
 *  >>> correct_bracketing "<<><>>"
 *  true
 *  >>> correct_bracketing "><<>"
 *  false
 *)
let correct_bracketing (brackets : string) : bool =
  let len = String.length brackets in
  let rec loop i bal =
    (* If we reached the end, the balance must be zero *)
    if i = len then bal = 0
    else
      let bal' =
        match String.get brackets i with
        | '<' -> bal + 1
        | '>' -> bal - 1
        | _   -> bal          (* ignore any other character – not expected *)
      in
      (* If we ever have a negative balance, a closing bracket was unmatched *)
      if bal' < 0 then false
      else loop (i + 1) bal'
  in
  loop 0 0

let assertions =
 let candidate = correct_bracketing in
  (assert ((candidate "<>") = true));
  (assert ((candidate "<<><>>") = true));
  (assert ((candidate "<><><<><>><>") = true));
  (assert ((candidate "<><><<<><><>><>><<><><<>>>") = true));
  (assert ((candidate "<<<><>>>>") = false));
  (assert ((candidate "><<>") = false));
  (assert ((candidate "<") = false));
  (assert ((candidate "<<<<") = false));
  (assert ((candidate ">") = false));
  (assert ((candidate "<<>") = false));
  (assert ((candidate "<><><<><>><>><<>") = false));
  (assert ((candidate "<><><<><>><>>><>") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**brackets is a string of "<" and ">".
 * return true if every opening bracket has a corresponding closing bracket.
 * >>> correct_bracketing "<"
 * false
 * >>> correct_bracketing "<>"
 * true
 * >>> correct_bracketing "<<><>>"
 * true
 * >>> correct_bracketing "><<>"
 * false
*)
(* Check that every opening bracket '<' has a matching closing bracket '>' and
   that the brackets are correctly nested. *)
let correct_bracketing (brackets : string) : bool =
  (* Helper: iterate over the string while keeping a counter of unmatched
     opening brackets. *)
  let rec aux idx balance =
    if idx = String.length brackets then
      (* All characters processed: balanced iff counter is zero. *)
      balance = 0
    else
      match brackets.[idx] with
      | '<' -> aux (idx + 1) (balance + 1)          (* opening bracket *)
      | '>' ->
        if balance = 0 then
          false                                   (* closing without opening *)
        else
          aux (idx + 1) (balance - 1)              (* closing bracket *)
      | _ -> false                                 (* invalid character *)
  in
  aux 0 0

let assertions =
 let candidate = correct_bracketing in
  (assert ((candidate "<>") = true));
  (assert ((candidate "<<><>>") = true));
  (assert ((candidate "<><><<><>><>") = true));
  (assert ((candidate "<><><<<><><>><>><<><><<>>>") = true));
  (assert ((candidate "<<<><>>>>") = false));
  (assert ((candidate "><<>") = false));
  (assert ((candidate "<") = false));
  (assert ((candidate "<<<<") = false));
  (assert ((candidate ">") = false));
  (assert ((candidate "<<>") = false));
  (assert ((candidate "<><><<><>><>><<>") = false));
  (assert ((candidate "<><><<><>><>>><>") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**brackets is a string of "<" and ">".
 * return true if every opening bracket has a corresponding closing bracket.
 * >>> correct_bracketing "<"
 * false
 * >>> correct_bracketing "<>"
 * true
 * >>> correct_bracketing "<<><>>"
 * true
 * >>> correct_bracketing "><<>"
 * false
*)
(* correct_bracketing : string -> bool
   Returns true if every opening '<' has a matching closing '>' in the
   correct order. *)
let correct_bracketing (brackets : string) : bool =
  let rec aux idx balance =
    if idx = String.length brackets then
      balance = 0
    else
      match brackets.[idx] with
      | '<' -> aux (idx + 1) (balance + 1)
      | '>' ->
          if balance = 0 then
            false
          else
            aux (idx + 1) (balance - 1)
      | _ -> false   (* any other character is invalid *)
  in
  aux 0 0

let assertions =
 let candidate = correct_bracketing in
  (assert ((candidate "<>") = true));
  (assert ((candidate "<<><>>") = true));
  (assert ((candidate "<><><<><>><>") = true));
  (assert ((candidate "<><><<<><><>><>><<><><<>>>") = true));
  (assert ((candidate "<<<><>>>>") = false));
  (assert ((candidate "><<>") = false));
  (assert ((candidate "<") = false));
  (assert ((candidate "<<<<") = false));
  (assert ((candidate ">") = false));
  (assert ((candidate "<<>") = false));
  (assert ((candidate "<><><<><>><>><<>") = false));
  (assert ((candidate "<><><<><>><>>><>") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 58 (ML) - HumanEval_58_common
================================================================================

PROMPT:
----------------------------------------
(**Return sorted unique common elements for two lists.
 * >>> common [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]
 * [1; 5; 653]
 * >>> common [5; 3; 2; 8] [3; 2]
 * [2; 3]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = common in
  (assert ((candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]) = [1; 5; 653]));
  (assert ((candidate [5; 3; 2; 8] [3; 2]) = [2; 3]));
  (assert ((candidate [4; 3; 2; 8] [3; 2; 4]) = [2; 3; 4]));
  (assert ((candidate [4; 3; 2; 8] []) = []));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Return sorted unique common elements for two lists.
 * >>> common [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]
 * [1; 5; 653]
 * >>> common [5; 3; 2; 8] [3; 2]
 * [2; 3]
*)
let common (l1 : int list) (l2 : int list) : int list =
  l1
  |> List.filter (fun x -> List.mem x l2)
  |> List.sort_uniq compare

let assertions =
 let candidate = common in
  (assert ((candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]) = [1; 5; 653]));
  (assert ((candidate [5; 3; 2; 8] [3; 2]) = [2; 3]));
  (assert ((candidate [4; 3; 2; 8] [3; 2; 4]) = [2; 3; 4]));
  (assert ((candidate [4; 3; 2; 8] []) = []));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Return sorted unique common elements for two lists.
 * >>> common [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]
 * [1; 5; 653]
 * >>> common [5; 3; 2; 8] [3; 2]
 * [2; 3]
*)
(* Return sorted unique common elements for two lists. *)
let common (l1 : int list) (l2 : int list) : int list =
  (* Remove duplicates and sort each list. *)
  let s1 = List.sort_uniq compare l1 in
  let s2 = List.sort_uniq compare l2 in
  (* Keep only the elements that appear in both lists. *)
  List.filter (fun x -> List.mem x s2) s1

let assertions =
 let candidate = common in
  (assert ((candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]) = [1; 5; 653]));
  (assert ((candidate [5; 3; 2; 8] [3; 2]) = [2; 3]));
  (assert ((candidate [4; 3; 2; 8] [3; 2; 4]) = [2; 3; 4]));
  (assert ((candidate [4; 3; 2; 8] []) = []));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Return sorted unique common elements for two lists.
 * >>> common [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]
 * [1; 5; 653]
 * >>> common [5; 3; 2; 8] [3; 2]
 * [2; 3]
*)
(** Return sorted unique common elements for two lists.
 *  >>> common [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]
 *  [1; 5; 653]
 *  >>> common [5; 3; 2; 8] [3; 2]
 *  [2; 3]
 *)
let common (l1 : int list) (l2 : int list) : int list =
  l1
  |> List.filter (fun x -> List.mem x l2)   (* keep only elements that appear in l2 *)
  |> List.sort_uniq compare                (* remove duplicates and sort *)

let assertions =
 let candidate = common in
  (assert ((candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]) = [1; 5; 653]));
  (assert ((candidate [5; 3; 2; 8] [3; 2]) = [2; 3]));
  (assert ((candidate [4; 3; 2; 8] [3; 2; 4]) = [2; 3; 4]));
  (assert ((candidate [4; 3; 2; 8] []) = []));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Return sorted unique common elements for two lists.
 * >>> common [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]
 * [1; 5; 653]
 * >>> common [5; 3; 2; 8] [3; 2]
 * [2; 3]
*)
let common (l1 : int list) (l2 : int list) : int list =
  (* Step 1 – keep only elements that appear in both lists *)
  let filtered = List.filter (fun x -> List.mem x l2) l1 in
  (* Step 2 – remove duplicates while preserving order *)
  let unique =
    List.fold_left
      (fun acc x -> if List.mem x acc then acc else x :: acc)
      [] filtered
  in
  (* Step 3 – sort the unique elements *)
  List.sort compare unique

let assertions =
 let candidate = common in
  (assert ((candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]) = [1; 5; 653]));
  (assert ((candidate [5; 3; 2; 8] [3; 2]) = [2; 3]));
  (assert ((candidate [4; 3; 2; 8] [3; 2; 4]) = [2; 3; 4]));
  (assert ((candidate [4; 3; 2; 8] []) = []));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183716
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 59 (ML) - HumanEval_59_largest_prime_factor
================================================================================

PROMPT:
----------------------------------------
(**Return the largest prime factor of n. Assume n > 1 and is not a prime.
 * >>> largest_prime_factor 13195
 * 29
 * >>> largest_prime_factor 2048
 * 2
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = largest_prime_factor in
  (assert ((candidate 15) = 5));
  (assert ((candidate 27) = 3));
  (assert ((candidate 63) = 7));
  (assert ((candidate 330) = 11));
  (assert ((candidate 13195) = 29));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Return the largest prime factor of n. Assume n > 1 and is not a prime.
 * >>> largest_prime_factor 13195
 * 29
 * >>> largest_prime_factor 2048
 * 2
*)
let largest_prime_factor (n : int) : int =
  let rec loop i n max_f =
    if i * i > n then
      if n > 1 then max max_f n else max_f
    else if n mod i = 0 then
      loop i (n / i) i
    else
      loop (i + 1) n max_f
  in
  loop 2 n 1

let assertions =
 let candidate = largest_prime_factor in
  (assert ((candidate 15) = 5));
  (assert ((candidate 27) = 3));
  (assert ((candidate 63) = 7));
  (assert ((candidate 330) = 11));
  (assert ((candidate 13195) = 29));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Return the largest prime factor of n. Assume n > 1 and is not a prime.
 * >>> largest_prime_factor 13195
 * 29
 * >>> largest_prime_factor 2048
 * 2
*)
let largest_prime_factor (n : int) : int =
  let rec loop n factor largest =
    if n = 1 then largest
    else if n mod factor = 0 then
      loop (n / factor) factor (max factor largest)
    else
      loop n (factor + 1) largest
  in
  loop n 2 0

let assertions =
 let candidate = largest_prime_factor in
  (assert ((candidate 15) = 5));
  (assert ((candidate 27) = 3));
  (assert ((candidate 63) = 7));
  (assert ((candidate 330) = 11));
  (assert ((candidate 13195) = 29));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Return the largest prime factor of n. Assume n > 1 and is not a prime.
 * >>> largest_prime_factor 13195
 * 29
 * >>> largest_prime_factor 2048
 * 2
*)
(* Return the largest prime factor of n. Assume n > 1 and is not a prime. *)
let largest_prime_factor (n : int) : int =
  (* Recursive helper that divides out factors and keeps track of the largest one seen. *)
  let rec aux current divisor largest =
    if divisor * divisor > current then
      (* If current is now > 1, it must be a prime factor larger than any seen before. *)
      if current > 1 then max largest current else largest
    else if current mod divisor = 0 then
      (* Found a factor: keep dividing by it and update the largest factor. *)
      aux (current / divisor) divisor (max largest divisor)
    else
      (* No factor at this divisor: try the next one. *)
      aux current (divisor + 1) largest
  in
  aux n 2 0

let assertions =
 let candidate = largest_prime_factor in
  (assert ((candidate 15) = 5));
  (assert ((candidate 27) = 3));
  (assert ((candidate 63) = 7));
  (assert ((candidate 330) = 11));
  (assert ((candidate 13195) = 29));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Return the largest prime factor of n. Assume n > 1 and is not a prime.
 * >>> largest_prime_factor 13195
 * 29
 * >>> largest_prime_factor 2048
 * 2
*)
(* Return the largest prime factor of n. Assume n > 1 and is not a prime. *)
let largest_prime_factor (n : int) : int =
  let rec aux m i largest =
    if i * i > m then
      if m > 1 then max largest m else largest
    else if m mod i = 0 then
      aux (m / i) i i
    else
      aux m (i + 1) largest
  in
  aux n 2 0

let assertions =
 let candidate = largest_prime_factor in
  (assert ((candidate 15) = 5));
  (assert ((candidate 27) = 3));
  (assert ((candidate 63) = 7));
  (assert ((candidate 330) = 11));
  (assert ((candidate 13195) = 29));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------
