As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 72 (LUA) - HumanEval_72_will_it_fly
================================================================================

PROMPT:
----------------------------------------
-- Write a function that returns true if the object q will fly, and false otherwise.
-- The object q will fly if it's balanced (it is a palindromic table) and the sum of its elements is less than or equal the maximum possible weight w.
-- Example:
-- >>> will_it_fly({1, 2}, 5)
-- false
-- # 1+2 is less than the maximum possible weight, but it's unbalanced.
-- >>> will_it_fly({3, 2, 3}, 1)
-- false
-- # it's balanced, but 3+2+3 is more than the maximum possible weight.
-- >>> will_it_fly({3, 2, 3}, 9)
-- true
-- # 3+2+3 is less than the maximum possible weight, and it's balanced.
-- >>> will_it_fly({3}, 5)
-- true
-- # 3 is less than the maximum possible weight, and it's balanced.

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = will_it_fly
    lu.assertEquals(candidate({3, 2, 3}, 9), true)
    lu.assertEquals(candidate({1, 2}, 5), false)
    lu.assertEquals(candidate({3}, 5), true)
    lu.assertEquals(candidate({3, 2, 3}, 1), false)
    lu.assertEquals(candidate({1, 2, 3}, 6), false)
    lu.assertEquals(candidate({5}, 5), true)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Write a function that returns true if the object q will fly, and false otherwise.
-- The object q will fly if it's balanced (it is a palindromic table) and the sum of its elements is less than or equal the maximum possible weight w.
-- Example:
-- >>> will_it_fly({1, 2}, 5)
-- false
-- # 1+2 is less than the maximum possible weight, but it's unbalanced.
-- >>> will_it_fly({3, 2, 3}, 1)
-- false
-- # it's balanced, but 3+2+3 is more than the maximum possible weight.
-- >>> will_it_fly({3, 2, 3}, 9)
-- true
-- # 3+2+3 is less than the maximum possible weight, and it's balanced.
-- >>> will_it_fly({3}, 5)
-- true
-- # 3 is less than the maximum possible weight, and it's balanced.
-- Returns true if the table `q` is palindromic (balanced) and the sum of its
-- elements is less than or equal to the maximum weight `w`. Otherwise returns false.
local function will_it_fly(q, w)
    -- Check if q is a palindrome
    local n = #q
    for i = 1, math.floor(n / 2) do
        if q[i] ~= q[n - i + 1] then
            return false
        end
    end

    -- Compute the sum of elements
    local sum = 0
    for _, v in ipairs(q) do
        sum = sum + v
    end

    -- Check weight constraint
    return sum <= w
end
lu = require('luaunit')

function test_humaneval()
local candidate = will_it_fly
    lu.assertEquals(candidate({3, 2, 3}, 9), true)
    lu.assertEquals(candidate({1, 2}, 5), false)
    lu.assertEquals(candidate({3}, 5), true)
    lu.assertEquals(candidate({3, 2, 3}, 1), false)
    lu.assertEquals(candidate({1, 2, 3}, 6), false)
    lu.assertEquals(candidate({5}, 5), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Write a function that returns true if the object q will fly, and false otherwise.
-- The object q will fly if it's balanced (it is a palindromic table) and the sum of its elements is less than or equal the maximum possible weight w.
-- Example:
-- >>> will_it_fly({1, 2}, 5)
-- false
-- # 1+2 is less than the maximum possible weight, but it's unbalanced.
-- >>> will_it_fly({3, 2, 3}, 1)
-- false
-- # it's balanced, but 3+2+3 is more than the maximum possible weight.
-- >>> will_it_fly({3, 2, 3}, 9)
-- true
-- # 3+2+3 is less than the maximum possible weight, and it's balanced.
-- >>> will_it_fly({3}, 5)
-- true
-- # 3 is less than the maximum possible weight, and it's balanced.
-- Returns true if the table `q` is palindromic (balanced) and its sum
-- does not exceed the maximum weight `w`. Otherwise returns false.
local function will_it_fly(q, w)
    local n = #q
    local sum = 0

    -- Check for palindrome and compute sum in a single pass
    for i = 1, n do
        sum = sum + q[i]
        -- Only need to check the first half of the table
        if i <= math.floor(n / 2) then
            if q[i] ~= q[n - i + 1] then
                return false  -- not balanced
            end
        end
    end

    -- After confirming palindrome, check weight constraint
    return sum <= w
end
lu = require('luaunit')

function test_humaneval()
local candidate = will_it_fly
    lu.assertEquals(candidate({3, 2, 3}, 9), true)
    lu.assertEquals(candidate({1, 2}, 5), false)
    lu.assertEquals(candidate({3}, 5), true)
    lu.assertEquals(candidate({3, 2, 3}, 1), false)
    lu.assertEquals(candidate({1, 2, 3}, 6), false)
    lu.assertEquals(candidate({5}, 5), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Write a function that returns true if the object q will fly, and false otherwise.
-- The object q will fly if it's balanced (it is a palindromic table) and the sum of its elements is less than or equal the maximum possible weight w.
-- Example:
-- >>> will_it_fly({1, 2}, 5)
-- false
-- # 1+2 is less than the maximum possible weight, but it's unbalanced.
-- >>> will_it_fly({3, 2, 3}, 1)
-- false
-- # it's balanced, but 3+2+3 is more than the maximum possible weight.
-- >>> will_it_fly({3, 2, 3}, 9)
-- true
-- # 3+2+3 is less than the maximum possible weight, and it's balanced.
-- >>> will_it_fly({3}, 5)
-- true
-- # 3 is less than the maximum possible weight, and it's balanced.
local function will_it_fly(q, w)
  local sum = 0
  local n = #q

  for i = 1, n do
    sum = sum + q[i]
    if q[i] ~= q[n - i + 1] then
      return false   -- not balanced
    end
  end

  return sum <= w
end
lu = require('luaunit')

function test_humaneval()
local candidate = will_it_fly
    lu.assertEquals(candidate({3, 2, 3}, 9), true)
    lu.assertEquals(candidate({1, 2}, 5), false)
    lu.assertEquals(candidate({3}, 5), true)
    lu.assertEquals(candidate({3, 2, 3}, 1), false)
    lu.assertEquals(candidate({1, 2, 3}, 6), false)
    lu.assertEquals(candidate({5}, 5), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Write a function that returns true if the object q will fly, and false otherwise.
-- The object q will fly if it's balanced (it is a palindromic table) and the sum of its elements is less than or equal the maximum possible weight w.
-- Example:
-- >>> will_it_fly({1, 2}, 5)
-- false
-- # 1+2 is less than the maximum possible weight, but it's unbalanced.
-- >>> will_it_fly({3, 2, 3}, 1)
-- false
-- # it's balanced, but 3+2+3 is more than the maximum possible weight.
-- >>> will_it_fly({3, 2, 3}, 9)
-- true
-- # 3+2+3 is less than the maximum possible weight, and it's balanced.
-- >>> will_it_fly({3}, 5)
-- true
-- # 3 is less than the maximum possible weight, and it's balanced.
-- Returns true if the table `q` is palindromic (balanced) and the sum of its
-- elements is less than or equal to the maximum weight `w`. Otherwise returns
-- false.
local function will_it_fly(q, w)
    -- Calculate the sum of the elements.
    local sum = 0
    for _, val in ipairs(q) do
        sum = sum + val
    end

    -- If the sum exceeds the allowed weight, it cannot fly.
    if sum > w then
        return false
    end

    -- Check if the table is palindromic.
    local n = #q
    for i = 1, math.floor(n / 2) do
        if q[i] ~= q[n - i + 1] then
            return false
        end
    end

    -- Balanced and within weight limits.
    return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = will_it_fly
    lu.assertEquals(candidate({3, 2, 3}, 9), true)
    lu.assertEquals(candidate({1, 2}, 5), false)
    lu.assertEquals(candidate({3}, 5), true)
    lu.assertEquals(candidate({3, 2, 3}, 1), false)
    lu.assertEquals(candidate({1, 2, 3}, 6), false)
    lu.assertEquals(candidate({5}, 5), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 73 (LUA) - HumanEval_73_smallest_change
================================================================================

PROMPT:
----------------------------------------
-- Given a table arr of integers, find the minimum number of elements that
-- need to be changed to make the table palindromic. A palindromic table is a table that
-- is read the same backwards and forwards. In one change, you can change one element to any other element.
-- For example:
-- >>> smallest_change({1, 2, 3, 5, 4, 7, 9, 6})
-- 4
-- >>> smallest_change({1, 2, 3, 4, 3, 2, 2})
-- 1
-- >>> smallest_change({1, 2, 3, 2, 1})
-- 0

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = smallest_change
    lu.assertEquals(candidate({1, 2, 3, 5, 4, 7, 9, 6}), 4)
    lu.assertEquals(candidate({1, 2, 3, 4, 3, 2, 2}), 1)
    lu.assertEquals(candidate({1, 4, 2}), 1)
    lu.assertEquals(candidate({1, 4, 4, 2}), 1)
    lu.assertEquals(candidate({1, 2, 3, 2, 1}), 0)
    lu.assertEquals(candidate({3, 1, 1, 3}), 0)
    lu.assertEquals(candidate({1}), 0)
    lu.assertEquals(candidate({0, 1}), 1)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a table arr of integers, find the minimum number of elements that
-- need to be changed to make the table palindromic. A palindromic table is a table that
-- is read the same backwards and forwards. In one change, you can change one element to any other element.
-- For example:
-- >>> smallest_change({1, 2, 3, 5, 4, 7, 9, 6})
-- 4
-- >>> smallest_change({1, 2, 3, 4, 3, 2, 2})
-- 1
-- >>> smallest_change({1, 2, 3, 2, 1})
-- 0
-- Return the minimum number of changes needed to make `arr` a palindrome.
-- A change consists of replacing one element with any other value.
local function smallest_change(arr)
    local n = #arr
    local changes = 0
    for i = 1, math.floor(n / 2) do
        if arr[i] ~= arr[n - i + 1] then
            changes = changes + 1
        end
    end
    return changes
end
lu = require('luaunit')

function test_humaneval()
local candidate = smallest_change
    lu.assertEquals(candidate({1, 2, 3, 5, 4, 7, 9, 6}), 4)
    lu.assertEquals(candidate({1, 2, 3, 4, 3, 2, 2}), 1)
    lu.assertEquals(candidate({1, 4, 2}), 1)
    lu.assertEquals(candidate({1, 4, 4, 2}), 1)
    lu.assertEquals(candidate({1, 2, 3, 2, 1}), 0)
    lu.assertEquals(candidate({3, 1, 1, 3}), 0)
    lu.assertEquals(candidate({1}), 0)
    lu.assertEquals(candidate({0, 1}), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a table arr of integers, find the minimum number of elements that
-- need to be changed to make the table palindromic. A palindromic table is a table that
-- is read the same backwards and forwards. In one change, you can change one element to any other element.
-- For example:
-- >>> smallest_change({1, 2, 3, 5, 4, 7, 9, 6})
-- 4
-- >>> smallest_change({1, 2, 3, 4, 3, 2, 2})
-- 1
-- >>> smallest_change({1, 2, 3, 2, 1})
-- 0
-- | smallest_change
-- | Compute the minimum number of elements that must be changed to make
-- | the given array palindromic.  For each pair of symmetric positions
-- | (i, n-i-1) we need to change at least one element if they differ.
-- | The optimal strategy is to change exactly one element for each
-- | mismatched pair, so the answer is simply the count of mismatched pairs.
local function smallest_change(arr)
    local n = #arr
    local changes = 0
    for i = 1, math.floor(n / 2) do
        if arr[i] ~= arr[n - i + 1] then
            changes = changes + 1
        end
    end
    return changes
end
lu = require('luaunit')

function test_humaneval()
local candidate = smallest_change
    lu.assertEquals(candidate({1, 2, 3, 5, 4, 7, 9, 6}), 4)
    lu.assertEquals(candidate({1, 2, 3, 4, 3, 2, 2}), 1)
    lu.assertEquals(candidate({1, 4, 2}), 1)
    lu.assertEquals(candidate({1, 4, 4, 2}), 1)
    lu.assertEquals(candidate({1, 2, 3, 2, 1}), 0)
    lu.assertEquals(candidate({3, 1, 1, 3}), 0)
    lu.assertEquals(candidate({1}), 0)
    lu.assertEquals(candidate({0, 1}), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a table arr of integers, find the minimum number of elements that
-- need to be changed to make the table palindromic. A palindromic table is a table that
-- is read the same backwards and forwards. In one change, you can change one element to any other element.
-- For example:
-- >>> smallest_change({1, 2, 3, 5, 4, 7, 9, 6})
-- 4
-- >>> smallest_change({1, 2, 3, 4, 3, 2, 2})
-- 1
-- >>> smallest_change({1, 2, 3, 2, 1})
-- 0
-- Find the minimum number of changes required to make an array palindromic.
-- The array is represented as a Lua table `arr` where indices start at 1.
-- In each change we can replace any element with any other value.
--
-- The optimal strategy is to compare symmetric pairs from the ends of the array.
-- For each pair `(arr[i], arr[n-i+1])` that are different we must change at least one
-- element of the pair.  The minimal number of changes equals the number of mismatched
-- pairs.

local function smallest_change(arr)
    local n = #arr
    local changes = 0
    -- Iterate over the first half of the array.
    for i = 1, math.floor(n / 2) do
        local j = n - i + 1
        if arr[i] ~= arr[j] then
            changes = changes + 1
        end
    end
    return changes
end

-- Example usage:
-- print(smallest_change({1, 2, 3, 5, 4, 7, 9, 6})) -- 4
-- print(smallest_change({1, 2, 3, 4, 3, 2, 2}))   -- 1
-- print(smallest_change({1, 2, 3, 2, 1}))          -- 0
lu = require('luaunit')

function test_humaneval()
local candidate = smallest_change
    lu.assertEquals(candidate({1, 2, 3, 5, 4, 7, 9, 6}), 4)
    lu.assertEquals(candidate({1, 2, 3, 4, 3, 2, 2}), 1)
    lu.assertEquals(candidate({1, 4, 2}), 1)
    lu.assertEquals(candidate({1, 4, 4, 2}), 1)
    lu.assertEquals(candidate({1, 2, 3, 2, 1}), 0)
    lu.assertEquals(candidate({3, 1, 1, 3}), 0)
    lu.assertEquals(candidate({1}), 0)
    lu.assertEquals(candidate({0, 1}), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a table arr of integers, find the minimum number of elements that
-- need to be changed to make the table palindromic. A palindromic table is a table that
-- is read the same backwards and forwards. In one change, you can change one element to any other element.
-- For example:
-- >>> smallest_change({1, 2, 3, 5, 4, 7, 9, 6})
-- 4
-- >>> smallest_change({1, 2, 3, 4, 3, 2, 2})
-- 1
-- >>> smallest_change({1, 2, 3, 2, 1})
-- 0
-- Minimal number of changes needed to make an array palindromic
local function smallest_change(arr)
  local n = #arr
  local changes = 0

  -- Compare each element with its symmetric counterpart
  for i = 1, math.floor(n / 2) do
    if arr[i] ~= arr[n - i + 1] then
      changes = changes + 1
    end
  end

  return changes
end
lu = require('luaunit')

function test_humaneval()
local candidate = smallest_change
    lu.assertEquals(candidate({1, 2, 3, 5, 4, 7, 9, 6}), 4)
    lu.assertEquals(candidate({1, 2, 3, 4, 3, 2, 2}), 1)
    lu.assertEquals(candidate({1, 4, 2}), 1)
    lu.assertEquals(candidate({1, 4, 4, 2}), 1)
    lu.assertEquals(candidate({1, 2, 3, 2, 1}), 0)
    lu.assertEquals(candidate({3, 1, 1, 3}), 0)
    lu.assertEquals(candidate({1}), 0)
    lu.assertEquals(candidate({0, 1}), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 75 (LUA) - HumanEval_75_is_multiply_prime
================================================================================

PROMPT:
----------------------------------------
-- Write a function that returns true if the given number is the multiplication of 3 prime numbers
-- and false otherwise.
-- Knowing that (a) is less then 100. 
-- Example:
-- >>> is_multiply_prime(30)
-- true
-- 30 = 2 * 3 * 5

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = is_multiply_prime
    lu.assertEquals(candidate(5), false)
    lu.assertEquals(candidate(30), true)
    lu.assertEquals(candidate(8), true)
    lu.assertEquals(candidate(10), false)
    lu.assertEquals(candidate(125), true)
    lu.assertEquals(candidate(105), true)
    lu.assertEquals(candidate(126), false)
    lu.assertEquals(candidate(729), false)
    lu.assertEquals(candidate(891), false)
    lu.assertEquals(candidate(1001), true)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Write a function that returns true if the given number is the multiplication of 3 prime numbers
-- and false otherwise.
-- Knowing that (a) is less then 100. 
-- Example:
-- >>> is_multiply_prime(30)
-- true
-- 30 = 2 * 3 * 5
local function is_multiply_prime(a)
  if a <= 1 then return false end

  local count = 0
  local n = a
  local i = 2

  while i * i <= n do
    while n % i == 0 do
      count = count + 1
      n = n / i
    end
    i = i + 1
  end

  if n > 1 then
    count = count + 1
  end

  return count == 3
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_multiply_prime
    lu.assertEquals(candidate(5), false)
    lu.assertEquals(candidate(30), true)
    lu.assertEquals(candidate(8), true)
    lu.assertEquals(candidate(10), false)
    lu.assertEquals(candidate(125), true)
    lu.assertEquals(candidate(105), true)
    lu.assertEquals(candidate(126), false)
    lu.assertEquals(candidate(729), false)
    lu.assertEquals(candidate(891), false)
    lu.assertEquals(candidate(1001), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Write a function that returns true if the given number is the multiplication of 3 prime numbers
-- and false otherwise.
-- Knowing that (a) is less then 100. 
-- Example:
-- >>> is_multiply_prime(30)
-- true
-- 30 = 2 * 3 * 5
-- Returns true if the given number `a` is a product of exactly three prime numbers,
-- otherwise returns false.  The function counts prime factors with multiplicity.
-- It works for any positive integer (the problem states a < 100, but the implementation
-- is general).
local function is_multiply_prime(a)
    -- Handle non‑positive inputs
    if a <= 1 then
        return false
    end

    local count = 0          -- number of prime factors found
    local n = a              -- working copy of the number

    -- Check divisibility by 2 first to allow skipping even numbers later
    while n % 2 == 0 do
        count = count + 1
        n = n / 2
    end

    -- Check odd divisors up to sqrt(n)
    local i = 3
    while i * i <= n do
        while n % i == 0 do
            count = count + 1
            n = n / i
        end
        i = i + 2
    end

    -- If there's any remaining prime factor greater than sqrt(original a)
    if n > 1 then
        count = count + 1
    end

    -- The number is a product of exactly three prime numbers iff count == 3
    return count == 3
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_multiply_prime
    lu.assertEquals(candidate(5), false)
    lu.assertEquals(candidate(30), true)
    lu.assertEquals(candidate(8), true)
    lu.assertEquals(candidate(10), false)
    lu.assertEquals(candidate(125), true)
    lu.assertEquals(candidate(105), true)
    lu.assertEquals(candidate(126), false)
    lu.assertEquals(candidate(729), false)
    lu.assertEquals(candidate(891), false)
    lu.assertEquals(candidate(1001), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Write a function that returns true if the given number is the multiplication of 3 prime numbers
-- and false otherwise.
-- Knowing that (a) is less then 100. 
-- Example:
-- >>> is_multiply_prime(30)
-- true
-- 30 = 2 * 3 * 5
-- Returns true if the given number is the product of exactly three prime factors
-- (counting multiplicity), otherwise returns false.
-- Assumes a < 100.
local function is_multiply_prime(a)
    if a < 2 then
        return false
    end

    local count = 0
    local n = a
    local i = 2

    -- Trial division to factorize the number
    while i * i <= n do
        while n % i == 0 do
            count = count + 1
            n = n / i
            if count > 3 then
                return false  -- More than 3 prime factors
            end
        end
        i = i + 1
    end

    -- If there's any remaining prime factor larger than sqrt(n)
    if n > 1 then
        count = count + 1
    end

    return count == 3
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_multiply_prime
    lu.assertEquals(candidate(5), false)
    lu.assertEquals(candidate(30), true)
    lu.assertEquals(candidate(8), true)
    lu.assertEquals(candidate(10), false)
    lu.assertEquals(candidate(125), true)
    lu.assertEquals(candidate(105), true)
    lu.assertEquals(candidate(126), false)
    lu.assertEquals(candidate(729), false)
    lu.assertEquals(candidate(891), false)
    lu.assertEquals(candidate(1001), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Write a function that returns true if the given number is the multiplication of 3 prime numbers
-- and false otherwise.
-- Knowing that (a) is less then 100. 
-- Example:
-- >>> is_multiply_prime(30)
-- true
-- 30 = 2 * 3 * 5
-- Returns true if `a` is the product of exactly three prime numbers,
-- false otherwise. Works for numbers less than 100.
local function is_multiply_prime(a)
    -- Numbers smaller than 8 cannot be a product of 3 primes
    if a < 8 then
        return false
    end

    local count = 0
    local n = a
    local i = 2

    -- Factorize `n` and count prime factors
    while i * i <= n do
        while n % i == 0 do
            count = count + 1
            n = n / i
            if count > 3 then
                return false   -- early exit if more than 3 factors
            end
        end
        i = i + 1
    end

    -- If there's any remaining prime factor > sqrt(original n)
    if n > 1 then
        count = count + 1
    end

    return count == 3
end

-- Example usage:
-- print(is_multiply_prime(30))   --> true  (30 = 2 * 3 * 5)
-- print(is_multiply_prime(8))    --> true  (8 = 2 * 2 * 2)
-- print(is_multiply_prime(12))   --> false (12 = 2 * 2 * 3, but 3 primes)
lu = require('luaunit')

function test_humaneval()
local candidate = is_multiply_prime
    lu.assertEquals(candidate(5), false)
    lu.assertEquals(candidate(30), true)
    lu.assertEquals(candidate(8), true)
    lu.assertEquals(candidate(10), false)
    lu.assertEquals(candidate(125), true)
    lu.assertEquals(candidate(105), true)
    lu.assertEquals(candidate(126), false)
    lu.assertEquals(candidate(729), false)
    lu.assertEquals(candidate(891), false)
    lu.assertEquals(candidate(1001), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 77 (LUA) - HumanEval_77_iscube
================================================================================

PROMPT:
----------------------------------------
-- Write a function that takes an integer a and returns true 
-- if this ingeger is a cube of some integer number.
-- Note: you may assume the input is always valid.
-- Examples:
-- >>> iscube(1)
-- true
-- >>> iscube(2)
-- false
-- >>> iscube(-1)
-- true
-- >>> iscube(64)
-- true
-- >>> iscube(0)
-- true
-- >>> iscube(180)
-- false

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = iscube
    lu.assertEquals(candidate(1), true)
    lu.assertEquals(candidate(2), false)
    lu.assertEquals(candidate(-1), true)
    lu.assertEquals(candidate(64), true)
    lu.assertEquals(candidate(180), false)
    lu.assertEquals(candidate(1000), true)
    lu.assertEquals(candidate(0), true)
    lu.assertEquals(candidate(1729), false)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Write a function that takes an integer a and returns true 
-- if this ingeger is a cube of some integer number.
-- Note: you may assume the input is always valid.
-- Examples:
-- >>> iscube(1)
-- true
-- >>> iscube(2)
-- false
-- >>> iscube(-1)
-- true
-- >>> iscube(64)
-- true
-- >>> iscube(0)
-- true
-- >>> iscube(180)
-- false
local function iscube(a)
  -- Compute the absolute value to handle negative numbers
  local absA = math.abs(a)

  -- Roughly estimate the cube root and round to the nearest integer
  local c = math.floor(absA^(1/3) + 0.5)

  -- Check whether the cube of the rounded value equals the original absolute value
  return c^3 == absA
end
lu = require('luaunit')

function test_humaneval()
local candidate = iscube
    lu.assertEquals(candidate(1), true)
    lu.assertEquals(candidate(2), false)
    lu.assertEquals(candidate(-1), true)
    lu.assertEquals(candidate(64), true)
    lu.assertEquals(candidate(180), false)
    lu.assertEquals(candidate(1000), true)
    lu.assertEquals(candidate(0), true)
    lu.assertEquals(candidate(1729), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Write a function that takes an integer a and returns true 
-- if this ingeger is a cube of some integer number.
-- Note: you may assume the input is always valid.
-- Examples:
-- >>> iscube(1)
-- true
-- >>> iscube(2)
-- false
-- >>> iscube(-1)
-- true
-- >>> iscube(64)
-- true
-- >>> iscube(0)
-- true
-- >>> iscube(180)
-- false
-- Returns true if `a` is a perfect cube of an integer, otherwise false
local function iscube(a)
  -- Handle zero immediately
  if a == 0 then return true end

  local absA = math.abs(a)
  -- Approximate cube root and round to nearest integer
  local n = math.floor(absA^(1/3) + 0.5)

  -- Check the cube against the original number
  if a > 0 then
    return n^3 == a
  else
    return (-n)^3 == a
  end
end
lu = require('luaunit')

function test_humaneval()
local candidate = iscube
    lu.assertEquals(candidate(1), true)
    lu.assertEquals(candidate(2), false)
    lu.assertEquals(candidate(-1), true)
    lu.assertEquals(candidate(64), true)
    lu.assertEquals(candidate(180), false)
    lu.assertEquals(candidate(1000), true)
    lu.assertEquals(candidate(0), true)
    lu.assertEquals(candidate(1729), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Write a function that takes an integer a and returns true 
-- if this ingeger is a cube of some integer number.
-- Note: you may assume the input is always valid.
-- Examples:
-- >>> iscube(1)
-- true
-- >>> iscube(2)
-- false
-- >>> iscube(-1)
-- true
-- >>> iscube(64)
-- true
-- >>> iscube(0)
-- true
-- >>> iscube(180)
-- false
-- Returns true if `a` is a perfect cube of an integer.
local function iscube(a)
    -- Zero is a cube (0^3)
    if a == 0 then
        return true
    end

    -- Determine the sign and work with the absolute value
    local sign = a < 0 and -1 or 1
    local absA = math.abs(a)

    -- Estimate the cube root and round to the nearest integer
    local n = math.floor(absA^(1/3) + 0.5)

    -- Check if the rounded value really cubes back to the original number
    return sign * n * n * n == a
end
lu = require('luaunit')

function test_humaneval()
local candidate = iscube
    lu.assertEquals(candidate(1), true)
    lu.assertEquals(candidate(2), false)
    lu.assertEquals(candidate(-1), true)
    lu.assertEquals(candidate(64), true)
    lu.assertEquals(candidate(180), false)
    lu.assertEquals(candidate(1000), true)
    lu.assertEquals(candidate(0), true)
    lu.assertEquals(candidate(1729), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Write a function that takes an integer a and returns true 
-- if this ingeger is a cube of some integer number.
-- Note: you may assume the input is always valid.
-- Examples:
-- >>> iscube(1)
-- true
-- >>> iscube(2)
-- false
-- >>> iscube(-1)
-- true
-- >>> iscube(64)
-- true
-- >>> iscube(0)
-- true
-- >>> iscube(180)
-- false
-- Determine whether an integer is a perfect cube
local function iscube(a)
    -- Work with the absolute value to avoid issues with negative bases
    local absA = a < 0 and -a or a

    -- Compute the nearest integer cube root
    local c = math.floor(absA ^ (1/3) + 0.5)

    -- Check if the cube of that integer matches the original absolute value
    return c ^ 3 == absA
end
lu = require('luaunit')

function test_humaneval()
local candidate = iscube
    lu.assertEquals(candidate(1), true)
    lu.assertEquals(candidate(2), false)
    lu.assertEquals(candidate(-1), true)
    lu.assertEquals(candidate(64), true)
    lu.assertEquals(candidate(180), false)
    lu.assertEquals(candidate(1000), true)
    lu.assertEquals(candidate(0), true)
    lu.assertEquals(candidate(1729), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 78 (LUA) - HumanEval_78_hex_key
================================================================================

PROMPT:
----------------------------------------
-- You have been tasked to write a function that receives 
-- a hexadecimal number as a string and counts the number of hexadecimal 
-- digits that are primes (prime number, or a prime, is a natural number 
-- greater than 1 that is not a product of two smaller natural numbers).
-- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
-- Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
-- So you have to determine a number of the following digits: 2, 3, 5, 7, 
-- B (=decimal 11), D (=decimal 13).
-- Note: you may assume the input is always correct or empty string, 
-- and symbols A,B,C,D,E,F are always uppercase.
-- Examples:
-- >>> hex_key('AB')
-- 1
-- >>> hex_key('1077E')
-- 2
-- >>> hex_key('ABED1A33')
-- 4
-- >>> hex_key('123456789ABCDEF0')
-- 6
-- >>> hex_key('2020')
-- 2

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = hex_key
    lu.assertEquals(candidate('AB'), 1)
    lu.assertEquals(candidate('1077E'), 2)
    lu.assertEquals(candidate('ABED1A33'), 4)
    lu.assertEquals(candidate('2020'), 2)
    lu.assertEquals(candidate('123456789ABCDEF0'), 6)
    lu.assertEquals(candidate('112233445566778899AABBCCDDEEFF00'), 12)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You have been tasked to write a function that receives 
-- a hexadecimal number as a string and counts the number of hexadecimal 
-- digits that are primes (prime number, or a prime, is a natural number 
-- greater than 1 that is not a product of two smaller natural numbers).
-- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
-- Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
-- So you have to determine a number of the following digits: 2, 3, 5, 7, 
-- B (=decimal 11), D (=decimal 13).
-- Note: you may assume the input is always correct or empty string, 
-- and symbols A,B,C,D,E,F are always uppercase.
-- Examples:
-- >>> hex_key('AB')
-- 1
-- >>> hex_key('1077E')
-- 2
-- >>> hex_key('ABED1A33')
-- 4
-- >>> hex_key('123456789ABCDEF0')
-- 6
-- >>> hex_key('2020')
-- 2
-- Counts the number of prime hexadecimal digits in a string.
-- Prime hex digits: 2, 3, 5, 7, B (11), D (13)
local function hex_key(num)
    -- Set of prime hex digits for quick lookup
    local primes = {
        ['2'] = true,
        ['3'] = true,
        ['5'] = true,
        ['7'] = true,
        ['B'] = true,
        ['D'] = true
    }

    local count = 0
    for i = 1, #num do
        local c = num:sub(i, i)
        if primes[c] then
            count = count + 1
        end
    end
    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = hex_key
    lu.assertEquals(candidate('AB'), 1)
    lu.assertEquals(candidate('1077E'), 2)
    lu.assertEquals(candidate('ABED1A33'), 4)
    lu.assertEquals(candidate('2020'), 2)
    lu.assertEquals(candidate('123456789ABCDEF0'), 6)
    lu.assertEquals(candidate('112233445566778899AABBCCDDEEFF00'), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You have been tasked to write a function that receives 
-- a hexadecimal number as a string and counts the number of hexadecimal 
-- digits that are primes (prime number, or a prime, is a natural number 
-- greater than 1 that is not a product of two smaller natural numbers).
-- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
-- Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
-- So you have to determine a number of the following digits: 2, 3, 5, 7, 
-- B (=decimal 11), D (=decimal 13).
-- Note: you may assume the input is always correct or empty string, 
-- and symbols A,B,C,D,E,F are always uppercase.
-- Examples:
-- >>> hex_key('AB')
-- 1
-- >>> hex_key('1077E')
-- 2
-- >>> hex_key('ABED1A33')
-- 4
-- >>> hex_key('123456789ABCDEF0')
-- 6
-- >>> hex_key('2020')
-- 2
-- Count how many hexadecimal digits in the string are prime numbers
-- (2, 3, 5, 7, B (=11), D (=13)).
local function hex_key(num)
    -- Set of prime hexadecimal digits for quick lookup
    local prime_digits = {
        ['2'] = true,
        ['3'] = true,
        ['5'] = true,
        ['7'] = true,
        ['B'] = true,
        ['D'] = true
    }

    local count = 0
    -- Iterate over each character in the string
    for i = 1, #num do
        local c = num:sub(i, i)
        if prime_digits[c] then
            count = count + 1
        end
    end
    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = hex_key
    lu.assertEquals(candidate('AB'), 1)
    lu.assertEquals(candidate('1077E'), 2)
    lu.assertEquals(candidate('ABED1A33'), 4)
    lu.assertEquals(candidate('2020'), 2)
    lu.assertEquals(candidate('123456789ABCDEF0'), 6)
    lu.assertEquals(candidate('112233445566778899AABBCCDDEEFF00'), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You have been tasked to write a function that receives 
-- a hexadecimal number as a string and counts the number of hexadecimal 
-- digits that are primes (prime number, or a prime, is a natural number 
-- greater than 1 that is not a product of two smaller natural numbers).
-- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
-- Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
-- So you have to determine a number of the following digits: 2, 3, 5, 7, 
-- B (=decimal 11), D (=decimal 13).
-- Note: you may assume the input is always correct or empty string, 
-- and symbols A,B,C,D,E,F are always uppercase.
-- Examples:
-- >>> hex_key('AB')
-- 1
-- >>> hex_key('1077E')
-- 2
-- >>> hex_key('ABED1A33')
-- 4
-- >>> hex_key('123456789ABCDEF0')
-- 6
-- >>> hex_key('2020')
-- 2
local function hex_key(num)
    -- Table of hexadecimal digits that are prime numbers
    local prime_digits = {
        ['2'] = true,
        ['3'] = true,
        ['5'] = true,
        ['7'] = true,
        ['B'] = true,   -- 11 in decimal
        ['D'] = true    -- 13 in decimal
    }

    local count = 0
    -- Iterate over each character in the string
    for i = 1, #num do
        local c = num:sub(i, i)
        if prime_digits[c] then
            count = count + 1
        end
    end

    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = hex_key
    lu.assertEquals(candidate('AB'), 1)
    lu.assertEquals(candidate('1077E'), 2)
    lu.assertEquals(candidate('ABED1A33'), 4)
    lu.assertEquals(candidate('2020'), 2)
    lu.assertEquals(candidate('123456789ABCDEF0'), 6)
    lu.assertEquals(candidate('112233445566778899AABBCCDDEEFF00'), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You have been tasked to write a function that receives 
-- a hexadecimal number as a string and counts the number of hexadecimal 
-- digits that are primes (prime number, or a prime, is a natural number 
-- greater than 1 that is not a product of two smaller natural numbers).
-- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
-- Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
-- So you have to determine a number of the following digits: 2, 3, 5, 7, 
-- B (=decimal 11), D (=decimal 13).
-- Note: you may assume the input is always correct or empty string, 
-- and symbols A,B,C,D,E,F are always uppercase.
-- Examples:
-- >>> hex_key('AB')
-- 1
-- >>> hex_key('1077E')
-- 2
-- >>> hex_key('ABED1A33')
-- 4
-- >>> hex_key('123456789ABCDEF0')
-- 6
-- >>> hex_key('2020')
-- 2
-- Count how many hexadecimal digits in the string are prime numbers
-- (2, 3, 5, 7, B(11), D(13))
local function hex_key(num)
    -- Set of prime hex digits
    local prime_digits = {
        ['2'] = true,
        ['3'] = true,
        ['5'] = true,
        ['7'] = true,
        ['B'] = true,
        ['D'] = true
    }

    local count = 0
    for i = 1, #num do
        local c = num:sub(i, i)
        if prime_digits[c] then
            count = count + 1
        end
    end

    return count
end

-- Test examples
print(hex_key('AB'))          -- 1
print(hex_key('1077E'))       -- 2
print(hex_key('ABED1A33'))    -- 4
print(hex_key('123456789ABCDEF0')) -- 6
print(hex_key('2020'))        -- 2
lu = require('luaunit')

function test_humaneval()
local candidate = hex_key
    lu.assertEquals(candidate('AB'), 1)
    lu.assertEquals(candidate('1077E'), 2)
    lu.assertEquals(candidate('ABED1A33'), 4)
    lu.assertEquals(candidate('2020'), 2)
    lu.assertEquals(candidate('123456789ABCDEF0'), 6)
    lu.assertEquals(candidate('112233445566778899AABBCCDDEEFF00'), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
1
2
4
6
2
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 80 (LUA) - HumanEval_80_is_happy
================================================================================

PROMPT:
----------------------------------------
-- You are given a string s.
-- Your task is to check if the string is haplua or not.
-- A string is haplua if its length is at least 3 and every 3 consecutive letters are distinct
-- For example:
-- >>> is_happy('a')
-- false
-- >>> is_happy('aa')
-- false
-- >>> is_happy('abcd')
-- true
-- >>> is_happy('aabb')
-- false
-- >>> is_happy('adb')
-- true
-- >>> is_happy('xyy')
-- false

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = is_happy
    lu.assertEquals(candidate('a'), false)
    lu.assertEquals(candidate('aa'), false)
    lu.assertEquals(candidate('abcd'), true)
    lu.assertEquals(candidate('aabb'), false)
    lu.assertEquals(candidate('adb'), true)
    lu.assertEquals(candidate('xyy'), false)
    lu.assertEquals(candidate('iopaxpoi'), true)
    lu.assertEquals(candidate('iopaxioi'), false)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You are given a string s.
-- Your task is to check if the string is haplua or not.
-- A string is haplua if its length is at least 3 and every 3 consecutive letters are distinct
-- For example:
-- >>> is_happy('a')
-- false
-- >>> is_happy('aa')
-- false
-- >>> is_happy('abcd')
-- true
-- >>> is_happy('aabb')
-- false
-- >>> is_happy('adb')
-- true
-- >>> is_happy('xyy')
-- false
local function is_happy(s)
  if #s < 3 then
    return false
  end

  for i = 1, #s - 2 do
    local a = s:sub(i, i)
    local b = s:sub(i + 1, i + 1)
    local c = s:sub(i + 2, i + 2)

    if a == b or a == c or b == c then
      return false
    end
  end

  return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_happy
    lu.assertEquals(candidate('a'), false)
    lu.assertEquals(candidate('aa'), false)
    lu.assertEquals(candidate('abcd'), true)
    lu.assertEquals(candidate('aabb'), false)
    lu.assertEquals(candidate('adb'), true)
    lu.assertEquals(candidate('xyy'), false)
    lu.assertEquals(candidate('iopaxpoi'), true)
    lu.assertEquals(candidate('iopaxioi'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You are given a string s.
-- Your task is to check if the string is haplua or not.
-- A string is haplua if its length is at least 3 and every 3 consecutive letters are distinct
-- For example:
-- >>> is_happy('a')
-- false
-- >>> is_happy('aa')
-- false
-- >>> is_happy('abcd')
-- true
-- >>> is_happy('aabb')
-- false
-- >>> is_happy('adb')
-- true
-- >>> is_happy('xyy')
-- false
local function is_happy(s)
    -- A string must be at least length 3
    if #s < 3 then
        return false
    end

    -- Check every group of 3 consecutive characters
    for i = 1, #s - 2 do
        local a = s:sub(i, i)
        local b = s:sub(i + 1, i + 1)
        local c = s:sub(i + 2, i + 2)

        if a == b or a == c or b == c then
            return false
        end
    end

    return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_happy
    lu.assertEquals(candidate('a'), false)
    lu.assertEquals(candidate('aa'), false)
    lu.assertEquals(candidate('abcd'), true)
    lu.assertEquals(candidate('aabb'), false)
    lu.assertEquals(candidate('adb'), true)
    lu.assertEquals(candidate('xyy'), false)
    lu.assertEquals(candidate('iopaxpoi'), true)
    lu.assertEquals(candidate('iopaxioi'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You are given a string s.
-- Your task is to check if the string is haplua or not.
-- A string is haplua if its length is at least 3 and every 3 consecutive letters are distinct
-- For example:
-- >>> is_happy('a')
-- false
-- >>> is_happy('aa')
-- false
-- >>> is_happy('abcd')
-- true
-- >>> is_happy('aabb')
-- false
-- >>> is_happy('adb')
-- true
-- >>> is_happy('xyy')
-- false
local function is_happy(s)
    local len = #s
    if len < 3 then
        return false
    end

    for i = 1, len - 2 do
        local a = s:sub(i, i)
        local b = s:sub(i + 1, i + 1)
        local c = s:sub(i + 2, i + 2)

        if a == b or a == c or b == c then
            return false
        end
    end

    return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_happy
    lu.assertEquals(candidate('a'), false)
    lu.assertEquals(candidate('aa'), false)
    lu.assertEquals(candidate('abcd'), true)
    lu.assertEquals(candidate('aabb'), false)
    lu.assertEquals(candidate('adb'), true)
    lu.assertEquals(candidate('xyy'), false)
    lu.assertEquals(candidate('iopaxpoi'), true)
    lu.assertEquals(candidate('iopaxioi'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You are given a string s.
-- Your task is to check if the string is haplua or not.
-- A string is haplua if its length is at least 3 and every 3 consecutive letters are distinct
-- For example:
-- >>> is_happy('a')
-- false
-- >>> is_happy('aa')
-- false
-- >>> is_happy('abcd')
-- true
-- >>> is_happy('aabb')
-- false
-- >>> is_happy('adb')
-- true
-- >>> is_happy('xyy')
-- false
local function is_happy(s)
    if #s < 3 then
        return false
    end

    for i = 1, #s - 2 do
        local a = s:sub(i, i)
        local b = s:sub(i + 1, i + 1)
        local c = s:sub(i + 2, i + 2)

        if a == b or a == c or b == c then
            return false
        end
    end

    return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_happy
    lu.assertEquals(candidate('a'), false)
    lu.assertEquals(candidate('aa'), false)
    lu.assertEquals(candidate('abcd'), true)
    lu.assertEquals(candidate('aabb'), false)
    lu.assertEquals(candidate('adb'), true)
    lu.assertEquals(candidate('xyy'), false)
    lu.assertEquals(candidate('iopaxpoi'), true)
    lu.assertEquals(candidate('iopaxioi'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 81 (LUA) - HumanEval_81_numerical_letter_grade
================================================================================

PROMPT:
----------------------------------------
-- It is the last week of the semester and the teacher has to give the grades
-- to students. The teacher has been making her own algorithm for grading.
-- The only problem is, she has lost the code she used for grading.
-- She has given you a table of GPAs for some students and you have to write 
-- a function that can output a table of letter grades using the following table:
--          GPA       |    Letter grade
--           4.0                A+
--         > 3.7                A 
--         > 3.3                A- 
--         > 3.0                B+
--         > 2.7                B 
--         > 2.3                B-
--         > 2.0                C+
--         > 1.7                C
--         > 1.3                C-
--         > 1.0                D+ 
--         > 0.7                D 
--         > 0.0                D-
--           0.0                E
-- Example:
-- >>> grade_equation({4.0, 3, 1.7, 2, 3.5})
-- {'A+', 'B', 'C-', 'C', 'A-'}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = numerical_letter_grade
    lu.assertEquals(candidate({4.0, 3, 1.7, 2, 3.5}), {'A+', 'B', 'C-', 'C', 'A-'})
    lu.assertEquals(candidate({1.2}), {'D+'})
    lu.assertEquals(candidate({0.5}), {'D-'})
    lu.assertEquals(candidate({0.0}), {'E'})
    lu.assertEquals(candidate({1.0, 0.3, 1.5, 2.8, 3.3}), {'D', 'D-', 'C-', 'B', 'B+'})
    lu.assertEquals(candidate({0.0, 0.7}), {'E', 'D-'})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- It is the last week of the semester and the teacher has to give the grades
-- to students. The teacher has been making her own algorithm for grading.
-- The only problem is, she has lost the code she used for grading.
-- She has given you a table of GPAs for some students and you have to write 
-- a function that can output a table of letter grades using the following table:
--          GPA       |    Letter grade
--           4.0                A+
--         > 3.7                A 
--         > 3.3                A- 
--         > 3.0                B+
--         > 2.7                B 
--         > 2.3                B-
--         > 2.0                C+
--         > 1.7                C
--         > 1.3                C-
--         > 1.0                D+ 
--         > 0.7                D 
--         > 0.0                D-
--           0.0                E
-- Example:
-- >>> grade_equation({4.0, 3, 1.7, 2, 3.5})
-- {'A+', 'B', 'C-', 'C', 'A-'}
local function numerical_letter_grade(grades)
  local result = {}
  for _, g in ipairs(grades) do
    local letter
    if g == 4.0 then
      letter = "A+"
    elseif g > 3.7 then
      letter = "A"
    elseif g > 3.3 then
      letter = "A-"
    elseif g > 3.0 then
      letter = "B+"
    elseif g > 2.7 then
      letter = "B"
    elseif g > 2.3 then
      letter = "B-"
    elseif g > 2.0 then
      letter = "C+"
    elseif g > 1.7 then
      letter = "C"
    elseif g > 1.3 then
      letter = "C-"
    elseif g > 1.0 then
      letter = "D+"
    elseif g > 0.7 then
      letter = "D"
    elseif g > 0.0 then
      letter = "D-"
    else
      letter = "E"
    end
    table.insert(result, letter)
  end
  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = numerical_letter_grade
    lu.assertEquals(candidate({4.0, 3, 1.7, 2, 3.5}), {'A+', 'B', 'C-', 'C', 'A-'})
    lu.assertEquals(candidate({1.2}), {'D+'})
    lu.assertEquals(candidate({0.5}), {'D-'})
    lu.assertEquals(candidate({0.0}), {'E'})
    lu.assertEquals(candidate({1.0, 0.3, 1.5, 2.8, 3.3}), {'D', 'D-', 'C-', 'B', 'B+'})
    lu.assertEquals(candidate({0.0, 0.7}), {'E', 'D-'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- It is the last week of the semester and the teacher has to give the grades
-- to students. The teacher has been making her own algorithm for grading.
-- The only problem is, she has lost the code she used for grading.
-- She has given you a table of GPAs for some students and you have to write 
-- a function that can output a table of letter grades using the following table:
--          GPA       |    Letter grade
--           4.0                A+
--         > 3.7                A 
--         > 3.3                A- 
--         > 3.0                B+
--         > 2.7                B 
--         > 2.3                B-
--         > 2.0                C+
--         > 1.7                C
--         > 1.3                C-
--         > 1.0                D+ 
--         > 0.7                D 
--         > 0.0                D-
--           0.0                E
-- Example:
-- >>> grade_equation({4.0, 3, 1.7, 2, 3.5})
-- {'A+', 'B', 'C-', 'C', 'A-'}
local function numerical_letter_grade(grades)
    local result = {}
    for i, g in ipairs(grades) do
        local letter
        if g == 4.0 then
            letter = "A+"
        elseif g > 3.7 then
            letter = "A"
        elseif g > 3.3 then
            letter = "A-"
        elseif g > 3.0 then
            letter = "B+"
        elseif g > 2.7 then
            letter = "B"
        elseif g > 2.3 then
            letter = "B-"
        elseif g > 2.0 then
            letter = "C+"
        elseif g > 1.7 then
            letter = "C"
        elseif g > 1.3 then
            letter = "C-"
        elseif g > 1.0 then
            letter = "D+"
        elseif g > 0.7 then
            letter = "D"
        elseif g > 0.0 then
            letter = "D-"
        else
            letter = "E"
        end
        result[i] = letter
    end
    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = numerical_letter_grade
    lu.assertEquals(candidate({4.0, 3, 1.7, 2, 3.5}), {'A+', 'B', 'C-', 'C', 'A-'})
    lu.assertEquals(candidate({1.2}), {'D+'})
    lu.assertEquals(candidate({0.5}), {'D-'})
    lu.assertEquals(candidate({0.0}), {'E'})
    lu.assertEquals(candidate({1.0, 0.3, 1.5, 2.8, 3.3}), {'D', 'D-', 'C-', 'B', 'B+'})
    lu.assertEquals(candidate({0.0, 0.7}), {'E', 'D-'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- It is the last week of the semester and the teacher has to give the grades
-- to students. The teacher has been making her own algorithm for grading.
-- The only problem is, she has lost the code she used for grading.
-- She has given you a table of GPAs for some students and you have to write 
-- a function that can output a table of letter grades using the following table:
--          GPA       |    Letter grade
--           4.0                A+
--         > 3.7                A 
--         > 3.3                A- 
--         > 3.0                B+
--         > 2.7                B 
--         > 2.3                B-
--         > 2.0                C+
--         > 1.7                C
--         > 1.3                C-
--         > 1.0                D+ 
--         > 0.7                D 
--         > 0.0                D-
--           0.0                E
-- Example:
-- >>> grade_equation({4.0, 3, 1.7, 2, 3.5})
-- {'A+', 'B', 'C-', 'C', 'A-'}
-- Map a numeric GPA to a letter grade according to the specified rules.
-- @param grades table: a list of numeric GPAs (e.g., {4.0, 3, 1.7, 2, 3.5})
-- @return table: a list of corresponding letter grades in the same order
local function numerical_letter_grade(grades)
    local result = {}
    for i, g in ipairs(grades) do
        local letter
        if g == 4.0 then
            letter = "A+"
        elseif g > 3.7 then
            letter = "A"
        elseif g > 3.3 then
            letter = "A-"
        elseif g > 3.0 then
            letter = "B+"
        elseif g > 2.7 then
            letter = "B"
        elseif g > 2.3 then
            letter = "B-"
        elseif g > 2.0 then
            letter = "C+"
        elseif g > 1.7 then
            letter = "C"
        elseif g > 1.3 then
            letter = "C-"
        elseif g > 1.0 then
            letter = "D+"
        elseif g > 0.7 then
            letter = "D"
        elseif g > 0.0 then
            letter = "D-"
        else
            letter = "E"
        end
        result[i] = letter
    end
    return result
end

-- Example usage:
-- local grades = {4.0, 3, 1.7, 2, 3.5}
-- local letters = numerical_letter_grade(grades)
-- for _, l in ipairs(letters) do print(l) end
lu = require('luaunit')

function test_humaneval()
local candidate = numerical_letter_grade
    lu.assertEquals(candidate({4.0, 3, 1.7, 2, 3.5}), {'A+', 'B', 'C-', 'C', 'A-'})
    lu.assertEquals(candidate({1.2}), {'D+'})
    lu.assertEquals(candidate({0.5}), {'D-'})
    lu.assertEquals(candidate({0.0}), {'E'})
    lu.assertEquals(candidate({1.0, 0.3, 1.5, 2.8, 3.3}), {'D', 'D-', 'C-', 'B', 'B+'})
    lu.assertEquals(candidate({0.0, 0.7}), {'E', 'D-'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- It is the last week of the semester and the teacher has to give the grades
-- to students. The teacher has been making her own algorithm for grading.
-- The only problem is, she has lost the code she used for grading.
-- She has given you a table of GPAs for some students and you have to write 
-- a function that can output a table of letter grades using the following table:
--          GPA       |    Letter grade
--           4.0                A+
--         > 3.7                A 
--         > 3.3                A- 
--         > 3.0                B+
--         > 2.7                B 
--         > 2.3                B-
--         > 2.0                C+
--         > 1.7                C
--         > 1.3                C-
--         > 1.0                D+ 
--         > 0.7                D 
--         > 0.0                D-
--           0.0                E
-- Example:
-- >>> grade_equation({4.0, 3, 1.7, 2, 3.5})
-- {'A+', 'B', 'C-', 'C', 'A-'}
-- numerical_letter_grade: Convert an array of GPAs to letter grades.
-- @param grades table of numeric GPAs
-- @return table of letter grades in the same order
local function numerical_letter_grade(grades)
  local result = {}
  for i, g in ipairs(grades) do
    local letter
    if g == 4.0 then
      letter = 'A+'
    elseif g > 3.7 then
      letter = 'A'
    elseif g > 3.3 then
      letter = 'A-'
    elseif g > 3.0 then
      letter = 'B+'
    elseif g > 2.7 then
      letter = 'B'
    elseif g > 2.3 then
      letter = 'B-'
    elseif g > 2.0 then
      letter = 'C+'
    elseif g > 1.7 then
      letter = 'C'
    elseif g > 1.3 then
      letter = 'C-'
    elseif g > 1.0 then
      letter = 'D+'
    elseif g > 0.7 then
      letter = 'D'
    elseif g > 0.0 then
      letter = 'D-'
    else
      letter = 'E'
    end
    result[i] = letter
  end
  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = numerical_letter_grade
    lu.assertEquals(candidate({4.0, 3, 1.7, 2, 3.5}), {'A+', 'B', 'C-', 'C', 'A-'})
    lu.assertEquals(candidate({1.2}), {'D+'})
    lu.assertEquals(candidate({0.5}), {'D-'})
    lu.assertEquals(candidate({0.0}), {'E'})
    lu.assertEquals(candidate({1.0, 0.3, 1.5, 2.8, 3.3}), {'D', 'D-', 'C-', 'B', 'B+'})
    lu.assertEquals(candidate({0.0, 0.7}), {'E', 'D-'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 82 (LUA) - HumanEval_82_prime_length
================================================================================

PROMPT:
----------------------------------------
-- Write a function that takes a string and returns true if the string
-- length is a prime number or false otherwise
-- Examples
-- >>> prime_length('Hello')
-- true
-- >>> prime_length('abcdcba')
-- true
-- >>> prime_length('kittens')
-- true
-- >>> prime_length('orange')
-- false

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = prime_length
    lu.assertEquals(candidate('Hello'), true)
    lu.assertEquals(candidate('abcdcba'), true)
    lu.assertEquals(candidate('kittens'), true)
    lu.assertEquals(candidate('orange'), false)
    lu.assertEquals(candidate('wow'), true)
    lu.assertEquals(candidate('world'), true)
    lu.assertEquals(candidate('MadaM'), true)
    lu.assertEquals(candidate('Wow'), true)
    lu.assertEquals(candidate(''), false)
    lu.assertEquals(candidate('HI'), true)
    lu.assertEquals(candidate('go'), true)
    lu.assertEquals(candidate('gogo'), false)
    lu.assertEquals(candidate('aaaaaaaaaaaaaaa'), false)
    lu.assertEquals(candidate('Madam'), true)
    lu.assertEquals(candidate('M'), false)
    lu.assertEquals(candidate('0'), false)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Write a function that takes a string and returns true if the string
-- length is a prime number or false otherwise
-- Examples
-- >>> prime_length('Hello')
-- true
-- >>> prime_length('abcdcba')
-- true
-- >>> prime_length('kittens')
-- true
-- >>> prime_length('orange')
-- false
-- Return true if the length of the string is a prime number, false otherwise
local function prime_length(string)
  local len = #string
  if len < 2 then
    return false
  end
  local limit = math.floor(math.sqrt(len))
  for i = 2, limit do
    if len % i == 0 then
      return false
    end
  end
  return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = prime_length
    lu.assertEquals(candidate('Hello'), true)
    lu.assertEquals(candidate('abcdcba'), true)
    lu.assertEquals(candidate('kittens'), true)
    lu.assertEquals(candidate('orange'), false)
    lu.assertEquals(candidate('wow'), true)
    lu.assertEquals(candidate('world'), true)
    lu.assertEquals(candidate('MadaM'), true)
    lu.assertEquals(candidate('Wow'), true)
    lu.assertEquals(candidate(''), false)
    lu.assertEquals(candidate('HI'), true)
    lu.assertEquals(candidate('go'), true)
    lu.assertEquals(candidate('gogo'), false)
    lu.assertEquals(candidate('aaaaaaaaaaaaaaa'), false)
    lu.assertEquals(candidate('Madam'), true)
    lu.assertEquals(candidate('M'), false)
    lu.assertEquals(candidate('0'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Write a function that takes a string and returns true if the string
-- length is a prime number or false otherwise
-- Examples
-- >>> prime_length('Hello')
-- true
-- >>> prime_length('abcdcba')
-- true
-- >>> prime_length('kittens')
-- true
-- >>> prime_length('orange')
-- false
local function prime_length(string)
    local n = #string
    if n <= 1 then return false end          -- 0 or 1 are not prime
    if n == 2 then return true end           -- 2 is prime
    if n % 2 == 0 then return false end      -- even numbers > 2 are not prime

    local limit = math.floor(math.sqrt(n))
    for i = 3, limit, 2 do
        if n % i == 0 then
            return false
        end
    end
    return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = prime_length
    lu.assertEquals(candidate('Hello'), true)
    lu.assertEquals(candidate('abcdcba'), true)
    lu.assertEquals(candidate('kittens'), true)
    lu.assertEquals(candidate('orange'), false)
    lu.assertEquals(candidate('wow'), true)
    lu.assertEquals(candidate('world'), true)
    lu.assertEquals(candidate('MadaM'), true)
    lu.assertEquals(candidate('Wow'), true)
    lu.assertEquals(candidate(''), false)
    lu.assertEquals(candidate('HI'), true)
    lu.assertEquals(candidate('go'), true)
    lu.assertEquals(candidate('gogo'), false)
    lu.assertEquals(candidate('aaaaaaaaaaaaaaa'), false)
    lu.assertEquals(candidate('Madam'), true)
    lu.assertEquals(candidate('M'), false)
    lu.assertEquals(candidate('0'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Write a function that takes a string and returns true if the string
-- length is a prime number or false otherwise
-- Examples
-- >>> prime_length('Hello')
-- true
-- >>> prime_length('abcdcba')
-- true
-- >>> prime_length('kittens')
-- true
-- >>> prime_length('orange')
-- false
local function prime_length(string)
    local len = #string
    if len < 2 then
        return false
    end

    local limit = math.floor(math.sqrt(len))
    for i = 2, limit do
        if len % i == 0 then
            return false
        end
    end

    return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = prime_length
    lu.assertEquals(candidate('Hello'), true)
    lu.assertEquals(candidate('abcdcba'), true)
    lu.assertEquals(candidate('kittens'), true)
    lu.assertEquals(candidate('orange'), false)
    lu.assertEquals(candidate('wow'), true)
    lu.assertEquals(candidate('world'), true)
    lu.assertEquals(candidate('MadaM'), true)
    lu.assertEquals(candidate('Wow'), true)
    lu.assertEquals(candidate(''), false)
    lu.assertEquals(candidate('HI'), true)
    lu.assertEquals(candidate('go'), true)
    lu.assertEquals(candidate('gogo'), false)
    lu.assertEquals(candidate('aaaaaaaaaaaaaaa'), false)
    lu.assertEquals(candidate('Madam'), true)
    lu.assertEquals(candidate('M'), false)
    lu.assertEquals(candidate('0'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Write a function that takes a string and returns true if the string
-- length is a prime number or false otherwise
-- Examples
-- >>> prime_length('Hello')
-- true
-- >>> prime_length('abcdcba')
-- true
-- >>> prime_length('kittens')
-- true
-- >>> prime_length('orange')
-- false
-- Write a function that takes a string and returns true if the string
-- length is a prime number or false otherwise
-- Examples
-- >>> prime_length('Hello')
-- true
-- >>> prime_length('abcdcba')
-- true
-- >>> prime_length('kittens')
-- true
-- >>> prime_length('orange')
-- false
local function prime_length(str)
    -- Get the length of the string
    local len = #str

    -- A prime number must be greater than 1
    if len < 2 then
        return false
    end

    -- Check divisibility from 2 up to the square root of len
    local sqrt = math.floor(math.sqrt(len))
    for i = 2, sqrt do
        if len % i == 0 then
            return false
        end
    end

    return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = prime_length
    lu.assertEquals(candidate('Hello'), true)
    lu.assertEquals(candidate('abcdcba'), true)
    lu.assertEquals(candidate('kittens'), true)
    lu.assertEquals(candidate('orange'), false)
    lu.assertEquals(candidate('wow'), true)
    lu.assertEquals(candidate('world'), true)
    lu.assertEquals(candidate('MadaM'), true)
    lu.assertEquals(candidate('Wow'), true)
    lu.assertEquals(candidate(''), false)
    lu.assertEquals(candidate('HI'), true)
    lu.assertEquals(candidate('go'), true)
    lu.assertEquals(candidate('gogo'), false)
    lu.assertEquals(candidate('aaaaaaaaaaaaaaa'), false)
    lu.assertEquals(candidate('Madam'), true)
    lu.assertEquals(candidate('M'), false)
    lu.assertEquals(candidate('0'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 83 (LUA) - HumanEval_83_starts_one_ends
================================================================================

PROMPT:
----------------------------------------
-- Given a positive integer n, return the count of the numbers of n-digit
-- positive integers that start or end with 1.

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = starts_one_ends
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(2), 18)
    lu.assertEquals(candidate(3), 180)
    lu.assertEquals(candidate(4), 1800)
    lu.assertEquals(candidate(5), 18000)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a positive integer n, return the count of the numbers of n-digit
-- positive integers that start or end with 1.
-- Count of n‑digit positive integers that start or end with 1
local function starts_one_ends(n)
    if n == 1 then
        return 1
    else
        return 18 * 10^(n-2)
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = starts_one_ends
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(2), 18)
    lu.assertEquals(candidate(3), 180)
    lu.assertEquals(candidate(4), 1800)
    lu.assertEquals(candidate(5), 18000)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a positive integer n, return the count of the numbers of n-digit
-- positive integers that start or end with 1.
-- Count n‑digit positive integers that start or end with 1
local function starts_one_ends(n)
    -- n must be a positive integer
    if n <= 0 then return 0 end

    -- For a single‑digit number the only candidate is 1 itself
    if n == 1 then return 1 end

    -- Numbers that start with 1: 1 followed by any (n‑1) digits
    local start_with_one = 10 ^ (n - 1)

    -- Numbers that end with 1:
    -- first digit 1‑9 (9 choices), middle (n‑2) digits any 0‑9
    local end_with_one = 9 * (10 ^ (n - 2))

    -- Subtract overlap (numbers that both start and end with 1)
    local overlap = 10 ^ (n - 2)

    return start_with_one + end_with_one - overlap
end
lu = require('luaunit')

function test_humaneval()
local candidate = starts_one_ends
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(2), 18)
    lu.assertEquals(candidate(3), 180)
    lu.assertEquals(candidate(4), 1800)
    lu.assertEquals(candidate(5), 18000)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a positive integer n, return the count of the numbers of n-digit
-- positive integers that start or end with 1.
-- Count the n‑digit positive integers that start or end with 1
local function starts_one_ends(n)
  if n == 1 then
    -- Only the number 1 satisfies the condition
    return 1
  end
  -- For n ≥ 2:
  --   start‑with‑1 numbers: 10^(n-1)
  --   end‑with‑1 numbers:   9 * 10^(n-2)
  --   overlap (start & end with 1): 10^(n-2)
  --   total = 10^(n-1) + 9*10^(n-2) - 10^(n-2) = 18 * 10^(n-2)
  local pow10 = 10^(n - 2)
  return 18 * pow10
end
lu = require('luaunit')

function test_humaneval()
local candidate = starts_one_ends
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(2), 18)
    lu.assertEquals(candidate(3), 180)
    lu.assertEquals(candidate(4), 1800)
    lu.assertEquals(candidate(5), 18000)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a positive integer n, return the count of the numbers of n-digit
-- positive integers that start or end with 1.
-- Given a positive integer n, return the count of the numbers of n-digit
-- positive integers that start or end with 1.
local function starts_one_ends(n)
    -- For a single‑digit number the only candidate is 1 itself.
    if n == 1 then
        return 1
    end

    -- For n ≥ 2:
    --   * 10^(n-1) numbers start with 1,
    --   * 9·10^(n-2) numbers end with 1,
    --   * 10^(n-2) numbers start and end with 1 (double‑counted).
    --   Total = 10^(n-1) + 9·10^(n-2) – 10^(n-2) = 18·10^(n-2).
    return 18 * 10 ^ (n - 2)
end
lu = require('luaunit')

function test_humaneval()
local candidate = starts_one_ends
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(2), 18)
    lu.assertEquals(candidate(3), 180)
    lu.assertEquals(candidate(4), 1800)
    lu.assertEquals(candidate(5), 18000)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 84 (LUA) - HumanEval_84_solve
================================================================================

PROMPT:
----------------------------------------
-- Given a positive integer N, return the total sum of its digits in binary.
-- Example
-- >>> solve(1000)
-- '1'
-- >>> solve(150)
-- '110'
-- >>> solve(147)
-- '1100'
-- Variables:
--     @N integer
--          Constraints: 0 ≤ N ≤ 10000.
-- Output:
--      a string of binary number

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = solve
    lu.assertEquals(candidate(1000), '1')
    lu.assertEquals(candidate(150), '110')
    lu.assertEquals(candidate(147), '1100')
    lu.assertEquals(candidate(333), '1001')
    lu.assertEquals(candidate(963), '10010')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a positive integer N, return the total sum of its digits in binary.
-- Example
-- >>> solve(1000)
-- '1'
-- >>> solve(150)
-- '110'
-- >>> solve(147)
-- '1100'
-- Variables:
--     @N integer
--          Constraints: 0 ≤ N ≤ 10000.
-- Output:
--      a string of binary number
local function solve(N)
    -- Compute the sum of decimal digits of N
    local sum = 0
    local num = N
    while num > 0 do
        sum = sum + (num % 10)
        num = math.floor(num / 10)
    end

    -- Convert the sum to a binary string
    if sum == 0 then
        return "0"
    end

    local bits = ""
    while sum > 0 do
        bits = (sum % 2 == 1 and "1" or "0") .. bits
        sum = math.floor(sum / 2)
    end

    return bits
end
lu = require('luaunit')

function test_humaneval()
local candidate = solve
    lu.assertEquals(candidate(1000), '1')
    lu.assertEquals(candidate(150), '110')
    lu.assertEquals(candidate(147), '1100')
    lu.assertEquals(candidate(333), '1001')
    lu.assertEquals(candidate(963), '10010')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a positive integer N, return the total sum of its digits in binary.
-- Example
-- >>> solve(1000)
-- '1'
-- >>> solve(150)
-- '110'
-- >>> solve(147)
-- '1100'
-- Variables:
--     @N integer
--          Constraints: 0 ≤ N ≤ 10000.
-- Output:
--      a string of binary number
-- Sum the decimal digits of N and return that sum written in binary
local function solve(N)
    -- Step 1: sum the decimal digits
    local sum = 0
    for digit in tostring(N):gmatch("%d") do
        sum = sum + tonumber(digit)
    end

    -- Step 2: convert the sum to binary
    if sum == 0 then
        return "0"
    end

    local bits = {}
    while sum > 0 do
        table.insert(bits, 1, tostring(sum % 2))
        sum = math.floor(sum / 2)
    end

    return table.concat(bits)
end
lu = require('luaunit')

function test_humaneval()
local candidate = solve
    lu.assertEquals(candidate(1000), '1')
    lu.assertEquals(candidate(150), '110')
    lu.assertEquals(candidate(147), '1100')
    lu.assertEquals(candidate(333), '1001')
    lu.assertEquals(candidate(963), '10010')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a positive integer N, return the total sum of its digits in binary.
-- Example
-- >>> solve(1000)
-- '1'
-- >>> solve(150)
-- '110'
-- >>> solve(147)
-- '1100'
-- Variables:
--     @N integer
--          Constraints: 0 ≤ N ≤ 10000.
-- Output:
--      a string of binary number
-- Calculate the sum of the decimal digits of N
-- then return that sum expressed as a binary string.
local function solve(N)
    -- Sum the decimal digits
    local sum = 0
    local temp = N
    while temp > 0 do
        sum = sum + (temp % 10)
        temp = math.floor(temp / 10)
    end

    -- Special case: when N is 0, the sum is 0
    if sum == 0 then
        return "0"
    end

    -- Convert the sum to binary
    local bits = ""
    while sum > 0 do
        bits = tostring(sum % 2) .. bits
        sum = math.floor(sum / 2)
    end

    return bits
end
lu = require('luaunit')

function test_humaneval()
local candidate = solve
    lu.assertEquals(candidate(1000), '1')
    lu.assertEquals(candidate(150), '110')
    lu.assertEquals(candidate(147), '1100')
    lu.assertEquals(candidate(333), '1001')
    lu.assertEquals(candidate(963), '10010')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a positive integer N, return the total sum of its digits in binary.
-- Example
-- >>> solve(1000)
-- '1'
-- >>> solve(150)
-- '110'
-- >>> solve(147)
-- '1100'
-- Variables:
--     @N integer
--          Constraints: 0 ≤ N ≤ 10000.
-- Output:
--      a string of binary number
-- Sum the decimal digits of N, then return that sum in binary as a string.
-- Handles the case N = 0 correctly.
local function solve(N)
    -- Step 1: compute the sum of decimal digits.
    local sum = 0
    local temp = N
    while temp > 0 do
        sum = sum + (temp % 10)
        temp = math.floor(temp / 10)
    end

    -- Step 2: convert the sum to binary.
    if sum == 0 then
        return "0"
    end

    local binary = ""
    while sum > 0 do
        binary = tostring(sum % 2) .. binary
        sum = math.floor(sum / 2)
    end

    return binary
end

-- Example usage:
print(solve(1000))  -- Output: "1"
print(solve(150))   -- Output: "110"
print(solve(147))   -- Output: "1100"
lu = require('luaunit')

function test_humaneval()
local candidate = solve
    lu.assertEquals(candidate(1000), '1')
    lu.assertEquals(candidate(150), '110')
    lu.assertEquals(candidate(147), '1100')
    lu.assertEquals(candidate(333), '1001')
    lu.assertEquals(candidate(963), '10010')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154473
STDOUT:
1
110
1100
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------
