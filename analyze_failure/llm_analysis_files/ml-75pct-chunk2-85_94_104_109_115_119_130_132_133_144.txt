As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 85 (ML) - HumanEval_85_add
================================================================================

PROMPT:
----------------------------------------
(**Given a non-empty list of integers lst. add the even elements that are at odd indices..
 * Examples:
 * >>> add [4; 2; 6; 7]
 * 2
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = add in
  (assert ((candidate [4; 88]) = 88));
  (assert ((candidate [4; 5; 6; 7; 2; 122]) = 122));
  (assert ((candidate [4; 0; 6; 7]) = 0));
  (assert ((candidate [4; 4; 6; 8]) = 12));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given a non-empty list of integers lst. add the even elements that are at odd indices..
 * Examples:
 * >>> add [4; 2; 6; 7]
 * 2
*)
let add (lst : int list) : int =
  let rec aux l idx acc =
    match l with
    | [] -> acc
    | h :: t ->
        let acc' =
          if idx mod 2 = 1 && h mod 2 = 0 then acc + h else acc
        in
        aux t (idx + 1) acc'
  in
  aux lst 0 0

let assertions =
 let candidate = add in
  (assert ((candidate [4; 88]) = 88));
  (assert ((candidate [4; 5; 6; 7; 2; 122]) = 122));
  (assert ((candidate [4; 0; 6; 7]) = 0));
  (assert ((candidate [4; 4; 6; 8]) = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given a non-empty list of integers lst. add the even elements that are at odd indices..
 * Examples:
 * >>> add [4; 2; 6; 7]
 * 2
*)
let add (lst : int list) : int =
    lst
    |> List.mapi (fun idx x -> if idx % 2 = 1 && x % 2 = 0 then x else 0)
    |> List.sum

let assertions =
 let candidate = add in
  (assert ((candidate [4; 88]) = 88));
  (assert ((candidate [4; 5; 6; 7; 2; 122]) = 122));
  (assert ((candidate [4; 0; 6; 7]) = 0));
  (assert ((candidate [4; 4; 6; 8]) = 12));
  ()


EXECUTION RESULTS:
Exit Code: 2
Status: Exception
Timestamp: 1755183720
STDOUT: (empty)
STDERR:
File "/tmp/tmps7e974d7.ml", line 9, characters 7-15:
9 |     |> List.sum
           ^^^^^^^^
Error: Unbound value List.sum
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given a non-empty list of integers lst. add the even elements that are at odd indices..
 * Examples:
 * >>> add [4; 2; 6; 7]
 * 2
*)
let add (lst : int list) : int =
  let rec aux l idx acc =
    match l with
    | [] -> acc
    | x :: xs ->
        let acc' = if idx mod 2 = 1 && x mod 2 = 0 then acc + x else acc in
        aux xs (idx + 1) acc'
  in
  aux lst 0 0

let assertions =
 let candidate = add in
  (assert ((candidate [4; 88]) = 88));
  (assert ((candidate [4; 5; 6; 7; 2; 122]) = 122));
  (assert ((candidate [4; 0; 6; 7]) = 0));
  (assert ((candidate [4; 4; 6; 8]) = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given a non-empty list of integers lst. add the even elements that are at odd indices..
 * Examples:
 * >>> add [4; 2; 6; 7]
 * 2
*)
(* Sum all even elements that are located at odd indices (0‑based). *)
let add (lst : int list) : int =
  let rec aux l idx acc =
    match l with
    | [] -> acc
    | x :: xs ->
        let acc' =
          if idx mod 2 = 1 && x mod 2 = 0 then acc + x else acc
        in
        aux xs (idx + 1) acc'
  in
  aux lst 0 0

let assertions =
 let candidate = add in
  (assert ((candidate [4; 88]) = 88));
  (assert ((candidate [4; 5; 6; 7; 2; 122]) = 122));
  (assert ((candidate [4; 0; 6; 7]) = 0));
  (assert ((candidate [4; 4; 6; 8]) = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 94 (ML) - HumanEval_94_skjkasdkd
================================================================================

PROMPT:
----------------------------------------
(**You are given a list of integers.
 * You need to find the largest prime value and return the sum of its digits.
 * Examples:
 * >>> skjkasdkd [0; 3; 2; 1; 3; 5; 7; 4; 5; 5; 5; 2; 181; 32; 4; 32; 3; 2; 32; 324; 4; 3]
 * 10
 * >>> skjkasdkd [1; 0; 1; 8; 2; 4597; 2; 1; 3; 40; 1; 2; 1; 2; 4; 2; 5; 1]
 * 25
 * >>> skjkasdkd [1; 3; 1; 32; 5107; 34; 83278; 109; 163; 23; 2323; 32; 30; 1; 9; 3]
 * 13
 * >>> skjkasdkd [0; 724; 32; 71; 99; 32; 6; 0; 5; 91; 83; 0; 5; 6]
 * 11
 * >>> skjkasdkd [0; 81; 12; 3; 1; 21]
 * 3
 * >>> skjkasdkd [0; 8; 1; 2; 1; 7]
 * 7
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = skjkasdkd in
  (assert ((candidate [0; 3; 2; 1; 3; 5; 7; 4; 5; 5; 5; 2; 181; 32; 4; 32; 3; 2; 32; 324; 4; 3]) = 10));
  (assert ((candidate [1; 0; 1; 8; 2; 4597; 2; 1; 3; 40; 1; 2; 1; 2; 4; 2; 5; 1]) = 25));
  (assert ((candidate [1; 3; 1; 32; 5107; 34; 83278; 109; 163; 23; 2323; 32; 30; 1; 9; 3]) = 13));
  (assert ((candidate [0; 724; 32; 71; 99; 32; 6; 0; 5; 91; 83; 0; 5; 6]) = 11));
  (assert ((candidate [0; 81; 12; 3; 1; 21]) = 3));
  (assert ((candidate [0; 8; 1; 2; 1; 7]) = 7));
  (assert ((candidate [8191]) = 19));
  (assert ((candidate [8191; 123456; 127; 7]) = 19));
  (assert ((candidate [127; 97; 8192]) = 10));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**You are given a list of integers.
 * You need to find the largest prime value and return the sum of its digits.
 * Examples:
 * >>> skjkasdkd [0; 3; 2; 1; 3; 5; 7; 4; 5; 5; 5; 2; 181; 32; 4; 32; 3; 2; 32; 324; 4; 3]
 * 10
 * >>> skjkasdkd [1; 0; 1; 8; 2; 4597; 2; 1; 3; 40; 1; 2; 1; 2; 4; 2; 5; 1]
 * 25
 * >>> skjkasdkd [1; 3; 1; 32; 5107; 34; 83278; 109; 163; 23; 2323; 32; 30; 1; 9; 3]
 * 13
 * >>> skjkasdkd [0; 724; 32; 71; 99; 32; 6; 0; 5; 91; 83; 0; 5; 6]
 * 11
 * >>> skjkasdkd [0; 81; 12; 3; 1; 21]
 * 3
 * >>> skjkasdkd [0; 8; 1; 2; 1; 7]
 * 7
*)
let skjkasdkd (lst : int list) : int =
    // Helper: check whether an integer is prime
    let isPrime (n:int) : bool =
        if n <= 1 then false
        elif n = 2 then true
        elif n % 2 = 0 then false
        else
            let rec loop d =
                if d * d > n then true
                elif n % d = 0 then false
                else loop (d + 2)
            loop 3

    // Helper: sum the decimal digits of a non‑negative integer
    let sumDigits (n:int) : int =
        let rec loop x acc =
            if x = 0 then acc
            else loop (x / 10) (acc + (x % 10))
        loop n 0

    // Find the largest prime in the list
    let primes = List.filter isPrime lst
    match List.sort primes with
    | [] -> 0   // no prime found
    | sorted -> sumDigits (List.last sorted)

let assertions =
 let candidate = skjkasdkd in
  (assert ((candidate [0; 3; 2; 1; 3; 5; 7; 4; 5; 5; 5; 2; 181; 32; 4; 32; 3; 2; 32; 324; 4; 3]) = 10));
  (assert ((candidate [1; 0; 1; 8; 2; 4597; 2; 1; 3; 40; 1; 2; 1; 2; 4; 2; 5; 1]) = 25));
  (assert ((candidate [1; 3; 1; 32; 5107; 34; 83278; 109; 163; 23; 2323; 32; 30; 1; 9; 3]) = 13));
  (assert ((candidate [0; 724; 32; 71; 99; 32; 6; 0; 5; 91; 83; 0; 5; 6]) = 11));
  (assert ((candidate [0; 81; 12; 3; 1; 21]) = 3));
  (assert ((candidate [0; 8; 1; 2; 1; 7]) = 7));
  (assert ((candidate [8191]) = 19));
  (assert ((candidate [8191; 123456; 127; 7]) = 19));
  (assert ((candidate [127; 97; 8192]) = 10));
  ()


EXECUTION RESULTS:
Exit Code: 2
Status: SyntaxError
Timestamp: 1755183721
STDOUT: (empty)
STDERR:
File "/tmp/tmpeczu7c8w.ml", line 18, characters 4-6:
18 |     // Helper: check whether an integer is prime
         ^^
Error: Syntax error
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**You are given a list of integers.
 * You need to find the largest prime value and return the sum of its digits.
 * Examples:
 * >>> skjkasdkd [0; 3; 2; 1; 3; 5; 7; 4; 5; 5; 5; 2; 181; 32; 4; 32; 3; 2; 32; 324; 4; 3]
 * 10
 * >>> skjkasdkd [1; 0; 1; 8; 2; 4597; 2; 1; 3; 40; 1; 2; 1; 2; 4; 2; 5; 1]
 * 25
 * >>> skjkasdkd [1; 3; 1; 32; 5107; 34; 83278; 109; 163; 23; 2323; 32; 30; 1; 9; 3]
 * 13
 * >>> skjkasdkd [0; 724; 32; 71; 99; 32; 6; 0; 5; 91; 83; 0; 5; 6]
 * 11
 * >>> skjkasdkd [0; 81; 12; 3; 1; 21]
 * 3
 * >>> skjkasdkd [0; 8; 1; 2; 1; 7]
 * 7
*)
(* Find the largest prime number in the list and return the sum of its digits. *)
let skjkasdkd (lst : int list) : int =
  (* Helper: test if an integer is prime *)
  let is_prime n =
    if n <= 1 then false
    else if n = 2 then true
    else if n mod 2 = 0 then false
    else
      let rec aux d =
        d * d > n || (n mod d <> 0 && aux (d + 2))
      in
      aux 3
  in

  (* Helper: sum the decimal digits of an integer *)
  let rec sum_digits n =
    if n = 0 then 0 else (n mod 10) + sum_digits (n / 10)
  in

  (* Find the largest prime in the list *)
  let rec find_max_prime l current_max =
    match l with
    | [] -> current_max
    | h :: t ->
        if is_prime h then
          let new_max = if h > current_max then h else current_max in
          find_max_prime t new_max
        else
          find_max_prime t current_max
  in

  let max_prime = find_max_prime lst (-1) in
  (* If no prime was found, return 0 (though the problem guarantees at least one prime) *)
  if max_prime = -1 then 0 else sum_digits max_prime

let assertions =
 let candidate = skjkasdkd in
  (assert ((candidate [0; 3; 2; 1; 3; 5; 7; 4; 5; 5; 5; 2; 181; 32; 4; 32; 3; 2; 32; 324; 4; 3]) = 10));
  (assert ((candidate [1; 0; 1; 8; 2; 4597; 2; 1; 3; 40; 1; 2; 1; 2; 4; 2; 5; 1]) = 25));
  (assert ((candidate [1; 3; 1; 32; 5107; 34; 83278; 109; 163; 23; 2323; 32; 30; 1; 9; 3]) = 13));
  (assert ((candidate [0; 724; 32; 71; 99; 32; 6; 0; 5; 91; 83; 0; 5; 6]) = 11));
  (assert ((candidate [0; 81; 12; 3; 1; 21]) = 3));
  (assert ((candidate [0; 8; 1; 2; 1; 7]) = 7));
  (assert ((candidate [8191]) = 19));
  (assert ((candidate [8191; 123456; 127; 7]) = 19));
  (assert ((candidate [127; 97; 8192]) = 10));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183721
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**You are given a list of integers.
 * You need to find the largest prime value and return the sum of its digits.
 * Examples:
 * >>> skjkasdkd [0; 3; 2; 1; 3; 5; 7; 4; 5; 5; 5; 2; 181; 32; 4; 32; 3; 2; 32; 324; 4; 3]
 * 10
 * >>> skjkasdkd [1; 0; 1; 8; 2; 4597; 2; 1; 3; 40; 1; 2; 1; 2; 4; 2; 5; 1]
 * 25
 * >>> skjkasdkd [1; 3; 1; 32; 5107; 34; 83278; 109; 163; 23; 2323; 32; 30; 1; 9; 3]
 * 13
 * >>> skjkasdkd [0; 724; 32; 71; 99; 32; 6; 0; 5; 91; 83; 0; 5; 6]
 * 11
 * >>> skjkasdkd [0; 81; 12; 3; 1; 21]
 * 3
 * >>> skjkasdkd [0; 8; 1; 2; 1; 7]
 * 7
*)
(* Find the largest prime in a list and return the sum of its digits *)
let skjkasdkd (lst : int list) : int =
  (* Helper: check if a number is prime *)
  let is_prime n =
    if n <= 1 then false
    else if n = 2 then true
    else if n mod 2 = 0 then false
    else
      let rec aux d =
        if d * d > n then true
        else if n mod d = 0 then false
        else aux (d + 2)
      in
      aux 3
  in

  (* Find the maximum prime in the list *)
  let max_prime =
    List.fold_left
      (fun acc x ->
        if is_prime x then
          if x > acc then x else acc
        else acc)
      (-1) (* start with -1 to indicate no prime found yet *)
      lst
  in

  (* If no prime was found, return 0 (or any default you prefer) *)
  if max_prime = -1 then 0
  else
    (* Sum the digits of the maximum prime *)
    let rec sum_digits n acc =
      if n = 0 then acc
      else sum_digits (n / 10) (acc + (n mod 10))
    in
    sum_digits max_prime 0

let assertions =
 let candidate = skjkasdkd in
  (assert ((candidate [0; 3; 2; 1; 3; 5; 7; 4; 5; 5; 5; 2; 181; 32; 4; 32; 3; 2; 32; 324; 4; 3]) = 10));
  (assert ((candidate [1; 0; 1; 8; 2; 4597; 2; 1; 3; 40; 1; 2; 1; 2; 4; 2; 5; 1]) = 25));
  (assert ((candidate [1; 3; 1; 32; 5107; 34; 83278; 109; 163; 23; 2323; 32; 30; 1; 9; 3]) = 13));
  (assert ((candidate [0; 724; 32; 71; 99; 32; 6; 0; 5; 91; 83; 0; 5; 6]) = 11));
  (assert ((candidate [0; 81; 12; 3; 1; 21]) = 3));
  (assert ((candidate [0; 8; 1; 2; 1; 7]) = 7));
  (assert ((candidate [8191]) = 19));
  (assert ((candidate [8191; 123456; 127; 7]) = 19));
  (assert ((candidate [127; 97; 8192]) = 10));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183721
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**You are given a list of integers.
 * You need to find the largest prime value and return the sum of its digits.
 * Examples:
 * >>> skjkasdkd [0; 3; 2; 1; 3; 5; 7; 4; 5; 5; 5; 2; 181; 32; 4; 32; 3; 2; 32; 324; 4; 3]
 * 10
 * >>> skjkasdkd [1; 0; 1; 8; 2; 4597; 2; 1; 3; 40; 1; 2; 1; 2; 4; 2; 5; 1]
 * 25
 * >>> skjkasdkd [1; 3; 1; 32; 5107; 34; 83278; 109; 163; 23; 2323; 32; 30; 1; 9; 3]
 * 13
 * >>> skjkasdkd [0; 724; 32; 71; 99; 32; 6; 0; 5; 91; 83; 0; 5; 6]
 * 11
 * >>> skjkasdkd [0; 81; 12; 3; 1; 21]
 * 3
 * >>> skjkasdkd [0; 8; 1; 2; 1; 7]
 * 7
*)
(* Find the largest prime in the list and return the sum of its digits. *)
let skjkasdkd (lst : int list) : int =
  (* Check if a number is prime.  Negative numbers, 0 and 1 are not prime. *)
  let is_prime n =
    if n <= 1 then false
    else if n <= 3 then true
    else if n mod 2 = 0 || n mod 3 = 0 then false
    else
      let rec loop i =
        if i * i > n then true
        else if n mod i = 0 || n mod (i + 2) = 0 then false
        else loop (i + 6)
      in
      loop 5
  in

  (* Find the maximum prime in the list.  If there is none, return None. *)
  let max_prime =
    List.fold_left
      (fun acc x ->
        if is_prime x then
          match acc with
          | None -> Some x
          | Some y -> if x > y then Some x else acc
        else acc)
      None
      lst
  in

  (* Sum the decimal digits of a non‑negative integer. *)
  let rec sum_digits n =
    if n = 0 then 0 else (n mod 10) + sum_digits (n / 10)
  in

  match max_prime with
  | None -> 0  (* No prime found – return 0. *)
  | Some p -> sum_digits p

let assertions =
 let candidate = skjkasdkd in
  (assert ((candidate [0; 3; 2; 1; 3; 5; 7; 4; 5; 5; 5; 2; 181; 32; 4; 32; 3; 2; 32; 324; 4; 3]) = 10));
  (assert ((candidate [1; 0; 1; 8; 2; 4597; 2; 1; 3; 40; 1; 2; 1; 2; 4; 2; 5; 1]) = 25));
  (assert ((candidate [1; 3; 1; 32; 5107; 34; 83278; 109; 163; 23; 2323; 32; 30; 1; 9; 3]) = 13));
  (assert ((candidate [0; 724; 32; 71; 99; 32; 6; 0; 5; 91; 83; 0; 5; 6]) = 11));
  (assert ((candidate [0; 81; 12; 3; 1; 21]) = 3));
  (assert ((candidate [0; 8; 1; 2; 1; 7]) = 7));
  (assert ((candidate [8191]) = 19));
  (assert ((candidate [8191; 123456; 127; 7]) = 19));
  (assert ((candidate [127; 97; 8192]) = 10));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183721
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 104 (ML) - HumanEval_104_unique_digits
================================================================================

PROMPT:
----------------------------------------
(**Given a list of positive integers x. return a sorted list of all 
 * elements that hasn't any even digit.
 * Note: Returned list should be sorted in increasing order.
 * For example:
 * >>> unique_digits [15; 33; 1422; 1]
 * [1; 15; 33]
 * >>> unique_digits [152; 323; 1422; 10]
 * []
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = unique_digits in
  (assert ((candidate [15; 33; 1422; 1]) = [1; 15; 33]));
  (assert ((candidate [152; 323; 1422; 10]) = []));
  (assert ((candidate [12345; 2033; 111; 151]) = [111; 151]));
  (assert ((candidate [135; 103; 31]) = [31; 135]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given a list of positive integers x. return a sorted list of all 
 * elements that hasn't any even digit.
 * Note: Returned list should be sorted in increasing order.
 * For example:
 * >>> unique_digits [15; 33; 1422; 1]
 * [1; 15; 33]
 * >>> unique_digits [152; 323; 1422; 10]
 * []
*)
let unique_digits (x : int list) : int list =
  (* Helper that checks whether a positive integer contains an even digit. *)
  let rec has_even_digit n =
    if n = 0 then false            (* 0 itself is not considered here because
                                      the input list contains only positive
                                      integers; for completeness we treat 0
                                      as having no even digit. *)
    else
      let d = n mod 10 in
      if d mod 2 = 0 then true
      else has_even_digit (n / 10)
  in
  (* Keep only numbers with no even digit and sort the result. *)
  x
  |> List.filter (fun n -> not (has_even_digit n))
  |> List.sort compare

let assertions =
 let candidate = unique_digits in
  (assert ((candidate [15; 33; 1422; 1]) = [1; 15; 33]));
  (assert ((candidate [152; 323; 1422; 10]) = []));
  (assert ((candidate [12345; 2033; 111; 151]) = [111; 151]));
  (assert ((candidate [135; 103; 31]) = [31; 135]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183723
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given a list of positive integers x. return a sorted list of all 
 * elements that hasn't any even digit.
 * Note: Returned list should be sorted in increasing order.
 * For example:
 * >>> unique_digits [15; 33; 1422; 1]
 * [1; 15; 33]
 * >>> unique_digits [152; 323; 1422; 10]
 * []
*)
let unique_digits (x : int list) : int list =
  (* Helper to check if a number contains any even digit *)
  let rec has_even_digit n =
    if n = 0 then false
    else
      let d = n mod 10 in
      if d mod 2 = 0 then true
      else has_even_digit (n / 10)
  in
  (* Filter numbers that have no even digit *)
  let filtered = List.filter (fun n -> not (has_even_digit n)) x in
  (* Return the filtered list sorted in increasing order *)
  List.sort compare filtered

let assertions =
 let candidate = unique_digits in
  (assert ((candidate [15; 33; 1422; 1]) = [1; 15; 33]));
  (assert ((candidate [152; 323; 1422; 10]) = []));
  (assert ((candidate [12345; 2033; 111; 151]) = [111; 151]));
  (assert ((candidate [135; 103; 31]) = [31; 135]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183723
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given a list of positive integers x. return a sorted list of all 
 * elements that hasn't any even digit.
 * Note: Returned list should be sorted in increasing order.
 * For example:
 * >>> unique_digits [15; 33; 1422; 1]
 * [1; 15; 33]
 * >>> unique_digits [152; 323; 1422; 10]
 * []
*)
let unique_digits (x : int list) : int list =
  (* Helper: true iff the number contains at least one even digit *)
  let rec has_even_digit n =
    if n = 0 then true                     (* 0 itself is an even digit *)
    else
      let d = n mod 10 in
      if d mod 2 = 0 then true
      else has_even_digit (n / 10)
  in
  (* Keep only numbers that have no even digit, then sort them *)
  x
  |> List.filter (fun n -> not (has_even_digit n))
  |> List.sort compare

let assertions =
 let candidate = unique_digits in
  (assert ((candidate [15; 33; 1422; 1]) = [1; 15; 33]));
  (assert ((candidate [152; 323; 1422; 10]) = []));
  (assert ((candidate [12345; 2033; 111; 151]) = [111; 151]));
  (assert ((candidate [135; 103; 31]) = [31; 135]));
  ()


EXECUTION RESULTS:
Exit Code: 2
Status: AssertionError
Timestamp: 1755183723
STDOUT: (empty)
STDERR:
Exception: Assert_failure ("/tmp/tmpg1pp021p.ml", 26, 2).
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given a list of positive integers x. return a sorted list of all 
 * elements that hasn't any even digit.
 * Note: Returned list should be sorted in increasing order.
 * For example:
 * >>> unique_digits [15; 33; 1422; 1]
 * [1; 15; 33]
 * >>> unique_digits [152; 323; 1422; 10]
 * []
*)
let unique_digits (x : int list) : int list =
  (* Helper that returns true if the number contains an even digit *)
  let rec has_even_digit n =
    if n = 0 then false
    else
      let d = n mod 10 in
      if d mod 2 = 0 then true
      else has_even_digit (n / 10)
  in
  (* Filter numbers that have no even digit, then sort them *)
  List.sort compare (List.filter (fun n -> not (has_even_digit n)) x)

let assertions =
 let candidate = unique_digits in
  (assert ((candidate [15; 33; 1422; 1]) = [1; 15; 33]));
  (assert ((candidate [152; 323; 1422; 10]) = []));
  (assert ((candidate [12345; 2033; 111; 151]) = [111; 151]));
  (assert ((candidate [135; 103; 31]) = [31; 135]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183723
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 109 (ML) - HumanEval_109_move_one_ball
================================================================================

PROMPT:
----------------------------------------
(**We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
 * numbers in the list will be randomly ordered. Your task is to determine if
 * it is possible to get a list sorted in non-decreasing order by performing 
 * the following operation on the given list:
 * You are allowed to perform right shift operation any number of times.
 * One right shift operation means shifting all elements of the list by one
 * position in the right direction. The last element of the list will be moved to
 * the starting position in the list i.e. 0th index. 
 * If it is possible to obtain the sorted list by performing the above operation
 * then return true else return false.
 * If the given list is empty then return true.
 * Note: The given list is guaranteed to have unique elements.
 * For Example:
 * >>> move_one_ball [3; 4; 5; 1; 2]
 * true
 * Explanation: By performin 2 right shift operations, non-decreasing order can
 * be achieved for the given list.
 * >>> move_one_ball [3; 5; 4; 1; 2]
 * false
 * Explanation:It is not possible to get non-decreasing order for the given
 * list by performing any number of right shift operations.
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = move_one_ball in
  (assert ((candidate [3; 4; 5; 1; 2]) = true));
  (assert ((candidate [3; 5; 10; 1; 2]) = true));
  (assert ((candidate [4; 3; 1; 2]) = false));
  (assert ((candidate [3; 5; 4; 1; 2]) = false));
  (assert ((candidate []) = true));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
 * numbers in the list will be randomly ordered. Your task is to determine if
 * it is possible to get a list sorted in non-decreasing order by performing 
 * the following operation on the given list:
 * You are allowed to perform right shift operation any number of times.
 * One right shift operation means shifting all elements of the list by one
 * position in the right direction. The last element of the list will be moved to
 * the starting position in the list i.e. 0th index. 
 * If it is possible to obtain the sorted list by performing the above operation
 * then return true else return false.
 * If the given list is empty then return true.
 * Note: The given list is guaranteed to have unique elements.
 * For Example:
 * >>> move_one_ball [3; 4; 5; 1; 2]
 * true
 * Explanation: By performin 2 right shift operations, non-decreasing order can
 * be achieved for the given list.
 * >>> move_one_ball [3; 5; 4; 1; 2]
 * false
 * Explanation:It is not possible to get non-decreasing order for the given
 * list by performing any number of right shift operations.
*)
(* Check whether a list can become sorted by any number of right‑shift operations. *)
let move_one_ball (arr : int list) : bool =
  (* Empty list is considered sorted. *)
  if arr = [] then true
  else
    let a = Array.of_list arr in
    let n = Array.length a in
    (* Count the number of positions where the order is broken. *)
    let rec count_breaks i cnt =
      if i = n then cnt
      else
        let next = (i + 1) mod n in
        let cnt' =
          if a.(i) > a.(next) then cnt + 1 else cnt
        in
        count_breaks (i + 1) cnt'
    in
    let breaks = count_breaks 0 0 in
    match breaks with
    | 0 -> true  (* already sorted *)
    | 1 ->
        (* For a single break to be a valid rotation, the last element
           must be less than or equal to the first element. *)
        a.(n - 1) <= a.(0)
    | _ -> false

let assertions =
 let candidate = move_one_ball in
  (assert ((candidate [3; 4; 5; 1; 2]) = true));
  (assert ((candidate [3; 5; 10; 1; 2]) = true));
  (assert ((candidate [4; 3; 1; 2]) = false));
  (assert ((candidate [3; 5; 4; 1; 2]) = false));
  (assert ((candidate []) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183723
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
 * numbers in the list will be randomly ordered. Your task is to determine if
 * it is possible to get a list sorted in non-decreasing order by performing 
 * the following operation on the given list:
 * You are allowed to perform right shift operation any number of times.
 * One right shift operation means shifting all elements of the list by one
 * position in the right direction. The last element of the list will be moved to
 * the starting position in the list i.e. 0th index. 
 * If it is possible to obtain the sorted list by performing the above operation
 * then return true else return false.
 * If the given list is empty then return true.
 * Note: The given list is guaranteed to have unique elements.
 * For Example:
 * >>> move_one_ball [3; 4; 5; 1; 2]
 * true
 * Explanation: By performin 2 right shift operations, non-decreasing order can
 * be achieved for the given list.
 * >>> move_one_ball [3; 5; 4; 1; 2]
 * false
 * Explanation:It is not possible to get non-decreasing order for the given
 * list by performing any number of right shift operations.
*)
let move_one_ball (arr : int list) : bool =
  (* An array can be sorted by right‑shifts iff it is a rotation of a sorted
     ascending list.  For a rotation there can be at most one “drop” where
     an element is greater than the following one (cyclically). *)
  match arr with
  | [] | [_] -> true
  | first :: second :: rest ->
      (* Count the number of drops in the linear part of the list. *)
      let rec aux prev curr rest count =
        match rest with
        | [] -> count
        | next :: tl ->
            let count' = if curr > next then count + 1 else count in
            aux curr next tl count'
      in
      let drop_count = aux first second rest 0 in
      (* Compare last element with the first to capture the cyclic drop. *)
      let last = List.rev arr |> List.hd in
      let total_drops =
        if last > first then drop_count + 1 else drop_count
      in
      total_drops <= 1

let assertions =
 let candidate = move_one_ball in
  (assert ((candidate [3; 4; 5; 1; 2]) = true));
  (assert ((candidate [3; 5; 10; 1; 2]) = true));
  (assert ((candidate [4; 3; 1; 2]) = false));
  (assert ((candidate [3; 5; 4; 1; 2]) = false));
  (assert ((candidate []) = true));
  ()


EXECUTION RESULTS:
Exit Code: 2
Status: AssertionError
Timestamp: 1755183723
STDOUT: (empty)
STDERR:
Exception: Assert_failure ("/tmp/tmppa_26hct.ml", 50, 2).
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
 * numbers in the list will be randomly ordered. Your task is to determine if
 * it is possible to get a list sorted in non-decreasing order by performing 
 * the following operation on the given list:
 * You are allowed to perform right shift operation any number of times.
 * One right shift operation means shifting all elements of the list by one
 * position in the right direction. The last element of the list will be moved to
 * the starting position in the list i.e. 0th index. 
 * If it is possible to obtain the sorted list by performing the above operation
 * then return true else return false.
 * If the given list is empty then return true.
 * Note: The given list is guaranteed to have unique elements.
 * For Example:
 * >>> move_one_ball [3; 4; 5; 1; 2]
 * true
 * Explanation: By performin 2 right shift operations, non-decreasing order can
 * be achieved for the given list.
 * >>> move_one_ball [3; 5; 4; 1; 2]
 * false
 * Explanation:It is not possible to get non-decreasing order for the given
 * list by performing any number of right shift operations.
*)
(* Check whether a list can become sorted by right‑shifting any number of times. *)
let move_one_ball (arr : int list) : bool =
  match arr with
  | [] -> true
  | _ ->
    (* Convert to an array for efficient random access. *)
    let a = Array.of_list arr in
    let n = Array.length a in
    (* Count the number of places where the order is violated. *)
    let inv = ref 0 in
    for i = 0 to n - 2 do
      if a.(i) > a.(i + 1) then incr inv
    done;
    (* If no violation, the list is already sorted. *)
    if !inv = 0 then true
    (* If exactly one violation and the last element is not greater than the first,
       the list is a rotation of a sorted list. *)
    else if !inv = 1 && a.(n - 1) <= a.(0) then true
    else false

let assertions =
 let candidate = move_one_ball in
  (assert ((candidate [3; 4; 5; 1; 2]) = true));
  (assert ((candidate [3; 5; 10; 1; 2]) = true));
  (assert ((candidate [4; 3; 1; 2]) = false));
  (assert ((candidate [3; 5; 4; 1; 2]) = false));
  (assert ((candidate []) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183723
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
 * numbers in the list will be randomly ordered. Your task is to determine if
 * it is possible to get a list sorted in non-decreasing order by performing 
 * the following operation on the given list:
 * You are allowed to perform right shift operation any number of times.
 * One right shift operation means shifting all elements of the list by one
 * position in the right direction. The last element of the list will be moved to
 * the starting position in the list i.e. 0th index. 
 * If it is possible to obtain the sorted list by performing the above operation
 * then return true else return false.
 * If the given list is empty then return true.
 * Note: The given list is guaranteed to have unique elements.
 * For Example:
 * >>> move_one_ball [3; 4; 5; 1; 2]
 * true
 * Explanation: By performin 2 right shift operations, non-decreasing order can
 * be achieved for the given list.
 * >>> move_one_ball [3; 5; 4; 1; 2]
 * false
 * Explanation:It is not possible to get non-decreasing order for the given
 * list by performing any number of right shift operations.
*)
(* Return true if the list can become sorted in non‑decreasing order
   by performing any number of right‑shift operations (rotations). *)
let move_one_ball (arr : int list) : bool =
  match arr with
  | [] -> true
  | _ ->
    let sorted = List.sort compare arr in
    let n = List.length arr in

    (* Find the rotation offset k such that sorted[k] = arr[0] *)
    let rec find_k i =
      if i = n then None
      else if List.nth sorted i = List.hd arr then Some i else find_k (i + 1)
    in

    match find_k 0 with
    | None -> false  (* arr[0] not found in sorted list – impossible *)
    | Some k ->
      (* Verify that the rest of the elements match the rotated sorted list *)
      let rec check i =
        if i = n then true
        else
          let idx = (k + i) mod n in
          if List.nth sorted idx = List.nth arr i
          then check (i + 1)
          else false
      in
      check 0

let assertions =
 let candidate = move_one_ball in
  (assert ((candidate [3; 4; 5; 1; 2]) = true));
  (assert ((candidate [3; 5; 10; 1; 2]) = true));
  (assert ((candidate [4; 3; 1; 2]) = false));
  (assert ((candidate [3; 5; 4; 1; 2]) = false));
  (assert ((candidate []) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183723
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 115 (ML) - HumanEval_115_max_fill
================================================================================

PROMPT:
----------------------------------------
(**You are given a rectangular grid of wells. Each row represents a single well,
 * and each 1 in a row represents a single unit of water.
 * Each well has a corresponding bucket that can be used to extract water from it, 
 * and all buckets have the same capacity.
 * Your task is to use the buckets to empty the wells.
 * Output the number of times you need to lower the buckets.
 * Example 1:
 * >>> max_fill [[0; 0; 1; 0]; [0; 1; 0; 0]; [1; 1; 1; 1]] 1
 * 6
 * Example 2:
 * >>> max_fill [[0; 0; 1; 1]; [0; 0; 0; 0]; [1; 1; 1; 1]; [0; 1; 1; 1]] 2
 * 5
 * Example 3:
 * >>> max_fill [[0; 0; 0]; [0; 0; 0]] 5
 * 0
 * Constraints:
 * * all wells have the same length
 * * 1 <= grid.length <= 10^2
 * * 1 <= grid[:,1].length <= 10^2
 * * grid[i][j] -> 0 | 1
 * * 1 <= capacity <= 10
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = max_fill in
  (assert ((candidate [[0; 0; 1; 0]; [0; 1; 0; 0]; [1; 1; 1; 1]] 1) = 6));
  (assert ((candidate [[0; 0; 1; 1]; [0; 0; 0; 0]; [1; 1; 1; 1]; [0; 1; 1; 1]] 2) = 5));
  (assert ((candidate [[0; 0; 0]; [0; 0; 0]] 5) = 0));
  (assert ((candidate [[1; 1; 1; 1]; [1; 1; 1; 1]] 2) = 4));
  (assert ((candidate [[1; 1; 1; 1]; [1; 1; 1; 1]] 9) = 2));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**You are given a rectangular grid of wells. Each row represents a single well,
 * and each 1 in a row represents a single unit of water.
 * Each well has a corresponding bucket that can be used to extract water from it, 
 * and all buckets have the same capacity.
 * Your task is to use the buckets to empty the wells.
 * Output the number of times you need to lower the buckets.
 * Example 1:
 * >>> max_fill [[0; 0; 1; 0]; [0; 1; 0; 0]; [1; 1; 1; 1]] 1
 * 6
 * Example 2:
 * >>> max_fill [[0; 0; 1; 1]; [0; 0; 0; 0]; [1; 1; 1; 1]; [0; 1; 1; 1]] 2
 * 5
 * Example 3:
 * >>> max_fill [[0; 0; 0]; [0; 0; 0]] 5
 * 0
 * Constraints:
 * * all wells have the same length
 * * 1 <= grid.length <= 10^2
 * * 1 <= grid[:,1].length <= 10^2
 * * grid[i][j] -> 0 | 1
 * * 1 <= capacity <= 10
*)
let max_fill (grid : int list list) (capacity : int) : int =
  (* Count the number of 1's in a row *)
  let count_ones row =
    List.fold_left (fun acc x -> if x = 1 then acc + 1 else acc) 0 row
  in
  (* Compute how many times we need to lower the bucket for a single well *)
  let lowers_for_row row =
    let ones = count_ones row in
    if ones = 0 then 0
    else (ones + capacity - 1) / capacity  (* ceil(ones / capacity) *)
  in
  (* Sum over all wells *)
  List.fold_left (fun acc row -> acc + lowers_for_row row) 0 grid

let assertions =
 let candidate = max_fill in
  (assert ((candidate [[0; 0; 1; 0]; [0; 1; 0; 0]; [1; 1; 1; 1]] 1) = 6));
  (assert ((candidate [[0; 0; 1; 1]; [0; 0; 0; 0]; [1; 1; 1; 1]; [0; 1; 1; 1]] 2) = 5));
  (assert ((candidate [[0; 0; 0]; [0; 0; 0]] 5) = 0));
  (assert ((candidate [[1; 1; 1; 1]; [1; 1; 1; 1]] 2) = 4));
  (assert ((candidate [[1; 1; 1; 1]; [1; 1; 1; 1]] 9) = 2));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183724
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**You are given a rectangular grid of wells. Each row represents a single well,
 * and each 1 in a row represents a single unit of water.
 * Each well has a corresponding bucket that can be used to extract water from it, 
 * and all buckets have the same capacity.
 * Your task is to use the buckets to empty the wells.
 * Output the number of times you need to lower the buckets.
 * Example 1:
 * >>> max_fill [[0; 0; 1; 0]; [0; 1; 0; 0]; [1; 1; 1; 1]] 1
 * 6
 * Example 2:
 * >>> max_fill [[0; 0; 1; 1]; [0; 0; 0; 0]; [1; 1; 1; 1]; [0; 1; 1; 1]] 2
 * 5
 * Example 3:
 * >>> max_fill [[0; 0; 0]; [0; 0; 0]] 5
 * 0
 * Constraints:
 * * all wells have the same length
 * * 1 <= grid.length <= 10^2
 * * 1 <= grid[:,1].length <= 10^2
 * * grid[i][j] -> 0 | 1
 * * 1 <= capacity <= 10
*)
let max_fill (grid : int list list) (capacity : int) : int =
  (* For each well (row), count the number of units of water (ones),
     then compute the number of bucket fills needed using ceiling division. *)
  List.fold_left
    (fun acc row ->
      let ones = List.fold_left ( + ) 0 row in
      acc + (ones + capacity - 1) / capacity)
    0
    grid

let assertions =
 let candidate = max_fill in
  (assert ((candidate [[0; 0; 1; 0]; [0; 1; 0; 0]; [1; 1; 1; 1]] 1) = 6));
  (assert ((candidate [[0; 0; 1; 1]; [0; 0; 0; 0]; [1; 1; 1; 1]; [0; 1; 1; 1]] 2) = 5));
  (assert ((candidate [[0; 0; 0]; [0; 0; 0]] 5) = 0));
  (assert ((candidate [[1; 1; 1; 1]; [1; 1; 1; 1]] 2) = 4));
  (assert ((candidate [[1; 1; 1; 1]; [1; 1; 1; 1]] 9) = 2));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183724
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**You are given a rectangular grid of wells. Each row represents a single well,
 * and each 1 in a row represents a single unit of water.
 * Each well has a corresponding bucket that can be used to extract water from it, 
 * and all buckets have the same capacity.
 * Your task is to use the buckets to empty the wells.
 * Output the number of times you need to lower the buckets.
 * Example 1:
 * >>> max_fill [[0; 0; 1; 0]; [0; 1; 0; 0]; [1; 1; 1; 1]] 1
 * 6
 * Example 2:
 * >>> max_fill [[0; 0; 1; 1]; [0; 0; 0; 0]; [1; 1; 1; 1]; [0; 1; 1; 1]] 2
 * 5
 * Example 3:
 * >>> max_fill [[0; 0; 0]; [0; 0; 0]] 5
 * 0
 * Constraints:
 * * all wells have the same length
 * * 1 <= grid.length <= 10^2
 * * 1 <= grid[:,1].length <= 10^2
 * * grid[i][j] -> 0 | 1
 * * 1 <= capacity <= 10
*)
let max_fill (grid : int list list) (capacity : int) : int =
    // For each well (row) count the number of water units (ones).
    // Compute the number of bucket lowers needed for that well:
    //   - If the well is empty, 0 lowers.
    //   - Otherwise, ceil(count / capacity) lowers.
    grid
    |> List.map (fun row ->
        let count = List.sum row
        if count = 0 then 0
        else (count + capacity - 1) / capacity)
    |> List.sum

let assertions =
 let candidate = max_fill in
  (assert ((candidate [[0; 0; 1; 0]; [0; 1; 0; 0]; [1; 1; 1; 1]] 1) = 6));
  (assert ((candidate [[0; 0; 1; 1]; [0; 0; 0; 0]; [1; 1; 1; 1]; [0; 1; 1; 1]] 2) = 5));
  (assert ((candidate [[0; 0; 0]; [0; 0; 0]] 5) = 0));
  (assert ((candidate [[1; 1; 1; 1]; [1; 1; 1; 1]] 2) = 4));
  (assert ((candidate [[1; 1; 1; 1]; [1; 1; 1; 1]] 9) = 2));
  ()


EXECUTION RESULTS:
Exit Code: 2
Status: SyntaxError
Timestamp: 1755183724
STDOUT: (empty)
STDERR:
File "/tmp/tmp35u7osil.ml", line 24, characters 4-6:
24 |     // For each well (row) count the number of water units (ones).
         ^^
Error: Syntax error
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**You are given a rectangular grid of wells. Each row represents a single well,
 * and each 1 in a row represents a single unit of water.
 * Each well has a corresponding bucket that can be used to extract water from it, 
 * and all buckets have the same capacity.
 * Your task is to use the buckets to empty the wells.
 * Output the number of times you need to lower the buckets.
 * Example 1:
 * >>> max_fill [[0; 0; 1; 0]; [0; 1; 0; 0]; [1; 1; 1; 1]] 1
 * 6
 * Example 2:
 * >>> max_fill [[0; 0; 1; 1]; [0; 0; 0; 0]; [1; 1; 1; 1]; [0; 1; 1; 1]] 2
 * 5
 * Example 3:
 * >>> max_fill [[0; 0; 0]; [0; 0; 0]] 5
 * 0
 * Constraints:
 * * all wells have the same length
 * * 1 <= grid.length <= 10^2
 * * 1 <= grid[:,1].length <= 10^2
 * * grid[i][j] -> 0 | 1
 * * 1 <= capacity <= 10
*)
let max_fill (grid : int list list) (capacity : int) : int =
  (* Count the number of 1's in a row and compute how many bucket lowers
     are required for that row. *)
  let lowers_for_row row =
    let ones =
      List.fold_left (fun acc x -> if x = 1 then acc + 1 else acc) 0 row
    in
    (* Ceiling division: (ones + capacity - 1) / capacity *)
    (ones + capacity - 1) / capacity
  in
  (* Sum the lowers needed for every row. *)
  List.fold_left (fun acc row -> acc + lowers_for_row row) 0 grid

let assertions =
 let candidate = max_fill in
  (assert ((candidate [[0; 0; 1; 0]; [0; 1; 0; 0]; [1; 1; 1; 1]] 1) = 6));
  (assert ((candidate [[0; 0; 1; 1]; [0; 0; 0; 0]; [1; 1; 1; 1]; [0; 1; 1; 1]] 2) = 5));
  (assert ((candidate [[0; 0; 0]; [0; 0; 0]] 5) = 0));
  (assert ((candidate [[1; 1; 1; 1]; [1; 1; 1; 1]] 2) = 4));
  (assert ((candidate [[1; 1; 1; 1]; [1; 1; 1; 1]] 9) = 2));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183724
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 119 (ML) - HumanEval_119_match_parens
================================================================================

PROMPT:
----------------------------------------
(**You are given a list of two strings, both strings consist of open
 * parentheses '(' or close parentheses ')' only.
 * Your job is to check if it is possible to concatenate the two strings in
 * some order, that the resulting string will be good.
 * A string S is considered to be good if and only if all parentheses in S
 * are balanced. For example: the string '(())()' is good, while the string
 * '())' is not.
 * Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
 * Examples:
 * >>> match_parens ["()("; ")"]
 * "Yes"
 * >>> match_parens [")"; ")"]
 * "No"
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = match_parens in
  (assert ((candidate ["()("; ")"]) = "Yes"));
  (assert ((candidate [")"; ")"]) = "No"));
  (assert ((candidate ["(()(())"; "())())"]) = "No"));
  (assert ((candidate [")())"; "(()()("]) = "Yes"));
  (assert ((candidate ["(())))"; "(()())(("]) = "Yes"));
  (assert ((candidate ["()"; "())"]) = "No"));
  (assert ((candidate ["(()("; "()))()"]) = "Yes"));
  (assert ((candidate ["(((("; "((())"]) = "No"));
  (assert ((candidate [")(()"; "(()("]) = "No"));
  (assert ((candidate [")("; ")("]) = "No"));
  (assert ((candidate ["("; ")"]) = "Yes"));
  (assert ((candidate [")"; "("]) = "Yes"));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**You are given a list of two strings, both strings consist of open
 * parentheses '(' or close parentheses ')' only.
 * Your job is to check if it is possible to concatenate the two strings in
 * some order, that the resulting string will be good.
 * A string S is considered to be good if and only if all parentheses in S
 * are balanced. For example: the string '(())()' is good, while the string
 * '())' is not.
 * Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
 * Examples:
 * >>> match_parens ["()("; ")"]
 * "Yes"
 * >>> match_parens [")"; ")"]
 * "No"
*)
(** Return "Yes" if the two strings of parentheses can be concatenated
    (in some order) to form a balanced string, otherwise "No". *)
let match_parens (lst : string list) : string =
  (* Compute the net balance and the minimum prefix balance of a string. *)
  let analyze (s : string) : int * int =
    let n = String.length s in
    let net = ref 0 in
    let min_pref = ref 0 in
    for i = 0 to n - 1 do
      match s.[i] with
      | '(' -> incr net
      | ')' -> decr net
      | _ -> ()   (* input guarantees only '(' or ')' *)
      if !net < !min_pref then min_pref := !net
    done;
    (!net, !min_pref)
  in

  (* Helper that checks whether the two strings can be concatenated in
     some order to produce a balanced string. *)
  let can_be_balanced (s1 : string) (s2 : string) : bool =
    let (net1, min1) = analyze s1 in
    let (net2, min2) = analyze s2 in

    (* First order: s1 followed by s2 *)
    let ok1 =
      (min1 >= 0) &&
      (min2 >= -net1) &&
      (net1 + net2 = 0)
    in
    (* Second order: s2 followed by s1 *)
    let ok2 =
      (min2 >= 0) &&
      (min1 >= -net2) &&
      (net1 + net2 = 0)
    in
    ok1 || ok2
  in

  match lst with
  | [s1; s2] ->
      if can_be_balanced s1 s2 then "Yes" else "No"
  | _ -> "No"   (* not exactly two strings – treat as impossible *)

let assertions =
 let candidate = match_parens in
  (assert ((candidate ["()("; ")"]) = "Yes"));
  (assert ((candidate [")"; ")"]) = "No"));
  (assert ((candidate ["(()(())"; "())())"]) = "No"));
  (assert ((candidate [")())"; "(()()("]) = "Yes"));
  (assert ((candidate ["(())))"; "(()())(("]) = "Yes"));
  (assert ((candidate ["()"; "())"]) = "No"));
  (assert ((candidate ["(()("; "()))()"]) = "Yes"));
  (assert ((candidate ["(((("; "((())"]) = "No"));
  (assert ((candidate [")(()"; "(()("]) = "No"));
  (assert ((candidate [")("; ")("]) = "No"));
  (assert ((candidate ["("; ")"]) = "Yes"));
  (assert ((candidate [")"; "("]) = "Yes"));
  ()


EXECUTION RESULTS:
Exit Code: 2
Status: SyntaxError
Timestamp: 1755183725
STDOUT: (empty)
STDERR:
File "/tmp/tmp9plt8h7h.ml", line 28, characters 6-8:
28 |       if !net < !min_pref then min_pref := !net
           ^^
Error: Syntax error
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**You are given a list of two strings, both strings consist of open
 * parentheses '(' or close parentheses ')' only.
 * Your job is to check if it is possible to concatenate the two strings in
 * some order, that the resulting string will be good.
 * A string S is considered to be good if and only if all parentheses in S
 * are balanced. For example: the string '(())()' is good, while the string
 * '())' is not.
 * Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
 * Examples:
 * >>> match_parens ["()("; ")"]
 * "Yes"
 * >>> match_parens [")"; ")"]
 * "No"
*)
(* Check whether a string consisting of '(' and ')' is balanced *)
let is_balanced (s : string) : bool =
  let rec aux idx depth =
    if idx = String.length s then depth = 0
    else
      let c = s.[idx] in
      let depth' =
        match c with
        | '(' -> depth + 1
        | ')' -> depth - 1
        | _   -> depth (* should not happen *)
      in
      depth' >= 0 && aux (idx + 1) depth'
  in
  aux 0 0

(* Main function *)
let match_parens (lst : string list) : string =
  match lst with
  | [s1; s2] ->
      if is_balanced (s1 ^ s2) || is_balanced (s2 ^ s1) then "Yes"
      else "No"
  | _ -> "No"   (* invalid input – not exactly two strings *)

let assertions =
 let candidate = match_parens in
  (assert ((candidate ["()("; ")"]) = "Yes"));
  (assert ((candidate [")"; ")"]) = "No"));
  (assert ((candidate ["(()(())"; "())())"]) = "No"));
  (assert ((candidate [")())"; "(()()("]) = "Yes"));
  (assert ((candidate ["(())))"; "(()())(("]) = "Yes"));
  (assert ((candidate ["()"; "())"]) = "No"));
  (assert ((candidate ["(()("; "()))()"]) = "Yes"));
  (assert ((candidate ["(((("; "((())"]) = "No"));
  (assert ((candidate [")(()"; "(()("]) = "No"));
  (assert ((candidate [")("; ")("]) = "No"));
  (assert ((candidate ["("; ")"]) = "Yes"));
  (assert ((candidate [")"; "("]) = "Yes"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**You are given a list of two strings, both strings consist of open
 * parentheses '(' or close parentheses ')' only.
 * Your job is to check if it is possible to concatenate the two strings in
 * some order, that the resulting string will be good.
 * A string S is considered to be good if and only if all parentheses in S
 * are balanced. For example: the string '(())()' is good, while the string
 * '())' is not.
 * Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
 * Examples:
 * >>> match_parens ["()("; ")"]
 * "Yes"
 * >>> match_parens [")"; ")"]
 * "No"
*)
(* Check whether a single string of parentheses is balanced *)
let is_balanced (s : string) : bool =
  let rec aux i bal =
    if i = String.length s then bal = 0
    else
      let bal' =
        match s.[i] with
        | '(' -> bal + 1
        | ')' -> bal - 1
        | _   -> bal  (* not expected, but safe *)
      in
      if bal' < 0 then false
      else aux (i + 1) bal'
  in
  aux 0 0

(* Main function *)
let match_parens (lst : string list) : string =
  match lst with
  | [s1; s2] ->
      let c1 = s1 ^ s2 in
      let c2 = s2 ^ s1 in
      if is_balanced c1 || is_balanced c2 then "Yes" else "No"
  | _ -> "No"   (* The problem guarantees a list of two strings,
                    but we return "No" for any other input. *)

let assertions =
 let candidate = match_parens in
  (assert ((candidate ["()("; ")"]) = "Yes"));
  (assert ((candidate [")"; ")"]) = "No"));
  (assert ((candidate ["(()(())"; "())())"]) = "No"));
  (assert ((candidate [")())"; "(()()("]) = "Yes"));
  (assert ((candidate ["(())))"; "(()())(("]) = "Yes"));
  (assert ((candidate ["()"; "())"]) = "No"));
  (assert ((candidate ["(()("; "()))()"]) = "Yes"));
  (assert ((candidate ["(((("; "((())"]) = "No"));
  (assert ((candidate [")(()"; "(()("]) = "No"));
  (assert ((candidate [")("; ")("]) = "No"));
  (assert ((candidate ["("; ")"]) = "Yes"));
  (assert ((candidate [")"; "("]) = "Yes"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**You are given a list of two strings, both strings consist of open
 * parentheses '(' or close parentheses ')' only.
 * Your job is to check if it is possible to concatenate the two strings in
 * some order, that the resulting string will be good.
 * A string S is considered to be good if and only if all parentheses in S
 * are balanced. For example: the string '(())()' is good, while the string
 * '())' is not.
 * Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
 * Examples:
 * >>> match_parens ["()("; ")"]
 * "Yes"
 * >>> match_parens [")"; ")"]
 * "No"
*)
let match_parens (lst : string list) : string =
  (* Helper that returns (total_balance, min_prefix_balance) for a string *)
  let analyze (s : string) : int * int =
    let len = String.length s in
    let rec aux i bal min_bal =
      if i = len then (bal, min_bal)
      else
        let c = s.[i] in
        let bal' = if c = '(' then bal + 1 else bal - 1 in
        let min_bal' = min min_bal bal' in
        aux (i + 1) bal' min_bal'
    in
    aux 0 0 0
  in

  (* Check if concatenating s1 then s2 yields a balanced string *)
  let can_concat s1 s2 =
    let (t1, m1) = analyze s1 in
    let (t2, m2) = analyze s2 in
    (* total balance must be zero *)
    let total = t1 + t2 in
    if total <> 0 then false
    else
      (* prefixes must never go negative *)
      m1 >= 0 && (t1 + m2) >= 0
  in

  match lst with
  | [s1; s2] ->
      if can_concat s1 s2 || can_concat s2 s1 then "Yes" else "No"
  | _ -> "No"   (* invalid input – not two strings *)

let assertions =
 let candidate = match_parens in
  (assert ((candidate ["()("; ")"]) = "Yes"));
  (assert ((candidate [")"; ")"]) = "No"));
  (assert ((candidate ["(()(())"; "())())"]) = "No"));
  (assert ((candidate [")())"; "(()()("]) = "Yes"));
  (assert ((candidate ["(())))"; "(()())(("]) = "Yes"));
  (assert ((candidate ["()"; "())"]) = "No"));
  (assert ((candidate ["(()("; "()))()"]) = "Yes"));
  (assert ((candidate ["(((("; "((())"]) = "No"));
  (assert ((candidate [")(()"; "(()("]) = "No"));
  (assert ((candidate [")("; ")("]) = "No"));
  (assert ((candidate ["("; ")"]) = "Yes"));
  (assert ((candidate [")"; "("]) = "Yes"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 130 (ML) - HumanEval_130_tri
================================================================================

PROMPT:
----------------------------------------
(**Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
 * the last couple centuries. However, what people don't know is Tribonacci sequence.
 * Tribonacci sequence is defined by the recurrence:
 * tri(1) = 3
 * tri(n) = 1 + n / 2, if n is even.
 * tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
 * For example:
 * tri(2) = 1 + (2 / 2) = 2
 * tri(4) = 3
 * tri(3) = tri(2) + tri(1) + tri(4)
 * = 2 + 3 + 3 = 8 
 * You are given a non-negative integer number n, you have to a return a list of the 
 * first n + 1 numbers of the Tribonacci sequence.
 * Examples:
 * >>> tri 3
 * [1; 3; 2; 8]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = tri in
  (assert ((candidate 3) = [1; 3; 2; 8]));
  (assert ((candidate 4) = [1; 3; 2; 8; 3]));
  (assert ((candidate 5) = [1; 3; 2; 8; 3; 15]));
  (assert ((candidate 6) = [1; 3; 2; 8; 3; 15; 4]));
  (assert ((candidate 7) = [1; 3; 2; 8; 3; 15; 4; 24]));
  (assert ((candidate 8) = [1; 3; 2; 8; 3; 15; 4; 24; 5]));
  (assert ((candidate 9) = [1; 3; 2; 8; 3; 15; 4; 24; 5; 35]));
  (assert ((candidate 20) = [1; 3; 2; 8; 3; 15; 4; 24; 5; 35; 6; 48; 7; 63; 8; 80; 9; 99; 10; 120; 11]));
  (assert ((candidate 0) = [1]));
  (assert ((candidate 1) = [1; 3]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
 * the last couple centuries. However, what people don't know is Tribonacci sequence.
 * Tribonacci sequence is defined by the recurrence:
 * tri(1) = 3
 * tri(n) = 1 + n / 2, if n is even.
 * tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
 * For example:
 * tri(2) = 1 + (2 / 2) = 2
 * tri(4) = 3
 * tri(3) = tri(2) + tri(1) + tri(4)
 * = 2 + 3 + 3 = 8 
 * You are given a non-negative integer number n, you have to a return a list of the 
 * first n + 1 numbers of the Tribonacci sequence.
 * Examples:
 * >>> tri 3
 * [1; 3; 2; 8]
*)
(* Tribonacci sequence implementation *)
let tri (n : int) : int list =
  (* We need to compute values up to index n (inclusive).
     For odd indices we also need the next value, so allocate one
     extra slot (n + 2). *)
  let size = n + 2 in
  let arr = Array.make size 0 in

  (* Base cases *)
  arr.(0) <- 1;                (* tri(0) = 1 + 0/2 *)
  if n >= 1 then arr.(1) <- 3; (* tri(1) = 3 *)

  (* Fill even indices directly; leave odd indices for later. *)
  for i = 2 to n + 1 do
    if i mod 2 = 0 then
      arr.(i) <- 1 + i / 2
  done;

  (* Compute odd indices from high to low.
     For odd i ≥ 3 we use the recurrence:
         tri(i) = tri(i-1) + tri(i-2) + tri(i+1) *)
  for i = n downto 3 do
    if i mod 2 = 1 then
      arr.(i) <- arr.(i - 1) + arr.(i - 2) + arr.(i + 1)
  done;

  (* Convert the needed part of the array into a list. *)
  List.init (n + 1) (fun i -> arr.(i))

let assertions =
 let candidate = tri in
  (assert ((candidate 3) = [1; 3; 2; 8]));
  (assert ((candidate 4) = [1; 3; 2; 8; 3]));
  (assert ((candidate 5) = [1; 3; 2; 8; 3; 15]));
  (assert ((candidate 6) = [1; 3; 2; 8; 3; 15; 4]));
  (assert ((candidate 7) = [1; 3; 2; 8; 3; 15; 4; 24]));
  (assert ((candidate 8) = [1; 3; 2; 8; 3; 15; 4; 24; 5]));
  (assert ((candidate 9) = [1; 3; 2; 8; 3; 15; 4; 24; 5; 35]));
  (assert ((candidate 20) = [1; 3; 2; 8; 3; 15; 4; 24; 5; 35; 6; 48; 7; 63; 8; 80; 9; 99; 10; 120; 11]));
  (assert ((candidate 0) = [1]));
  (assert ((candidate 1) = [1; 3]));
  ()


EXECUTION RESULTS:
Exit Code: 2
Status: AssertionError
Timestamp: 1755183727
STDOUT: (empty)
STDERR:
Exception: Assert_failure ("/tmp/tmpkfh174j4.ml", 51, 2).
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
 * the last couple centuries. However, what people don't know is Tribonacci sequence.
 * Tribonacci sequence is defined by the recurrence:
 * tri(1) = 3
 * tri(n) = 1 + n / 2, if n is even.
 * tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
 * For example:
 * tri(2) = 1 + (2 / 2) = 2
 * tri(4) = 3
 * tri(3) = tri(2) + tri(1) + tri(4)
 * = 2 + 3 + 3 = 8 
 * You are given a non-negative integer number n, you have to a return a list of the 
 * first n + 1 numbers of the Tribonacci sequence.
 * Examples:
 * >>> tri 3
 * [1; 3; 2; 8]
*)
(*  Tribonacci sequence implementation
    tri(0) is defined as 1 (to match the example)
    tri(1) = 3
    tri(n) = 1 + n/2          if n is even
    tri(n) = tri(n-1)+tri(n-2)+tri(n+1)  if n is odd
*)
let tri (n : int) : int list =
  (* we need indices up to n+1 to compute odd terms that refer to n+1 *)
  let size = n + 2 in
  let a = Array.make size 0 in
  (* base values *)
  a.(0) <- 1;
  if n >= 1 then a.(1) <- 3;
  (* first compute all even indices up to n+1 *)
  let rec compute_evens i =
    if i > n + 1 then ()
    else if i mod 2 = 0 then begin
      a.(i) <- 1 + i / 2;
      compute_evens (i + 1)
    end else
      compute_evens (i + 1)
  in
  compute_evens 2;
  (* now compute odd indices (except 1 which is already set) *)
  let rec compute_odds i =
    if i > n then ()
    else if i mod 2 = 1 then begin
      (* for i = 1 we already have the correct value, skip *)
      if i <> 1 then
        a.(i) <- a.(i-1) + a.(i-2) + a.(i+1);
      compute_odds (i + 1)
    end else
      compute_odds (i + 1)
  in
  compute_odds 1;
  (* build the result list from indices 0 .. n *)
  Array.sub a 0 (n+1) |> Array.to_list

let assertions =
 let candidate = tri in
  (assert ((candidate 3) = [1; 3; 2; 8]));
  (assert ((candidate 4) = [1; 3; 2; 8; 3]));
  (assert ((candidate 5) = [1; 3; 2; 8; 3; 15]));
  (assert ((candidate 6) = [1; 3; 2; 8; 3; 15; 4]));
  (assert ((candidate 7) = [1; 3; 2; 8; 3; 15; 4; 24]));
  (assert ((candidate 8) = [1; 3; 2; 8; 3; 15; 4; 24; 5]));
  (assert ((candidate 9) = [1; 3; 2; 8; 3; 15; 4; 24; 5; 35]));
  (assert ((candidate 20) = [1; 3; 2; 8; 3; 15; 4; 24; 5; 35; 6; 48; 7; 63; 8; 80; 9; 99; 10; 120; 11]));
  (assert ((candidate 0) = [1]));
  (assert ((candidate 1) = [1; 3]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183727
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
 * the last couple centuries. However, what people don't know is Tribonacci sequence.
 * Tribonacci sequence is defined by the recurrence:
 * tri(1) = 3
 * tri(n) = 1 + n / 2, if n is even.
 * tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
 * For example:
 * tri(2) = 1 + (2 / 2) = 2
 * tri(4) = 3
 * tri(3) = tri(2) + tri(1) + tri(4)
 * = 2 + 3 + 3 = 8 
 * You are given a non-negative integer number n, you have to a return a list of the 
 * first n + 1 numbers of the Tribonacci sequence.
 * Examples:
 * >>> tri 3
 * [1; 3; 2; 8]
*)
(* Tribonacci sequence:
   tri(0) = 1
   tri(1) = 3
   tri(n) = 1 + n / 2          if n is even
   tri(n) = tri(n-1) + tri(n-2) + tri(n+1)  if n is odd (n > 1)
   For an odd n, n+1 is even, so tri(n+1) = 1 + (n+1)/2 *)
let tri (n : int) : int list =
  (* Allocate an array to store the first n+1 terms *)
  let arr = Array.make (n + 1) 0 in

  (* Base cases *)
  arr.(0) <- 1;
  if n >= 1 then arr.(1) <- 3;

  (* Compute remaining terms *)
  for i = 2 to n do
    if i mod 2 = 0 then
      (* Even index *)
      arr.(i) <- 1 + i / 2
    else
      (* Odd index (i > 1) *)
      arr.(i) <- arr.(i-1) + arr.(i-2) + (1 + (i + 1) / 2)
  done;

  (* Convert the array to a list *)
  Array.to_list arr

let assertions =
 let candidate = tri in
  (assert ((candidate 3) = [1; 3; 2; 8]));
  (assert ((candidate 4) = [1; 3; 2; 8; 3]));
  (assert ((candidate 5) = [1; 3; 2; 8; 3; 15]));
  (assert ((candidate 6) = [1; 3; 2; 8; 3; 15; 4]));
  (assert ((candidate 7) = [1; 3; 2; 8; 3; 15; 4; 24]));
  (assert ((candidate 8) = [1; 3; 2; 8; 3; 15; 4; 24; 5]));
  (assert ((candidate 9) = [1; 3; 2; 8; 3; 15; 4; 24; 5; 35]));
  (assert ((candidate 20) = [1; 3; 2; 8; 3; 15; 4; 24; 5; 35; 6; 48; 7; 63; 8; 80; 9; 99; 10; 120; 11]));
  (assert ((candidate 0) = [1]));
  (assert ((candidate 1) = [1; 3]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183727
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
 * the last couple centuries. However, what people don't know is Tribonacci sequence.
 * Tribonacci sequence is defined by the recurrence:
 * tri(1) = 3
 * tri(n) = 1 + n / 2, if n is even.
 * tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
 * For example:
 * tri(2) = 1 + (2 / 2) = 2
 * tri(4) = 3
 * tri(3) = tri(2) + tri(1) + tri(4)
 * = 2 + 3 + 3 = 8 
 * You are given a non-negative integer number n, you have to a return a list of the 
 * first n + 1 numbers of the Tribonacci sequence.
 * Examples:
 * >>> tri 3
 * [1; 3; 2; 8]
*)
(* Implementation of the Tribonacci sequence as described in the problem statement *)
let tri (n : int) : int list =
  (* Memoization table to avoid repeated calculations *)
  let memo = Hashtbl.create (n + 3) in

  (* Recursive helper that computes tri(k) according to the rules *)
  let rec tri_rec k =
    if Hashtbl.mem memo k then
      Hashtbl.find memo k
    else
      let value =
        if k = 0 then
          1  (* tri(0) is defined by the example *)
        else if k = 1 then
          3  (* base case *)
        else if k mod 2 = 0 then
          1 + k / 2  (* even case *)
        else
          (* odd case: uses the next even index k+1 *)
          tri_rec (k - 1) + tri_rec (k - 2) + tri_rec (k + 1)
      in
      Hashtbl.add memo k value;
      value
  in

  (* Build the list of the first n + 1 Tribonacci numbers *)
  List.init (n + 1) (fun i -> tri_rec i)

let assertions =
 let candidate = tri in
  (assert ((candidate 3) = [1; 3; 2; 8]));
  (assert ((candidate 4) = [1; 3; 2; 8; 3]));
  (assert ((candidate 5) = [1; 3; 2; 8; 3; 15]));
  (assert ((candidate 6) = [1; 3; 2; 8; 3; 15; 4]));
  (assert ((candidate 7) = [1; 3; 2; 8; 3; 15; 4; 24]));
  (assert ((candidate 8) = [1; 3; 2; 8; 3; 15; 4; 24; 5]));
  (assert ((candidate 9) = [1; 3; 2; 8; 3; 15; 4; 24; 5; 35]));
  (assert ((candidate 20) = [1; 3; 2; 8; 3; 15; 4; 24; 5; 35; 6; 48; 7; 63; 8; 80; 9; 99; 10; 120; 11]));
  (assert ((candidate 0) = [1]));
  (assert ((candidate 1) = [1; 3]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183727
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 132 (ML) - HumanEval_132_is_nested
================================================================================

PROMPT:
----------------------------------------
(**Create a function that takes a string as input which contains only square brackets.
 * The function should return true if and only if there is a valid subsequence of brackets 
 * where at least one bracket in the subsequence is nested.
 * >>> is_nested "[[]]"
 * true
 * >>> is_nested "[]]]]]]][[[[[]"
 * false
 * >>> is_nested "[][]"
 * false
 * >>> is_nested "[]"
 * false
 * >>> is_nested "[[][]]"
 * true
 * >>> is_nested "[[]][["
 * true
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = is_nested in
  (assert ((candidate "[[]]") = true));
  (assert ((candidate "[]]]]]]][[[[[]") = false));
  (assert ((candidate "[][]") = false));
  (assert ((candidate "[]") = false));
  (assert ((candidate "[[[[]]]]") = true));
  (assert ((candidate "[]]]]]]]]]]") = false));
  (assert ((candidate "[][][[]]") = true));
  (assert ((candidate "[[]") = false));
  (assert ((candidate "[]]") = false));
  (assert ((candidate "[[]][[") = true));
  (assert ((candidate "[[][]]") = true));
  (assert ((candidate "") = false));
  (assert ((candidate "[[[[[[[[") = false));
  (assert ((candidate "]]]]]]]]") = false));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Create a function that takes a string as input which contains only square brackets.
 * The function should return true if and only if there is a valid subsequence of brackets 
 * where at least one bracket in the subsequence is nested.
 * >>> is_nested "[[]]"
 * true
 * >>> is_nested "[]]]]]]][[[[[]"
 * false
 * >>> is_nested "[][]"
 * false
 * >>> is_nested "[]"
 * false
 * >>> is_nested "[[][]]"
 * true
 * >>> is_nested "[[]][["
 * true
*)
exception Found

let is_nested (s : string) : bool =
  let n = String.length s in
  (* suffix[i] = number of ']' in s[i..n-1] *)
  let suffix = Array.make (n + 1) 0 in
  for i = n - 1 downto 0 do
    suffix.(i) <- suffix.(i + 1) + if s.[i] = ']' then 1 else 0
  done;
  let count_open = ref 0 in
  try
    for i = 0 to n - 1 do
      match s.[i] with
      | '[' ->
          (* i is a potential second '[' (j) *)
          if !count_open > 0 && suffix.(i + 1) >= 2 then raise Found;
          incr count_open
      | ']' -> ()
      | _ -> () (* input is guaranteed to contain only '[' and ']' *)
    done;
    false
  with Found -> true

let assertions =
 let candidate = is_nested in
  (assert ((candidate "[[]]") = true));
  (assert ((candidate "[]]]]]]][[[[[]") = false));
  (assert ((candidate "[][]") = false));
  (assert ((candidate "[]") = false));
  (assert ((candidate "[[[[]]]]") = true));
  (assert ((candidate "[]]]]]]]]]]") = false));
  (assert ((candidate "[][][[]]") = true));
  (assert ((candidate "[[]") = false));
  (assert ((candidate "[]]") = false));
  (assert ((candidate "[[]][[") = true));
  (assert ((candidate "[[][]]") = true));
  (assert ((candidate "") = false));
  (assert ((candidate "[[[[[[[[") = false));
  (assert ((candidate "]]]]]]]]") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183727
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Create a function that takes a string as input which contains only square brackets.
 * The function should return true if and only if there is a valid subsequence of brackets 
 * where at least one bracket in the subsequence is nested.
 * >>> is_nested "[[]]"
 * true
 * >>> is_nested "[]]]]]]][[[[[]"
 * false
 * >>> is_nested "[][]"
 * false
 * >>> is_nested "[]"
 * false
 * >>> is_nested "[[][]]"
 * true
 * >>> is_nested "[[]][["
 * true
*)
let is_nested (s : string) : bool =
  let n = String.length s in
  (* suffix_has[i] is true iff there is a ']' at an index >= i *)
  let suffix_has = Array.make (n + 1) false in
  for i = n - 1 downto 0 do
    suffix_has.(i) <- suffix_has.(i + 1) || (s.[i] = ']')
  done;
  let rec aux i open_cnt =
    if i = n then false
    else
      match s.[i] with
      | '[' -> aux (i + 1) (open_cnt + 1)
      | ']' ->
          if open_cnt >= 2 && suffix_has.(i + 1) then true
          else aux (i + 1) open_cnt
  in
  aux 0 0

let assertions =
 let candidate = is_nested in
  (assert ((candidate "[[]]") = true));
  (assert ((candidate "[]]]]]]][[[[[]") = false));
  (assert ((candidate "[][]") = false));
  (assert ((candidate "[]") = false));
  (assert ((candidate "[[[[]]]]") = true));
  (assert ((candidate "[]]]]]]]]]]") = false));
  (assert ((candidate "[][][[]]") = true));
  (assert ((candidate "[[]") = false));
  (assert ((candidate "[]]") = false));
  (assert ((candidate "[[]][[") = true));
  (assert ((candidate "[[][]]") = true));
  (assert ((candidate "") = false));
  (assert ((candidate "[[[[[[[[") = false));
  (assert ((candidate "]]]]]]]]") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183727
STDOUT: (empty)
STDERR:
File "/tmp/tmprphycity.ml", lines 27-31, characters 6-35:
27 | ......match s.[i] with
28 |       | '[' -> aux (i + 1) (open_cnt + 1)
29 |       | ']' ->
30 |           if open_cnt >= 2 && suffix_has.(i + 1) then true
31 |           else aux (i + 1) open_cnt
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
'a'
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Create a function that takes a string as input which contains only square brackets.
 * The function should return true if and only if there is a valid subsequence of brackets 
 * where at least one bracket in the subsequence is nested.
 * >>> is_nested "[[]]"
 * true
 * >>> is_nested "[]]]]]]][[[[[]"
 * false
 * >>> is_nested "[][]"
 * false
 * >>> is_nested "[]"
 * false
 * >>> is_nested "[[][]]"
 * true
 * >>> is_nested "[[]][["
 * true
*)
[   [   ]   ]
 ^   ^   ^   ^
 i   j   k   l

let assertions =
 let candidate = is_nested in
  (assert ((candidate "[[]]") = true));
  (assert ((candidate "[]]]]]]][[[[[]") = false));
  (assert ((candidate "[][]") = false));
  (assert ((candidate "[]") = false));
  (assert ((candidate "[[[[]]]]") = true));
  (assert ((candidate "[]]]]]]]]]]") = false));
  (assert ((candidate "[][][[]]") = true));
  (assert ((candidate "[[]") = false));
  (assert ((candidate "[]]") = false));
  (assert ((candidate "[[]][[") = true));
  (assert ((candidate "[[][]]") = true));
  (assert ((candidate "") = false));
  (assert ((candidate "[[[[[[[[") = false));
  (assert ((candidate "]]]]]]]]") = false));
  ()


EXECUTION RESULTS:
Exit Code: 2
Status: SyntaxError
Timestamp: 1755183727
STDOUT: (empty)
STDERR:
File "/tmp/tmpn7uojo6b.ml", line 18, characters 5-6:
18 |  ^   ^   ^   ^
          ^
Error: Syntax error
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Create a function that takes a string as input which contains only square brackets.
 * The function should return true if and only if there is a valid subsequence of brackets 
 * where at least one bracket in the subsequence is nested.
 * >>> is_nested "[[]]"
 * true
 * >>> is_nested "[]]]]]]][[[[[]"
 * false
 * >>> is_nested "[][]"
 * false
 * >>> is_nested "[]"
 * false
 * >>> is_nested "[[][]]"
 * true
 * >>> is_nested "[[]][["
 * true
*)
(*  Checks whether a string of '[' and ']' contains a nested
    subsequence of brackets.  A nested subsequence is a valid
    bracket sequence of the form "[[...]]" (at least one pair
    nested inside another).  The function looks for four
    characters in order: an opening bracket, a second opening
    bracket, a closing bracket that comes after the second
    opening, and finally another closing bracket that comes
    after that.  If all four can be found, the string has a
    nested subsequence. *)

let is_nested (s : string) : bool =
  let n = String.length s in

  (* Find the first occurrence of character c starting at index i.
     Returns Some index or None if not found. *)
  let rec find i c =
    if i >= n then None
    else if s.[i] = c then Some i
    else find (i + 1) c
  in

  match find 0 '[' with
  | None -> false
  | Some i ->
    (* second opening bracket after i *)
    (match find (i + 1) '[' with
    | None -> false
    | Some j ->
      (* first closing bracket after j *)
      (match find (j + 1) ']' with
      | None -> false
      | Some k ->
        (* second closing bracket after k *)
        (match find (k + 1) ']' with
        | None -> false
        | Some _ -> true)))

let assertions =
 let candidate = is_nested in
  (assert ((candidate "[[]]") = true));
  (assert ((candidate "[]]]]]]][[[[[]") = false));
  (assert ((candidate "[][]") = false));
  (assert ((candidate "[]") = false));
  (assert ((candidate "[[[[]]]]") = true));
  (assert ((candidate "[]]]]]]]]]]") = false));
  (assert ((candidate "[][][[]]") = true));
  (assert ((candidate "[[]") = false));
  (assert ((candidate "[]]") = false));
  (assert ((candidate "[[]][[") = true));
  (assert ((candidate "[[][]]") = true));
  (assert ((candidate "") = false));
  (assert ((candidate "[[[[[[[[") = false));
  (assert ((candidate "]]]]]]]]") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183727
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 133 (ML) - HumanEval_133_sum_squares
================================================================================

PROMPT:
----------------------------------------
(**You are given a list of numbers.
 * You need to return the sum of squared numbers in the given list,
 * round each element in the list to the upper int(Ceiling) first.
 * Examples:
 * >>> lst [1.0; 2.0; 3.0]
 * 14
 * >>> lst [1.0; 4.0; 9.0]
 * 98
 * >>> lst [1.0; 3.0; 5.0; 7.0]
 * 84
 * >>> lst [1.4; 4.2; 0.0]
 * 29
 * >>> lst [-2.4; 1.0; 1.0]
 * 6
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = sum_squares in
  (assert ((candidate [1.0; 2.0; 3.0]) = 14));
  (assert ((candidate [1.0; 2.0; 3.0]) = 14));
  (assert ((candidate [1.0; 3.0; 5.0; 7.0]) = 84));
  (assert ((candidate [1.4; 4.2; 0.0]) = 29));
  (assert ((candidate [-2.4; 1.0; 1.0]) = 6));
  (assert ((candidate [100.0; 1.0; 15.0; 2.0]) = 10230));
  (assert ((candidate [10000.0; 10000.0]) = 200000000));
  (assert ((candidate [-1.4; 4.6; 6.3]) = 75));
  (assert ((candidate [-1.4; 17.9; 18.9; 19.9]) = 1086));
  (assert ((candidate [0.0]) = 0));
  (assert ((candidate [-1.0]) = 1));
  (assert ((candidate [-1.0; 1.0; 0.0]) = 2));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**You are given a list of numbers.
 * You need to return the sum of squared numbers in the given list,
 * round each element in the list to the upper int(Ceiling) first.
 * Examples:
 * >>> lst [1.0; 2.0; 3.0]
 * 14
 * >>> lst [1.0; 4.0; 9.0]
 * 98
 * >>> lst [1.0; 3.0; 5.0; 7.0]
 * 84
 * >>> lst [1.4; 4.2; 0.0]
 * 29
 * >>> lst [-2.4; 1.0; 1.0]
 * 6
*)
(* Sum of squared numbers after rounding each element up (Ceiling). *)
let sum_squares (lst : float list) : int =
  lst
  |> List.map (fun x -> int_of_float (ceil x))   (* round up to integer *)
  |> List.map (fun i -> i * i)                  (* square each integer *)
  |> List.fold_left (+) 0                       (* sum all squares *)

let assertions =
 let candidate = sum_squares in
  (assert ((candidate [1.0; 2.0; 3.0]) = 14));
  (assert ((candidate [1.0; 2.0; 3.0]) = 14));
  (assert ((candidate [1.0; 3.0; 5.0; 7.0]) = 84));
  (assert ((candidate [1.4; 4.2; 0.0]) = 29));
  (assert ((candidate [-2.4; 1.0; 1.0]) = 6));
  (assert ((candidate [100.0; 1.0; 15.0; 2.0]) = 10230));
  (assert ((candidate [10000.0; 10000.0]) = 200000000));
  (assert ((candidate [-1.4; 4.6; 6.3]) = 75));
  (assert ((candidate [-1.4; 17.9; 18.9; 19.9]) = 1086));
  (assert ((candidate [0.0]) = 0));
  (assert ((candidate [-1.0]) = 1));
  (assert ((candidate [-1.0; 1.0; 0.0]) = 2));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183727
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**You are given a list of numbers.
 * You need to return the sum of squared numbers in the given list,
 * round each element in the list to the upper int(Ceiling) first.
 * Examples:
 * >>> lst [1.0; 2.0; 3.0]
 * 14
 * >>> lst [1.0; 4.0; 9.0]
 * 98
 * >>> lst [1.0; 3.0; 5.0; 7.0]
 * 84
 * >>> lst [1.4; 4.2; 0.0]
 * 29
 * >>> lst [-2.4; 1.0; 1.0]
 * 6
*)
let sum_squares (lst : float list) : int =
  List.fold_left (fun acc x ->
    let y = int_of_float (ceil x) in
    acc + y * y
  ) 0 lst

let assertions =
 let candidate = sum_squares in
  (assert ((candidate [1.0; 2.0; 3.0]) = 14));
  (assert ((candidate [1.0; 2.0; 3.0]) = 14));
  (assert ((candidate [1.0; 3.0; 5.0; 7.0]) = 84));
  (assert ((candidate [1.4; 4.2; 0.0]) = 29));
  (assert ((candidate [-2.4; 1.0; 1.0]) = 6));
  (assert ((candidate [100.0; 1.0; 15.0; 2.0]) = 10230));
  (assert ((candidate [10000.0; 10000.0]) = 200000000));
  (assert ((candidate [-1.4; 4.6; 6.3]) = 75));
  (assert ((candidate [-1.4; 17.9; 18.9; 19.9]) = 1086));
  (assert ((candidate [0.0]) = 0));
  (assert ((candidate [-1.0]) = 1));
  (assert ((candidate [-1.0; 1.0; 0.0]) = 2));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183727
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**You are given a list of numbers.
 * You need to return the sum of squared numbers in the given list,
 * round each element in the list to the upper int(Ceiling) first.
 * Examples:
 * >>> lst [1.0; 2.0; 3.0]
 * 14
 * >>> lst [1.0; 4.0; 9.0]
 * 98
 * >>> lst [1.0; 3.0; 5.0; 7.0]
 * 84
 * >>> lst [1.4; 4.2; 0.0]
 * 29
 * >>> lst [-2.4; 1.0; 1.0]
 * 6
*)
let sum_squares (lst : float list) : int =
    lst
    |> List.map (fun x -> ceil x |> int)   // round each element up
    |> List.map (fun i -> i * i)           // square the integer
    |> List.sum                            // sum all squares

let assertions =
 let candidate = sum_squares in
  (assert ((candidate [1.0; 2.0; 3.0]) = 14));
  (assert ((candidate [1.0; 2.0; 3.0]) = 14));
  (assert ((candidate [1.0; 3.0; 5.0; 7.0]) = 84));
  (assert ((candidate [1.4; 4.2; 0.0]) = 29));
  (assert ((candidate [-2.4; 1.0; 1.0]) = 6));
  (assert ((candidate [100.0; 1.0; 15.0; 2.0]) = 10230));
  (assert ((candidate [10000.0; 10000.0]) = 200000000));
  (assert ((candidate [-1.4; 4.6; 6.3]) = 75));
  (assert ((candidate [-1.4; 17.9; 18.9; 19.9]) = 1086));
  (assert ((candidate [0.0]) = 0));
  (assert ((candidate [-1.0]) = 1));
  (assert ((candidate [-1.0; 1.0; 0.0]) = 2));
  ()


EXECUTION RESULTS:
Exit Code: 2
Status: Exception
Timestamp: 1755183727
STDOUT: (empty)
STDERR:
File "/tmp/tmp9yf43k5e.ml", line 20, characters 43-45:
20 |     |> List.sum                            // sum all squares
                                                ^^
Error: Unbound value //
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**You are given a list of numbers.
 * You need to return the sum of squared numbers in the given list,
 * round each element in the list to the upper int(Ceiling) first.
 * Examples:
 * >>> lst [1.0; 2.0; 3.0]
 * 14
 * >>> lst [1.0; 4.0; 9.0]
 * 98
 * >>> lst [1.0; 3.0; 5.0; 7.0]
 * 84
 * >>> lst [1.4; 4.2; 0.0]
 * 29
 * >>> lst [-2.4; 1.0; 1.0]
 * 6
*)
let sum_squares (lst : float list) : int =
  List.fold_left (fun acc x ->
    let yi = int_of_float (ceil x) in
    acc + yi * yi
  ) 0 lst

let assertions =
 let candidate = sum_squares in
  (assert ((candidate [1.0; 2.0; 3.0]) = 14));
  (assert ((candidate [1.0; 2.0; 3.0]) = 14));
  (assert ((candidate [1.0; 3.0; 5.0; 7.0]) = 84));
  (assert ((candidate [1.4; 4.2; 0.0]) = 29));
  (assert ((candidate [-2.4; 1.0; 1.0]) = 6));
  (assert ((candidate [100.0; 1.0; 15.0; 2.0]) = 10230));
  (assert ((candidate [10000.0; 10000.0]) = 200000000));
  (assert ((candidate [-1.4; 4.6; 6.3]) = 75));
  (assert ((candidate [-1.4; 17.9; 18.9; 19.9]) = 1086));
  (assert ((candidate [0.0]) = 0));
  (assert ((candidate [-1.0]) = 1));
  (assert ((candidate [-1.0; 1.0; 0.0]) = 2));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183727
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 144 (ML) - HumanEval_144_simplify
================================================================================

PROMPT:
----------------------------------------
(**Your task is to implement a function that will simplify the expression
 * x * n. The function returns true if x * n evaluates to a whole number and false
 * otherwise. Both x and n, are string representation of a fraction, and have the following format,
 * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
 * You can assume that x, and n are valid fractions, and do not have zero as denominator.
 * >>> simplify "1/5" "5/1"
 * true
 * >>> simplify "1/6" "2/1"
 * false
 * >>> simplify "7/10" "10/2"
 * false
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = simplify in
  (assert ((candidate "1/5" "5/1") = true));
  (assert ((candidate "1/6" "2/1") = false));
  (assert ((candidate "5/1" "3/1") = true));
  (assert ((candidate "7/10" "10/2") = false));
  (assert ((candidate "2/10" "50/10") = true));
  (assert ((candidate "7/2" "4/2") = true));
  (assert ((candidate "11/6" "6/1") = true));
  (assert ((candidate "2/3" "5/2") = false));
  (assert ((candidate "5/2" "3/5") = false));
  (assert ((candidate "2/4" "8/4") = true));
  (assert ((candidate "2/4" "4/2") = true));
  (assert ((candidate "1/5" "5/1") = true));
  (assert ((candidate "1/5" "1/5") = false));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Your task is to implement a function that will simplify the expression
 * x * n. The function returns true if x * n evaluates to a whole number and false
 * otherwise. Both x and n, are string representation of a fraction, and have the following format,
 * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
 * You can assume that x, and n are valid fractions, and do not have zero as denominator.
 * >>> simplify "1/5" "5/1"
 * true
 * >>> simplify "1/6" "2/1"
 * false
 * >>> simplify "7/10" "10/2"
 * false
*)
let simplify (x : string) (n : string) : bool =
  (* Parse a fraction string "numerator/denominator" into two Int64 values *)
  let parse s =
    match String.split_on_char '/' s with
    | [num; den] -> (Int64.of_string num, Int64.of_string den)
    | _ -> failwith "Invalid fraction format"
  in

  (* Extract the numerators and denominators *)
  let (a, b) = parse x in
  let (c, d) = parse n in

  (* Compute the product numerator and denominator *)
  let num = Int64.mul a c in
  let den = Int64.mul b d in

  (* The product is an integer iff den divides num exactly *)
  Int64.rem num den = 0L

let assertions =
 let candidate = simplify in
  (assert ((candidate "1/5" "5/1") = true));
  (assert ((candidate "1/6" "2/1") = false));
  (assert ((candidate "5/1" "3/1") = true));
  (assert ((candidate "7/10" "10/2") = false));
  (assert ((candidate "2/10" "50/10") = true));
  (assert ((candidate "7/2" "4/2") = true));
  (assert ((candidate "11/6" "6/1") = true));
  (assert ((candidate "2/3" "5/2") = false));
  (assert ((candidate "5/2" "3/5") = false));
  (assert ((candidate "2/4" "8/4") = true));
  (assert ((candidate "2/4" "4/2") = true));
  (assert ((candidate "1/5" "5/1") = true));
  (assert ((candidate "1/5" "1/5") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183729
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Your task is to implement a function that will simplify the expression
 * x * n. The function returns true if x * n evaluates to a whole number and false
 * otherwise. Both x and n, are string representation of a fraction, and have the following format,
 * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
 * You can assume that x, and n are valid fractions, and do not have zero as denominator.
 * >>> simplify "1/5" "5/1"
 * true
 * >>> simplify "1/6" "2/1"
 * false
 * >>> simplify "7/10" "10/2"
 * false
*)
let simplify (x : string) (n : string) : bool =
  (* Parse a fraction string "numerator/denominator" into a pair of ints *)
  let parse_frac s =
    match String.split_on_char '/' s with
    | [num_str; den_str] ->
        (int_of_string num_str, int_of_string den_str)
    | _ -> failwith "Invalid fraction format"
  in
  let (num1, den1) = parse_frac x in
  let (num2, den2) = parse_frac n in
  let num = num1 * num2 in
  let den = den1 * den2 in
  (* The product is a whole number iff the denominator divides the numerator *)
  num mod den = 0

let assertions =
 let candidate = simplify in
  (assert ((candidate "1/5" "5/1") = true));
  (assert ((candidate "1/6" "2/1") = false));
  (assert ((candidate "5/1" "3/1") = true));
  (assert ((candidate "7/10" "10/2") = false));
  (assert ((candidate "2/10" "50/10") = true));
  (assert ((candidate "7/2" "4/2") = true));
  (assert ((candidate "11/6" "6/1") = true));
  (assert ((candidate "2/3" "5/2") = false));
  (assert ((candidate "5/2" "3/5") = false));
  (assert ((candidate "2/4" "8/4") = true));
  (assert ((candidate "2/4" "4/2") = true));
  (assert ((candidate "1/5" "5/1") = true));
  (assert ((candidate "1/5" "1/5") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183729
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Your task is to implement a function that will simplify the expression
 * x * n. The function returns true if x * n evaluates to a whole number and false
 * otherwise. Both x and n, are string representation of a fraction, and have the following format,
 * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
 * You can assume that x, and n are valid fractions, and do not have zero as denominator.
 * >>> simplify "1/5" "5/1"
 * true
 * >>> simplify "1/6" "2/1"
 * false
 * >>> simplify "7/10" "10/2"
 * false
*)
let simplify (x : string) (n : string) : bool =
    // Helper to split a fraction string into numerator and denominator
    let parseFraction (s : string) =
        let parts = s.Split('/')
        int parts.[0], int parts.[1]

    // Parse both fractions
    let a, b = parseFraction x
    let c, d = parseFraction n

    // Compute the product fraction
    let numerator   = a * c
    let denominator = b * d

    // The product is a whole number iff numerator is divisible by denominator
    numerator % denominator = 0

let assertions =
 let candidate = simplify in
  (assert ((candidate "1/5" "5/1") = true));
  (assert ((candidate "1/6" "2/1") = false));
  (assert ((candidate "5/1" "3/1") = true));
  (assert ((candidate "7/10" "10/2") = false));
  (assert ((candidate "2/10" "50/10") = true));
  (assert ((candidate "7/2" "4/2") = true));
  (assert ((candidate "11/6" "6/1") = true));
  (assert ((candidate "2/3" "5/2") = false));
  (assert ((candidate "5/2" "3/5") = false));
  (assert ((candidate "2/4" "8/4") = true));
  (assert ((candidate "2/4" "4/2") = true));
  (assert ((candidate "1/5" "5/1") = true));
  (assert ((candidate "1/5" "1/5") = false));
  ()


EXECUTION RESULTS:
Exit Code: 2
Status: SyntaxError
Timestamp: 1755183729
STDOUT: (empty)
STDERR:
File "/tmp/tmp8klbnfxn.ml", line 14, characters 4-6:
14 |     // Helper to split a fraction string into numerator and denominator
         ^^
Error: Syntax error
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Your task is to implement a function that will simplify the expression
 * x * n. The function returns true if x * n evaluates to a whole number and false
 * otherwise. Both x and n, are string representation of a fraction, and have the following format,
 * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
 * You can assume that x, and n are valid fractions, and do not have zero as denominator.
 * >>> simplify "1/5" "5/1"
 * true
 * >>> simplify "1/6" "2/1"
 * false
 * >>> simplify "7/10" "10/2"
 * false
*)
let simplify (x : string) (n : string) : bool =
  (* Helper to parse a fraction string "a/b" into (a, b) *)
  let parse frac =
    match String.split_on_char '/' frac with
    | [a; b] -> (int_of_string a, int_of_string b)
    | _ -> failwith "Invalid fraction format"
  in
  let (num1, den1) = parse x in
  let (num2, den2) = parse n in
  let num = num1 * num2 in
  let den = den1 * den2 in
  num mod den = 0

let assertions =
 let candidate = simplify in
  (assert ((candidate "1/5" "5/1") = true));
  (assert ((candidate "1/6" "2/1") = false));
  (assert ((candidate "5/1" "3/1") = true));
  (assert ((candidate "7/10" "10/2") = false));
  (assert ((candidate "2/10" "50/10") = true));
  (assert ((candidate "7/2" "4/2") = true));
  (assert ((candidate "11/6" "6/1") = true));
  (assert ((candidate "2/3" "5/2") = false));
  (assert ((candidate "5/2" "3/5") = false));
  (assert ((candidate "2/4" "8/4") = true));
  (assert ((candidate "2/4" "4/2") = true));
  (assert ((candidate "1/5" "5/1") = true));
  (assert ((candidate "1/5" "1/5") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183729
STDOUT: (empty)
STDERR: (empty)
--------------------
