As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 10 (LUA) - HumanEval_10_make_palindrome
================================================================================

PROMPT:
----------------------------------------
-- Find the shortest palindrome that begins with a supplied string.
-- Algorithm idea is simple:
-- - Find the longest postfix of supplied string that is a palindrome.
-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
-- >>> make_palindrome('')
-- ''
-- >>> make_palindrome('cat')
-- 'catac'
-- >>> make_palindrome('cata')
-- 'catac'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = make_palindrome
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('x'), 'x')
    lu.assertEquals(candidate('xyz'), 'xyzyx')
    lu.assertEquals(candidate('xyx'), 'xyx')
    lu.assertEquals(candidate('jerry'), 'jerryrrej')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Find the shortest palindrome that begins with a supplied string.
-- Algorithm idea is simple:
-- - Find the longest postfix of supplied string that is a palindrome.
-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
-- >>> make_palindrome('')
-- ''
-- >>> make_palindrome('cat')
-- 'catac'
-- >>> make_palindrome('cata')
-- 'catac'
-- Find the shortest palindrome that begins with a supplied string.
-- Algorithm idea is simple:
-- - Find the longest postfix of supplied string that is a palindrome.
-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
-- >>> make_palindrome('')
-- ''
-- >>> make_palindrome('cat')
-- 'catac'
-- >>> make_palindrome('cata')
-- 'catac'
local function make_palindrome(str)
  local len = #str
  if len == 0 then
    return ''
  end

  -- Find the start index of the longest palindromic suffix
  local startIdx = 1
  for i = 1, len do
    local suffix = string.sub(str, i, len)
    if suffix == string.reverse(suffix) then
      startIdx = i
      break
    end
  end

  -- Prefix that precedes the palindromic suffix
  local prefix = string.sub(str, 1, startIdx - 1)
  -- Append the reverse of that prefix to make the whole string a palindrome
  return str .. string.reverse(prefix)
end
lu = require('luaunit')

function test_humaneval()
local candidate = make_palindrome
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('x'), 'x')
    lu.assertEquals(candidate('xyz'), 'xyzyx')
    lu.assertEquals(candidate('xyx'), 'xyx')
    lu.assertEquals(candidate('jerry'), 'jerryrrej')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Find the shortest palindrome that begins with a supplied string.
-- Algorithm idea is simple:
-- - Find the longest postfix of supplied string that is a palindrome.
-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
-- >>> make_palindrome('')
-- ''
-- >>> make_palindrome('cat')
-- 'catac'
-- >>> make_palindrome('cata')
-- 'catac'
-- Find the shortest palindrome that begins with a supplied string.
-- Algorithm idea is simple:
-- - Find the longest postfix of supplied string that is a palindrome.
-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
-- >>> make_palindrome('')
-- ''
-- >>> make_palindrome('cat')
-- 'catac'
-- >>> make_palindrome('cata')
-- 'catac'
local function make_palindrome(str)
  -- Helper: check if a string is a palindrome
  local function is_pal(s)
    local n = #s
    for i = 1, math.floor(n / 2) do
      if s:sub(i, i) ~= s:sub(n - i + 1, n - i + 1) then
        return false
      end
    end
    return true
  end

  if str == '' then
    return ''
  end

  local n = #str
  local pal_start = 1  -- index where the longest palindromic suffix starts

  -- Find the longest suffix that is a palindrome
  for i = 1, n do
    local suffix = str:sub(i)
    if is_pal(suffix) then
      pal_start = i
      break
    end
  end

  -- Prefix before the palindromic suffix
  local prefix = str:sub(1, pal_start - 1)
  -- Reverse the prefix and append
  return str .. string.reverse(prefix)
end
lu = require('luaunit')

function test_humaneval()
local candidate = make_palindrome
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('x'), 'x')
    lu.assertEquals(candidate('xyz'), 'xyzyx')
    lu.assertEquals(candidate('xyx'), 'xyx')
    lu.assertEquals(candidate('jerry'), 'jerryrrej')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Find the shortest palindrome that begins with a supplied string.
-- Algorithm idea is simple:
-- - Find the longest postfix of supplied string that is a palindrome.
-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
-- >>> make_palindrome('')
-- ''
-- >>> make_palindrome('cat')
-- 'catac'
-- >>> make_palindrome('cata')
-- 'catac'
-- Find the shortest palindrome that begins with a supplied string.
-- Algorithm idea is simple:
-- - Find the longest postfix of supplied string that is a palindrome.
-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
-- >>> make_palindrome('')
-- ''
-- >>> make_palindrome('cat')
-- 'catac'
-- >>> make_palindrome('cata')
-- 'catac'
local function make_palindrome(str)
    local n = #str
    if n == 0 then
        return ""
    end

    -- Helper to check if a substring s[l..r] is a palindrome
    local function is_palindrome(l, r)
        while l < r do
            if string.sub(str, l, l) ~= string.sub(str, r, r) then
                return false
            end
            l, r = l + 1, r - 1
        end
        return true
    end

    -- Find the smallest index `i` such that str[i..n] is a palindrome
    local pal_start = 1
    for i = 1, n do
        if is_palindrome(i, n) then
            pal_start = i
            break
        end
    end

    -- Prefix before the palindromic suffix
    local prefix = string.sub(str, 1, pal_start - 1)

    -- Reverse the prefix
    local rev_prefix = {}
    for i = #prefix, 1, -1 do
        rev_prefix[#rev_prefix + 1] = string.sub(prefix, i, i)
    end
    rev_prefix = table.concat(rev_prefix)

    return str .. rev_prefix
end
lu = require('luaunit')

function test_humaneval()
local candidate = make_palindrome
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('x'), 'x')
    lu.assertEquals(candidate('xyz'), 'xyzyx')
    lu.assertEquals(candidate('xyx'), 'xyx')
    lu.assertEquals(candidate('jerry'), 'jerryrrej')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Find the shortest palindrome that begins with a supplied string.
-- Algorithm idea is simple:
-- - Find the longest postfix of supplied string that is a palindrome.
-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
-- >>> make_palindrome('')
-- ''
-- >>> make_palindrome('cat')
-- 'catac'
-- >>> make_palindrome('cata')
-- 'catac'
-- Find the shortest palindrome that begins with a supplied string.
-- Algorithm idea is simple:
-- - Find the longest postfix of supplied string that is a palindrome.
-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
-- >>> make_palindrome('')
-- ''
-- >>> make_palindrome('cat')
-- 'catac'
-- >>> make_palindrome('cata')
-- 'catac'
local function make_palindrome(s)
    local n = #s
    if n == 0 then return "" end

    -- Find the earliest index i such that s[i..n] is a palindrome.
    local pal_start = 1
    for i = 1, n do
        local suffix = s:sub(i)
        if suffix == suffix:reverse() then
            pal_start = i
            break
        end
    end

    -- Prefix before the palindromic suffix
    local prefix = s:sub(1, pal_start - 1)
    return s .. prefix:reverse()
end
lu = require('luaunit')

function test_humaneval()
local candidate = make_palindrome
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('x'), 'x')
    lu.assertEquals(candidate('xyz'), 'xyzyx')
    lu.assertEquals(candidate('xyx'), 'xyx')
    lu.assertEquals(candidate('jerry'), 'jerryrrej')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 11 (LUA) - HumanEval_11_string_xor
================================================================================

PROMPT:
----------------------------------------
-- Input are two strings a and b consisting only of 1s and 0s.
-- Perform binary XOR on these inputs and return result also as a string.
-- >>> string_xor('010', '110')
-- '100'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = string_xor
    lu.assertEquals(candidate('111000', '101010'), '010010')
    lu.assertEquals(candidate('1', '1'), '0')
    lu.assertEquals(candidate('0101', '0000'), '0101')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Input are two strings a and b consisting only of 1s and 0s.
-- Perform binary XOR on these inputs and return result also as a string.
-- >>> string_xor('010', '110')
-- '100'
local function string_xor(a, b)
    -- Pad the shorter string with leading zeros so both have the same length
    local la, lb = #a, #b
    if la < lb then
        a = string.rep('0', lb - la) .. a
        la = lb
    elseif lb < la then
        b = string.rep('0', la - lb) .. b
        lb = la
    end

    -- Perform XOR on each corresponding bit
    local result = {}
    for i = 1, la do
        local ca = a:sub(i, i)
        local cb = b:sub(i, i)
        result[i] = (ca == cb) and '0' or '1'
    end

    return table.concat(result)
end
lu = require('luaunit')

function test_humaneval()
local candidate = string_xor
    lu.assertEquals(candidate('111000', '101010'), '010010')
    lu.assertEquals(candidate('1', '1'), '0')
    lu.assertEquals(candidate('0101', '0000'), '0101')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Input are two strings a and b consisting only of 1s and 0s.
-- Perform binary XOR on these inputs and return result also as a string.
-- >>> string_xor('010', '110')
-- '100'
-- Perform binary XOR on two binary strings `a` and `b` and return the result.
-- Assumes `a` and `b` are the same length and contain only '0' and '1'.
local function string_xor(a, b)
    local result = {}                     -- table to collect the XORed bits
    local len = #a                         -- length of the input strings

    for i = 1, len do
        local bit_a = a:sub(i, i)          -- current bit from string a
        local bit_b = b:sub(i, i)          -- current bit from string b

        -- XOR: bits are different → '1', otherwise '0'
        result[i] = (bit_a ~= bit_b) and '1' or '0'
    end

    return table.concat(result)           -- convert table back to string
end

-- Example usage:
-- print(string_xor('010', '110'))  --> '100'
lu = require('luaunit')

function test_humaneval()
local candidate = string_xor
    lu.assertEquals(candidate('111000', '101010'), '010010')
    lu.assertEquals(candidate('1', '1'), '0')
    lu.assertEquals(candidate('0101', '0000'), '0101')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Input are two strings a and b consisting only of 1s and 0s.
-- Perform binary XOR on these inputs and return result also as a string.
-- >>> string_xor('010', '110')
-- '100'
-- Perform binary XOR on two binary strings
-- Example:
--   string_xor('010', '110') --> '100'
local function string_xor(a, b)
  -- Ensure the strings are of equal length
  assert(#a == #b, "Input strings must be of the same length")

  local result = {}
  for i = 1, #a do
    local bit_a = a:sub(i, i)
    local bit_b = b:sub(i, i)
    -- XOR: 1 if bits differ, 0 otherwise
    result[i] = (bit_a ~= bit_b) and '1' or '0'
  end

  return table.concat(result)
end
lu = require('luaunit')

function test_humaneval()
local candidate = string_xor
    lu.assertEquals(candidate('111000', '101010'), '010010')
    lu.assertEquals(candidate('1', '1'), '0')
    lu.assertEquals(candidate('0101', '0000'), '0101')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Input are two strings a and b consisting only of 1s and 0s.
-- Perform binary XOR on these inputs and return result also as a string.
-- >>> string_xor('010', '110')
-- '100'
-- Performs a bit‑wise XOR on two binary strings of equal length.
-- The result is returned as a binary string.
--
-- Example:
--   string_xor('010', '110') --> '100'
--
local function string_xor(a, b)
    -- Ensure both strings are the same length.
    local n = #a
    if #b ~= n then
        error("string_xor: input strings must have the same length")
    end

    local res = {}
    for i = 1, n do
        local bit_a = a:sub(i, i)
        local bit_b = b:sub(i, i)
        -- XOR: 0 if bits are equal, 1 otherwise
        if bit_a == bit_b then
            res[i] = '0'
        else
            res[i] = '1'
        end
    end

    return table.concat(res)
end
lu = require('luaunit')

function test_humaneval()
local candidate = string_xor
    lu.assertEquals(candidate('111000', '101010'), '010010')
    lu.assertEquals(candidate('1', '1'), '0')
    lu.assertEquals(candidate('0101', '0000'), '0101')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 12 (LUA) - HumanEval_12_longest
================================================================================

PROMPT:
----------------------------------------
-- Out of table of strings, return the longest one. Return the first one in case of multiple
-- strings of the same length. Return nil in case the input table is empty.
-- >>> longest({})
-- None
-- >>> longest({'a', 'b', 'c'})
-- 'a'
-- >>> longest({'a', 'bb', 'ccc'})
-- 'ccc'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = longest
    lu.assertEquals(candidate({}), None)
    lu.assertEquals(candidate({'x', 'y', 'z'}), 'x')
    lu.assertEquals(candidate({'x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc'}), 'zzzz')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Out of table of strings, return the longest one. Return the first one in case of multiple
-- strings of the same length. Return nil in case the input table is empty.
-- >>> longest({})
-- None
-- >>> longest({'a', 'b', 'c'})
-- 'a'
-- >>> longest({'a', 'bb', 'ccc'})
-- 'ccc'
-- Out of table of strings, return the longest one. Return the first one in case of multiple
-- strings of the same length. Return nil in case the input table is empty.
-- >>> longest({})
-- None
-- >>> longest({'a', 'b', 'c'})
-- 'a'
-- >>> longest({'a', 'bb', 'ccc'})
-- 'ccc'
local function longest(strings)
    -- If the table is empty or nil, return nil
    if not strings or #strings == 0 then
        return nil
    end

    local best   = strings[1]          -- first string as initial candidate
    local bestlen = #best

    for i = 2, #strings do
        local s = strings[i]
        local len = #s
        if len > bestlen then          -- strictly greater, so first one wins ties
            best   = s
            bestlen = len
        end
    end

    return best
end
lu = require('luaunit')

function test_humaneval()
local candidate = longest
    lu.assertEquals(candidate({}), None)
    lu.assertEquals(candidate({'x', 'y', 'z'}), 'x')
    lu.assertEquals(candidate({'x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc'}), 'zzzz')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Out of table of strings, return the longest one. Return the first one in case of multiple
-- strings of the same length. Return nil in case the input table is empty.
-- >>> longest({})
-- None
-- >>> longest({'a', 'b', 'c'})
-- 'a'
-- >>> longest({'a', 'bb', 'ccc'})
-- 'ccc'
-- Return the longest string in the table.
-- If there are multiple with the same maximum length, return the first one.
-- Return nil if the table is empty.
local function longest(strings)
  -- Handle empty table
  if #strings == 0 then
    return nil
  end

  local longest_str = strings[1]
  local max_len = #longest_str

  for i = 2, #strings do
    local s = strings[i]
    local len = #s
    if len > max_len then
      max_len = len
      longest_str = s
    end
  end

  return longest_str
end
lu = require('luaunit')

function test_humaneval()
local candidate = longest
    lu.assertEquals(candidate({}), None)
    lu.assertEquals(candidate({'x', 'y', 'z'}), 'x')
    lu.assertEquals(candidate({'x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc'}), 'zzzz')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Out of table of strings, return the longest one. Return the first one in case of multiple
-- strings of the same length. Return nil in case the input table is empty.
-- >>> longest({})
-- None
-- >>> longest({'a', 'b', 'c'})
-- 'a'
-- >>> longest({'a', 'bb', 'ccc'})
-- 'ccc'
local function longest(strings)
  -- Return nil if the table is empty
  if #strings == 0 then
    return nil
  end

  -- Start with the first string as the current longest
  local longest_str = strings[1]

  -- Iterate over the rest of the strings
  for i = 2, #strings do
    local s = strings[i]
    -- If a longer string is found, update longest_str
    if #s > #longest_str then
      longest_str = s
    end
  end

  return longest_str
end
lu = require('luaunit')

function test_humaneval()
local candidate = longest
    lu.assertEquals(candidate({}), None)
    lu.assertEquals(candidate({'x', 'y', 'z'}), 'x')
    lu.assertEquals(candidate({'x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc'}), 'zzzz')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Out of table of strings, return the longest one. Return the first one in case of multiple
-- strings of the same length. Return nil in case the input table is empty.
-- >>> longest({})
-- None
-- >>> longest({'a', 'b', 'c'})
-- 'a'
-- >>> longest({'a', 'bb', 'ccc'})
-- 'ccc'
local function longest(strings)
  -- Return nil if the input table is nil or empty
  if not strings or #strings == 0 then
    return nil
  end

  local maxLen = -1
  local result = nil

  -- Iterate over the array part of the table (preserving order)
  for _, s in ipairs(strings) do
    -- Ensure we are dealing with a string
    if type(s) == "string" then
      local len = #s
      if len > maxLen then
        maxLen = len
        result = s
      end
    end
  end

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = longest
    lu.assertEquals(candidate({}), None)
    lu.assertEquals(candidate({'x', 'y', 'z'}), 'x')
    lu.assertEquals(candidate({'x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc'}), 'zzzz')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 13 (LUA) - HumanEval_13_greatest_common_divisor
================================================================================

PROMPT:
----------------------------------------
-- Return a greatest common divisor of two integers a and b
-- >>> greatest_common_divisor(3, 5)
-- 1
-- >>> greatest_common_divisor(25, 15)
-- 5

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = greatest_common_divisor
    lu.assertEquals(candidate(3, 7), 1)
    lu.assertEquals(candidate(10, 15), 5)
    lu.assertEquals(candidate(49, 14), 7)
    lu.assertEquals(candidate(144, 60), 12)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Return a greatest common divisor of two integers a and b
-- >>> greatest_common_divisor(3, 5)
-- 1
-- >>> greatest_common_divisor(25, 15)
-- 5
local function greatest_common_divisor(a, b)
  -- Handle negative numbers and zero
  a = math.abs(a)
  b = math.abs(b)

  -- Euclidean algorithm
  while b ~= 0 do
    local r = a % b
    a = b
    b = r
  end

  return a
end
lu = require('luaunit')

function test_humaneval()
local candidate = greatest_common_divisor
    lu.assertEquals(candidate(3, 7), 1)
    lu.assertEquals(candidate(10, 15), 5)
    lu.assertEquals(candidate(49, 14), 7)
    lu.assertEquals(candidate(144, 60), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Return a greatest common divisor of two integers a and b
-- >>> greatest_common_divisor(3, 5)
-- 1
-- >>> greatest_common_divisor(25, 15)
-- 5
-- Return a greatest common divisor of two integers a and b
-- >>> greatest_common_divisor(3, 5)
-- 1
-- >>> greatest_common_divisor(25, 15)
-- 5
local function greatest_common_divisor(a, b)
    -- Ensure we work with positive numbers
    a = math.abs(a)
    b = math.abs(b)

    -- Euclidean algorithm
    while b ~= 0 do
        local temp = a % b
        a = b
        b = temp
    end

    return a
end
lu = require('luaunit')

function test_humaneval()
local candidate = greatest_common_divisor
    lu.assertEquals(candidate(3, 7), 1)
    lu.assertEquals(candidate(10, 15), 5)
    lu.assertEquals(candidate(49, 14), 7)
    lu.assertEquals(candidate(144, 60), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Return a greatest common divisor of two integers a and b
-- >>> greatest_common_divisor(3, 5)
-- 1
-- >>> greatest_common_divisor(25, 15)
-- 5
-- Return a greatest common divisor of two integers a and b
-- >>> greatest_common_divisor(3, 5)
-- 1
-- >>> greatest_common_divisor(25, 15)
-- 5
local function greatest_common_divisor(a, b)
    -- Work with absolute values to handle negative inputs
    a = math.abs(a)
    b = math.abs(b)

    -- Edge cases: if one of them is zero
    if a == 0 then return b end
    if b == 0 then return a end

    -- Euclidean algorithm
    while b ~= 0 do
        local r = a % b
        a, b = b, r
    end

    return a
end
lu = require('luaunit')

function test_humaneval()
local candidate = greatest_common_divisor
    lu.assertEquals(candidate(3, 7), 1)
    lu.assertEquals(candidate(10, 15), 5)
    lu.assertEquals(candidate(49, 14), 7)
    lu.assertEquals(candidate(144, 60), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Return a greatest common divisor of two integers a and b
-- >>> greatest_common_divisor(3, 5)
-- 1
-- >>> greatest_common_divisor(25, 15)
-- 5
-- Return a greatest common divisor of two integers a and b
-- >>> greatest_common_divisor(3, 5)
-- 1
-- >>> greatest_common_divisor(25, 15)
-- 5
local function greatest_common_divisor(a, b)
    -- Ensure we work with absolute values
    a = math.abs(a)
    b = math.abs(b)

    -- Euclidean algorithm
    while b ~= 0 do
        local temp = b
        b = a % b
        a = temp
    end

    return a
end
lu = require('luaunit')

function test_humaneval()
local candidate = greatest_common_divisor
    lu.assertEquals(candidate(3, 7), 1)
    lu.assertEquals(candidate(10, 15), 5)
    lu.assertEquals(candidate(49, 14), 7)
    lu.assertEquals(candidate(144, 60), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 15 (LUA) - HumanEval_15_string_sequence
================================================================================

PROMPT:
----------------------------------------
-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.
-- >>> string_sequence(0)
-- '0'
-- >>> string_sequence(5)
-- '0 1 2 3 4 5'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = string_sequence
    lu.assertEquals(candidate(0), '0')
    lu.assertEquals(candidate(3), '0 1 2 3')
    lu.assertEquals(candidate(10), '0 1 2 3 4 5 6 7 8 9 10')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.
-- >>> string_sequence(0)
-- '0'
-- >>> string_sequence(5)
-- '0 1 2 3 4 5'
-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.
-- >>> string_sequence(0)
-- '0'
-- >>> string_sequence(5)
-- '0 1 2 3 4 5'
local function string_sequence(n)
  local parts = {}
  for i = 0, n do
    parts[#parts + 1] = tostring(i)
  end
  return table.concat(parts, " ")
end
lu = require('luaunit')

function test_humaneval()
local candidate = string_sequence
    lu.assertEquals(candidate(0), '0')
    lu.assertEquals(candidate(3), '0 1 2 3')
    lu.assertEquals(candidate(10), '0 1 2 3 4 5 6 7 8 9 10')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.
-- >>> string_sequence(0)
-- '0'
-- >>> string_sequence(5)
-- '0 1 2 3 4 5'
local function string_sequence(n)
    local parts = {}
    for i = 0, n do
        parts[#parts + 1] = tostring(i)
    end
    return table.concat(parts, " ")
end
lu = require('luaunit')

function test_humaneval()
local candidate = string_sequence
    lu.assertEquals(candidate(0), '0')
    lu.assertEquals(candidate(3), '0 1 2 3')
    lu.assertEquals(candidate(10), '0 1 2 3 4 5 6 7 8 9 10')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.
-- >>> string_sequence(0)
-- '0'
-- >>> string_sequence(5)
-- '0 1 2 3 4 5'
-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.
-- >>> string_sequence(0)
-- '0'
-- >>> string_sequence(5)
-- '0 1 2 3 4 5'
local function string_sequence(n)
    local parts = {}
    for i = 0, n do
        parts[#parts + 1] = tostring(i)
    end
    return table.concat(parts, ' ')
end
lu = require('luaunit')

function test_humaneval()
local candidate = string_sequence
    lu.assertEquals(candidate(0), '0')
    lu.assertEquals(candidate(3), '0 1 2 3')
    lu.assertEquals(candidate(10), '0 1 2 3 4 5 6 7 8 9 10')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.
-- >>> string_sequence(0)
-- '0'
-- >>> string_sequence(5)
-- '0 1 2 3 4 5'
-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.
-- >>> string_sequence(0)
-- '0'
-- >>> string_sequence(5)
-- '0 1 2 3 4 5'
local function string_sequence(n)
    local parts = {}
    for i = 0, n do
        parts[#parts + 1] = tostring(i)
    end
    return table.concat(parts, " ")
end
lu = require('luaunit')

function test_humaneval()
local candidate = string_sequence
    lu.assertEquals(candidate(0), '0')
    lu.assertEquals(candidate(3), '0 1 2 3')
    lu.assertEquals(candidate(10), '0 1 2 3 4 5 6 7 8 9 10')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 16 (LUA) - HumanEval_16_count_distinct_characters
================================================================================

PROMPT:
----------------------------------------
-- Given a string, find out how many distinct characters (regardless of case) does it consist of
-- >>> count_distinct_characters('xyzXYZ')
-- 3
-- >>> count_distinct_characters('Jerry')
-- 4

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = count_distinct_characters
    lu.assertEquals(candidate(''), 0)
    lu.assertEquals(candidate('abcde'), 5)
    lu.assertEquals(candidate('abcdecadeCADE'), 5)
    lu.assertEquals(candidate('aaaaAAAAaaaa'), 1)
    lu.assertEquals(candidate('Jerry jERRY JeRRRY'), 5)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a string, find out how many distinct characters (regardless of case) does it consist of
-- >>> count_distinct_characters('xyzXYZ')
-- 3
-- >>> count_distinct_characters('Jerry')
-- 4
local function count_distinct_characters(str)
    local seen = {}
    for i = 1, #str do
        local c = str:sub(i, i):lower()
        seen[c] = true
    end
    local count = 0
    for _ in pairs(seen) do
        count = count + 1
    end
    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = count_distinct_characters
    lu.assertEquals(candidate(''), 0)
    lu.assertEquals(candidate('abcde'), 5)
    lu.assertEquals(candidate('abcdecadeCADE'), 5)
    lu.assertEquals(candidate('aaaaAAAAaaaa'), 1)
    lu.assertEquals(candidate('Jerry jERRY JeRRRY'), 5)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a string, find out how many distinct characters (regardless of case) does it consist of
-- >>> count_distinct_characters('xyzXYZ')
-- 3
-- >>> count_distinct_characters('Jerry')
-- 4
-- | Count the number of distinct characters in a string, ignoring case.
--
-- Example:
--   >>> count_distinct_characters('xyzXYZ')
--   3
--   >>> count_distinct_characters('Jerry')
--   4
--
-- @param str The input string.
-- @return number The number of distinct characters (case‑insensitive).

local function count_distinct_characters(str)
    -- Ensure we have a string; if nil or not a string, return 0
    if type(str) ~= "string" then
        return 0
    end

    -- Convert to lower‑case to ignore case differences
    local lower = str:lower()

    -- Table to keep track of seen characters
    local seen = {}
    local len = #lower

    for i = 1, len do
        local ch = lower:sub(i, i)
        seen[ch] = true
    end

    -- Count the unique keys in the table
    local count = 0
    for _ in pairs(seen) do
        count = count + 1
    end

    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = count_distinct_characters
    lu.assertEquals(candidate(''), 0)
    lu.assertEquals(candidate('abcde'), 5)
    lu.assertEquals(candidate('abcdecadeCADE'), 5)
    lu.assertEquals(candidate('aaaaAAAAaaaa'), 1)
    lu.assertEquals(candidate('Jerry jERRY JeRRRY'), 5)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a string, find out how many distinct characters (regardless of case) does it consist of
-- >>> count_distinct_characters('xyzXYZ')
-- 3
-- >>> count_distinct_characters('Jerry')
-- 4
-- Count the number of distinct characters in a string, ignoring case
local function count_distinct_characters(str)
    -- Convert the string to a single case (lowercase) so that 'A' and 'a' are treated the same
    local lower_str = str:lower()

    -- Table used as a set to keep track of characters we've already seen
    local seen = {}
    local distinct_count = 0

    -- Iterate over each character in the string
    for i = 1, #lower_str do
        local char = lower_str:sub(i, i)  -- Get the i-th character
        if not seen[char] then
            seen[char] = true
            distinct_count = distinct_count + 1
        end
    end

    return distinct_count
end
lu = require('luaunit')

function test_humaneval()
local candidate = count_distinct_characters
    lu.assertEquals(candidate(''), 0)
    lu.assertEquals(candidate('abcde'), 5)
    lu.assertEquals(candidate('abcdecadeCADE'), 5)
    lu.assertEquals(candidate('aaaaAAAAaaaa'), 1)
    lu.assertEquals(candidate('Jerry jERRY JeRRRY'), 5)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a string, find out how many distinct characters (regardless of case) does it consist of
-- >>> count_distinct_characters('xyzXYZ')
-- 3
-- >>> count_distinct_characters('Jerry')
-- 4
-- Count distinct characters in a string, case‑insensitive
local function count_distinct_characters(str)
    -- Convert the whole string to lower case
    local lower = str:lower()

    -- Use a table as a set to store unique characters
    local seen = {}
    local count = 0

    for i = 1, #lower do
        local char = lower:sub(i, i)
        if not seen[char] then
            seen[char] = true
            count = count + 1
        end
    end

    return count
end

-- Example usage
-- print(count_distinct_characters('xyzXYZ'))  -- Output: 3
-- print(count_distinct_characters('Jerry'))   -- Output: 4
lu = require('luaunit')

function test_humaneval()
local candidate = count_distinct_characters
    lu.assertEquals(candidate(''), 0)
    lu.assertEquals(candidate('abcde'), 5)
    lu.assertEquals(candidate('abcdecadeCADE'), 5)
    lu.assertEquals(candidate('aaaaAAAAaaaa'), 1)
    lu.assertEquals(candidate('Jerry jERRY JeRRRY'), 5)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 17 (LUA) - HumanEval_17_parse_music
================================================================================

PROMPT:
----------------------------------------
-- Input to this function is a string representing musical notes in a special ASCII format.
-- Your task is to parse this string and return table of integers corresponding to how many beats does each
-- not last.
-- Here is a legend:
-- 'o' - whole note, lasts four beats
-- 'o|' - half note, lasts two beats
-- '.|' - quater note, lasts one beat
-- >>> parse_music('o o| .| o| o| .| .| .| .| o o')
-- {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = parse_music
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('o o o o'), {4, 4, 4, 4})
    lu.assertEquals(candidate('.| .| .| .|'), {1, 1, 1, 1})
    lu.assertEquals(candidate('o| o| .| .| o o o o'), {2, 2, 1, 1, 4, 4, 4, 4})
    lu.assertEquals(candidate('o| .| o| .| o o| o o|'), {2, 1, 2, 1, 4, 2, 4, 2})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Input to this function is a string representing musical notes in a special ASCII format.
-- Your task is to parse this string and return table of integers corresponding to how many beats does each
-- not last.
-- Here is a legend:
-- 'o' - whole note, lasts four beats
-- 'o|' - half note, lasts two beats
-- '.|' - quater note, lasts one beat
-- >>> parse_music('o o| .| o| o| .| .| .| .| o o')
-- {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}
-- Parse a string of ASCII‑encoded musical notes into a table of beat counts.
--
-- Supported note symbols:
--   "o"   → whole note (4 beats)
--   "o|"  → half note (2 beats)
--   ".|"  → quarter note (1 beat)
--
-- Notes are expected to be separated by whitespace.
--
-- Example:
--   parse_music('o o| .| o| o| .| .| .| .| o o')
--   --> {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}
--
local function parse_music(music_string)
    local beats = {}

    -- Iterate over each non‑whitespace token in the input string.
    for token in string.gmatch(music_string, "%S+") do
        if token == "o" then
            table.insert(beats, 4)
        elseif token == "o|" then
            table.insert(beats, 2)
        elseif token == ".|" then
            table.insert(beats, 1)
        else
            -- If an unknown token is encountered, raise an error.
            error("Unknown note token: " .. token)
        end
    end

    return beats
end
lu = require('luaunit')

function test_humaneval()
local candidate = parse_music
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('o o o o'), {4, 4, 4, 4})
    lu.assertEquals(candidate('.| .| .| .|'), {1, 1, 1, 1})
    lu.assertEquals(candidate('o| o| .| .| o o o o'), {2, 2, 1, 1, 4, 4, 4, 4})
    lu.assertEquals(candidate('o| .| o| .| o o| o o|'), {2, 1, 2, 1, 4, 2, 4, 2})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Input to this function is a string representing musical notes in a special ASCII format.
-- Your task is to parse this string and return table of integers corresponding to how many beats does each
-- not last.
-- Here is a legend:
-- 'o' - whole note, lasts four beats
-- 'o|' - half note, lasts two beats
-- '.|' - quater note, lasts one beat
-- >>> parse_music('o o| .| o| o| .| .| .| .| o o')
-- {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}
-- Parse a musical string into a table of beat counts
local function parse_music(music_string)
    -- Mapping of note symbols to their beat values
    local beats_map = {
        ["o"]  = 4,  -- whole note
        ["o|"] = 2,  -- half note
        [".|"] = 1   -- quarter note
    }

    local result = {}

    -- Iterate over each non‑whitespace token in the input string
    for token in string.gmatch(music_string, "%S+") do
        local beats = beats_map[token]
        if beats then
            table.insert(result, beats)
        else
            -- If an unexpected token is encountered, you can decide how to handle it.
            -- For now we simply ignore it.
        end
    end

    return result
end

-- Example usage:
-- local beats = parse_music('o o| .| o| o| .| .| .| .| o o')
-- print(table.concat(beats, ", "))  --> 4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4
lu = require('luaunit')

function test_humaneval()
local candidate = parse_music
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('o o o o'), {4, 4, 4, 4})
    lu.assertEquals(candidate('.| .| .| .|'), {1, 1, 1, 1})
    lu.assertEquals(candidate('o| o| .| .| o o o o'), {2, 2, 1, 1, 4, 4, 4, 4})
    lu.assertEquals(candidate('o| .| o| .| o o| o o|'), {2, 1, 2, 1, 4, 2, 4, 2})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Input to this function is a string representing musical notes in a special ASCII format.
-- Your task is to parse this string and return table of integers corresponding to how many beats does each
-- not last.
-- Here is a legend:
-- 'o' - whole note, lasts four beats
-- 'o|' - half note, lasts two beats
-- '.|' - quater note, lasts one beat
-- >>> parse_music('o o| .| o| o| .| .| .| .| o o')
-- {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}
-- Parse a string of musical notes into a table of beat counts
-- Legend:
--   'o'   → whole note  (4 beats)
--   'o|'  → half note   (2 beats)
--   '.|'  → quarter note(1 beat)
--
-- Example:
--   parse_music('o o| .| o| o| .| .| .| .| o o')
--   → {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}
local function parse_music(music_string)
  local beats = {}

  -- Iterate over each non‑whitespace token
  for token in music_string:gmatch("%S+") do
    if token == "o" then
      table.insert(beats, 4)
    elseif token == "o|" then
      table.insert(beats, 2)
    elseif token == ".|" then
      table.insert(beats, 1)
    end
  end

  return beats
end
lu = require('luaunit')

function test_humaneval()
local candidate = parse_music
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('o o o o'), {4, 4, 4, 4})
    lu.assertEquals(candidate('.| .| .| .|'), {1, 1, 1, 1})
    lu.assertEquals(candidate('o| o| .| .| o o o o'), {2, 2, 1, 1, 4, 4, 4, 4})
    lu.assertEquals(candidate('o| .| o| .| o o| o o|'), {2, 1, 2, 1, 4, 2, 4, 2})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Input to this function is a string representing musical notes in a special ASCII format.
-- Your task is to parse this string and return table of integers corresponding to how many beats does each
-- not last.
-- Here is a legend:
-- 'o' - whole note, lasts four beats
-- 'o|' - half note, lasts two beats
-- '.|' - quater note, lasts one beat
-- >>> parse_music('o o| .| o| o| .| .| .| .| o o')
-- {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}
-- Parses a string of ASCII‑encoded musical notes and returns a table of beat counts.
-- Supported note symbols:
--   'o'   → whole note (4 beats)
--   'o|'  → half note (2 beats)
--   '.|'  → quarter note (1 beat)
--
-- Example:
--   parse_music('o o| .| o| o| .| .| .| .| o o')
--   --> {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}
local function parse_music(music_string)
    local beats = {}

    -- Iterate over each non‑whitespace token in the input string
    for token in string.gmatch(music_string, "%S+") do
        if token == "o" then
            table.insert(beats, 4)
        elseif token == "o|" then
            table.insert(beats, 2)
        elseif token == ".|" then
            table.insert(beats, 1)
        else
            -- Unknown token – you could raise an error or simply ignore it.
            -- For now we ignore it.
        end
    end

    return beats
end
lu = require('luaunit')

function test_humaneval()
local candidate = parse_music
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('o o o o'), {4, 4, 4, 4})
    lu.assertEquals(candidate('.| .| .| .|'), {1, 1, 1, 1})
    lu.assertEquals(candidate('o| o| .| .| o o o o'), {2, 2, 1, 1, 4, 4, 4, 4})
    lu.assertEquals(candidate('o| .| o| .| o o| o o|'), {2, 1, 2, 1, 4, 2, 4, 2})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 18 (LUA) - HumanEval_18_how_many_times
================================================================================

PROMPT:
----------------------------------------
-- Find how many times a given substring can be found in the original string. Count overlaping cases.
-- >>> how_many_times('', 'a')
-- 0
-- >>> how_many_times('aaa', 'a')
-- 3
-- >>> how_many_times('aaaa', 'aa')
-- 3

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = how_many_times
    lu.assertEquals(candidate('', 'x'), 0)
    lu.assertEquals(candidate('xyxyxyx', 'x'), 4)
    lu.assertEquals(candidate('cacacacac', 'cac'), 4)
    lu.assertEquals(candidate('john doe', 'john'), 1)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Find how many times a given substring can be found in the original string. Count overlaping cases.
-- >>> how_many_times('', 'a')
-- 0
-- >>> how_many_times('aaa', 'a')
-- 3
-- >>> how_many_times('aaaa', 'aa')
-- 3
local function how_many_times(string, substring)
    -- Edge cases: empty string or empty substring
    if string == "" or substring == "" then
        return 0
    end

    local count = 0
    local s_len = #string
    local sub_len = #substring

    -- If the substring is longer than the string, it can't appear
    if sub_len > s_len then
        return 0
    end

    -- Scan the string, allowing overlaps
    for i = 1, s_len - sub_len + 1 do
        if string:sub(i, i + sub_len - 1) == substring then
            count = count + 1
        end
    end

    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = how_many_times
    lu.assertEquals(candidate('', 'x'), 0)
    lu.assertEquals(candidate('xyxyxyx', 'x'), 4)
    lu.assertEquals(candidate('cacacacac', 'cac'), 4)
    lu.assertEquals(candidate('john doe', 'john'), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Find how many times a given substring can be found in the original string. Count overlaping cases.
-- >>> how_many_times('', 'a')
-- 0
-- >>> how_many_times('aaa', 'a')
-- 3
-- >>> how_many_times('aaaa', 'aa')
-- 3
local function how_many_times(string, substring)
    -- If the substring is empty, there are no meaningful matches.
    if #substring == 0 then
        return 0
    end

    local count   = 0
    local slen    = #string
    local sublen  = #substring

    -- Iterate over every possible starting position
    for i = 1, slen - sublen + 1 do
        if string:sub(i, i + sublen - 1) == substring then
            count = count + 1
        end
    end

    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = how_many_times
    lu.assertEquals(candidate('', 'x'), 0)
    lu.assertEquals(candidate('xyxyxyx', 'x'), 4)
    lu.assertEquals(candidate('cacacacac', 'cac'), 4)
    lu.assertEquals(candidate('john doe', 'john'), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Find how many times a given substring can be found in the original string. Count overlaping cases.
-- >>> how_many_times('', 'a')
-- 0
-- >>> how_many_times('aaa', 'a')
-- 3
-- >>> how_many_times('aaaa', 'aa')
-- 3
-- Find how many times a given substring can be found in the original string.
-- Count overlapping cases.
-- >>> how_many_times('', 'a')
-- 0
-- >>> how_many_times('aaa', 'a')
-- 3
-- >>> how_many_times('aaaa', 'aa')
-- 3
local function how_many_times(string, substring)
    local len = #string
    local sublen = #substring

    if sublen == 0 or len == 0 or sublen > len then
        return 0
    end

    local count = 0
    for i = 1, len - sublen + 1 do
        if string:sub(i, i + sublen - 1) == substring then
            count = count + 1
        end
    end

    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = how_many_times
    lu.assertEquals(candidate('', 'x'), 0)
    lu.assertEquals(candidate('xyxyxyx', 'x'), 4)
    lu.assertEquals(candidate('cacacacac', 'cac'), 4)
    lu.assertEquals(candidate('john doe', 'john'), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Find how many times a given substring can be found in the original string. Count overlaping cases.
-- >>> how_many_times('', 'a')
-- 0
-- >>> how_many_times('aaa', 'a')
-- 3
-- >>> how_many_times('aaaa', 'aa')
-- 3
local function how_many_times(string, substring)
  -- Handle nil or empty inputs
  if not string or not substring then
    return 0
  end

  local len_str   = #string
  local len_sub   = #substring

  -- If the substring is longer than the string or empty, no matches are possible
  if len_sub == 0 or len_str < len_sub then
    return 0
  end

  local count = 0
  -- Iterate over all possible starting positions (allowing overlaps)
  for i = 1, len_str - len_sub + 1 do
    if string:sub(i, i + len_sub - 1) == substring then
      count = count + 1
    end
  end

  return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = how_many_times
    lu.assertEquals(candidate('', 'x'), 0)
    lu.assertEquals(candidate('xyxyxyx', 'x'), 4)
    lu.assertEquals(candidate('cacacacac', 'cac'), 4)
    lu.assertEquals(candidate('john doe', 'john'), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 19 (LUA) - HumanEval_19_sort_numbers
================================================================================

PROMPT:
----------------------------------------
-- Input is a space-delimited string of numberals from 'zero' to 'nine'.
-- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
-- Return the string with numbers sorted from smallest to largest
-- >>> sort_numbers('three one five')
-- 'one three five'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = sort_numbers
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('three'), 'three')
    lu.assertEquals(candidate('three five nine'), 'three five nine')
    lu.assertEquals(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')
    lu.assertEquals(candidate('six five four three two one zero'), 'zero one two three four five six')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Input is a space-delimited string of numberals from 'zero' to 'nine'.
-- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
-- Return the string with numbers sorted from smallest to largest
-- >>> sort_numbers('three one five')
-- 'one three five'
-- Sort a space‑delimited list of number words from smallest to largest.
-- Valid words are 'zero' .. 'nine'.
local function sort_numbers(numbers)
    -- Map each word to its numeric value.
    local word_to_num = {
        zero   = 0, one   = 1, two   = 2, three = 3,
        four   = 4, five  = 5, six   = 6, seven = 7,
        eight  = 8, nine  = 9
    }

    -- Split the input string into individual words.
    local words = {}
    for w in string.gmatch(numbers, "%S+") do
        table.insert(words, w)
    end

    -- Sort the words according to their numeric value.
    table.sort(words, function(a, b)
        return word_to_num[a] < word_to_num[b]
    end)

    -- Join the sorted words back into a single string.
    return table.concat(words, " ")
end
lu = require('luaunit')

function test_humaneval()
local candidate = sort_numbers
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('three'), 'three')
    lu.assertEquals(candidate('three five nine'), 'three five nine')
    lu.assertEquals(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')
    lu.assertEquals(candidate('six five four three two one zero'), 'zero one two three four five six')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Input is a space-delimited string of numberals from 'zero' to 'nine'.
-- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
-- Return the string with numbers sorted from smallest to largest
-- >>> sort_numbers('three one five')
-- 'one three five'
-- Sort a space‑delimited string of number words from smallest to largest
local function sort_numbers(numbers)
  -- Mapping from word to numeric value
  local to_num = {
    zero  = 0, one   = 1, two   = 2, three = 3,
    four  = 4, five  = 5, six   = 6, seven = 7,
    eight = 8, nine  = 9
  }

  -- Reverse mapping (numeric value → word)
  local to_word = {}
  for word, num in pairs(to_num) do
    to_word[num] = word
  end

  -- Empty input → empty output
  if numbers == "" then
    return ""
  end

  -- Split the input into individual words
  local words = {}
  for w in string.gmatch(numbers, "%S+") do
    table.insert(words, w)
  end

  -- Sort the words by their numeric value
  table.sort(words, function(a, b)
    return to_num[a] < to_num[b]
  end)

  -- Join the sorted words back into a string
  return table.concat(words, " ")
end
lu = require('luaunit')

function test_humaneval()
local candidate = sort_numbers
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('three'), 'three')
    lu.assertEquals(candidate('three five nine'), 'three five nine')
    lu.assertEquals(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')
    lu.assertEquals(candidate('six five four three two one zero'), 'zero one two three four five six')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Input is a space-delimited string of numberals from 'zero' to 'nine'.
-- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
-- Return the string with numbers sorted from smallest to largest
-- >>> sort_numbers('three one five')
-- 'one three five'
local function sort_numbers(numbers)
    -- Mapping from word to its numeric value
    local word_to_num = {
        zero   = 0,
        one    = 1,
        two    = 2,
        three  = 3,
        four   = 4,
        five   = 5,
        six    = 6,
        seven  = 7,
        eight  = 8,
        nine   = 9
    }

    -- Handle nil or empty input
    if not numbers or numbers == '' then
        return ''
    end

    -- Split the input string into words
    local words = {}
    for word in string.gmatch(numbers, "%S+") do
        table.insert(words, word)
    end

    -- Sort the words based on their numeric value
    table.sort(words, function(a, b)
        return word_to_num[a] < word_to_num[b]
    end)

    -- Join the sorted words back into a string
    return table.concat(words, ' ')
end
lu = require('luaunit')

function test_humaneval()
local candidate = sort_numbers
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('three'), 'three')
    lu.assertEquals(candidate('three five nine'), 'three five nine')
    lu.assertEquals(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')
    lu.assertEquals(candidate('six five four three two one zero'), 'zero one two three four five six')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Input is a space-delimited string of numberals from 'zero' to 'nine'.
-- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
-- Return the string with numbers sorted from smallest to largest
-- >>> sort_numbers('three one five')
-- 'one three five'
local function sort_numbers(numbers)
  -- Mapping from word to numeric value
  local word_to_num = {
    zero   = 0, one    = 1, two    = 2, three  = 3, four   = 4,
    five   = 5, six    = 6, seven  = 7, eight  = 8, nine   = 9
  }
  -- Reverse mapping from numeric value to word
  local num_to_word = {}
  for w, n in pairs(word_to_num) do
    num_to_word[n] = w
  end

  -- Split the input string into words
  local words = {}
  for w in string.gmatch(numbers or "", "%S+") do
    table.insert(words, w)
  end

  -- Sort the words by their numeric value
  table.sort(words, function(a, b)
    return word_to_num[a] < word_to_num[b]
  end)

  -- Convert back to a space‑delimited string
  return table.concat(words, " ")
end
lu = require('luaunit')

function test_humaneval()
local candidate = sort_numbers
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('three'), 'three')
    lu.assertEquals(candidate('three five nine'), 'three five nine')
    lu.assertEquals(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')
    lu.assertEquals(candidate('six five four three two one zero'), 'zero one two three four five six')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154466
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 22 (LUA) - HumanEval_22_filter_integers
================================================================================

PROMPT:
----------------------------------------
-- Filter given table of any luathon values only for integers
-- >>> filter_integers({'a', 3.14, 5})
-- {5}
-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})
-- {1, 2, 3}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = filter_integers
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({4, {}, {}, 23.2, 9, 'adasd'}), {4, 9})
    lu.assertEquals(candidate({3, 'c', 3, 3, 'a', 'b'}), {3, 3, 3})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Filter given table of any luathon values only for integers
-- >>> filter_integers({'a', 3.14, 5})
-- {5}
-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})
-- {1, 2, 3}
-- Filter given table of any luathon values only for integers
-- >>> filter_integers({'a', 3.14, 5})
-- {5}
-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})
-- {1, 2, 3}
local function filter_integers(values)
  local result = {}
  for _, v in ipairs(values) do
    if type(v) == "number" and math.floor(v) == v then
      table.insert(result, v)
    end
  end
  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = filter_integers
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({4, {}, {}, 23.2, 9, 'adasd'}), {4, 9})
    lu.assertEquals(candidate({3, 'c', 3, 3, 'a', 'b'}), {3, 3, 3})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154467
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Filter given table of any luathon values only for integers
-- >>> filter_integers({'a', 3.14, 5})
-- {5}
-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})
-- {1, 2, 3}
-- Filter given table of any luathon values only for integers
-- >>> filter_integers({'a', 3.14, 5})
-- {5}
-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})
-- {1, 2, 3}
local function filter_integers(values)
  local result = {}

  -- Helper to determine if a number is an integer.
  local function is_integer(n)
    if type(n) ~= "number" then
      return false
    end

    -- Prefer Lua 5.3+ integer check if available.
    if math.type then
      return math.type(n) == "integer"
    end

    -- Fallback for older Lua versions.
    return n == math.floor(n)
  end

  for _, v in ipairs(values) do
    if is_integer(v) then
      table.insert(result, v)
    end
  end

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = filter_integers
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({4, {}, {}, 23.2, 9, 'adasd'}), {4, 9})
    lu.assertEquals(candidate({3, 'c', 3, 3, 'a', 'b'}), {3, 3, 3})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154467
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Filter given table of any luathon values only for integers
-- >>> filter_integers({'a', 3.14, 5})
-- {5}
-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})
-- {1, 2, 3}
-- Filter given table of any luathon values only for integers
-- >>> filter_integers({'a', 3.14, 5})
-- {5}
-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})
-- {1, 2, 3}
local function filter_integers(values)
  local result = {}
  for _, v in ipairs(values) do
    if type(v) == 'number' and v % 1 == 0 then
      table.insert(result, v)
    end
  end
  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = filter_integers
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({4, {}, {}, 23.2, 9, 'adasd'}), {4, 9})
    lu.assertEquals(candidate({3, 'c', 3, 3, 'a', 'b'}), {3, 3, 3})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154467
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Filter given table of any luathon values only for integers
-- >>> filter_integers({'a', 3.14, 5})
-- {5}
-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})
-- {1, 2, 3}
-- Filter given table of any luathon values only for integers
-- >>> filter_integers({'a', 3.14, 5})
-- {5}
-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})
-- {1, 2, 3}
local function filter_integers(values)
    local result = {}
    for _, v in ipairs(values) do
        if type(v) == "number" then
            -- Lua 5.3+ has integer type support
            if math.type then
                if math.type(v) == "integer" then
                    table.insert(result, v)
                end
            else
                -- Fallback for older Lua versions
                if v % 1 == 0 then
                    table.insert(result, v)
                end
            end
        end
    end
    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = filter_integers
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({4, {}, {}, 23.2, 9, 'adasd'}), {4, 9})
    lu.assertEquals(candidate({3, 'c', 3, 3, 'a', 'b'}), {3, 3, 3})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154467
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------
