As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 18 (ML) - HumanEval_18_how_many_times
================================================================================

PROMPT:
----------------------------------------
(**Find how many times a given substring can be found in the original string. Count overlaping cases.
 * >>> how_many_times "" "a"
 * 0
 * >>> how_many_times "aaa" "a"
 * 3
 * >>> how_many_times "aaaa" "aa"
 * 3
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = how_many_times in
  (assert ((candidate "" "x") = 0));
  (assert ((candidate "xyxyxyx" "x") = 4));
  (assert ((candidate "cacacacac" "cac") = 4));
  (assert ((candidate "john doe" "john") = 1));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Find how many times a given substring can be found in the original string. Count overlaping cases.
 * >>> how_many_times "" "a"
 * 0
 * >>> how_many_times "aaa" "a"
 * 3
 * >>> how_many_times "aaaa" "aa"
 * 3
*)
let how_many_times (string : string) (substring : string) : int =
  let n = String.length string in
  let m = String.length substring in
  if m = 0 then 0
  else
    let rec aux i count =
      if i + m > n then count
      else
        if String.sub string i m = substring
        then aux (i + 1) (count + 1)
        else aux (i + 1) count
    in
    aux 0 0

let assertions =
 let candidate = how_many_times in
  (assert ((candidate "" "x") = 0));
  (assert ((candidate "xyxyxyx" "x") = 4));
  (assert ((candidate "cacacacac" "cac") = 4));
  (assert ((candidate "john doe" "john") = 1));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Find how many times a given substring can be found in the original string. Count overlaping cases.
 * >>> how_many_times "" "a"
 * 0
 * >>> how_many_times "aaa" "a"
 * 3
 * >>> how_many_times "aaaa" "aa"
 * 3
*)
let how_many_times (string : string) (substring : string) : int =
  let n = String.length string in
  let m = String.length substring in
  if m = 0 then 0  (* empty substring is not counted *)
  else
    let rec aux i acc =
      if i > n - m then acc
      else
        if String.sub string i m = substring
        then aux (i + 1) (acc + 1)
        else aux (i + 1) acc
    in
    aux 0 0

let assertions =
 let candidate = how_many_times in
  (assert ((candidate "" "x") = 0));
  (assert ((candidate "xyxyxyx" "x") = 4));
  (assert ((candidate "cacacacac" "cac") = 4));
  (assert ((candidate "john doe" "john") = 1));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Find how many times a given substring can be found in the original string. Count overlaping cases.
 * >>> how_many_times "" "a"
 * 0
 * >>> how_many_times "aaa" "a"
 * 3
 * >>> how_many_times "aaaa" "aa"
 * 3
*)
let how_many_times (string : string) (substring : string) : int =
  let len_s = String.length string in
  let len_sub = String.length substring in
  if len_sub = 0 || len_s < len_sub then 0
  else
    let rec aux i count =
      if i > len_s - len_sub then count
      else
        if String.sub string i len_sub = substring then aux (i + 1) (count + 1)
        else aux (i + 1) count
    in aux 0 0

let assertions =
 let candidate = how_many_times in
  (assert ((candidate "" "x") = 0));
  (assert ((candidate "xyxyxyx" "x") = 4));
  (assert ((candidate "cacacacac" "cac") = 4));
  (assert ((candidate "john doe" "john") = 1));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Find how many times a given substring can be found in the original string. Count overlaping cases.
 * >>> how_many_times "" "a"
 * 0
 * >>> how_many_times "aaa" "a"
 * 3
 * >>> how_many_times "aaaa" "aa"
 * 3
*)
(** Find how many times a given substring can be found in the original string.
    Count overlapping cases. *)
let how_many_times (string : string) (substring : string) : int =
  let n = String.length string in
  let m = String.length substring in
  if m = 0 then 0  (* Empty substring – treat as 0 occurrences *)
  else
    let rec aux i acc =
      if i > n - m then acc
      else
        if String.sub string i m = substring
        then aux (i + 1) (acc + 1)
        else aux (i + 1) acc
    in
    aux 0 0

let assertions =
 let candidate = how_many_times in
  (assert ((candidate "" "x") = 0));
  (assert ((candidate "xyxyxyx" "x") = 4));
  (assert ((candidate "cacacacac" "cac") = 4));
  (assert ((candidate "john doe" "john") = 1));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 21 (ML) - HumanEval_21_rescale_to_unit
================================================================================

PROMPT:
----------------------------------------
(**Given list of numbers (of at least two elements), apply a linear transform to that list,
 * such that the smallest number will become 0 and the largest will become 1
 * >>> rescale_to_unit [1.0; 2.0; 3.0; 4.0; 5.0]
 * [0.0; 0.25; 0.5; 0.75; 1.0]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = rescale_to_unit in
  (assert ((candidate [2.0; 49.9]) = [0.0; 1.0]));
  (assert ((candidate [100.0; 49.9]) = [1.0; 0.0]));
  (assert ((candidate [1.0; 2.0; 3.0; 4.0; 5.0]) = [0.0; 0.25; 0.5; 0.75; 1.0]));
  (assert ((candidate [2.0; 1.0; 5.0; 3.0; 4.0]) = [0.25; 0.0; 1.0; 0.5; 0.75]));
  (assert ((candidate [12.0; 11.0; 15.0; 13.0; 14.0]) = [0.25; 0.0; 1.0; 0.5; 0.75]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given list of numbers (of at least two elements), apply a linear transform to that list,
 * such that the smallest number will become 0 and the largest will become 1
 * >>> rescale_to_unit [1.0; 2.0; 3.0; 4.0; 5.0]
 * [0.0; 0.25; 0.5; 0.75; 1.0]
*)
let rescale_to_unit (numbers : float list) : float list =
  (* Find the minimum and maximum values in the list. *)
  let min_val =
    List.fold_left min (List.hd numbers) (List.tl numbers)
  in
  let max_val =
    List.fold_left max (List.hd numbers) (List.tl numbers)
  in
  (* If all numbers are equal, avoid division by zero and return a list of zeros. *)
  if min_val = max_val then
    List.map (fun _ -> 0.0) numbers
  else
    (* Apply the linear transformation to each number. *)
    List.map (fun x -> (x -. min_val) /. (max_val -. min_val)) numbers

let assertions =
 let candidate = rescale_to_unit in
  (assert ((candidate [2.0; 49.9]) = [0.0; 1.0]));
  (assert ((candidate [100.0; 49.9]) = [1.0; 0.0]));
  (assert ((candidate [1.0; 2.0; 3.0; 4.0; 5.0]) = [0.0; 0.25; 0.5; 0.75; 1.0]));
  (assert ((candidate [2.0; 1.0; 5.0; 3.0; 4.0]) = [0.25; 0.0; 1.0; 0.5; 0.75]));
  (assert ((candidate [12.0; 11.0; 15.0; 13.0; 14.0]) = [0.25; 0.0; 1.0; 0.5; 0.75]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given list of numbers (of at least two elements), apply a linear transform to that list,
 * such that the smallest number will become 0 and the largest will become 1
 * >>> rescale_to_unit [1.0; 2.0; 3.0; 4.0; 5.0]
 * [0.0; 0.25; 0.5; 0.75; 1.0]
*)
(** Given list of numbers (of at least two elements), apply a linear transform to that list,
    * such that the smallest number will become 0 and the largest will become 1
    * >>> rescale_to_unit [1.0; 2.0; 3.0; 4.0; 5.0]
    * [0.0; 0.25; 0.5; 0.75; 1.0]
*)
let rescale_to_unit (numbers : float list) : float list =
  (* Helper to find the minimum value in the list *)
  let min_val =
    List.fold_left
      (fun acc n -> if n < acc then n else acc)
      (List.hd numbers)
      numbers
  in
  (* Helper to find the maximum value in the list *)
  let max_val =
    List.fold_left
      (fun acc n -> if n > acc then n else acc)
      (List.hd numbers)
      numbers
  in
  (* Avoid division by zero: if all numbers are equal, return a list of zeros *)
  if max_val = min_val then
    List.map (fun _ -> 0.0) numbers
  else
    List.map (fun n -> (n -. min_val) /. (max_val -. min_val)) numbers

let assertions =
 let candidate = rescale_to_unit in
  (assert ((candidate [2.0; 49.9]) = [0.0; 1.0]));
  (assert ((candidate [100.0; 49.9]) = [1.0; 0.0]));
  (assert ((candidate [1.0; 2.0; 3.0; 4.0; 5.0]) = [0.0; 0.25; 0.5; 0.75; 1.0]));
  (assert ((candidate [2.0; 1.0; 5.0; 3.0; 4.0]) = [0.25; 0.0; 1.0; 0.5; 0.75]));
  (assert ((candidate [12.0; 11.0; 15.0; 13.0; 14.0]) = [0.25; 0.0; 1.0; 0.5; 0.75]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given list of numbers (of at least two elements), apply a linear transform to that list,
 * such that the smallest number will become 0 and the largest will become 1
 * >>> rescale_to_unit [1.0; 2.0; 3.0; 4.0; 5.0]
 * [0.0; 0.25; 0.5; 0.75; 1.0]
*)
let rescale_to_unit (numbers : float list) : float list =
  (* Find the minimum and maximum values in the list *)
  let min_val =
    List.fold_left min max_float numbers
  in
  let max_val =
    List.fold_left max min_float numbers
  in
  let range = max_val -. min_val in
  (* If all numbers are identical, map them all to 0.0 to avoid division by zero *)
  if range = 0.0 then
    List.map (fun _ -> 0.0) numbers
  else
    List.map (fun x -> (x -. min_val) /. range) numbers

let assertions =
 let candidate = rescale_to_unit in
  (assert ((candidate [2.0; 49.9]) = [0.0; 1.0]));
  (assert ((candidate [100.0; 49.9]) = [1.0; 0.0]));
  (assert ((candidate [1.0; 2.0; 3.0; 4.0; 5.0]) = [0.0; 0.25; 0.5; 0.75; 1.0]));
  (assert ((candidate [2.0; 1.0; 5.0; 3.0; 4.0]) = [0.25; 0.0; 1.0; 0.5; 0.75]));
  (assert ((candidate [12.0; 11.0; 15.0; 13.0; 14.0]) = [0.25; 0.0; 1.0; 0.5; 0.75]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given list of numbers (of at least two elements), apply a linear transform to that list,
 * such that the smallest number will become 0 and the largest will become 1
 * >>> rescale_to_unit [1.0; 2.0; 3.0; 4.0; 5.0]
 * [0.0; 0.25; 0.5; 0.75; 1.0]
*)
let rescale_to_unit (numbers : float list) : float list =
  (* Find the minimum and maximum values in the list *)
  let min_val, max_val =
    List.fold_left
      (fun (min_acc, max_acc) n ->
        let min_acc = min min_acc n in
        let max_acc = max max_acc n in
        (min_acc, max_acc))
      (max_float, min_float) numbers
  in
  let range = max_val -. min_val in
  (* If all numbers are equal, return a list of zeros *)
  if range = 0.0 then
    List.map (fun _ -> 0.0) numbers
  else
    List.map (fun n -> (n -. min_val) /. range) numbers

let assertions =
 let candidate = rescale_to_unit in
  (assert ((candidate [2.0; 49.9]) = [0.0; 1.0]));
  (assert ((candidate [100.0; 49.9]) = [1.0; 0.0]));
  (assert ((candidate [1.0; 2.0; 3.0; 4.0; 5.0]) = [0.0; 0.25; 0.5; 0.75; 1.0]));
  (assert ((candidate [2.0; 1.0; 5.0; 3.0; 4.0]) = [0.25; 0.0; 1.0; 0.5; 0.75]));
  (assert ((candidate [12.0; 11.0; 15.0; 13.0; 14.0]) = [0.25; 0.0; 1.0; 0.5; 0.75]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 23 (ML) - HumanEval_23_strlen
================================================================================

PROMPT:
----------------------------------------
(**Return length of given string
 * >>> strlen ""
 * 0
 * >>> strlen "abc"
 * 3
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = strlen in
  (assert ((candidate "") = 0));
  (assert ((candidate "x") = 1));
  (assert ((candidate "asdasnakj") = 9));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Return length of given string
 * >>> strlen ""
 * 0
 * >>> strlen "abc"
 * 3
*)
let strlen (s : string) : int =
  String.length s

let assertions =
 let candidate = strlen in
  (assert ((candidate "") = 0));
  (assert ((candidate "x") = 1));
  (assert ((candidate "asdasnakj") = 9));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Return length of given string
 * >>> strlen ""
 * 0
 * >>> strlen "abc"
 * 3
*)
(* Return length of given string
 * >>> strlen ""
 * 0
 * >>> strlen "abc"
 * 3
*)
let strlen (s : string) : int =
  String.length s

let assertions =
 let candidate = strlen in
  (assert ((candidate "") = 0));
  (assert ((candidate "x") = 1));
  (assert ((candidate "asdasnakj") = 9));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Return length of given string
 * >>> strlen ""
 * 0
 * >>> strlen "abc"
 * 3
*)
let strlen (string : string) : int =
  String.length string

let assertions =
 let candidate = strlen in
  (assert ((candidate "") = 0));
  (assert ((candidate "x") = 1));
  (assert ((candidate "asdasnakj") = 9));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Return length of given string
 * >>> strlen ""
 * 0
 * >>> strlen "abc"
 * 3
*)
let strlen (string : string) : int =
  String.length string

let assertions =
 let candidate = strlen in
  (assert ((candidate "") = 0));
  (assert ((candidate "x") = 1));
  (assert ((candidate "asdasnakj") = 9));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 24 (ML) - HumanEval_24_largest_divisor
================================================================================

PROMPT:
----------------------------------------
(**For a given number n, find the largest number that divides n evenly, smaller than n
 * >>> largest_divisor 15
 * 5
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = largest_divisor in
  (assert ((candidate 3) = 1));
  (assert ((candidate 7) = 1));
  (assert ((candidate 10) = 5));
  (assert ((candidate 100) = 50));
  (assert ((candidate 49) = 7));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**For a given number n, find the largest number that divides n evenly, smaller than n
 * >>> largest_divisor 15
 * 5
*)
(* Find the largest divisor of n that is strictly smaller than n.
   If n is prime (or n = 1) the function returns 1 (the only proper divisor). *)
let largest_divisor (n : int) : int =
  (* Handle the edge case where n is 0 or 1 – return 0 as there is no proper divisor. *)
  if n <= 1 then 0
  else
    (* Start checking from n-1 downwards until we find a divisor. *)
    let rec loop d =
      if d = 1 then 1               (* n is prime, so 1 is the largest proper divisor *)
      else if n mod d = 0 then d    (* found the largest proper divisor *)
      else loop (d - 1)             (* continue searching *)
    in
    loop (n - 1)

let assertions =
 let candidate = largest_divisor in
  (assert ((candidate 3) = 1));
  (assert ((candidate 7) = 1));
  (assert ((candidate 10) = 5));
  (assert ((candidate 100) = 50));
  (assert ((candidate 49) = 7));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**For a given number n, find the largest number that divides n evenly, smaller than n
 * >>> largest_divisor 15
 * 5
*)
(* For a given number n, find the largest number that divides n evenly,
   smaller than n *)
let largest_divisor (n : int) : int =
  (* If n is 0 or 1 there is no proper divisor, return 0 *)
  if n <= 1 then 0
  else
    let rec find d =
      if d = 1 then 1              (* 1 always divides n *)
      else if n mod d = 0 then d   (* d is a divisor *)
      else find (d - 1)            (* try the next smaller number *)
    in
    find (n / 2)                    (* start from the largest possible divisor *)

let assertions =
 let candidate = largest_divisor in
  (assert ((candidate 3) = 1));
  (assert ((candidate 7) = 1));
  (assert ((candidate 10) = 5));
  (assert ((candidate 100) = 50));
  (assert ((candidate 49) = 7));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**For a given number n, find the largest number that divides n evenly, smaller than n
 * >>> largest_divisor 15
 * 5
*)
(* Find the largest integer that divides n evenly and is strictly smaller than n. *)
let largest_divisor (n : int) : int =
  (* Helper function that searches downwards from the current candidate i. *)
  let rec aux i =
    if i <= 1 then
      (* If we reach 1, it is the only divisor left. *)
      1
    else if n mod i = 0 then
      (* i divides n evenly – this is the largest such divisor. *)
      i
    else
      (* Continue searching with the next smaller candidate. *)
      aux (i - 1)
  in
  (* Start the search from n-1, the largest possible proper divisor. *)
  aux (n - 1)

let assertions =
 let candidate = largest_divisor in
  (assert ((candidate 3) = 1));
  (assert ((candidate 7) = 1));
  (assert ((candidate 10) = 5));
  (assert ((candidate 100) = 50));
  (assert ((candidate 49) = 7));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**For a given number n, find the largest number that divides n evenly, smaller than n
 * >>> largest_divisor 15
 * 5
*)
(* Find the largest proper divisor of n (i.e., the greatest integer < n that divides n). *)
let largest_divisor (n : int) : int =
  (* Helper that searches downward from n-1 until it finds a divisor. *)
  let rec aux i =
    if i = 0 then 1                         (* fallback – only reached for n = 1 *)
    else if n mod i = 0 then i              (* i divides n → it is the largest one *)
    else aux (i - 1)                        (* keep searching *)
  in
  aux (n - 1)

let assertions =
 let candidate = largest_divisor in
  (assert ((candidate 3) = 1));
  (assert ((candidate 7) = 1));
  (assert ((candidate 10) = 5));
  (assert ((candidate 100) = 50));
  (assert ((candidate 49) = 7));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 25 (ML) - HumanEval_25_factorize
================================================================================

PROMPT:
----------------------------------------
(**Return list of prime factors of given integer in the order from smallest to largest.
 * Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
 * Input number should be equal to the product of all factors
 * >>> factorize 8
 * [2; 2; 2]
 * >>> factorize 25
 * [5; 5]
 * >>> factorize 70
 * [2; 5; 7]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = factorize in
  (assert ((candidate 2) = [2]));
  (assert ((candidate 4) = [2; 2]));
  (assert ((candidate 8) = [2; 2; 2]));
  (assert ((candidate 57) = [3; 19]));
  (assert ((candidate 3249) = [3; 3; 19; 19]));
  (assert ((candidate 185193) = [3; 3; 3; 19; 19; 19]));
  (assert ((candidate 20577) = [3; 19; 19; 19]));
  (assert ((candidate 18) = [2; 3; 3]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Return list of prime factors of given integer in the order from smallest to largest.
 * Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
 * Input number should be equal to the product of all factors
 * >>> factorize 8
 * [2; 2; 2]
 * >>> factorize 25
 * [5; 5]
 * >>> factorize 70
 * [2; 5; 7]
*)
(** Return list of prime factors of given integer in the order from smallest to largest.
 *  Each of the factors should be listed number of times corresponding to how many times
 *  it appears in factorization.
 *  Input number should be equal to the product of all factors
 *  >>> factorize 8
 *  [2; 2; 2]
 *  >>> factorize 25
 *  [5; 5]
 *  >>> factorize 70
 *  [2; 5; 7]
*)
let factorize (n : int) : int list =
  let rec aux n d acc =
    if d * d > n then
      (* If n > 1, it is a prime factor larger than sqrt(original n) *)
      if n > 1 then n :: acc else acc
    else if n mod d = 0 then
      aux (n / d) d (d :: acc)      (* Found a factor, keep dividing by same d *)
    else
      aux n (d + 1) acc              (* Try next potential divisor *)
  in
  List.rev (aux n 2 [])

let assertions =
 let candidate = factorize in
  (assert ((candidate 2) = [2]));
  (assert ((candidate 4) = [2; 2]));
  (assert ((candidate 8) = [2; 2; 2]));
  (assert ((candidate 57) = [3; 19]));
  (assert ((candidate 3249) = [3; 3; 19; 19]));
  (assert ((candidate 185193) = [3; 3; 3; 19; 19; 19]));
  (assert ((candidate 20577) = [3; 19; 19; 19]));
  (assert ((candidate 18) = [2; 3; 3]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Return list of prime factors of given integer in the order from smallest to largest.
 * Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
 * Input number should be equal to the product of all factors
 * >>> factorize 8
 * [2; 2; 2]
 * >>> factorize 25
 * [5; 5]
 * >>> factorize 70
 * [2; 5; 7]
*)
(* Return list of prime factors of given integer in the order from smallest to largest.
 * Each of the factors should be listed number of times corresponding to how many times
 * it appears in the factorization.
 * Input number should be equal to the product of all factors
 * >>> factorize 8
 * [2; 2; 2]
 * >>> factorize 25
 * [5; 5]
 * >>> factorize 70
 * [2; 5; 7]
 *)
let factorize (n : int) : int list =
  let rec aux n divisor acc =
    if n = 1 then List.rev acc
    else if divisor * divisor > n then List.rev (n :: acc)
    else if n mod divisor = 0 then aux (n / divisor) divisor (divisor :: acc)
    else aux n (divisor + 1) acc
  in
  if n <= 1 then [] else aux n 2 []

let assertions =
 let candidate = factorize in
  (assert ((candidate 2) = [2]));
  (assert ((candidate 4) = [2; 2]));
  (assert ((candidate 8) = [2; 2; 2]));
  (assert ((candidate 57) = [3; 19]));
  (assert ((candidate 3249) = [3; 3; 19; 19]));
  (assert ((candidate 185193) = [3; 3; 3; 19; 19; 19]));
  (assert ((candidate 20577) = [3; 19; 19; 19]));
  (assert ((candidate 18) = [2; 3; 3]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Return list of prime factors of given integer in the order from smallest to largest.
 * Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
 * Input number should be equal to the product of all factors
 * >>> factorize 8
 * [2; 2; 2]
 * >>> factorize 25
 * [5; 5]
 * >>> factorize 70
 * [2; 5; 7]
*)
(* Return list of prime factors of given integer in the order from smallest to largest.
 * Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
 * Input number should be equal to the product of all factors
 * >>> factorize 8
 * [2; 2; 2]
 * >>> factorize 25
 * [5; 5]
 * >>> factorize 70
 * [2; 5; 7]
*)
let factorize (n : int) : int list =
  (* Helper: recursively factorize n starting from divisor d.
     Accumulator acc collects factors in reverse order. *)
  let rec aux n d acc =
    if n = 1 then List.rev acc
    else if d * d > n then List.rev (n :: acc)  (* n is prime *)
    else if n mod d = 0 then aux (n / d) d (d :: acc)
    else aux n (d + 1) acc
  in
  if n <= 1 then []
  else aux n 2 []

let assertions =
 let candidate = factorize in
  (assert ((candidate 2) = [2]));
  (assert ((candidate 4) = [2; 2]));
  (assert ((candidate 8) = [2; 2; 2]));
  (assert ((candidate 57) = [3; 19]));
  (assert ((candidate 3249) = [3; 3; 19; 19]));
  (assert ((candidate 185193) = [3; 3; 3; 19; 19; 19]));
  (assert ((candidate 20577) = [3; 19; 19; 19]));
  (assert ((candidate 18) = [2; 3; 3]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Return list of prime factors of given integer in the order from smallest to largest.
 * Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
 * Input number should be equal to the product of all factors
 * >>> factorize 8
 * [2; 2; 2]
 * >>> factorize 25
 * [5; 5]
 * >>> factorize 70
 * [2; 5; 7]
*)
let factorize (n : int) : int list =
  if n <= 1 then []
  else
    let rec aux n d acc =
      if d * d > n then
        if n > 1 then n :: acc else acc
      else if n mod d = 0 then
        aux (n / d) d (d :: acc)
      else
        aux n (d + 1) acc
    in
    List.rev (aux n 2 [])

let assertions =
 let candidate = factorize in
  (assert ((candidate 2) = [2]));
  (assert ((candidate 4) = [2; 2]));
  (assert ((candidate 8) = [2; 2; 2]));
  (assert ((candidate 57) = [3; 19]));
  (assert ((candidate 3249) = [3; 3; 19; 19]));
  (assert ((candidate 185193) = [3; 3; 3; 19; 19; 19]));
  (assert ((candidate 20577) = [3; 19; 19; 19]));
  (assert ((candidate 18) = [2; 3; 3]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183712
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 26 (ML) - HumanEval_26_remove_duplicates
================================================================================

PROMPT:
----------------------------------------
(**From a list of integers, remove all elements that occur more than once.
 * Keep order of elements left the same as in the input.
 * >>> remove_duplicates [1; 2; 3; 2; 4]
 * [1; 3; 4]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = remove_duplicates in
  (assert ((candidate []) = []));
  (assert ((candidate [1; 2; 3; 4]) = [1; 2; 3; 4]));
  (assert ((candidate [1; 2; 3; 2; 4; 3; 5]) = [1; 4; 5]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**From a list of integers, remove all elements that occur more than once.
 * Keep order of elements left the same as in the input.
 * >>> remove_duplicates [1; 2; 3; 2; 4]
 * [1; 3; 4]
*)
(* From a list of integers, remove all elements that occur more than once.
 * Keep order of elements left the same as in the input.
 * >>> remove_duplicates [1; 2; 3; 2; 4]
 * [1; 3; 4]
 *)
let remove_duplicates (numbers : int list) : int list =
  (* Build a frequency map as an association list *)
  let freq =
    List.fold_left
      (fun acc n ->
        let count =
          try List.assoc n acc with Not_found -> 0
        in
        (* Replace old entry with updated count *)
        (n, count + 1) :: List.remove_assoc n acc)
      [] numbers
  in
  (* Keep only those numbers whose count is exactly 1 *)
  List.filter (fun n -> List.assoc n freq = 1) numbers

let assertions =
 let candidate = remove_duplicates in
  (assert ((candidate []) = []));
  (assert ((candidate [1; 2; 3; 4]) = [1; 2; 3; 4]));
  (assert ((candidate [1; 2; 3; 2; 4; 3; 5]) = [1; 4; 5]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**From a list of integers, remove all elements that occur more than once.
 * Keep order of elements left the same as in the input.
 * >>> remove_duplicates [1; 2; 3; 2; 4]
 * [1; 3; 4]
*)
(* From a list of integers, remove all elements that occur more than once.
 * Keep order of elements left the same as in the input.
 * >>> remove_duplicates [1; 2; 3; 2; 4]
 * [1; 3; 4]
 *)
let remove_duplicates (numbers : int list) : int list =
  (* Count occurrences of each number *)
  let freq_tbl = Hashtbl.create 16 in
  List.iter (fun n ->
    let current = Hashtbl.find_opt freq_tbl n |> Option.value ~default:0 in
    Hashtbl.replace freq_tbl n (current + 1)
  ) numbers;

  (* Keep only numbers that appear exactly once *)
  List.filter (fun n ->
    Hashtbl.find_opt freq_tbl n = Some 1
  ) numbers

let assertions =
 let candidate = remove_duplicates in
  (assert ((candidate []) = []));
  (assert ((candidate [1; 2; 3; 4]) = [1; 2; 3; 4]));
  (assert ((candidate [1; 2; 3; 2; 4; 3; 5]) = [1; 4; 5]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**From a list of integers, remove all elements that occur more than once.
 * Keep order of elements left the same as in the input.
 * >>> remove_duplicates [1; 2; 3; 2; 4]
 * [1; 3; 4]
*)
(** From a list of integers, remove all elements that occur more than once.
 * Keep order of elements left the same as in the input.
 * >>> remove_duplicates [1; 2; 3; 2; 4]
 * [1; 3; 4]
*)
let remove_duplicates (numbers : int list) : int list =
  (* First pass: build a frequency table *)
  let freq_tbl = Hashtbl.create (List.length numbers) in
  List.iter (fun n ->
    let count = Hashtbl.find_opt freq_tbl n |> Option.value ~default:0 in
    Hashtbl.replace freq_tbl n (count + 1)
  ) numbers;
  (* Second pass: keep only those with frequency 1 *)
  List.filter (fun n ->
    Hashtbl.find_opt freq_tbl n |> Option.value ~default:0 = 1
  ) numbers

let assertions =
 let candidate = remove_duplicates in
  (assert ((candidate []) = []));
  (assert ((candidate [1; 2; 3; 4]) = [1; 2; 3; 4]));
  (assert ((candidate [1; 2; 3; 2; 4; 3; 5]) = [1; 4; 5]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**From a list of integers, remove all elements that occur more than once.
 * Keep order of elements left the same as in the input.
 * >>> remove_duplicates [1; 2; 3; 2; 4]
 * [1; 3; 4]
*)
let remove_duplicates (numbers : int list) : int list =
  (* Build a frequency table for all elements *)
  let freq = Hashtbl.create (List.length numbers) in
  List.iter (fun n ->
    let count = match Hashtbl.find_opt freq n with
      | None   -> 0
      | Some c -> c
    in
    Hashtbl.replace freq n (count + 1)
  ) numbers;

  (* Keep only the elements that appear exactly once *)
  List.filter (fun n -> Hashtbl.find freq n = 1) numbers

let assertions =
 let candidate = remove_duplicates in
  (assert ((candidate []) = []));
  (assert ((candidate [1; 2; 3; 4]) = [1; 2; 3; 4]));
  (assert ((candidate [1; 2; 3; 2; 4; 3; 5]) = [1; 4; 5]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 28 (ML) - HumanEval_28_concatenate
================================================================================

PROMPT:
----------------------------------------
(**Concatenate list of strings into a single string
 * >>> concatenate []
 * ""
 * >>> concatenate ["a"; "b"; "c"]
 * "abc"
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = concatenate in
  (assert ((candidate []) = ""));
  (assert ((candidate ["x"; "y"; "z"]) = "xyz"));
  (assert ((candidate ["x"; "y"; "z"; "w"; "k"]) = "xyzwk"));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Concatenate list of strings into a single string
 * >>> concatenate []
 * ""
 * >>> concatenate ["a"; "b"; "c"]
 * "abc"
*)
let concatenate (strings : string list) : string =
  String.concat "" strings

let assertions =
 let candidate = concatenate in
  (assert ((candidate []) = ""));
  (assert ((candidate ["x"; "y"; "z"]) = "xyz"));
  (assert ((candidate ["x"; "y"; "z"; "w"; "k"]) = "xyzwk"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Concatenate list of strings into a single string
 * >>> concatenate []
 * ""
 * >>> concatenate ["a"; "b"; "c"]
 * "abc"
*)
let concatenate (strings : string list) : string =
  List.fold_left (^) "" strings

let assertions =
 let candidate = concatenate in
  (assert ((candidate []) = ""));
  (assert ((candidate ["x"; "y"; "z"]) = "xyz"));
  (assert ((candidate ["x"; "y"; "z"; "w"; "k"]) = "xyzwk"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Concatenate list of strings into a single string
 * >>> concatenate []
 * ""
 * >>> concatenate ["a"; "b"; "c"]
 * "abc"
*)
(* Concatenate list of strings into a single string
 * >>> concatenate []
 * ""
 * >>> concatenate ["a"; "b"; "c"]
 * "abc"
 *)
let concatenate (strings : string list) : string =
  String.concat "" strings

let assertions =
 let candidate = concatenate in
  (assert ((candidate []) = ""));
  (assert ((candidate ["x"; "y"; "z"]) = "xyz"));
  (assert ((candidate ["x"; "y"; "z"; "w"; "k"]) = "xyzwk"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Concatenate list of strings into a single string
 * >>> concatenate []
 * ""
 * >>> concatenate ["a"; "b"; "c"]
 * "abc"
*)
let concatenate (strings : string list) : string =
  String.concat "" strings

let assertions =
 let candidate = concatenate in
  (assert ((candidate []) = ""));
  (assert ((candidate ["x"; "y"; "z"]) = "xyz"));
  (assert ((candidate ["x"; "y"; "z"; "w"; "k"]) = "xyzwk"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 29 (ML) - HumanEval_29_filter_by_prefix
================================================================================

PROMPT:
----------------------------------------
(**Filter an input list of strings only for ones that start with a given prefix.
 * >>> filter_by_prefix [] "a"
 * []
 * >>> filter_by_prefix ["abc"; "bcd"; "cde"; "array"] "a"
 * ["abc"; "array"]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = filter_by_prefix in
  (assert ((candidate [] "john") = []));
  (assert ((candidate ["xxx"; "asd"; "xxy"; "john doe"; "xxxAAA"; "xxx"] "xxx") = ["xxx"; "xxxAAA"; "xxx"]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Filter an input list of strings only for ones that start with a given prefix.
 * >>> filter_by_prefix [] "a"
 * []
 * >>> filter_by_prefix ["abc"; "bcd"; "cde"; "array"] "a"
 * ["abc"; "array"]
*)
(** Filter an input list of strings only for ones that start with a given prefix.
 *  >>> filter_by_prefix [] "a"
 *  []
 *  >>> filter_by_prefix ["abc"; "bcd"; "cde"; "array"] "a"
 *  ["abc"; "array"]
*)
let filter_by_prefix (strings : string list) (prefix : string) : string list =
  (* Helper to test whether a string starts with the given prefix *)
  let starts_with s =
    let plen = String.length prefix in
    let slen = String.length s in
    plen <= slen && String.sub s 0 plen = prefix
  in
  List.filter starts_with strings

let assertions =
 let candidate = filter_by_prefix in
  (assert ((candidate [] "john") = []));
  (assert ((candidate ["xxx"; "asd"; "xxy"; "john doe"; "xxxAAA"; "xxx"] "xxx") = ["xxx"; "xxxAAA"; "xxx"]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Filter an input list of strings only for ones that start with a given prefix.
 * >>> filter_by_prefix [] "a"
 * []
 * >>> filter_by_prefix ["abc"; "bcd"; "cde"; "array"] "a"
 * ["abc"; "array"]
*)
(** Filter an input list of strings only for ones that start with a given prefix.
 *  >>> filter_by_prefix [] "a"
 *  []
 *  >>> filter_by_prefix ["abc"; "bcd"; "cde"; "array"] "a"
 *  ["abc"; "array"]
 *)
let filter_by_prefix (strings : string list) (prefix : string) : string list =
  (* Helper to test if a string starts with the given prefix. *)
  let starts_with s p =
    let lp = String.length p in
    String.length s >= lp && String.sub s 0 lp = p
  in
  List.filter (fun s -> starts_with s prefix) strings

let assertions =
 let candidate = filter_by_prefix in
  (assert ((candidate [] "john") = []));
  (assert ((candidate ["xxx"; "asd"; "xxy"; "john doe"; "xxxAAA"; "xxx"] "xxx") = ["xxx"; "xxxAAA"; "xxx"]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Filter an input list of strings only for ones that start with a given prefix.
 * >>> filter_by_prefix [] "a"
 * []
 * >>> filter_by_prefix ["abc"; "bcd"; "cde"; "array"] "a"
 * ["abc"; "array"]
*)
(** Filter an input list of strings only for ones that start with a given prefix.
 *  >>> filter_by_prefix [] "a"
 *  []
 *  >>> filter_by_prefix ["abc"; "bcd"; "cde"; "array"] "a"
 *  ["abc"; "array"]
*)
let filter_by_prefix (strings : string list) (prefix : string) : string list =
  let prefix_len = String.length prefix in
  List.filter (fun s ->
    let len = String.length s in
    len >= prefix_len &&
    String.sub s 0 prefix_len = prefix
  ) strings

let assertions =
 let candidate = filter_by_prefix in
  (assert ((candidate [] "john") = []));
  (assert ((candidate ["xxx"; "asd"; "xxy"; "john doe"; "xxxAAA"; "xxx"] "xxx") = ["xxx"; "xxxAAA"; "xxx"]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Filter an input list of strings only for ones that start with a given prefix.
 * >>> filter_by_prefix [] "a"
 * []
 * >>> filter_by_prefix ["abc"; "bcd"; "cde"; "array"] "a"
 * ["abc"; "array"]
*)
(** Filter an input list of strings only for ones that start with a given prefix.
 *  >>> filter_by_prefix [] "a"
 *  []
 *  >>> filter_by_prefix ["abc"; "bcd"; "cde"; "array"] "a"
 *  ["abc"; "array"]
 *)
let filter_by_prefix (strings : string list) (prefix : string) : string list =
  let prefix_len = String.length prefix in
  List.filter (fun s ->
    let len = String.length s in
    len >= prefix_len && String.sub s 0 prefix_len = prefix
  ) strings

let assertions =
 let candidate = filter_by_prefix in
  (assert ((candidate [] "john") = []));
  (assert ((candidate ["xxx"; "asd"; "xxy"; "john doe"; "xxxAAA"; "xxx"] "xxx") = ["xxx"; "xxxAAA"; "xxx"]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 31 (ML) - HumanEval_31_is_prime
================================================================================

PROMPT:
----------------------------------------
(**Return true if a given number is prime, and false otherwise.
 * >>> is_prime 6
 * false
 * >>> is_prime 101
 * true
 * >>> is_prime 11
 * true
 * >>> is_prime 13441
 * true
 * >>> is_prime 61
 * true
 * >>> is_prime 4
 * false
 * >>> is_prime 1
 * false
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = is_prime in
  (assert ((candidate 6) = false));
  (assert ((candidate 101) = true));
  (assert ((candidate 11) = true));
  (assert ((candidate 13441) = true));
  (assert ((candidate 61) = true));
  (assert ((candidate 4) = false));
  (assert ((candidate 1) = false));
  (assert ((candidate 5) = true));
  (assert ((candidate 11) = true));
  (assert ((candidate 17) = true));
  (assert ((candidate 85) = false));
  (assert ((candidate 77) = false));
  (assert ((candidate 255379) = false));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Return true if a given number is prime, and false otherwise.
 * >>> is_prime 6
 * false
 * >>> is_prime 101
 * true
 * >>> is_prime 11
 * true
 * >>> is_prime 13441
 * true
 * >>> is_prime 61
 * true
 * >>> is_prime 4
 * false
 * >>> is_prime 1
 * false
*)
(* Return true if a given number is prime, and false otherwise. *)
let is_prime (n : int) : bool =
  (* Prime numbers must be greater than 1 *)
  if n <= 1 then false
  else if n = 2 then true
  (* Even numbers greater than 2 are not prime *)
  else if n mod 2 = 0 then false
  else
    (* Check odd divisors up to the integer square root of n *)
    let limit = int_of_float (sqrt (float_of_int n)) in
    let rec loop d =
      if d > limit then true
      else if n mod d = 0 then false
      else loop (d + 2)
    in
    loop 3

let assertions =
 let candidate = is_prime in
  (assert ((candidate 6) = false));
  (assert ((candidate 101) = true));
  (assert ((candidate 11) = true));
  (assert ((candidate 13441) = true));
  (assert ((candidate 61) = true));
  (assert ((candidate 4) = false));
  (assert ((candidate 1) = false));
  (assert ((candidate 5) = true));
  (assert ((candidate 11) = true));
  (assert ((candidate 17) = true));
  (assert ((candidate 85) = false));
  (assert ((candidate 77) = false));
  (assert ((candidate 255379) = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Return true if a given number is prime, and false otherwise.
 * >>> is_prime 6
 * false
 * >>> is_prime 101
 * true
 * >>> is_prime 11
 * true
 * >>> is_prime 13441
 * true
 * >>> is_prime 61
 * true
 * >>> is_prime 4
 * false
 * >>> is_prime 1
 * false
*)
let is_prime (n : int) : bool =
  (* Numbers less than 2 are not prime *)
  if n <= 1 then false
  else
    let limit = int_of_float (sqrt (float_of_int n)) in
    let rec loop i =
      if i > limit then true
      else if n mod i = 0 then false
      else loop (i + 1)
    in
    loop 2

let assertions =
 let candidate = is_prime in
  (assert ((candidate 6) = false));
  (assert ((candidate 101) = true));
  (assert ((candidate 11) = true));
  (assert ((candidate 13441) = true));
  (assert ((candidate 61) = true));
  (assert ((candidate 4) = false));
  (assert ((candidate 1) = false));
  (assert ((candidate 5) = true));
  (assert ((candidate 11) = true));
  (assert ((candidate 17) = true));
  (assert ((candidate 85) = false));
  (assert ((candidate 77) = false));
  (assert ((candidate 255379) = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Return true if a given number is prime, and false otherwise.
 * >>> is_prime 6
 * false
 * >>> is_prime 101
 * true
 * >>> is_prime 11
 * true
 * >>> is_prime 13441
 * true
 * >>> is_prime 61
 * true
 * >>> is_prime 4
 * false
 * >>> is_prime 1
 * false
*)
let is_prime (n : int) : bool =
  if n <= 1 then false
  else if n <= 3 then true
  else if n mod 2 = 0 || n mod 3 = 0 then false
  else
    let rec check i =
      if i * i > n then true
      else if n mod i = 0 || n mod (i + 2) = 0 then false
      else check (i + 6)
    in
    check 5

let assertions =
 let candidate = is_prime in
  (assert ((candidate 6) = false));
  (assert ((candidate 101) = true));
  (assert ((candidate 11) = true));
  (assert ((candidate 13441) = true));
  (assert ((candidate 61) = true));
  (assert ((candidate 4) = false));
  (assert ((candidate 1) = false));
  (assert ((candidate 5) = true));
  (assert ((candidate 11) = true));
  (assert ((candidate 17) = true));
  (assert ((candidate 85) = false));
  (assert ((candidate 77) = false));
  (assert ((candidate 255379) = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Return true if a given number is prime, and false otherwise.
 * >>> is_prime 6
 * false
 * >>> is_prime 101
 * true
 * >>> is_prime 11
 * true
 * >>> is_prime 13441
 * true
 * >>> is_prime 61
 * true
 * >>> is_prime 4
 * false
 * >>> is_prime 1
 * false
*)
let is_prime (n : int) : bool =
  if n <= 1 then false
  else
    let rec check i =
      if i * i > n then true
      else if n mod i = 0 then false
      else check (i + 1)
    in
    check 2

let assertions =
 let candidate = is_prime in
  (assert ((candidate 6) = false));
  (assert ((candidate 101) = true));
  (assert ((candidate 11) = true));
  (assert ((candidate 13441) = true));
  (assert ((candidate 61) = true));
  (assert ((candidate 4) = false));
  (assert ((candidate 1) = false));
  (assert ((candidate 5) = true));
  (assert ((candidate 11) = true));
  (assert ((candidate 17) = true));
  (assert ((candidate 85) = false));
  (assert ((candidate 77) = false));
  (assert ((candidate 255379) = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183713
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 34 (ML) - HumanEval_34_unique
================================================================================

PROMPT:
----------------------------------------
(**Return sorted unique elements in a list
 * >>> unique [5; 3; 5; 2; 3; 3; 9; 0; 123]
 * [0; 2; 3; 5; 9; 123]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = unique in
  (assert ((candidate [5; 3; 5; 2; 3; 3; 9; 0; 123]) = [0; 2; 3; 5; 9; 123]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Return sorted unique elements in a list
 * >>> unique [5; 3; 5; 2; 3; 3; 9; 0; 123]
 * [0; 2; 3; 5; 9; 123]
*)
let unique (l : int list) : int list =
  List.sort_uniq compare l

let assertions =
 let candidate = unique in
  (assert ((candidate [5; 3; 5; 2; 3; 3; 9; 0; 123]) = [0; 2; 3; 5; 9; 123]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Return sorted unique elements in a list
 * >>> unique [5; 3; 5; 2; 3; 3; 9; 0; 123]
 * [0; 2; 3; 5; 9; 123]
*)
let unique (l : int list) : int list =
  List.sort_uniq compare l

let assertions =
 let candidate = unique in
  (assert ((candidate [5; 3; 5; 2; 3; 3; 9; 0; 123]) = [0; 2; 3; 5; 9; 123]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Return sorted unique elements in a list
 * >>> unique [5; 3; 5; 2; 3; 3; 9; 0; 123]
 * [0; 2; 3; 5; 9; 123]
*)
(* Return sorted unique elements in a list
 * >>> unique [5; 3; 5; 2; 3; 3; 9; 0; 123]
 * [0; 2; 3; 5; 9; 123]
 *)
let unique (l : int list) : int list =
  (* Sort the list first *)
  let sorted = List.sort compare l in
  (* Remove consecutive duplicates *)
  let rec remove_dups acc = function
    | [] -> List.rev acc
    | h :: t ->
        (match acc with
        | [] -> remove_dups [h] t
        | h' :: _ when h = h' -> remove_dups acc t
        | _ -> remove_dups (h :: acc) t)
  in
  remove_dups [] sorted

let assertions =
 let candidate = unique in
  (assert ((candidate [5; 3; 5; 2; 3; 3; 9; 0; 123]) = [0; 2; 3; 5; 9; 123]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Return sorted unique elements in a list
 * >>> unique [5; 3; 5; 2; 3; 3; 9; 0; 123]
 * [0; 2; 3; 5; 9; 123]
*)
(* Return sorted unique elements in a list
 * >>> unique [5; 3; 5; 2; 3; 3; 9; 0; 123]
 * [0; 2; 3; 5; 9; 123]
 *)
let unique (l : int list) : int list =
  (* Sort the list first *)
  let sorted = List.sort compare l in
  (* Fold over the sorted list, keeping only the first occurrence of each element *)
  let rec aux acc = function
    | [] -> List.rev acc
    | x :: xs ->
        match acc with
        | [] -> aux [x] xs
        | h :: _ when h = x -> aux acc xs  (* duplicate, skip *)
        | _ -> aux (x :: acc) xs
  in
  aux [] sorted

let assertions =
 let candidate = unique in
  (assert ((candidate [5; 3; 5; 2; 3; 3; 9; 0; 123]) = [0; 2; 3; 5; 9; 123]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183714
STDOUT: (empty)
STDERR: (empty)
--------------------
