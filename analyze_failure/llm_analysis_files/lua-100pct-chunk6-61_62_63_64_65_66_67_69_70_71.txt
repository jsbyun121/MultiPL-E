As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 61 (LUA) - HumanEval_61_correct_bracketing
================================================================================

PROMPT:
----------------------------------------
-- brackets is a string of "(" and ")".
-- return true if every opening bracket has a corresponding closing bracket.
-- >>> correct_bracketing('(')
-- false
-- >>> correct_bracketing('()')
-- true
-- >>> correct_bracketing('(()())')
-- true
-- >>> correct_bracketing(')(()')
-- false

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = correct_bracketing
    lu.assertEquals(candidate('()'), true)
    lu.assertEquals(candidate('(()())'), true)
    lu.assertEquals(candidate('()()(()())()'), true)
    lu.assertEquals(candidate('()()((()()())())(()()(()))'), true)
    lu.assertEquals(candidate('((()())))'), false)
    lu.assertEquals(candidate(')(()'), false)
    lu.assertEquals(candidate('('), false)
    lu.assertEquals(candidate('(((('), false)
    lu.assertEquals(candidate(')'), false)
    lu.assertEquals(candidate('(()'), false)
    lu.assertEquals(candidate('()()(()())())(()'), false)
    lu.assertEquals(candidate('()()(()())()))()'), false)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- brackets is a string of "(" and ")".
-- return true if every opening bracket has a corresponding closing bracket.
-- >>> correct_bracketing('(')
-- false
-- >>> correct_bracketing('()')
-- true
-- >>> correct_bracketing('(()())')
-- true
-- >>> correct_bracketing(')(()')
-- false
local function correct_bracketing(brackets)
    -- counter for unmatched opening brackets
    local balance = 0

    for i = 1, #brackets do
        local c = brackets:sub(i, i)

        if c == '(' then
            balance = balance + 1
        elseif c == ')' then
            if balance == 0 then
                -- more closing brackets than opening ones
                return false
            end
            balance = balance - 1
        else
            -- ignore any other characters (if they appear)
        end
    end

    -- all opening brackets must have been matched
    return balance == 0
end
lu = require('luaunit')

function test_humaneval()
local candidate = correct_bracketing
    lu.assertEquals(candidate('()'), true)
    lu.assertEquals(candidate('(()())'), true)
    lu.assertEquals(candidate('()()(()())()'), true)
    lu.assertEquals(candidate('()()((()()())())(()()(()))'), true)
    lu.assertEquals(candidate('((()())))'), false)
    lu.assertEquals(candidate(')(()'), false)
    lu.assertEquals(candidate('('), false)
    lu.assertEquals(candidate('(((('), false)
    lu.assertEquals(candidate(')'), false)
    lu.assertEquals(candidate('(()'), false)
    lu.assertEquals(candidate('()()(()())())(()'), false)
    lu.assertEquals(candidate('()()(()())()))()'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- brackets is a string of "(" and ")".
-- return true if every opening bracket has a corresponding closing bracket.
-- >>> correct_bracketing('(')
-- false
-- >>> correct_bracketing('()')
-- true
-- >>> correct_bracketing('(()())')
-- true
-- >>> correct_bracketing(')(()')
-- false
-- Returns true if every opening bracket has a corresponding closing bracket
-- in the given string `brackets`.  
-- The string contains only '(' and ')'.
local function correct_bracketing(brackets)
    local balance = 0
    for i = 1, #brackets do
        local c = brackets:sub(i,i)
        if c == '(' then
            balance = balance + 1
        elseif c == ')' then
            balance = balance - 1
            -- If we close more brackets than we have opened, it's invalid
            if balance < 0 then
                return false
            end
        else
            -- If any other character appears, we can treat it as invalid
            -- or simply ignore it. Here we return false.
            return false
        end
    end
    -- Balanced only if we have no unmatched opening brackets left
    return balance == 0
end
lu = require('luaunit')

function test_humaneval()
local candidate = correct_bracketing
    lu.assertEquals(candidate('()'), true)
    lu.assertEquals(candidate('(()())'), true)
    lu.assertEquals(candidate('()()(()())()'), true)
    lu.assertEquals(candidate('()()((()()())())(()()(()))'), true)
    lu.assertEquals(candidate('((()())))'), false)
    lu.assertEquals(candidate(')(()'), false)
    lu.assertEquals(candidate('('), false)
    lu.assertEquals(candidate('(((('), false)
    lu.assertEquals(candidate(')'), false)
    lu.assertEquals(candidate('(()'), false)
    lu.assertEquals(candidate('()()(()())())(()'), false)
    lu.assertEquals(candidate('()()(()())()))()'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- brackets is a string of "(" and ")".
-- return true if every opening bracket has a corresponding closing bracket.
-- >>> correct_bracketing('(')
-- false
-- >>> correct_bracketing('()')
-- true
-- >>> correct_bracketing('(()())')
-- true
-- >>> correct_bracketing(')(()')
-- false
local function correct_bracketing(brackets)
    -- Count the balance of parentheses.
    local balance = 0
    for i = 1, #brackets do
        local c = brackets:sub(i, i)
        if c == '(' then
            balance = balance + 1
        elseif c == ')' then
            balance = balance - 1
            -- If we ever go negative, there's a closing bracket without a match.
            if balance < 0 then
                return false
            end
        end
    end
    -- All opening brackets must have been matched.
    return balance == 0
end
lu = require('luaunit')

function test_humaneval()
local candidate = correct_bracketing
    lu.assertEquals(candidate('()'), true)
    lu.assertEquals(candidate('(()())'), true)
    lu.assertEquals(candidate('()()(()())()'), true)
    lu.assertEquals(candidate('()()((()()())())(()()(()))'), true)
    lu.assertEquals(candidate('((()())))'), false)
    lu.assertEquals(candidate(')(()'), false)
    lu.assertEquals(candidate('('), false)
    lu.assertEquals(candidate('(((('), false)
    lu.assertEquals(candidate(')'), false)
    lu.assertEquals(candidate('(()'), false)
    lu.assertEquals(candidate('()()(()())())(()'), false)
    lu.assertEquals(candidate('()()(()())()))()'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- brackets is a string of "(" and ")".
-- return true if every opening bracket has a corresponding closing bracket.
-- >>> correct_bracketing('(')
-- false
-- >>> correct_bracketing('()')
-- true
-- >>> correct_bracketing('(()())')
-- true
-- >>> correct_bracketing(')(()')
-- false
-- Checks if the given string of brackets is correctly matched.
-- @param brackets A string consisting only of '(' and ')'.
-- @return true if every '(' has a corresponding ')', false otherwise.
local function correct_bracketing(brackets)
    local depth = 0  -- Number of unmatched '(' seen so far

    for i = 1, #brackets do
        local c = brackets:sub(i, i)
        if c == '(' then
            depth = depth + 1
        elseif c == ')' then
            depth = depth - 1
            if depth < 0 then
                -- Found a closing bracket without a matching opening one
                return false
            end
        else
            -- If any other character appears, the input is invalid
            return false
        end
    end

    -- All opening brackets must have been closed
    return depth == 0
end
lu = require('luaunit')

function test_humaneval()
local candidate = correct_bracketing
    lu.assertEquals(candidate('()'), true)
    lu.assertEquals(candidate('(()())'), true)
    lu.assertEquals(candidate('()()(()())()'), true)
    lu.assertEquals(candidate('()()((()()())())(()()(()))'), true)
    lu.assertEquals(candidate('((()())))'), false)
    lu.assertEquals(candidate(')(()'), false)
    lu.assertEquals(candidate('('), false)
    lu.assertEquals(candidate('(((('), false)
    lu.assertEquals(candidate(')'), false)
    lu.assertEquals(candidate('(()'), false)
    lu.assertEquals(candidate('()()(()())())(()'), false)
    lu.assertEquals(candidate('()()(()())()))()'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 62 (LUA) - HumanEval_62_derivative
================================================================================

PROMPT:
----------------------------------------
-- xs represent coefficients of a polynomial.
-- xs[0] + xs[1] * x + xs[2] * x^2 + ....
--  Return derivative of this polynomial in the same form.
-- >>> derivative({3, 1, 2, 4, 5})
-- {1, 4, 12, 20}
-- >>> derivative({1, 2, 3})
-- {2, 6}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = derivative
    lu.assertEquals(candidate({3, 1, 2, 4, 5}), {1, 4, 12, 20})
    lu.assertEquals(candidate({1, 2, 3}), {2, 6})
    lu.assertEquals(candidate({3, 2, 1}), {2, 2})
    lu.assertEquals(candidate({3, 2, 1, 0, 4}), {2, 2, 0, 16})
    lu.assertEquals(candidate({1}), {})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- xs represent coefficients of a polynomial.
-- xs[0] + xs[1] * x + xs[2] * x^2 + ....
--  Return derivative of this polynomial in the same form.
-- >>> derivative({3, 1, 2, 4, 5})
-- {1, 4, 12, 20}
-- >>> derivative({1, 2, 3})
-- {2, 6}
local function derivative(xs)
  local n = #xs
  local result = {}
  for i = 2, n do
    result[i-1] = xs[i] * (i-1)
  end
  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = derivative
    lu.assertEquals(candidate({3, 1, 2, 4, 5}), {1, 4, 12, 20})
    lu.assertEquals(candidate({1, 2, 3}), {2, 6})
    lu.assertEquals(candidate({3, 2, 1}), {2, 2})
    lu.assertEquals(candidate({3, 2, 1, 0, 4}), {2, 2, 0, 16})
    lu.assertEquals(candidate({1}), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- xs represent coefficients of a polynomial.
-- xs[0] + xs[1] * x + xs[2] * x^2 + ....
--  Return derivative of this polynomial in the same form.
-- >>> derivative({3, 1, 2, 4, 5})
-- {1, 4, 12, 20}
-- >>> derivative({1, 2, 3})
-- {2, 6}
-- derivative of a polynomial represented by a table of coefficients
-- xs[1] + xs[2] * x + xs[3] * x^2 + ...
-- returns a table of the derivative coefficients
local function derivative(xs)
    local result = {}
    -- start from the coefficient of x^1 (index 2)
    for i = 2, #xs do
        local power = i - 1          -- exponent of the current term
        result[#result + 1] = power * xs[i]
    end
    return result
end

-- Example usage:
-- print(table.concat(derivative({3, 1, 2, 4, 5}), ", "))  --> 1, 4, 12, 20
-- print(table.concat(derivative({1, 2, 3}), ", "))       --> 2, 6
lu = require('luaunit')

function test_humaneval()
local candidate = derivative
    lu.assertEquals(candidate({3, 1, 2, 4, 5}), {1, 4, 12, 20})
    lu.assertEquals(candidate({1, 2, 3}), {2, 6})
    lu.assertEquals(candidate({3, 2, 1}), {2, 2})
    lu.assertEquals(candidate({3, 2, 1, 0, 4}), {2, 2, 0, 16})
    lu.assertEquals(candidate({1}), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- xs represent coefficients of a polynomial.
-- xs[0] + xs[1] * x + xs[2] * x^2 + ....
--  Return derivative of this polynomial in the same form.
-- >>> derivative({3, 1, 2, 4, 5})
-- {1, 4, 12, 20}
-- >>> derivative({1, 2, 3})
-- {2, 6}
local function derivative(xs)
  local n = #xs
  if n <= 1 then
    return {}
  end
  local res = {}
  for i = 2, n do
    res[i - 1] = xs[i] * (i - 1)
  end
  return res
end
lu = require('luaunit')

function test_humaneval()
local candidate = derivative
    lu.assertEquals(candidate({3, 1, 2, 4, 5}), {1, 4, 12, 20})
    lu.assertEquals(candidate({1, 2, 3}), {2, 6})
    lu.assertEquals(candidate({3, 2, 1}), {2, 2})
    lu.assertEquals(candidate({3, 2, 1, 0, 4}), {2, 2, 0, 16})
    lu.assertEquals(candidate({1}), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- xs represent coefficients of a polynomial.
-- xs[0] + xs[1] * x + xs[2] * x^2 + ....
--  Return derivative of this polynomial in the same form.
-- >>> derivative({3, 1, 2, 4, 5})
-- {1, 4, 12, 20}
-- >>> derivative({1, 2, 3})
-- {2, 6}
local function derivative(xs)
    local n = #xs
    if n <= 1 then
        return {}
    end

    local result = {}
    for i = 2, n do
        result[i-1] = (i-1) * xs[i]
    end
    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = derivative
    lu.assertEquals(candidate({3, 1, 2, 4, 5}), {1, 4, 12, 20})
    lu.assertEquals(candidate({1, 2, 3}), {2, 6})
    lu.assertEquals(candidate({3, 2, 1}), {2, 2})
    lu.assertEquals(candidate({3, 2, 1, 0, 4}), {2, 2, 0, 16})
    lu.assertEquals(candidate({1}), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 63 (LUA) - HumanEval_63_fibfib
================================================================================

PROMPT:
----------------------------------------
-- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
-- fibfib(0) == 0
-- fibfib(1) == 0
-- fibfib(2) == 1
-- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
-- Please write a function to efficiently compute the n-th element of the fibfib number sequence.
-- >>> fibfib(1)
-- 0
-- >>> fibfib(5)
-- 4
-- >>> fibfib(8)
-- 24

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = fibfib
    lu.assertEquals(candidate(2), 1)
    lu.assertEquals(candidate(1), 0)
    lu.assertEquals(candidate(5), 4)
    lu.assertEquals(candidate(8), 24)
    lu.assertEquals(candidate(10), 81)
    lu.assertEquals(candidate(12), 274)
    lu.assertEquals(candidate(14), 927)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
-- fibfib(0) == 0
-- fibfib(1) == 0
-- fibfib(2) == 1
-- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
-- Please write a function to efficiently compute the n-th element of the fibfib number sequence.
-- >>> fibfib(1)
-- 0
-- >>> fibfib(5)
-- 4
-- >>> fibfib(8)
-- 24
-- Efficiently compute the n‑th element of the fibfib sequence.
-- We use an iterative dynamic‑programming approach that runs in O(n) time
-- and O(1) extra space.

local function fibfib(n)
  if n < 0 then
    error("fibfib: n must be a non‑negative integer")
  end

  -- Base cases
  if n == 0 or n == 1 then
    return 0
  elseif n == 2 then
    return 1
  end

  -- Use three variables to keep the last three values:
  -- a = fibfib(i-3), b = fibfib(i-2), c = fibfib(i-1)
  local a, b, c = 0, 0, 1

  for i = 3, n do
    local next = a + b + c
    a, b, c = b, c, next
  end

  return c
end

-- Example usage:
-- print(fibfib(1))  --> 0
-- print(fibfib(5))  --> 4
-- print(fibfib(8))  --> 24
lu = require('luaunit')

function test_humaneval()
local candidate = fibfib
    lu.assertEquals(candidate(2), 1)
    lu.assertEquals(candidate(1), 0)
    lu.assertEquals(candidate(5), 4)
    lu.assertEquals(candidate(8), 24)
    lu.assertEquals(candidate(10), 81)
    lu.assertEquals(candidate(12), 274)
    lu.assertEquals(candidate(14), 927)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
-- fibfib(0) == 0
-- fibfib(1) == 0
-- fibfib(2) == 1
-- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
-- Please write a function to efficiently compute the n-th element of the fibfib number sequence.
-- >>> fibfib(1)
-- 0
-- >>> fibfib(5)
-- 4
-- >>> fibfib(8)
-- 24
-- Efficient iterative implementation of the fibfib sequence
local function fibfib(n)
    -- Base cases
    if n == 0 or n == 1 then
        return 0
    elseif n == 2 then
        return 1
    end

    -- Initialize the first three terms
    local a, b, c = 0, 0, 1  -- fibfib(0), fibfib(1), fibfib(2)

    -- Compute up to fibfib(n) iteratively
    for i = 3, n do
        local d = a + b + c  -- fibfib(i) = fibfib(i-1) + fibfib(i-2) + fibfib(i-3)
        a, b, c = b, c, d
    end

    return c
end
lu = require('luaunit')

function test_humaneval()
local candidate = fibfib
    lu.assertEquals(candidate(2), 1)
    lu.assertEquals(candidate(1), 0)
    lu.assertEquals(candidate(5), 4)
    lu.assertEquals(candidate(8), 24)
    lu.assertEquals(candidate(10), 81)
    lu.assertEquals(candidate(12), 274)
    lu.assertEquals(candidate(14), 927)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
-- fibfib(0) == 0
-- fibfib(1) == 0
-- fibfib(2) == 1
-- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
-- Please write a function to efficiently compute the n-th element of the fibfib number sequence.
-- >>> fibfib(1)
-- 0
-- >>> fibfib(5)
-- 4
-- >>> fibfib(8)
-- 24
local function fibfib(n)
    if n < 0 then
        error("n must be a non‑negative integer")
    end

    -- Base cases
    if n == 0 or n == 1 then
        return 0
    elseif n == 2 then
        return 1
    end

    -- fibfib(0), fibfib(1), fibfib(2)
    local a, b, c = 0, 0, 1

    for i = 3, n do
        local next = a + b + c
        a, b, c = b, c, next
    end

    return c
end
lu = require('luaunit')

function test_humaneval()
local candidate = fibfib
    lu.assertEquals(candidate(2), 1)
    lu.assertEquals(candidate(1), 0)
    lu.assertEquals(candidate(5), 4)
    lu.assertEquals(candidate(8), 24)
    lu.assertEquals(candidate(10), 81)
    lu.assertEquals(candidate(12), 274)
    lu.assertEquals(candidate(14), 927)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
-- fibfib(0) == 0
-- fibfib(1) == 0
-- fibfib(2) == 1
-- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
-- Please write a function to efficiently compute the n-th element of the fibfib number sequence.
-- >>> fibfib(1)
-- 0
-- >>> fibfib(5)
-- 4
-- >>> fibfib(8)
-- 24
local function fibfib(n)
    -- Handle the base cases
    if n <= 0 then
        return 0
    elseif n == 1 then
        return 0
    elseif n == 2 then
        return 1
    end

    -- Use an iterative approach to avoid recursion overhead
    local a, b, c = 0, 0, 1  -- fibfib(0), fibfib(1), fibfib(2)
    for i = 3, n do
        local d = a + b + c   -- fibfib(i) = fibfib(i-1) + fibfib(i-2) + fibfib(i-3)
        a, b, c = b, c, d
    end

    return c
end
lu = require('luaunit')

function test_humaneval()
local candidate = fibfib
    lu.assertEquals(candidate(2), 1)
    lu.assertEquals(candidate(1), 0)
    lu.assertEquals(candidate(5), 4)
    lu.assertEquals(candidate(8), 24)
    lu.assertEquals(candidate(10), 81)
    lu.assertEquals(candidate(12), 274)
    lu.assertEquals(candidate(14), 927)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 64 (LUA) - HumanEval_64_vowels_count
================================================================================

PROMPT:
----------------------------------------
-- Write a function vowels_count which takes a string representing
-- a word as input and returns the number of vowels in the string.
-- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
-- vowel, but only when it is at the end of the given word.
-- Example:
-- >>> vowels_count('abcde')
-- 2
-- >>> vowels_count('ACEDY')
-- 3

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = vowels_count
    lu.assertEquals(candidate('abcde'), 2)
    lu.assertEquals(candidate('Alone'), 3)
    lu.assertEquals(candidate('key'), 2)
    lu.assertEquals(candidate('bye'), 1)
    lu.assertEquals(candidate('keY'), 2)
    lu.assertEquals(candidate('bYe'), 1)
    lu.assertEquals(candidate('ACEDY'), 3)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Write a function vowels_count which takes a string representing
-- a word as input and returns the number of vowels in the string.
-- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
-- vowel, but only when it is at the end of the given word.
-- Example:
-- >>> vowels_count('abcde')
-- 2
-- >>> vowels_count('ACEDY')
-- 3
local function vowels_count(s)
    local count = 0
    local len = #s
    for i = 1, len do
        local c = s:sub(i,i):lower()
        if c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' then
            count = count + 1
        elseif c == 'y' and i == len then
            count = count + 1
        end
    end
    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = vowels_count
    lu.assertEquals(candidate('abcde'), 2)
    lu.assertEquals(candidate('Alone'), 3)
    lu.assertEquals(candidate('key'), 2)
    lu.assertEquals(candidate('bye'), 1)
    lu.assertEquals(candidate('keY'), 2)
    lu.assertEquals(candidate('bYe'), 1)
    lu.assertEquals(candidate('ACEDY'), 3)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Write a function vowels_count which takes a string representing
-- a word as input and returns the number of vowels in the string.
-- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
-- vowel, but only when it is at the end of the given word.
-- Example:
-- >>> vowels_count('abcde')
-- 2
-- >>> vowels_count('ACEDY')
-- 3
-- Count the number of vowels in a word.
-- Vowels: a, e, i, o, u (case‑insensitive).
-- The letter 'y' is counted as a vowel only if it appears at the end of the word.
local function vowels_count(s)
    local count = 0
    local len = #s

    for i = 1, len do
        local c = s:sub(i, i):lower()
        if c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' then
            count = count + 1
        elseif c == 'y' and i == len then
            count = count + 1
        end
    end

    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = vowels_count
    lu.assertEquals(candidate('abcde'), 2)
    lu.assertEquals(candidate('Alone'), 3)
    lu.assertEquals(candidate('key'), 2)
    lu.assertEquals(candidate('bye'), 1)
    lu.assertEquals(candidate('keY'), 2)
    lu.assertEquals(candidate('bYe'), 1)
    lu.assertEquals(candidate('ACEDY'), 3)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Write a function vowels_count which takes a string representing
-- a word as input and returns the number of vowels in the string.
-- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
-- vowel, but only when it is at the end of the given word.
-- Example:
-- >>> vowels_count('abcde')
-- 2
-- >>> vowels_count('ACEDY')
-- 3
-- Count vowels in a word.
-- Vowels are 'a', 'e', 'i', 'o', 'u'.  The letter 'y' is counted as a vowel
-- only when it appears as the last character of the word.
local function vowels_count(s)
  local count = 0
  local len = #s
  local lower = s:lower()

  for i = 1, len do
    local c = lower:sub(i, i)
    if c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' then
      count = count + 1
    elseif c == 'y' and i == len then
      count = count + 1
    end
  end

  return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = vowels_count
    lu.assertEquals(candidate('abcde'), 2)
    lu.assertEquals(candidate('Alone'), 3)
    lu.assertEquals(candidate('key'), 2)
    lu.assertEquals(candidate('bye'), 1)
    lu.assertEquals(candidate('keY'), 2)
    lu.assertEquals(candidate('bYe'), 1)
    lu.assertEquals(candidate('ACEDY'), 3)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Write a function vowels_count which takes a string representing
-- a word as input and returns the number of vowels in the string.
-- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
-- vowel, but only when it is at the end of the given word.
-- Example:
-- >>> vowels_count('abcde')
-- 2
-- >>> vowels_count('ACEDY')
-- 3
local function vowels_count(s)
  local count = 0
  local len = #s
  for i = 1, len do
    local c = s:sub(i, i):lower()
    if c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' then
      count = count + 1
    elseif c == 'y' and i == len then
      count = count + 1
    end
  end
  return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = vowels_count
    lu.assertEquals(candidate('abcde'), 2)
    lu.assertEquals(candidate('Alone'), 3)
    lu.assertEquals(candidate('key'), 2)
    lu.assertEquals(candidate('bye'), 1)
    lu.assertEquals(candidate('keY'), 2)
    lu.assertEquals(candidate('bYe'), 1)
    lu.assertEquals(candidate('ACEDY'), 3)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 65 (LUA) - HumanEval_65_circular_shift
================================================================================

PROMPT:
----------------------------------------
-- Circular shift the digits of the integer x, shift the digits right by shift
-- and return the result as a string.
-- If shift > number of digits, return digits reversed.
-- >>> circular_shift(12, 1)
-- '21'
-- >>> circular_shift(12, 2)
-- '12'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = circular_shift
    lu.assertEquals(candidate(100, 2), '001')
    lu.assertEquals(candidate(12, 2), '12')
    lu.assertEquals(candidate(97, 8), '79')
    lu.assertEquals(candidate(12, 1), '21')
    lu.assertEquals(candidate(11, 101), '11')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Circular shift the digits of the integer x, shift the digits right by shift
-- and return the result as a string.
-- If shift > number of digits, return digits reversed.
-- >>> circular_shift(12, 1)
-- '21'
-- >>> circular_shift(12, 2)
-- '12'
-- Circular shift the digits of the integer x, shift the digits right by shift
-- and return the result as a string.
-- If shift > number of digits, return digits reversed.
-- >>> circular_shift(12, 1)
-- '21'
-- >>> circular_shift(12, 2)
-- '12'
local function circular_shift(x, shift)
    local s = tostring(x)
    local n = #s

    -- If shift is larger than the number of digits, simply reverse the string
    if shift > n then
        return string.reverse(s)
    end

    -- Normal circular right shift
    shift = shift % n
    if shift == 0 then
        return s
    end

    local part1 = s:sub(n - shift + 1)   -- last 'shift' digits
    local part2 = s:sub(1, n - shift)    -- the remaining digits
    return part1 .. part2
end
lu = require('luaunit')

function test_humaneval()
local candidate = circular_shift
    lu.assertEquals(candidate(100, 2), '001')
    lu.assertEquals(candidate(12, 2), '12')
    lu.assertEquals(candidate(97, 8), '79')
    lu.assertEquals(candidate(12, 1), '21')
    lu.assertEquals(candidate(11, 101), '11')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Circular shift the digits of the integer x, shift the digits right by shift
-- and return the result as a string.
-- If shift > number of digits, return digits reversed.
-- >>> circular_shift(12, 1)
-- '21'
-- >>> circular_shift(12, 2)
-- '12'
-- Circular shift the digits of the integer x, shift the digits right by shift
-- and return the result as a string.
-- If shift > number of digits, return digits reversed.
-- >>> circular_shift(12, 1)
-- '21'
-- >>> circular_shift(12, 2)
-- '12'
local function circular_shift(x, shift)
    local s = tostring(x)
    local n = #s

    -- If shift is greater than the number of digits, return reversed string
    if shift > n then
        return string.reverse(s)
    end

    -- Normal circular shift to the right
    local k = shift % n
    if k == 0 then
        return s
    end

    return s:sub(-k) .. s:sub(1, n - k)
end
lu = require('luaunit')

function test_humaneval()
local candidate = circular_shift
    lu.assertEquals(candidate(100, 2), '001')
    lu.assertEquals(candidate(12, 2), '12')
    lu.assertEquals(candidate(97, 8), '79')
    lu.assertEquals(candidate(12, 1), '21')
    lu.assertEquals(candidate(11, 101), '11')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Circular shift the digits of the integer x, shift the digits right by shift
-- and return the result as a string.
-- If shift > number of digits, return digits reversed.
-- >>> circular_shift(12, 1)
-- '21'
-- >>> circular_shift(12, 2)
-- '12'
local function circular_shift(x, shift)
  -- Convert the integer to a string of its digits
  local s = tostring(math.abs(x))
  local n = #s

  -- If shift is greater than the number of digits, return the digits reversed
  if shift > n then
    return s:reverse()
  end

  -- Normal circular shift to the right
  shift = shift % n
  if shift == 0 then
    return s
  end

  return s:sub(-shift) .. s:sub(1, n - shift)
end
lu = require('luaunit')

function test_humaneval()
local candidate = circular_shift
    lu.assertEquals(candidate(100, 2), '001')
    lu.assertEquals(candidate(12, 2), '12')
    lu.assertEquals(candidate(97, 8), '79')
    lu.assertEquals(candidate(12, 1), '21')
    lu.assertEquals(candidate(11, 101), '11')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Circular shift the digits of the integer x, shift the digits right by shift
-- and return the result as a string.
-- If shift > number of digits, return digits reversed.
-- >>> circular_shift(12, 1)
-- '21'
-- >>> circular_shift(12, 2)
-- '12'
-- Circular shift the digits of the integer x, shift the digits right by shift
-- and return the result as a string.
-- If shift > number of digits, return digits reversed.
-- >>> circular_shift(12, 1)
-- '21'
-- >>> circular_shift(12, 2)
-- '12'
local function circular_shift(x, shift)
    local s = tostring(x)
    local n = #s

    -- If shift is greater than the number of digits, reverse the string.
    if shift > n then
        local rev = {}
        for i = n, 1, -1 do
            rev[#rev + 1] = s:sub(i, i)
        end
        return table.concat(rev)
    end

    -- Normal right circular shift.
    shift = shift % n          -- just in case shift == n or > n
    if shift == 0 then
        return s
    end

    local part1 = s:sub(n - shift + 1, n)
    local part2 = s:sub(1, n - shift)
    return part1 .. part2
end
lu = require('luaunit')

function test_humaneval()
local candidate = circular_shift
    lu.assertEquals(candidate(100, 2), '001')
    lu.assertEquals(candidate(12, 2), '12')
    lu.assertEquals(candidate(97, 8), '79')
    lu.assertEquals(candidate(12, 1), '21')
    lu.assertEquals(candidate(11, 101), '11')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 66 (LUA) - HumanEval_66_digitSum
================================================================================

PROMPT:
----------------------------------------
-- Task
-- Write a function that takes a string as input and returns the sum of the upper characters only'
-- ASCII codes.
-- Examples:
-- >>> digitSum('')
-- 0
-- >>> digitSum('abAB')
-- 131
-- >>> digitSum('abcCd')
-- 67
-- >>> digitSum('helloE')
-- 69
-- >>> digitSum('woArBld')
-- 131
-- >>> digitSum('aAaaaXa')
-- 153

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = digitSum
    lu.assertEquals(candidate(''), 0)
    lu.assertEquals(candidate('abAB'), 131)
    lu.assertEquals(candidate('abcCd'), 67)
    lu.assertEquals(candidate('helloE'), 69)
    lu.assertEquals(candidate('woArBld'), 131)
    lu.assertEquals(candidate('aAaaaXa'), 153)
    lu.assertEquals(candidate(' How are yOu?'), 151)
    lu.assertEquals(candidate('You arE Very Smart'), 327)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Task
-- Write a function that takes a string as input and returns the sum of the upper characters only'
-- ASCII codes.
-- Examples:
-- >>> digitSum('')
-- 0
-- >>> digitSum('abAB')
-- 131
-- >>> digitSum('abcCd')
-- 67
-- >>> digitSum('helloE')
-- 69
-- >>> digitSum('woArBld')
-- 131
-- >>> digitSum('aAaaaXa')
-- 153
local function digitSum(s)
    local sum = 0
    for i = 1, #s do
        local byte = string.byte(s, i)
        if byte >= 65 and byte <= 90 then -- 'A' to 'Z'
            sum = sum + byte
        end
    end
    return sum
end
lu = require('luaunit')

function test_humaneval()
local candidate = digitSum
    lu.assertEquals(candidate(''), 0)
    lu.assertEquals(candidate('abAB'), 131)
    lu.assertEquals(candidate('abcCd'), 67)
    lu.assertEquals(candidate('helloE'), 69)
    lu.assertEquals(candidate('woArBld'), 131)
    lu.assertEquals(candidate('aAaaaXa'), 153)
    lu.assertEquals(candidate(' How are yOu?'), 151)
    lu.assertEquals(candidate('You arE Very Smart'), 327)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Task
-- Write a function that takes a string as input and returns the sum of the upper characters only'
-- ASCII codes.
-- Examples:
-- >>> digitSum('')
-- 0
-- >>> digitSum('abAB')
-- 131
-- >>> digitSum('abcCd')
-- 67
-- >>> digitSum('helloE')
-- 69
-- >>> digitSum('woArBld')
-- 131
-- >>> digitSum('aAaaaXa')
-- 153
-- Function that returns the sum of ASCII codes of uppercase letters only
local function digitSum(s)
    local sum = 0
    for i = 1, #s do
        local byte = string.byte(s, i)
        if byte >= string.byte('A') and byte <= string.byte('Z') then
            sum = sum + byte
        end
    end
    return sum
end
lu = require('luaunit')

function test_humaneval()
local candidate = digitSum
    lu.assertEquals(candidate(''), 0)
    lu.assertEquals(candidate('abAB'), 131)
    lu.assertEquals(candidate('abcCd'), 67)
    lu.assertEquals(candidate('helloE'), 69)
    lu.assertEquals(candidate('woArBld'), 131)
    lu.assertEquals(candidate('aAaaaXa'), 153)
    lu.assertEquals(candidate(' How are yOu?'), 151)
    lu.assertEquals(candidate('You arE Very Smart'), 327)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Task
-- Write a function that takes a string as input and returns the sum of the upper characters only'
-- ASCII codes.
-- Examples:
-- >>> digitSum('')
-- 0
-- >>> digitSum('abAB')
-- 131
-- >>> digitSum('abcCd')
-- 67
-- >>> digitSum('helloE')
-- 69
-- >>> digitSum('woArBld')
-- 131
-- >>> digitSum('aAaaaXa')
-- 153
-- Returns the sum of ASCII codes of the uppercase letters in the string `s`.
local function digitSum(s)
    local sum = 0
    for i = 1, #s do
        local c = s:sub(i, i)
        local code = string.byte(c)
        if code >= 65 and code <= 90 then   -- 'A' .. 'Z'
            sum = sum + code
        end
    end
    return sum
end
lu = require('luaunit')

function test_humaneval()
local candidate = digitSum
    lu.assertEquals(candidate(''), 0)
    lu.assertEquals(candidate('abAB'), 131)
    lu.assertEquals(candidate('abcCd'), 67)
    lu.assertEquals(candidate('helloE'), 69)
    lu.assertEquals(candidate('woArBld'), 131)
    lu.assertEquals(candidate('aAaaaXa'), 153)
    lu.assertEquals(candidate(' How are yOu?'), 151)
    lu.assertEquals(candidate('You arE Very Smart'), 327)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Task
-- Write a function that takes a string as input and returns the sum of the upper characters only'
-- ASCII codes.
-- Examples:
-- >>> digitSum('')
-- 0
-- >>> digitSum('abAB')
-- 131
-- >>> digitSum('abcCd')
-- 67
-- >>> digitSum('helloE')
-- 69
-- >>> digitSum('woArBld')
-- 131
-- >>> digitSum('aAaaaXa')
-- 153
local function digitSum(s)
    local sum = 0
    for i = 1, #s do
        local byte = string.byte(s, i)
        if byte >= 65 and byte <= 90 then  -- 'A' to 'Z'
            sum = sum + byte
        end
    end
    return sum
end
lu = require('luaunit')

function test_humaneval()
local candidate = digitSum
    lu.assertEquals(candidate(''), 0)
    lu.assertEquals(candidate('abAB'), 131)
    lu.assertEquals(candidate('abcCd'), 67)
    lu.assertEquals(candidate('helloE'), 69)
    lu.assertEquals(candidate('woArBld'), 131)
    lu.assertEquals(candidate('aAaaaXa'), 153)
    lu.assertEquals(candidate(' How are yOu?'), 151)
    lu.assertEquals(candidate('You arE Very Smart'), 327)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 67 (LUA) - HumanEval_67_fruit_distribution
================================================================================

PROMPT:
----------------------------------------
-- In this task, you will be given a string that represents a number of apples and oranges 
-- that are distributed in a basket of fruit this basket contains 
-- apples, oranges, and mango fruits. Given the string that represents the total number of 
-- the oranges and apples and an integer that represent the total number of the fruits 
-- in the basket return the number of the mango fruits in the basket.
-- for examble:
-- >>> fruit_distribution('5 apples and 6 oranges', 19)
-- 8
-- >>> fruit_distribution('0 apples and 1 oranges', 3)
-- 2
-- >>> fruit_distribution('2 apples and 3 oranges', 100)
-- 95
-- >>> fruit_distribution('100 apples and 1 oranges', 120)
-- 19

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = fruit_distribution
    lu.assertEquals(candidate('5 apples and 6 oranges', 19), 8)
    lu.assertEquals(candidate('5 apples and 6 oranges', 21), 10)
    lu.assertEquals(candidate('0 apples and 1 oranges', 3), 2)
    lu.assertEquals(candidate('1 apples and 0 oranges', 3), 2)
    lu.assertEquals(candidate('2 apples and 3 oranges', 100), 95)
    lu.assertEquals(candidate('2 apples and 3 oranges', 5), 0)
    lu.assertEquals(candidate('1 apples and 100 oranges', 120), 19)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- In this task, you will be given a string that represents a number of apples and oranges 
-- that are distributed in a basket of fruit this basket contains 
-- apples, oranges, and mango fruits. Given the string that represents the total number of 
-- the oranges and apples and an integer that represent the total number of the fruits 
-- in the basket return the number of the mango fruits in the basket.
-- for examble:
-- >>> fruit_distribution('5 apples and 6 oranges', 19)
-- 8
-- >>> fruit_distribution('0 apples and 1 oranges', 3)
-- 2
-- >>> fruit_distribution('2 apples and 3 oranges', 100)
-- 95
-- >>> fruit_distribution('100 apples and 1 oranges', 120)
-- 19
local function fruit_distribution(s, n)
    -- Extract the number of apples and oranges from the string.
    local apples_str, oranges_str = s:match("(%d+) apples and (%d+) oranges")
    local apples = tonumber(apples_str) or 0
    local oranges = tonumber(oranges_str) or 0

    -- Calculate the number of mangoes.
    local mangoes = n - (apples + oranges)

    return mangoes
end
lu = require('luaunit')

function test_humaneval()
local candidate = fruit_distribution
    lu.assertEquals(candidate('5 apples and 6 oranges', 19), 8)
    lu.assertEquals(candidate('5 apples and 6 oranges', 21), 10)
    lu.assertEquals(candidate('0 apples and 1 oranges', 3), 2)
    lu.assertEquals(candidate('1 apples and 0 oranges', 3), 2)
    lu.assertEquals(candidate('2 apples and 3 oranges', 100), 95)
    lu.assertEquals(candidate('2 apples and 3 oranges', 5), 0)
    lu.assertEquals(candidate('1 apples and 100 oranges', 120), 19)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- In this task, you will be given a string that represents a number of apples and oranges 
-- that are distributed in a basket of fruit this basket contains 
-- apples, oranges, and mango fruits. Given the string that represents the total number of 
-- the oranges and apples and an integer that represent the total number of the fruits 
-- in the basket return the number of the mango fruits in the basket.
-- for examble:
-- >>> fruit_distribution('5 apples and 6 oranges', 19)
-- 8
-- >>> fruit_distribution('0 apples and 1 oranges', 3)
-- 2
-- >>> fruit_distribution('2 apples and 3 oranges', 100)
-- 95
-- >>> fruit_distribution('100 apples and 1 oranges', 120)
-- 19
local function fruit_distribution(s, n)
  -- Extract the number of apples
  local apples = tonumber(s:match("(%d+)%s+apples"))
  -- Extract the number of oranges
  local oranges = tonumber(s:match("(%d+)%s+oranges"))

  -- If either number couldn't be parsed, treat it as 0
  apples = apples or 0
  oranges = oranges or 0

  -- Compute mangoes
  local mangoes = n - (apples + oranges)

  return mangoes
end
lu = require('luaunit')

function test_humaneval()
local candidate = fruit_distribution
    lu.assertEquals(candidate('5 apples and 6 oranges', 19), 8)
    lu.assertEquals(candidate('5 apples and 6 oranges', 21), 10)
    lu.assertEquals(candidate('0 apples and 1 oranges', 3), 2)
    lu.assertEquals(candidate('1 apples and 0 oranges', 3), 2)
    lu.assertEquals(candidate('2 apples and 3 oranges', 100), 95)
    lu.assertEquals(candidate('2 apples and 3 oranges', 5), 0)
    lu.assertEquals(candidate('1 apples and 100 oranges', 120), 19)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- In this task, you will be given a string that represents a number of apples and oranges 
-- that are distributed in a basket of fruit this basket contains 
-- apples, oranges, and mango fruits. Given the string that represents the total number of 
-- the oranges and apples and an integer that represent the total number of the fruits 
-- in the basket return the number of the mango fruits in the basket.
-- for examble:
-- >>> fruit_distribution('5 apples and 6 oranges', 19)
-- 8
-- >>> fruit_distribution('0 apples and 1 oranges', 3)
-- 2
-- >>> fruit_distribution('2 apples and 3 oranges', 100)
-- 95
-- >>> fruit_distribution('100 apples and 1 oranges', 120)
-- 19
local function fruit_distribution(s, n)
  -- Extract the number of apples and oranges from the string
  local apples   = tonumber(s:match("(%d+)%s*apples"))
  local oranges  = tonumber(s:match("(%d+)%s*oranges"))

  -- If the pattern does not match, raise an error
  if not apples or not oranges then
    error("Input string does not contain valid apple/orange counts")
  end

  -- Compute the number of mangoes
  return n - (apples + oranges)
end
lu = require('luaunit')

function test_humaneval()
local candidate = fruit_distribution
    lu.assertEquals(candidate('5 apples and 6 oranges', 19), 8)
    lu.assertEquals(candidate('5 apples and 6 oranges', 21), 10)
    lu.assertEquals(candidate('0 apples and 1 oranges', 3), 2)
    lu.assertEquals(candidate('1 apples and 0 oranges', 3), 2)
    lu.assertEquals(candidate('2 apples and 3 oranges', 100), 95)
    lu.assertEquals(candidate('2 apples and 3 oranges', 5), 0)
    lu.assertEquals(candidate('1 apples and 100 oranges', 120), 19)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- In this task, you will be given a string that represents a number of apples and oranges 
-- that are distributed in a basket of fruit this basket contains 
-- apples, oranges, and mango fruits. Given the string that represents the total number of 
-- the oranges and apples and an integer that represent the total number of the fruits 
-- in the basket return the number of the mango fruits in the basket.
-- for examble:
-- >>> fruit_distribution('5 apples and 6 oranges', 19)
-- 8
-- >>> fruit_distribution('0 apples and 1 oranges', 3)
-- 2
-- >>> fruit_distribution('2 apples and 3 oranges', 100)
-- 95
-- >>> fruit_distribution('100 apples and 1 oranges', 120)
-- 19
-- fruit_distribution(s, n)
--   s : string of the form "<apples> apples and <oranges> oranges"
--   n : integer, total number of fruits in the basket
-- returns : integer, number of mangoes

local function fruit_distribution(s, n)
  -- Use pattern matching to capture the two numbers
  local apples, oranges = s:match("(%d+)%s*apples%s+and%s+(%d+)%s*oranges")
  
  -- Convert captured strings to numbers
  apples = tonumber(apples) or 0
  oranges = tonumber(oranges) or 0
  
  -- Compute mangoes
  local mangoes = n - (apples + oranges)
  
  return mangoes
end

-- Example usage:
-- print(fruit_distribution('5 apples and 6 oranges', 19))  -- 8
-- print(fruit_distribution('0 apples and 1 oranges', 3))   -- 2
-- print(fruit_distribution('2 apples and 3 oranges', 100)) -- 95
-- print(fruit_distribution('100 apples and 1 oranges', 120)) -- 19
lu = require('luaunit')

function test_humaneval()
local candidate = fruit_distribution
    lu.assertEquals(candidate('5 apples and 6 oranges', 19), 8)
    lu.assertEquals(candidate('5 apples and 6 oranges', 21), 10)
    lu.assertEquals(candidate('0 apples and 1 oranges', 3), 2)
    lu.assertEquals(candidate('1 apples and 0 oranges', 3), 2)
    lu.assertEquals(candidate('2 apples and 3 oranges', 100), 95)
    lu.assertEquals(candidate('2 apples and 3 oranges', 5), 0)
    lu.assertEquals(candidate('1 apples and 100 oranges', 120), 19)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 69 (LUA) - HumanEval_69_search
================================================================================

PROMPT:
----------------------------------------
-- You are given a non-empty table of positive integers. Return the greatest integer that is greater than 
-- zero, and has a frequency greater than or equal to the value of the integer itself. 
-- The frequency of an integer is the number of times it appears in the table.
-- If no such a value exist, return -1.
-- Examples:
-- >>> search({4, 1, 2, 2, 3, 1})
-- 2
-- >>> search({1, 2, 2, 3, 3, 3, 4, 4, 4})
-- 3
-- >>> search({5, 5, 4, 4, 4})
-- -1

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = search
    lu.assertEquals(candidate({5, 5, 5, 5, 1}), 1)
    lu.assertEquals(candidate({4, 1, 4, 1, 4, 4}), 4)
    lu.assertEquals(candidate({3, 3}), -1)
    lu.assertEquals(candidate({8, 8, 8, 8, 8, 8, 8, 8}), 8)
    lu.assertEquals(candidate({2, 3, 3, 2, 2}), 2)
    lu.assertEquals(candidate({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), 1)
    lu.assertEquals(candidate({3, 2, 8, 2}), 2)
    lu.assertEquals(candidate({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), 1)
    lu.assertEquals(candidate({8, 8, 3, 6, 5, 6, 4}), -1)
    lu.assertEquals(candidate({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), 1)
    lu.assertEquals(candidate({1, 9, 10, 1, 3}), 1)
    lu.assertEquals(candidate({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), 5)
    lu.assertEquals(candidate({1}), 1)
    lu.assertEquals(candidate({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), 4)
    lu.assertEquals(candidate({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), 2)
    lu.assertEquals(candidate({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), 1)
    lu.assertEquals(candidate({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), 4)
    lu.assertEquals(candidate({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), 4)
    lu.assertEquals(candidate({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), 2)
    lu.assertEquals(candidate({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), -1)
    lu.assertEquals(candidate({10}), -1)
    lu.assertEquals(candidate({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), 2)
    lu.assertEquals(candidate({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), 1)
    lu.assertEquals(candidate({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), 1)
    lu.assertEquals(candidate({3, 10, 10, 9, 2}), -1)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You are given a non-empty table of positive integers. Return the greatest integer that is greater than 
-- zero, and has a frequency greater than or equal to the value of the integer itself. 
-- The frequency of an integer is the number of times it appears in the table.
-- If no such a value exist, return -1.
-- Examples:
-- >>> search({4, 1, 2, 2, 3, 1})
-- 2
-- >>> search({1, 2, 2, 3, 3, 3, 4, 4, 4})
-- 3
-- >>> search({5, 5, 4, 4, 4})
-- -1
local function search(lst)
    -- Count frequencies
    local freq = {}
    for _, val in ipairs(lst) do
        freq[val] = (freq[val] or 0) + 1
    end

    -- Find the greatest integer whose frequency >= its value
    local best = -1
    for num, count in pairs(freq) do
        if count >= num and num > best then
            best = num
        end
    end

    return best
end
lu = require('luaunit')

function test_humaneval()
local candidate = search
    lu.assertEquals(candidate({5, 5, 5, 5, 1}), 1)
    lu.assertEquals(candidate({4, 1, 4, 1, 4, 4}), 4)
    lu.assertEquals(candidate({3, 3}), -1)
    lu.assertEquals(candidate({8, 8, 8, 8, 8, 8, 8, 8}), 8)
    lu.assertEquals(candidate({2, 3, 3, 2, 2}), 2)
    lu.assertEquals(candidate({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), 1)
    lu.assertEquals(candidate({3, 2, 8, 2}), 2)
    lu.assertEquals(candidate({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), 1)
    lu.assertEquals(candidate({8, 8, 3, 6, 5, 6, 4}), -1)
    lu.assertEquals(candidate({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), 1)
    lu.assertEquals(candidate({1, 9, 10, 1, 3}), 1)
    lu.assertEquals(candidate({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), 5)
    lu.assertEquals(candidate({1}), 1)
    lu.assertEquals(candidate({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), 4)
    lu.assertEquals(candidate({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), 2)
    lu.assertEquals(candidate({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), 1)
    lu.assertEquals(candidate({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), 4)
    lu.assertEquals(candidate({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), 4)
    lu.assertEquals(candidate({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), 2)
    lu.assertEquals(candidate({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), -1)
    lu.assertEquals(candidate({10}), -1)
    lu.assertEquals(candidate({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), 2)
    lu.assertEquals(candidate({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), 1)
    lu.assertEquals(candidate({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), 1)
    lu.assertEquals(candidate({3, 10, 10, 9, 2}), -1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You are given a non-empty table of positive integers. Return the greatest integer that is greater than 
-- zero, and has a frequency greater than or equal to the value of the integer itself. 
-- The frequency of an integer is the number of times it appears in the table.
-- If no such a value exist, return -1.
-- Examples:
-- >>> search({4, 1, 2, 2, 3, 1})
-- 2
-- >>> search({1, 2, 2, 3, 3, 3, 4, 4, 4})
-- 3
-- >>> search({5, 5, 4, 4, 4})
-- -1
-- Find the greatest integer > 0 whose frequency >= its value
local function search(lst)
    -- Count frequencies
    local freq = {}
    for _, n in ipairs(lst) do
        if n > 0 then
            freq[n] = (freq[n] or 0) + 1
        end
    end

    -- Find the maximum qualifying integer
    local best = -1
    for n, cnt in pairs(freq) do
        if cnt >= n and n > best then
            best = n
        end
    end

    return best
end
lu = require('luaunit')

function test_humaneval()
local candidate = search
    lu.assertEquals(candidate({5, 5, 5, 5, 1}), 1)
    lu.assertEquals(candidate({4, 1, 4, 1, 4, 4}), 4)
    lu.assertEquals(candidate({3, 3}), -1)
    lu.assertEquals(candidate({8, 8, 8, 8, 8, 8, 8, 8}), 8)
    lu.assertEquals(candidate({2, 3, 3, 2, 2}), 2)
    lu.assertEquals(candidate({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), 1)
    lu.assertEquals(candidate({3, 2, 8, 2}), 2)
    lu.assertEquals(candidate({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), 1)
    lu.assertEquals(candidate({8, 8, 3, 6, 5, 6, 4}), -1)
    lu.assertEquals(candidate({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), 1)
    lu.assertEquals(candidate({1, 9, 10, 1, 3}), 1)
    lu.assertEquals(candidate({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), 5)
    lu.assertEquals(candidate({1}), 1)
    lu.assertEquals(candidate({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), 4)
    lu.assertEquals(candidate({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), 2)
    lu.assertEquals(candidate({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), 1)
    lu.assertEquals(candidate({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), 4)
    lu.assertEquals(candidate({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), 4)
    lu.assertEquals(candidate({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), 2)
    lu.assertEquals(candidate({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), -1)
    lu.assertEquals(candidate({10}), -1)
    lu.assertEquals(candidate({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), 2)
    lu.assertEquals(candidate({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), 1)
    lu.assertEquals(candidate({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), 1)
    lu.assertEquals(candidate({3, 10, 10, 9, 2}), -1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You are given a non-empty table of positive integers. Return the greatest integer that is greater than 
-- zero, and has a frequency greater than or equal to the value of the integer itself. 
-- The frequency of an integer is the number of times it appears in the table.
-- If no such a value exist, return -1.
-- Examples:
-- >>> search({4, 1, 2, 2, 3, 1})
-- 2
-- >>> search({1, 2, 2, 3, 3, 3, 4, 4, 4})
-- 3
-- >>> search({5, 5, 4, 4, 4})
-- -1
-- Returns the greatest integer > 0 whose frequency in `lst` is at least the integer itself.
-- If no such integer exists, returns -1.
local function search(lst)
    local freq = {}
    -- Count frequencies
    for _, v in ipairs(lst) do
        freq[v] = (freq[v] or 0) + 1
    end

    local best = -1
    for val, count in pairs(freq) do
        if val > 0 and count >= val and val > best then
            best = val
        end
    end

    return best
end
lu = require('luaunit')

function test_humaneval()
local candidate = search
    lu.assertEquals(candidate({5, 5, 5, 5, 1}), 1)
    lu.assertEquals(candidate({4, 1, 4, 1, 4, 4}), 4)
    lu.assertEquals(candidate({3, 3}), -1)
    lu.assertEquals(candidate({8, 8, 8, 8, 8, 8, 8, 8}), 8)
    lu.assertEquals(candidate({2, 3, 3, 2, 2}), 2)
    lu.assertEquals(candidate({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), 1)
    lu.assertEquals(candidate({3, 2, 8, 2}), 2)
    lu.assertEquals(candidate({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), 1)
    lu.assertEquals(candidate({8, 8, 3, 6, 5, 6, 4}), -1)
    lu.assertEquals(candidate({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), 1)
    lu.assertEquals(candidate({1, 9, 10, 1, 3}), 1)
    lu.assertEquals(candidate({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), 5)
    lu.assertEquals(candidate({1}), 1)
    lu.assertEquals(candidate({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), 4)
    lu.assertEquals(candidate({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), 2)
    lu.assertEquals(candidate({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), 1)
    lu.assertEquals(candidate({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), 4)
    lu.assertEquals(candidate({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), 4)
    lu.assertEquals(candidate({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), 2)
    lu.assertEquals(candidate({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), -1)
    lu.assertEquals(candidate({10}), -1)
    lu.assertEquals(candidate({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), 2)
    lu.assertEquals(candidate({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), 1)
    lu.assertEquals(candidate({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), 1)
    lu.assertEquals(candidate({3, 10, 10, 9, 2}), -1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You are given a non-empty table of positive integers. Return the greatest integer that is greater than 
-- zero, and has a frequency greater than or equal to the value of the integer itself. 
-- The frequency of an integer is the number of times it appears in the table.
-- If no such a value exist, return -1.
-- Examples:
-- >>> search({4, 1, 2, 2, 3, 1})
-- 2
-- >>> search({1, 2, 2, 3, 3, 3, 4, 4, 4})
-- 3
-- >>> search({5, 5, 4, 4, 4})
-- -1
-- Returns the greatest integer > 0 that appears in `lst` at least as many times
-- as its own value. If no such integer exists, returns -1.
local function search(lst)
    -- Count frequencies
    local freq = {}
    for _, v in ipairs(lst) do
        freq[v] = (freq[v] or 0) + 1
    end

    local best = -1
    for num, count in pairs(freq) do
        if num > 0 and count >= num then
            if num > best then
                best = num
            end
        end
    end
    return best
end
lu = require('luaunit')

function test_humaneval()
local candidate = search
    lu.assertEquals(candidate({5, 5, 5, 5, 1}), 1)
    lu.assertEquals(candidate({4, 1, 4, 1, 4, 4}), 4)
    lu.assertEquals(candidate({3, 3}), -1)
    lu.assertEquals(candidate({8, 8, 8, 8, 8, 8, 8, 8}), 8)
    lu.assertEquals(candidate({2, 3, 3, 2, 2}), 2)
    lu.assertEquals(candidate({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), 1)
    lu.assertEquals(candidate({3, 2, 8, 2}), 2)
    lu.assertEquals(candidate({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), 1)
    lu.assertEquals(candidate({8, 8, 3, 6, 5, 6, 4}), -1)
    lu.assertEquals(candidate({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), 1)
    lu.assertEquals(candidate({1, 9, 10, 1, 3}), 1)
    lu.assertEquals(candidate({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), 5)
    lu.assertEquals(candidate({1}), 1)
    lu.assertEquals(candidate({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), 4)
    lu.assertEquals(candidate({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), 2)
    lu.assertEquals(candidate({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), 1)
    lu.assertEquals(candidate({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), 4)
    lu.assertEquals(candidate({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), 4)
    lu.assertEquals(candidate({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), 2)
    lu.assertEquals(candidate({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), -1)
    lu.assertEquals(candidate({10}), -1)
    lu.assertEquals(candidate({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), 2)
    lu.assertEquals(candidate({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), 1)
    lu.assertEquals(candidate({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), 1)
    lu.assertEquals(candidate({3, 10, 10, 9, 2}), -1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 70 (LUA) - HumanEval_70_strange_sort_list
================================================================================

PROMPT:
----------------------------------------
-- Given table of integers, return table in strange order.
-- Strange sorting, is when you start with the minimum value,
-- then maximum of the remaining integers, then minimum and so on.
-- Examples:
-- >>> strange_sort_list({1, 2, 3, 4})
-- {1, 4, 2, 3}
-- >>> strange_sort_list({5, 5, 5, 5})
-- {5, 5, 5, 5}
-- >>> strange_sort_list({})
-- {}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = strange_sort_list
    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 4, 2, 3})
    lu.assertEquals(candidate({5, 6, 7, 8, 9}), {5, 9, 6, 8, 7})
    lu.assertEquals(candidate({1, 2, 3, 4, 5}), {1, 5, 2, 4, 3})
    lu.assertEquals(candidate({5, 6, 7, 8, 9, 1}), {1, 9, 5, 8, 6, 7})
    lu.assertEquals(candidate({5, 5, 5, 5}), {5, 5, 5, 5})
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8}), {1, 8, 2, 7, 3, 6, 4, 5})
    lu.assertEquals(candidate({0, 2, 2, 2, 5, 5, -5, -5}), {-5, 5, -5, 5, 0, 2, 2, 2})
    lu.assertEquals(candidate({111111}), {111111})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given table of integers, return table in strange order.
-- Strange sorting, is when you start with the minimum value,
-- then maximum of the remaining integers, then minimum and so on.
-- Examples:
-- >>> strange_sort_list({1, 2, 3, 4})
-- {1, 4, 2, 3}
-- >>> strange_sort_list({5, 5, 5, 5})
-- {5, 5, 5, 5}
-- >>> strange_sort_list({})
-- {}
-- Strange sorting: start with the minimum value, then maximum of the remaining integers,
-- then minimum, and so on.
local function strange_sort_list(lst)
    -- If the list is empty, just return an empty table
    if #lst == 0 then
        return {}
    end

    -- Make a copy so we don't modify the original table
    local sorted = {}
    for i = 1, #lst do
        sorted[i] = lst[i]
    end

    -- Sort the copy in ascending order
    table.sort(sorted)

    local result = {}
    local left  = 1          -- index of the current minimum
    local right = #sorted    -- index of the current maximum

    while left <= right do
        -- Take the current minimum
        result[#result + 1] = sorted[left]
        left = left + 1
        if left > right then break end

        -- Then take the current maximum
        result[#result + 1] = sorted[right]
        right = right - 1
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = strange_sort_list
    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 4, 2, 3})
    lu.assertEquals(candidate({5, 6, 7, 8, 9}), {5, 9, 6, 8, 7})
    lu.assertEquals(candidate({1, 2, 3, 4, 5}), {1, 5, 2, 4, 3})
    lu.assertEquals(candidate({5, 6, 7, 8, 9, 1}), {1, 9, 5, 8, 6, 7})
    lu.assertEquals(candidate({5, 5, 5, 5}), {5, 5, 5, 5})
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8}), {1, 8, 2, 7, 3, 6, 4, 5})
    lu.assertEquals(candidate({0, 2, 2, 2, 5, 5, -5, -5}), {-5, 5, -5, 5, 0, 2, 2, 2})
    lu.assertEquals(candidate({111111}), {111111})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given table of integers, return table in strange order.
-- Strange sorting, is when you start with the minimum value,
-- then maximum of the remaining integers, then minimum and so on.
-- Examples:
-- >>> strange_sort_list({1, 2, 3, 4})
-- {1, 4, 2, 3}
-- >>> strange_sort_list({5, 5, 5, 5})
-- {5, 5, 5, 5}
-- >>> strange_sort_list({})
-- {}
-- Strange sort: take the minimum, then the maximum of the remaining,
-- then the next minimum, and so on.
local function strange_sort_list(lst)
    local n = #lst
    if n == 0 then
        return {}
    end

    -- Make a copy so we don't modify the original table
    local sorted = {}
    for i = 1, n do
        sorted[i] = lst[i]
    end

    -- Sort ascending
    table.sort(sorted)

    local result = {}
    local left = 1
    local right = n

    while left <= right do
        -- Take the current minimum
        result[#result + 1] = sorted[left]
        if left == right then
            break
        end
        -- Take the current maximum
        result[#result + 1] = sorted[right]
        left = left + 1
        right = right - 1
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = strange_sort_list
    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 4, 2, 3})
    lu.assertEquals(candidate({5, 6, 7, 8, 9}), {5, 9, 6, 8, 7})
    lu.assertEquals(candidate({1, 2, 3, 4, 5}), {1, 5, 2, 4, 3})
    lu.assertEquals(candidate({5, 6, 7, 8, 9, 1}), {1, 9, 5, 8, 6, 7})
    lu.assertEquals(candidate({5, 5, 5, 5}), {5, 5, 5, 5})
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8}), {1, 8, 2, 7, 3, 6, 4, 5})
    lu.assertEquals(candidate({0, 2, 2, 2, 5, 5, -5, -5}), {-5, 5, -5, 5, 0, 2, 2, 2})
    lu.assertEquals(candidate({111111}), {111111})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given table of integers, return table in strange order.
-- Strange sorting, is when you start with the minimum value,
-- then maximum of the remaining integers, then minimum and so on.
-- Examples:
-- >>> strange_sort_list({1, 2, 3, 4})
-- {1, 4, 2, 3}
-- >>> strange_sort_list({5, 5, 5, 5})
-- {5, 5, 5, 5}
-- >>> strange_sort_list({})
-- {}
local function strange_sort_list(lst)
    local n = #lst
    if n == 0 then
        return {}
    end

    -- Make a copy of the input list so we don't modify the original
    local sorted = {}
    for i = 1, n do
        sorted[i] = lst[i]
    end

    -- Sort the copy in ascending order
    table.sort(sorted)

    -- Build the result using the "min, max, min, max, ..." pattern
    local result = {}
    local low = 1
    local high = n

    while low <= high do
        table.insert(result, sorted[low])
        low = low + 1
        if low <= high then
            table.insert(result, sorted[high])
            high = high - 1
        end
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = strange_sort_list
    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 4, 2, 3})
    lu.assertEquals(candidate({5, 6, 7, 8, 9}), {5, 9, 6, 8, 7})
    lu.assertEquals(candidate({1, 2, 3, 4, 5}), {1, 5, 2, 4, 3})
    lu.assertEquals(candidate({5, 6, 7, 8, 9, 1}), {1, 9, 5, 8, 6, 7})
    lu.assertEquals(candidate({5, 5, 5, 5}), {5, 5, 5, 5})
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8}), {1, 8, 2, 7, 3, 6, 4, 5})
    lu.assertEquals(candidate({0, 2, 2, 2, 5, 5, -5, -5}), {-5, 5, -5, 5, 0, 2, 2, 2})
    lu.assertEquals(candidate({111111}), {111111})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given table of integers, return table in strange order.
-- Strange sorting, is when you start with the minimum value,
-- then maximum of the remaining integers, then minimum and so on.
-- Examples:
-- >>> strange_sort_list({1, 2, 3, 4})
-- {1, 4, 2, 3}
-- >>> strange_sort_list({5, 5, 5, 5})
-- {5, 5, 5, 5}
-- >>> strange_sort_list({})
-- {}
-- Strange sorting: start with the minimum value, then the maximum of the
-- remaining integers, then the next minimum, and so on.
--
-- Examples:
-- >>> strange_sort_list({1, 2, 3, 4})
-- {1, 4, 2, 3}
-- >>> strange_sort_list({5, 5, 5, 5})
-- {5, 5, 5, 5}
-- >>> strange_sort_list({})
-- {}

local function strange_sort_list(lst)
    -- Make a copy of the list so we don't modify the original
    local sorted = {}
    for _, v in ipairs(lst) do
        table.insert(sorted, v)
    end

    -- Sort the copy in ascending order
    table.sort(sorted)

    -- Build the result by alternating from the front and back
    local result = {}
    local i, j = 1, #sorted
    while i <= j do
        table.insert(result, sorted[i])          -- take the current minimum
        if i ~= j then
            table.insert(result, sorted[j])      -- take the current maximum
        end
        i = i + 1
        j = j - 1
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = strange_sort_list
    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 4, 2, 3})
    lu.assertEquals(candidate({5, 6, 7, 8, 9}), {5, 9, 6, 8, 7})
    lu.assertEquals(candidate({1, 2, 3, 4, 5}), {1, 5, 2, 4, 3})
    lu.assertEquals(candidate({5, 6, 7, 8, 9, 1}), {1, 9, 5, 8, 6, 7})
    lu.assertEquals(candidate({5, 5, 5, 5}), {5, 5, 5, 5})
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8}), {1, 8, 2, 7, 3, 6, 4, 5})
    lu.assertEquals(candidate({0, 2, 2, 2, 5, 5, -5, -5}), {-5, 5, -5, 5, 0, 2, 2, 2})
    lu.assertEquals(candidate({111111}), {111111})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 71 (LUA) - HumanEval_71_triangle_area
================================================================================

PROMPT:
----------------------------------------
-- Given the lengths of the three sides of a triangle. Return the area of
-- the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
-- Otherwise return -1
-- Three sides make a valid triangle when the sum of any two sides is greater 
-- than the third side.
-- Example:
-- >>> triangle_area(3, 4, 5)
-- 6.0
-- >>> triangle_area(1, 2, 10)
-- -1

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = triangle_area
    lu.assertEquals(candidate(3, 4, 5), 6.0)
    lu.assertEquals(candidate(1, 2, 10), -1)
    lu.assertEquals(candidate(4, 8, 5), 8.18)
    lu.assertEquals(candidate(2, 2, 2), 1.73)
    lu.assertEquals(candidate(1, 2, 3), -1)
    lu.assertEquals(candidate(10, 5, 7), 16.25)
    lu.assertEquals(candidate(2, 6, 3), -1)
    lu.assertEquals(candidate(1, 1, 1), 0.43)
    lu.assertEquals(candidate(2, 2, 10), -1)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given the lengths of the three sides of a triangle. Return the area of
-- the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
-- Otherwise return -1
-- Three sides make a valid triangle when the sum of any two sides is greater 
-- than the third side.
-- Example:
-- >>> triangle_area(3, 4, 5)
-- 6.0
-- >>> triangle_area(1, 2, 10)
-- -1
-- Calculate the area of a triangle given its three side lengths.
-- Returns the area rounded to 2 decimal places if the sides form a valid triangle,
-- otherwise returns -1.
local function triangle_area(a, b, c)
  -- Validate that all sides are positive numbers
  if a <= 0 or b <= 0 or c <= 0 then
    return -1
  end

  -- Check the triangle inequality
  if a + b <= c or a + c <= b or b + c <= a then
    return -1
  end

  -- Heron's formula
  local s = (a + b + c) / 2
  local area = math.sqrt(s * (s - a) * (s - b) * (s - c))

  -- Round to 2 decimal places
  return math.floor(area * 100 + 0.5) / 100
end
lu = require('luaunit')

function test_humaneval()
local candidate = triangle_area
    lu.assertEquals(candidate(3, 4, 5), 6.0)
    lu.assertEquals(candidate(1, 2, 10), -1)
    lu.assertEquals(candidate(4, 8, 5), 8.18)
    lu.assertEquals(candidate(2, 2, 2), 1.73)
    lu.assertEquals(candidate(1, 2, 3), -1)
    lu.assertEquals(candidate(10, 5, 7), 16.25)
    lu.assertEquals(candidate(2, 6, 3), -1)
    lu.assertEquals(candidate(1, 1, 1), 0.43)
    lu.assertEquals(candidate(2, 2, 10), -1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given the lengths of the three sides of a triangle. Return the area of
-- the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
-- Otherwise return -1
-- Three sides make a valid triangle when the sum of any two sides is greater 
-- than the third side.
-- Example:
-- >>> triangle_area(3, 4, 5)
-- 6.0
-- >>> triangle_area(1, 2, 10)
-- -1
-- Returns the area of a triangle given its side lengths, rounded to 2 decimal places.
-- If the sides do not form a valid triangle, returns -1.
local function triangle_area(a, b, c)
    -- Basic validation: sides must be positive
    if a <= 0 or b <= 0 or c <= 0 then
        return -1
    end

    -- Triangle inequality check
    if a + b <= c or a + c <= b or b + c <= a then
        return -1
    end

    -- Heron's formula
    local s = (a + b + c) / 2
    local area = math.sqrt(s * (s - a) * (s - b) * (s - c))

    -- Round to two decimal places
    local rounded = math.floor(area * 100 + 0.5) / 100
    return rounded
end
lu = require('luaunit')

function test_humaneval()
local candidate = triangle_area
    lu.assertEquals(candidate(3, 4, 5), 6.0)
    lu.assertEquals(candidate(1, 2, 10), -1)
    lu.assertEquals(candidate(4, 8, 5), 8.18)
    lu.assertEquals(candidate(2, 2, 2), 1.73)
    lu.assertEquals(candidate(1, 2, 3), -1)
    lu.assertEquals(candidate(10, 5, 7), 16.25)
    lu.assertEquals(candidate(2, 6, 3), -1)
    lu.assertEquals(candidate(1, 1, 1), 0.43)
    lu.assertEquals(candidate(2, 2, 10), -1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given the lengths of the three sides of a triangle. Return the area of
-- the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
-- Otherwise return -1
-- Three sides make a valid triangle when the sum of any two sides is greater 
-- than the third side.
-- Example:
-- >>> triangle_area(3, 4, 5)
-- 6.0
-- >>> triangle_area(1, 2, 10)
-- -1
local function triangle_area(a, b, c)
    -- Check for positive sides
    if a <= 0 or b <= 0 or c <= 0 then
        return -1
    end

    -- Triangle inequality test
    if a + b <= c or a + c <= b or b + c <= a then
        return -1
    end

    -- Heron's formula
    local s = (a + b + c) / 2
    local area = math.sqrt(s * (s - a) * (s - b) * (s - c))

    -- Round to 2 decimal places
    local rounded = math.floor(area * 100 + 0.5) / 100
    return rounded
end
lu = require('luaunit')

function test_humaneval()
local candidate = triangle_area
    lu.assertEquals(candidate(3, 4, 5), 6.0)
    lu.assertEquals(candidate(1, 2, 10), -1)
    lu.assertEquals(candidate(4, 8, 5), 8.18)
    lu.assertEquals(candidate(2, 2, 2), 1.73)
    lu.assertEquals(candidate(1, 2, 3), -1)
    lu.assertEquals(candidate(10, 5, 7), 16.25)
    lu.assertEquals(candidate(2, 6, 3), -1)
    lu.assertEquals(candidate(1, 1, 1), 0.43)
    lu.assertEquals(candidate(2, 2, 10), -1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given the lengths of the three sides of a triangle. Return the area of
-- the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
-- Otherwise return -1
-- Three sides make a valid triangle when the sum of any two sides is greater 
-- than the third side.
-- Example:
-- >>> triangle_area(3, 4, 5)
-- 6.0
-- >>> triangle_area(1, 2, 10)
-- -1
-- Calculate the area of a triangle given side lengths a, b, and c.
-- Returns the area rounded to two decimal places if the sides form a valid triangle,
-- otherwise returns -1.
local function triangle_area(a, b, c)
    -- Check for a valid triangle
    if not (a + b > c and a + c > b and b + c > a) then
        return -1
    end

    -- Heron's formula
    local s = (a + b + c) / 2
    local area = math.sqrt(s * (s - a) * (s - b) * (s - c))

    -- Round to two decimal places
    local rounded = math.floor(area * 100 + 0.5) / 100
    return rounded
end
lu = require('luaunit')

function test_humaneval()
local candidate = triangle_area
    lu.assertEquals(candidate(3, 4, 5), 6.0)
    lu.assertEquals(candidate(1, 2, 10), -1)
    lu.assertEquals(candidate(4, 8, 5), 8.18)
    lu.assertEquals(candidate(2, 2, 2), 1.73)
    lu.assertEquals(candidate(1, 2, 3), -1)
    lu.assertEquals(candidate(10, 5, 7), 16.25)
    lu.assertEquals(candidate(2, 6, 3), -1)
    lu.assertEquals(candidate(1, 1, 1), 0.43)
    lu.assertEquals(candidate(2, 2, 10), -1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154472
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------
