As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 101 (LUA) - HumanEval_101_words_string
================================================================================

PROMPT:
----------------------------------------
-- You will be given a string of words separated by commas or spaces. Your task is
-- to split the string into words and return a table of the words.
-- For example:
-- >>> words_string('Hi, my name is John')
-- {'Hi', 'my', 'name', 'is', 'John'}
-- >>> words_string('One, two, three, four, five, six')
-- {'One', 'two', 'three', 'four', 'five', 'six'}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = words_string
    lu.assertEquals(candidate('Hi, my name is John'), {'Hi', 'my', 'name', 'is', 'John'})
    lu.assertEquals(candidate('One, two, three, four, five, six'), {'One', 'two', 'three', 'four', 'five', 'six'})
    lu.assertEquals(candidate('Hi, my name'), {'Hi', 'my', 'name'})
    lu.assertEquals(candidate('One,, two, three, four, five, six,'), {'One', 'two', 'three', 'four', 'five', 'six'})
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('ahmed     , gamal'), {'ahmed', 'gamal'})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You will be given a string of words separated by commas or spaces. Your task is
-- to split the string into words and return a table of the words.
-- For example:
-- >>> words_string('Hi, my name is John')
-- {'Hi', 'my', 'name', 'is', 'John'}
-- >>> words_string('One, two, three, four, five, six')
-- {'One', 'two', 'three', 'four', 'five', 'six'}
local function words_string(s)
    local words = {}
    for word in s:gmatch("[^,%s]+") do
        table.insert(words, word)
    end
    return words
end
lu = require('luaunit')

function test_humaneval()
local candidate = words_string
    lu.assertEquals(candidate('Hi, my name is John'), {'Hi', 'my', 'name', 'is', 'John'})
    lu.assertEquals(candidate('One, two, three, four, five, six'), {'One', 'two', 'three', 'four', 'five', 'six'})
    lu.assertEquals(candidate('Hi, my name'), {'Hi', 'my', 'name'})
    lu.assertEquals(candidate('One,, two, three, four, five, six,'), {'One', 'two', 'three', 'four', 'five', 'six'})
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('ahmed     , gamal'), {'ahmed', 'gamal'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You will be given a string of words separated by commas or spaces. Your task is
-- to split the string into words and return a table of the words.
-- For example:
-- >>> words_string('Hi, my name is John')
-- {'Hi', 'my', 'name', 'is', 'John'}
-- >>> words_string('One, two, three, four, five, six')
-- {'One', 'two', 'three', 'four', 'five', 'six'}
local function words_string(s)
  local words = {}
  for word in s:gmatch("[^, ]+") do
    table.insert(words, word)
  end
  return words
end
lu = require('luaunit')

function test_humaneval()
local candidate = words_string
    lu.assertEquals(candidate('Hi, my name is John'), {'Hi', 'my', 'name', 'is', 'John'})
    lu.assertEquals(candidate('One, two, three, four, five, six'), {'One', 'two', 'three', 'four', 'five', 'six'})
    lu.assertEquals(candidate('Hi, my name'), {'Hi', 'my', 'name'})
    lu.assertEquals(candidate('One,, two, three, four, five, six,'), {'One', 'two', 'three', 'four', 'five', 'six'})
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('ahmed     , gamal'), {'ahmed', 'gamal'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You will be given a string of words separated by commas or spaces. Your task is
-- to split the string into words and return a table of the words.
-- For example:
-- >>> words_string('Hi, my name is John')
-- {'Hi', 'my', 'name', 'is', 'John'}
-- >>> words_string('One, two, three, four, five, six')
-- {'One', 'two', 'three', 'four', 'five', 'six'}
-- Splits a string into words separated by commas or whitespace.
-- Returns an array (table) containing the words.
local function words_string(s)
    local t = {}
    for w in string.gmatch(s, "[^,%s]+") do
        table.insert(t, w)
    end
    return t
end
lu = require('luaunit')

function test_humaneval()
local candidate = words_string
    lu.assertEquals(candidate('Hi, my name is John'), {'Hi', 'my', 'name', 'is', 'John'})
    lu.assertEquals(candidate('One, two, three, four, five, six'), {'One', 'two', 'three', 'four', 'five', 'six'})
    lu.assertEquals(candidate('Hi, my name'), {'Hi', 'my', 'name'})
    lu.assertEquals(candidate('One,, two, three, four, five, six,'), {'One', 'two', 'three', 'four', 'five', 'six'})
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('ahmed     , gamal'), {'ahmed', 'gamal'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You will be given a string of words separated by commas or spaces. Your task is
-- to split the string into words and return a table of the words.
-- For example:
-- >>> words_string('Hi, my name is John')
-- {'Hi', 'my', 'name', 'is', 'John'}
-- >>> words_string('One, two, three, four, five, six')
-- {'One', 'two', 'three', 'four', 'five', 'six'}
local function words_string(s)
  local result = {}
  if type(s) ~= "string" then return result end

  -- Match sequences of characters that are not spaces or commas
  for word in s:gmatch("[^%s,]+") do
    table.insert(result, word)
  end

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = words_string
    lu.assertEquals(candidate('Hi, my name is John'), {'Hi', 'my', 'name', 'is', 'John'})
    lu.assertEquals(candidate('One, two, three, four, five, six'), {'One', 'two', 'three', 'four', 'five', 'six'})
    lu.assertEquals(candidate('Hi, my name'), {'Hi', 'my', 'name'})
    lu.assertEquals(candidate('One,, two, three, four, five, six,'), {'One', 'two', 'three', 'four', 'five', 'six'})
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('ahmed     , gamal'), {'ahmed', 'gamal'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 102 (LUA) - HumanEval_102_choose_num
================================================================================

PROMPT:
----------------------------------------
-- This function takes two positive numbers x and y and returns the
-- biggest even integer number that is in the range [x, y] inclusive. If 
-- there's no such number, then the function should return -1.
-- For example:
-- >>> choose_num(12, 15)
-- 14
-- >>> choose_num(13, 12)
-- -1

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = choose_num
    lu.assertEquals(candidate(12, 15), 14)
    lu.assertEquals(candidate(13, 12), -1)
    lu.assertEquals(candidate(33, 12354), 12354)
    lu.assertEquals(candidate(5234, 5233), -1)
    lu.assertEquals(candidate(6, 29), 28)
    lu.assertEquals(candidate(27, 10), -1)
    lu.assertEquals(candidate(7, 7), -1)
    lu.assertEquals(candidate(546, 546), 546)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- This function takes two positive numbers x and y and returns the
-- biggest even integer number that is in the range [x, y] inclusive. If 
-- there's no such number, then the function should return -1.
-- For example:
-- >>> choose_num(12, 15)
-- 14
-- >>> choose_num(13, 12)
-- -1
local function choose_num(x, y)
    -- If the range is invalid, immediately return -1
    if x > y then
        return -1
    end

    -- Find the largest even integer <= y
    local candidate = y
    if candidate % 2 ~= 0 then
        candidate = candidate - 1
    end

    -- Check if this candidate lies within the range [x, y]
    if candidate >= x then
        return candidate
    else
        return -1
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = choose_num
    lu.assertEquals(candidate(12, 15), 14)
    lu.assertEquals(candidate(13, 12), -1)
    lu.assertEquals(candidate(33, 12354), 12354)
    lu.assertEquals(candidate(5234, 5233), -1)
    lu.assertEquals(candidate(6, 29), 28)
    lu.assertEquals(candidate(27, 10), -1)
    lu.assertEquals(candidate(7, 7), -1)
    lu.assertEquals(candidate(546, 546), 546)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- This function takes two positive numbers x and y and returns the
-- biggest even integer number that is in the range [x, y] inclusive. If 
-- there's no such number, then the function should return -1.
-- For example:
-- >>> choose_num(12, 15)
-- 14
-- >>> choose_num(13, 12)
-- -1
-- This function takes two positive numbers x and y and returns the
-- biggest even integer number that is in the range [x, y] inclusive. If 
-- there's no such number, then the function should return -1.
-- For example:
-- >>> choose_num(12, 15)
-- 14
-- >>> choose_num(13, 12)
-- -1
local function choose_num(x, y)
    -- If the range is invalid, immediately return -1
    if x > y then
        return -1
    end

    -- Find the largest even number <= y
    local candidate
    if y % 2 == 0 then
        candidate = y
    else
        candidate = y - 1
    end

    -- Check if this candidate lies within the range [x, y]
    if candidate >= x then
        return candidate
    else
        return -1
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = choose_num
    lu.assertEquals(candidate(12, 15), 14)
    lu.assertEquals(candidate(13, 12), -1)
    lu.assertEquals(candidate(33, 12354), 12354)
    lu.assertEquals(candidate(5234, 5233), -1)
    lu.assertEquals(candidate(6, 29), 28)
    lu.assertEquals(candidate(27, 10), -1)
    lu.assertEquals(candidate(7, 7), -1)
    lu.assertEquals(candidate(546, 546), 546)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- This function takes two positive numbers x and y and returns the
-- biggest even integer number that is in the range [x, y] inclusive. If 
-- there's no such number, then the function should return -1.
-- For example:
-- >>> choose_num(12, 15)
-- 14
-- >>> choose_num(13, 12)
-- -1
-- This function takes two positive numbers x and y and returns the
-- biggest even integer number that is in the range [x, y] inclusive.
-- If there's no such number, then the function should return -1.
-- For example:
-- >>> choose_num(12, 15)
-- 14
-- >>> choose_num(13, 12)
-- -1
local function choose_num(x, y)
    -- Ensure x is not greater than y
    if x > y then
        return -1
    end

    -- Find the largest even number <= y
    local candidate = (y % 2 == 0) and y or y - 1

    -- Check if this candidate is within the range
    if candidate < x then
        return -1
    end

    return candidate
end
lu = require('luaunit')

function test_humaneval()
local candidate = choose_num
    lu.assertEquals(candidate(12, 15), 14)
    lu.assertEquals(candidate(13, 12), -1)
    lu.assertEquals(candidate(33, 12354), 12354)
    lu.assertEquals(candidate(5234, 5233), -1)
    lu.assertEquals(candidate(6, 29), 28)
    lu.assertEquals(candidate(27, 10), -1)
    lu.assertEquals(candidate(7, 7), -1)
    lu.assertEquals(candidate(546, 546), 546)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- This function takes two positive numbers x and y and returns the
-- biggest even integer number that is in the range [x, y] inclusive. If 
-- there's no such number, then the function should return -1.
-- For example:
-- >>> choose_num(12, 15)
-- 14
-- >>> choose_num(13, 12)
-- -1
-- This function takes two positive numbers x and y and returns the
-- biggest even integer number that is in the range [x, y] inclusive.
-- If there's no such number, then the function should return -1.
-- For example:
-- >>> choose_num(12, 15)
-- 14
-- >>> choose_num(13, 12)
-- -1
local function choose_num(x, y)
    -- If the interval is invalid, return -1 immediately
    if x > y then
        return -1
    end

    -- Find the largest even number not greater than y
    local candidate = math.floor(y / 2) * 2

    -- Check if that candidate lies within the interval
    if candidate >= x then
        return candidate
    else
        return -1
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = choose_num
    lu.assertEquals(candidate(12, 15), 14)
    lu.assertEquals(candidate(13, 12), -1)
    lu.assertEquals(candidate(33, 12354), 12354)
    lu.assertEquals(candidate(5234, 5233), -1)
    lu.assertEquals(candidate(6, 29), 28)
    lu.assertEquals(candidate(27, 10), -1)
    lu.assertEquals(candidate(7, 7), -1)
    lu.assertEquals(candidate(546, 546), 546)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 104 (LUA) - HumanEval_104_unique_digits
================================================================================

PROMPT:
----------------------------------------
-- Given a table of positive integers x. return a sorted table of all 
-- elements that hasn't any even digit.
-- Note: Returned table should be sorted in increasing order.
-- For example:
-- >>> unique_digits({15, 33, 1422, 1})
-- {1, 15, 33}
-- >>> unique_digits({152, 323, 1422, 10})
-- {}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = unique_digits
    lu.assertEquals(candidate({15, 33, 1422, 1}), {1, 15, 33})
    lu.assertEquals(candidate({152, 323, 1422, 10}), {})
    lu.assertEquals(candidate({12345, 2033, 111, 151}), {111, 151})
    lu.assertEquals(candidate({135, 103, 31}), {31, 135})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a table of positive integers x. return a sorted table of all 
-- elements that hasn't any even digit.
-- Note: Returned table should be sorted in increasing order.
-- For example:
-- >>> unique_digits({15, 33, 1422, 1})
-- {1, 15, 33}
-- >>> unique_digits({152, 323, 1422, 10})
-- {}
-- Returns a sorted table of all elements from `x` that contain
-- **no even digit** (i.e. all digits are odd).
-- The result is sorted in increasing order.
local function unique_digits(x)
    -- Result table
    local res = {}

    -- Helper to check if a number has only odd digits
    local function has_only_odd_digits(n)
        -- Special case: if n is 0, it has an even digit (0)
        if n == 0 then return false end

        while n > 0 do
            local digit = n % 10
            if digit % 2 == 0 then  -- even digit found
                return false
            end
            n = math.floor(n / 10)
        end
        return true
    end

    -- Iterate over the input table
    for _, num in ipairs(x) do
        if has_only_odd_digits(num) then
            table.insert(res, num)
        end
    end

    -- Sort the result in ascending order
    table.sort(res)

    return res
end
lu = require('luaunit')

function test_humaneval()
local candidate = unique_digits
    lu.assertEquals(candidate({15, 33, 1422, 1}), {1, 15, 33})
    lu.assertEquals(candidate({152, 323, 1422, 10}), {})
    lu.assertEquals(candidate({12345, 2033, 111, 151}), {111, 151})
    lu.assertEquals(candidate({135, 103, 31}), {31, 135})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a table of positive integers x. return a sorted table of all 
-- elements that hasn't any even digit.
-- Note: Returned table should be sorted in increasing order.
-- For example:
-- >>> unique_digits({15, 33, 1422, 1})
-- {1, 15, 33}
-- >>> unique_digits({152, 323, 1422, 10})
-- {}
-- Return a sorted table of all numbers from `x` that contain **only odd digits**.
-- Numbers that contain any even digit (0,2,4,6,8) are omitted.
-- The result is sorted in ascending order.
--
-- Example:
--   unique_digits({15, 33, 1422, 1})  --> {1, 15, 33}
--   unique_digits({152, 323, 1422, 10}) --> {}
local function unique_digits(x)
    local result = {}

    -- Helper: check if a number contains only odd digits
    local function has_only_odd_digits(n)
        while n > 0 do
            local digit = n % 10
            if digit % 2 == 0 then   -- even digit found
                return false
            end
            n = math.floor(n / 10)
        end
        return true
    end

    for _, num in ipairs(x) do
        if num > 0 and has_only_odd_digits(num) then
            table.insert(result, num)
        end
    end

    table.sort(result)
    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = unique_digits
    lu.assertEquals(candidate({15, 33, 1422, 1}), {1, 15, 33})
    lu.assertEquals(candidate({152, 323, 1422, 10}), {})
    lu.assertEquals(candidate({12345, 2033, 111, 151}), {111, 151})
    lu.assertEquals(candidate({135, 103, 31}), {31, 135})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a table of positive integers x. return a sorted table of all 
-- elements that hasn't any even digit.
-- Note: Returned table should be sorted in increasing order.
-- For example:
-- >>> unique_digits({15, 33, 1422, 1})
-- {1, 15, 33}
-- >>> unique_digits({152, 323, 1422, 10})
-- {}
-- Returns a sorted table of all numbers from `x` that contain **only odd digits**.
-- Numbers with any even digit (0,2,4,6,8) are excluded.
--
-- Example:
--   unique_digits({15, 33, 1422, 1})  --> {1, 15, 33}
--   unique_digits({152, 323, 1422, 10}) --> {}
local function unique_digits(x)
    local res = {}

    for _, n in ipairs(x) do
        local ok = true
        local num = n

        -- Check each decimal digit
        while num > 0 do
            local d = num % 10
            if d % 2 == 0 then   -- even digit found
                ok = false
                break
            end
            num = math.floor(num / 10)
        end

        if ok then
            table.insert(res, n)
        end
    end

    table.sort(res)   -- sort in increasing order
    return res
end
lu = require('luaunit')

function test_humaneval()
local candidate = unique_digits
    lu.assertEquals(candidate({15, 33, 1422, 1}), {1, 15, 33})
    lu.assertEquals(candidate({152, 323, 1422, 10}), {})
    lu.assertEquals(candidate({12345, 2033, 111, 151}), {111, 151})
    lu.assertEquals(candidate({135, 103, 31}), {31, 135})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a table of positive integers x. return a sorted table of all 
-- elements that hasn't any even digit.
-- Note: Returned table should be sorted in increasing order.
-- For example:
-- >>> unique_digits({15, 33, 1422, 1})
-- {1, 15, 33}
-- >>> unique_digits({152, 323, 1422, 10})
-- {}
-- Return a sorted table of numbers that contain only odd digits.
-- Input: x – a table of positive integers.
-- Output: a new table containing the qualifying numbers, sorted in ascending order.

local function unique_digits(x)
    -- Table to hold the qualifying numbers
    local result = {}

    -- Helper function to test if a number has only odd digits
    local function has_only_odd_digits(n)
        -- Handle the case of 0 (though the problem states positive integers)
        if n == 0 then return false end

        while n > 0 do
            local digit = n % 10
            if digit % 2 == 0 then  -- even digit found
                return false
            end
            n = math.floor(n / 10)
        end
        return true
    end

    -- Iterate over the input table
    for _, num in ipairs(x) do
        if has_only_odd_digits(num) then
            table.insert(result, num)
        end
    end

    -- Sort the result in increasing order
    table.sort(result)
    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = unique_digits
    lu.assertEquals(candidate({15, 33, 1422, 1}), {1, 15, 33})
    lu.assertEquals(candidate({152, 323, 1422, 10}), {})
    lu.assertEquals(candidate({12345, 2033, 111, 151}), {111, 151})
    lu.assertEquals(candidate({135, 103, 31}), {31, 135})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 105 (LUA) - HumanEval_105_by_length
================================================================================

PROMPT:
----------------------------------------
-- Given a table of integers, sort the integers that are between 1 and 9 inclusive,
-- reverse the resulting table, and then replace each digit by its corresponding name from
-- "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
-- For example:
-- >>> by_length({2, 1, 1, 4, 5, 8, 2, 3})
-- {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'}
--   If the table is empty, return an empty table:
-- >>> by_length({})
-- {}
--   If the table has any strange number ignore it:
-- >>> by_length({1, -1, 55})
-- {'One'}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = by_length
    lu.assertEquals(candidate({2, 1, 1, 4, 5, 8, 2, 3}), {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'})
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, -1, 55}), {'One'})
    lu.assertEquals(candidate({1, -1, 3, 2}), {'Three', 'Two', 'One'})
    lu.assertEquals(candidate({9, 4, 8}), {'Nine', 'Eight', 'Four'})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a table of integers, sort the integers that are between 1 and 9 inclusive,
-- reverse the resulting table, and then replace each digit by its corresponding name from
-- "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
-- For example:
-- >>> by_length({2, 1, 1, 4, 5, 8, 2, 3})
-- {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'}
--   If the table is empty, return an empty table:
-- >>> by_length({})
-- {}
--   If the table has any strange number ignore it:
-- >>> by_length({1, -1, 55})
-- {'One'}
-- Function to sort digits 1–9, reverse the order, and replace each digit with its name
local function by_length(arr)
  -- Mapping from digit to name
  local names = {
    [1] = "One",
    [2] = "Two",
    [3] = "Three",
    [4] = "Four",
    [5] = "Five",
    [6] = "Six",
    [7] = "Seven",
    [8] = "Eight",
    [9] = "Nine",
  }

  -- 1. Filter only numbers between 1 and 9 (inclusive)
  local filtered = {}
  for _, v in ipairs(arr) do
    if v >= 1 and v <= 9 then
      table.insert(filtered, v)
    end
  end

  -- 2. Sort the filtered numbers (ascending)
  table.sort(filtered)

  -- 3. Reverse the sorted table
  local reversed = {}
  for i = #filtered, 1, -1 do
    table.insert(reversed, filtered[i])
  end

  -- 4. Replace each digit by its corresponding name
  local result = {}
  for _, v in ipairs(reversed) do
    table.insert(result, names[v])
  end

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = by_length
    lu.assertEquals(candidate({2, 1, 1, 4, 5, 8, 2, 3}), {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'})
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, -1, 55}), {'One'})
    lu.assertEquals(candidate({1, -1, 3, 2}), {'Three', 'Two', 'One'})
    lu.assertEquals(candidate({9, 4, 8}), {'Nine', 'Eight', 'Four'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a table of integers, sort the integers that are between 1 and 9 inclusive,
-- reverse the resulting table, and then replace each digit by its corresponding name from
-- "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
-- For example:
-- >>> by_length({2, 1, 1, 4, 5, 8, 2, 3})
-- {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'}
--   If the table is empty, return an empty table:
-- >>> by_length({})
-- {}
--   If the table has any strange number ignore it:
-- >>> by_length({1, -1, 55})
-- {'One'}
-- Function to sort integers between 1 and 9, reverse the order,
-- and replace each digit with its word representation.
local function by_length(arr)
    -- Mapping from digit to name
    local names = {
        [1] = "One",
        [2] = "Two",
        [3] = "Three",
        [4] = "Four",
        [5] = "Five",
        [6] = "Six",
        [7] = "Seven",
        [8] = "Eight",
        [9] = "Nine"
    }

    -- 1. Filter only valid digits
    local filtered = {}
    for _, v in ipairs(arr) do
        if v >= 1 and v <= 9 then
            table.insert(filtered, v)
        end
    end

    -- 2. Sort ascending
    table.sort(filtered)

    -- 3. Reverse and map to names
    local result = {}
    for i = #filtered, 1, -1 do
        local digit = filtered[i]
        table.insert(result, names[digit])
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = by_length
    lu.assertEquals(candidate({2, 1, 1, 4, 5, 8, 2, 3}), {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'})
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, -1, 55}), {'One'})
    lu.assertEquals(candidate({1, -1, 3, 2}), {'Three', 'Two', 'One'})
    lu.assertEquals(candidate({9, 4, 8}), {'Nine', 'Eight', 'Four'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a table of integers, sort the integers that are between 1 and 9 inclusive,
-- reverse the resulting table, and then replace each digit by its corresponding name from
-- "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
-- For example:
-- >>> by_length({2, 1, 1, 4, 5, 8, 2, 3})
-- {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'}
--   If the table is empty, return an empty table:
-- >>> by_length({})
-- {}
--   If the table has any strange number ignore it:
-- >>> by_length({1, -1, 55})
-- {'One'}
-- Sort the integers that are between 1 and 9 inclusive, reverse the resulting
-- table, and then replace each digit by its corresponding name from
-- "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
--
-- Examples:
--   by_length({2, 1, 1, 4, 5, 8, 2, 3}) --> {"Eight","Five","Four","Three","Two","Two","One","One"}
--   by_length({}) --> {}
--   by_length({1, -1, 55}) --> {"One"}
local function by_length(arr)
    -- Mapping from digit to name
    local names = {
        [1] = "One",
        [2] = "Two",
        [3] = "Three",
        [4] = "Four",
        [5] = "Five",
        [6] = "Six",
        [7] = "Seven",
        [8] = "Eight",
        [9] = "Nine",
    }

    -- 1. Filter numbers in the range 1..9
    local filtered = {}
    for _, v in ipairs(arr) do
        if type(v) == "number" and v >= 1 and v <= 9 then
            table.insert(filtered, v)
        end
    end

    -- 2. Sort ascending
    table.sort(filtered)

    -- 3. Reverse and map to names
    local result = {}
    for i = #filtered, 1, -1 do
        local digit = filtered[i]
        table.insert(result, names[digit])
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = by_length
    lu.assertEquals(candidate({2, 1, 1, 4, 5, 8, 2, 3}), {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'})
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, -1, 55}), {'One'})
    lu.assertEquals(candidate({1, -1, 3, 2}), {'Three', 'Two', 'One'})
    lu.assertEquals(candidate({9, 4, 8}), {'Nine', 'Eight', 'Four'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a table of integers, sort the integers that are between 1 and 9 inclusive,
-- reverse the resulting table, and then replace each digit by its corresponding name from
-- "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
-- For example:
-- >>> by_length({2, 1, 1, 4, 5, 8, 2, 3})
-- {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'}
--   If the table is empty, return an empty table:
-- >>> by_length({})
-- {}
--   If the table has any strange number ignore it:
-- >>> by_length({1, -1, 55})
-- {'One'}
local function by_length(arr)
  -- Mapping from digit to its name
  local names = {
    [1] = "One",
    [2] = "Two",
    [3] = "Three",
    [4] = "Four",
    [5] = "Five",
    [6] = "Six",
    [7] = "Seven",
    [8] = "Eight",
    [9] = "Nine",
  }

  -- Guard against nil input
  if not arr then
    return {}
  end

  -- Filter out numbers that are not between 1 and 9 inclusive
  local filtered = {}
  for _, v in ipairs(arr) do
    if type(v) == "number" and v >= 1 and v <= 9 then
      table.insert(filtered, v)
    end
  end

  -- If nothing valid, return an empty table
  if #filtered == 0 then
    return {}
  end

  -- Sort the filtered numbers in ascending order
  table.sort(filtered)

  -- Build the result by iterating from the end (reverse order)
  local result = {}
  for i = #filtered, 1, -1 do
    local digit = filtered[i]
    result[#result + 1] = names[digit]
  end

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = by_length
    lu.assertEquals(candidate({2, 1, 1, 4, 5, 8, 2, 3}), {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'})
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, -1, 55}), {'One'})
    lu.assertEquals(candidate({1, -1, 3, 2}), {'Three', 'Two', 'One'})
    lu.assertEquals(candidate({9, 4, 8}), {'Nine', 'Eight', 'Four'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 106 (LUA) - HumanEval_106_f
================================================================================

PROMPT:
----------------------------------------
-- Implement the function f that takes n as a parameter,
-- and returns a table of size n, such that the value of the element at index i is the factorial of i if i is even
-- or the sum of numbers from 1 to i otherwise.
-- i starts from 1.
-- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
-- Example:
-- >>> f(5)
-- {1, 2, 6, 24, 15}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = f
    lu.assertEquals(candidate(5), {1, 2, 6, 24, 15})
    lu.assertEquals(candidate(7), {1, 2, 6, 24, 15, 720, 28})
    lu.assertEquals(candidate(1), {1})
    lu.assertEquals(candidate(3), {1, 2, 6})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Implement the function f that takes n as a parameter,
-- and returns a table of size n, such that the value of the element at index i is the factorial of i if i is even
-- or the sum of numbers from 1 to i otherwise.
-- i starts from 1.
-- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
-- Example:
-- >>> f(5)
-- {1, 2, 6, 24, 15}
local function f(n)
    local res = {}
    local fact = 1
    local sum = 0
    for i = 1, n do
        fact = fact * i
        sum = sum + i
        if i % 2 == 0 then
            res[i] = fact
        else
            res[i] = sum
        end
    end
    return res
end
lu = require('luaunit')

function test_humaneval()
local candidate = f
    lu.assertEquals(candidate(5), {1, 2, 6, 24, 15})
    lu.assertEquals(candidate(7), {1, 2, 6, 24, 15, 720, 28})
    lu.assertEquals(candidate(1), {1})
    lu.assertEquals(candidate(3), {1, 2, 6})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Implement the function f that takes n as a parameter,
-- and returns a table of size n, such that the value of the element at index i is the factorial of i if i is even
-- or the sum of numbers from 1 to i otherwise.
-- i starts from 1.
-- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
-- Example:
-- >>> f(5)
-- {1, 2, 6, 24, 15}
-- Computes a table where each element at index i is:
--   * factorial(i) if i is even
--   * sum from 1 to i (triangular number) if i is odd
-- i starts from 1.
local function f(n)
    local result = {}
    local fact = 1          -- running factorial
    for i = 1, n do
        fact = fact * i     -- update factorial for current i
        if i % 2 == 0 then
            result[i] = fact
        else
            result[i] = i * (i + 1) / 2
        end
    end
    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = f
    lu.assertEquals(candidate(5), {1, 2, 6, 24, 15})
    lu.assertEquals(candidate(7), {1, 2, 6, 24, 15, 720, 28})
    lu.assertEquals(candidate(1), {1})
    lu.assertEquals(candidate(3), {1, 2, 6})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Implement the function f that takes n as a parameter,
-- and returns a table of size n, such that the value of the element at index i is the factorial of i if i is even
-- or the sum of numbers from 1 to i otherwise.
-- i starts from 1.
-- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
-- Example:
-- >>> f(5)
-- {1, 2, 6, 24, 15}
-- Returns a table where:
--   - Even indices contain the factorial of the index
--   - Odd indices contain the sum of numbers from 1 to the index
local function f(n)
  local result = {}

  for i = 1, n do
    if i % 2 == 0 then
      -- Compute factorial for even i
      local fact = 1
      for j = 1, i do
        fact = fact * j
      end
      result[i] = fact
    else
      -- Compute sum for odd i
      local sum = 0
      for j = 1, i do
        sum = sum + j
      end
      result[i] = sum
    end
  end

  return result
end

-- Example usage:
-- print(table.concat(f(5), ", "))  --> 1, 2, 6, 24, 15
lu = require('luaunit')

function test_humaneval()
local candidate = f
    lu.assertEquals(candidate(5), {1, 2, 6, 24, 15})
    lu.assertEquals(candidate(7), {1, 2, 6, 24, 15, 720, 28})
    lu.assertEquals(candidate(1), {1})
    lu.assertEquals(candidate(3), {1, 2, 6})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Implement the function f that takes n as a parameter,
-- and returns a table of size n, such that the value of the element at index i is the factorial of i if i is even
-- or the sum of numbers from 1 to i otherwise.
-- i starts from 1.
-- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
-- Example:
-- >>> f(5)
-- {1, 2, 6, 24, 15}
-- Returns a table where each element is either the factorial (if the index is even)
-- or the sum of all numbers from 1 to that index (if the index is odd).
local function f(n)
  local result = {}

  for i = 1, n do
    if i % 2 == 0 then
      -- Compute factorial of i
      local fact = 1
      for j = 2, i do
        fact = fact * j
      end
      result[i] = fact
    else
      -- Compute sum of numbers from 1 to i
      result[i] = i * (i + 1) / 2
    end
  end

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = f
    lu.assertEquals(candidate(5), {1, 2, 6, 24, 15})
    lu.assertEquals(candidate(7), {1, 2, 6, 24, 15, 720, 28})
    lu.assertEquals(candidate(1), {1})
    lu.assertEquals(candidate(3), {1, 2, 6})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 107 (LUA) - HumanEval_107_even_odd_palindrome
================================================================================

PROMPT:
----------------------------------------
-- Given a positive integer n, return a table that has the number of even and odd
-- integer palindromes that fall within the range(1, n), inclusive.
-- Example 1:
-- >>> even_odd_palindrome(3)
-- {1, 2}
--     Explanation:
--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
-- Example 2:
-- >>> even_odd_palindrome(12)
-- {4, 6}
--     Explanation:
--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
-- Note:
--     1. 1 <= n <= 10^3
--     2. returned table has the number of even and odd integer palindromes respectively.

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = even_odd_palindrome
    lu.assertEquals(candidate(123), {8, 13})
    lu.assertEquals(candidate(12), {4, 6})
    lu.assertEquals(candidate(3), {1, 2})
    lu.assertEquals(candidate(63), {6, 8})
    lu.assertEquals(candidate(25), {5, 6})
    lu.assertEquals(candidate(19), {4, 6})
    lu.assertEquals(candidate(9), {4, 5})
    lu.assertEquals(candidate(1), {0, 1})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a positive integer n, return a table that has the number of even and odd
-- integer palindromes that fall within the range(1, n), inclusive.
-- Example 1:
-- >>> even_odd_palindrome(3)
-- {1, 2}
--     Explanation:
--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
-- Example 2:
-- >>> even_odd_palindrome(12)
-- {4, 6}
--     Explanation:
--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
-- Note:
--     1. 1 <= n <= 10^3
--     2. returned table has the number of even and odd integer palindromes respectively.
-- Helper function to check if a number is a palindrome
local function is_palindrome(num)
    local s = tostring(num)
    return s == s:reverse()
end

-- Main function: returns a table {even_count, odd_count}
local function even_odd_palindrome(n)
    local even, odd = 0, 0

    for i = 1, n do
        if is_palindrome(i) then
            if i % 2 == 0 then
                even = even + 1
            else
                odd = odd + 1
            end
        end
    end

    return {even, odd}
end
lu = require('luaunit')

function test_humaneval()
local candidate = even_odd_palindrome
    lu.assertEquals(candidate(123), {8, 13})
    lu.assertEquals(candidate(12), {4, 6})
    lu.assertEquals(candidate(3), {1, 2})
    lu.assertEquals(candidate(63), {6, 8})
    lu.assertEquals(candidate(25), {5, 6})
    lu.assertEquals(candidate(19), {4, 6})
    lu.assertEquals(candidate(9), {4, 5})
    lu.assertEquals(candidate(1), {0, 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a positive integer n, return a table that has the number of even and odd
-- integer palindromes that fall within the range(1, n), inclusive.
-- Example 1:
-- >>> even_odd_palindrome(3)
-- {1, 2}
--     Explanation:
--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
-- Example 2:
-- >>> even_odd_palindrome(12)
-- {4, 6}
--     Explanation:
--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
-- Note:
--     1. 1 <= n <= 10^3
--     2. returned table has the number of even and odd integer palindromes respectively.
-- Given a positive integer n, return a table that has the number of even and odd
-- integer palindromes that fall within the range(1, n), inclusive.
-- Example 1:
-- >>> even_odd_palindrome(3)
-- {1, 2}
--     Explanation:
--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
-- Example 2:
-- >>> even_odd_palindrome(12)
-- {4, 6}
--     Explanation:
--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
-- Note:
--     1. 1 <= n <= 10^3
--     2. returned table has the number of even and odd integer palindromes respectively.
local function even_odd_palindrome(n)
    -- Helper to check if a number is a palindrome
    local function is_palindrome(num)
        local s = tostring(num)
        local len = #s
        for i = 1, math.floor(len / 2) do
            if s:sub(i, i) ~= s:sub(len - i + 1, len - i + 1) then
                return false
            end
        end
        return true
    end

    local even_count = 0
    local odd_count = 0

    for i = 1, n do
        if is_palindrome(i) then
            if i % 2 == 0 then
                even_count = even_count + 1
            else
                odd_count = odd_count + 1
            end
        end
    end

    return {even_count, odd_count}
end
lu = require('luaunit')

function test_humaneval()
local candidate = even_odd_palindrome
    lu.assertEquals(candidate(123), {8, 13})
    lu.assertEquals(candidate(12), {4, 6})
    lu.assertEquals(candidate(3), {1, 2})
    lu.assertEquals(candidate(63), {6, 8})
    lu.assertEquals(candidate(25), {5, 6})
    lu.assertEquals(candidate(19), {4, 6})
    lu.assertEquals(candidate(9), {4, 5})
    lu.assertEquals(candidate(1), {0, 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a positive integer n, return a table that has the number of even and odd
-- integer palindromes that fall within the range(1, n), inclusive.
-- Example 1:
-- >>> even_odd_palindrome(3)
-- {1, 2}
--     Explanation:
--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
-- Example 2:
-- >>> even_odd_palindrome(12)
-- {4, 6}
--     Explanation:
--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
-- Note:
--     1. 1 <= n <= 10^3
--     2. returned table has the number of even and odd integer palindromes respectively.
-- Return a table {even, odd} where:
-- * even – number of even integer palindromes in [1, n]
-- * odd  – number of odd  integer palindromes in [1, n]
local function even_odd_palindrome(n)
    local even, odd = 0, 0

    for i = 1, n do
        local s = tostring(i)
        local rev = s:reverse()
        if s == rev then          -- i is a palindrome
            if i % 2 == 0 then
                even = even + 1
            else
                odd = odd + 1
            end
        end
    end

    return {even, odd}
end
lu = require('luaunit')

function test_humaneval()
local candidate = even_odd_palindrome
    lu.assertEquals(candidate(123), {8, 13})
    lu.assertEquals(candidate(12), {4, 6})
    lu.assertEquals(candidate(3), {1, 2})
    lu.assertEquals(candidate(63), {6, 8})
    lu.assertEquals(candidate(25), {5, 6})
    lu.assertEquals(candidate(19), {4, 6})
    lu.assertEquals(candidate(9), {4, 5})
    lu.assertEquals(candidate(1), {0, 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a positive integer n, return a table that has the number of even and odd
-- integer palindromes that fall within the range(1, n), inclusive.
-- Example 1:
-- >>> even_odd_palindrome(3)
-- {1, 2}
--     Explanation:
--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
-- Example 2:
-- >>> even_odd_palindrome(12)
-- {4, 6}
--     Explanation:
--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
-- Note:
--     1. 1 <= n <= 10^3
--     2. returned table has the number of even and odd integer palindromes respectively.
-- Returns a table {even_count, odd_count} of integer palindromes in [1, n]
local function even_odd_palindrome(n)
    local even, odd = 0, 0

    -- Helper to determine if an integer is a palindrome
    local function is_palindrome(num)
        local s = tostring(num)
        local rs = s:reverse()
        return s == rs
    end

    for i = 1, n do
        if is_palindrome(i) then
            if i % 2 == 0 then
                even = even + 1
            else
                odd = odd + 1
            end
        end
    end

    return {even, odd}
end
lu = require('luaunit')

function test_humaneval()
local candidate = even_odd_palindrome
    lu.assertEquals(candidate(123), {8, 13})
    lu.assertEquals(candidate(12), {4, 6})
    lu.assertEquals(candidate(3), {1, 2})
    lu.assertEquals(candidate(63), {6, 8})
    lu.assertEquals(candidate(25), {5, 6})
    lu.assertEquals(candidate(19), {4, 6})
    lu.assertEquals(candidate(9), {4, 5})
    lu.assertEquals(candidate(1), {0, 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 108 (LUA) - HumanEval_108_count_nums
================================================================================

PROMPT:
----------------------------------------
-- Write a function count_nums which takes a table of integers and returns
-- the number of elements which has a sum of digits > 0.
-- If a number is negative, then its first signed digit will be negative:
-- e.g. -123 has signed digits -1, 2, and 3.
-- >>> count_nums({})
-- 0
-- >>> count_nums({-1, 11, -11})
-- 1
-- >>> count_nums({1, 1, 2})
-- 3

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = count_nums
    lu.assertEquals(candidate({}), 0)
    lu.assertEquals(candidate({-1, -2, 0}), 0)
    lu.assertEquals(candidate({1, 1, 2, -2, 3, 4, 5}), 6)
    lu.assertEquals(candidate({1, 6, 9, -6, 0, 1, 5}), 5)
    lu.assertEquals(candidate({1, 100, 98, -7, 1, -1}), 4)
    lu.assertEquals(candidate({12, 23, 34, -45, -56, 0}), 5)
    lu.assertEquals(candidate({0, 1}), 1)
    lu.assertEquals(candidate({1}), 1)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Write a function count_nums which takes a table of integers and returns
-- the number of elements which has a sum of digits > 0.
-- If a number is negative, then its first signed digit will be negative:
-- e.g. -123 has signed digits -1, 2, and 3.
-- >>> count_nums({})
-- 0
-- >>> count_nums({-1, 11, -11})
-- 1
-- >>> count_nums({1, 1, 2})
-- 3
-- Count how many numbers in the table have a signed sum of digits > 0.
-- For negative numbers the first digit is treated as negative.
-- Example:
--   count_nums({-1, 11, -11})  --> 1
--   count_nums({1, 1, 2})      --> 3
local function count_nums(arr)
  local count = 0

  for _, num in ipairs(arr) do
    local sum = 0
    local negative = num < 0
    local abs_str = tostring(math.abs(num))

    for i = 1, #abs_str do
      local digit = tonumber(abs_str:sub(i, i))
      if i == 1 and negative then
        sum = sum - digit   -- first digit is negative
      else
        sum = sum + digit
      end
    end

    if sum > 0 then
      count = count + 1
    end
  end

  return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = count_nums
    lu.assertEquals(candidate({}), 0)
    lu.assertEquals(candidate({-1, -2, 0}), 0)
    lu.assertEquals(candidate({1, 1, 2, -2, 3, 4, 5}), 6)
    lu.assertEquals(candidate({1, 6, 9, -6, 0, 1, 5}), 5)
    lu.assertEquals(candidate({1, 100, 98, -7, 1, -1}), 4)
    lu.assertEquals(candidate({12, 23, 34, -45, -56, 0}), 5)
    lu.assertEquals(candidate({0, 1}), 1)
    lu.assertEquals(candidate({1}), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Write a function count_nums which takes a table of integers and returns
-- the number of elements which has a sum of digits > 0.
-- If a number is negative, then its first signed digit will be negative:
-- e.g. -123 has signed digits -1, 2, and 3.
-- >>> count_nums({})
-- 0
-- >>> count_nums({-1, 11, -11})
-- 1
-- >>> count_nums({1, 1, 2})
-- 3
local function count_nums(arr)
  local count = 0
  for _, n in ipairs(arr) do
    local sum = 0
    local s = tostring(math.abs(n))
    local first = true
    for i = 1, #s do
      local digit = tonumber(s:sub(i, i))
      if first and n < 0 then
        sum = sum - digit
        first = false
      else
        sum = sum + digit
      end
    end
    if sum > 0 then
      count = count + 1
    end
  end
  return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = count_nums
    lu.assertEquals(candidate({}), 0)
    lu.assertEquals(candidate({-1, -2, 0}), 0)
    lu.assertEquals(candidate({1, 1, 2, -2, 3, 4, 5}), 6)
    lu.assertEquals(candidate({1, 6, 9, -6, 0, 1, 5}), 5)
    lu.assertEquals(candidate({1, 100, 98, -7, 1, -1}), 4)
    lu.assertEquals(candidate({12, 23, 34, -45, -56, 0}), 5)
    lu.assertEquals(candidate({0, 1}), 1)
    lu.assertEquals(candidate({1}), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Write a function count_nums which takes a table of integers and returns
-- the number of elements which has a sum of digits > 0.
-- If a number is negative, then its first signed digit will be negative:
-- e.g. -123 has signed digits -1, 2, and 3.
-- >>> count_nums({})
-- 0
-- >>> count_nums({-1, 11, -11})
-- 1
-- >>> count_nums({1, 1, 2})
-- 3
-- Write a function count_nums which takes a table of integers and returns
-- the number of elements which has a sum of digits > 0.
-- If a number is negative, then its first signed digit will be negative:
-- e.g. -123 has signed digits -1, 2, and 3.
-- >>> count_nums({})
-- 0
-- >>> count_nums({-1, 11, -11})
-- 1
-- >>> count_nums({1, 1, 2})
-- 3
local function count_nums(arr)
  local count = 0
  for _, n in ipairs(arr) do
    local s = tostring(n)
    local sum = 0
    if s:sub(1, 1) == '-' then
      -- Negative number: first digit is signed negative
      local firstDigit = tonumber(s:sub(2, 2))
      sum = -firstDigit
      for i = 3, #s do
        sum = sum + tonumber(s:sub(i, i))
      end
    else
      -- Positive number: all digits are positive
      for i = 1, #s do
        sum = sum + tonumber(s:sub(i, i))
      end
    end
    if sum > 0 then
      count = count + 1
    end
  end
  return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = count_nums
    lu.assertEquals(candidate({}), 0)
    lu.assertEquals(candidate({-1, -2, 0}), 0)
    lu.assertEquals(candidate({1, 1, 2, -2, 3, 4, 5}), 6)
    lu.assertEquals(candidate({1, 6, 9, -6, 0, 1, 5}), 5)
    lu.assertEquals(candidate({1, 100, 98, -7, 1, -1}), 4)
    lu.assertEquals(candidate({12, 23, 34, -45, -56, 0}), 5)
    lu.assertEquals(candidate({0, 1}), 1)
    lu.assertEquals(candidate({1}), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Write a function count_nums which takes a table of integers and returns
-- the number of elements which has a sum of digits > 0.
-- If a number is negative, then its first signed digit will be negative:
-- e.g. -123 has signed digits -1, 2, and 3.
-- >>> count_nums({})
-- 0
-- >>> count_nums({-1, 11, -11})
-- 1
-- >>> count_nums({1, 1, 2})
-- 3
-- Count how many numbers in the array have a digit‑sum greater than zero.
-- For negative numbers the first digit is treated as negative.
local function count_nums(arr)
    local count = 0

    for _, n in ipairs(arr) do
        local sum = 0
        local s = tostring(n)

        -- Determine if the number is negative
        local startIdx = 1
        local firstDigitSign = 1
        if s:sub(1, 1) == '-' then
            firstDigitSign = -1
            startIdx = 2
        end

        -- Sum the digits, applying the sign to the first digit only
        for i = startIdx, #s do
            local digit = tonumber(s:sub(i, i))
            if digit then
                if i == startIdx then
                    sum = sum + firstDigitSign * digit
                else
                    sum = sum + digit
                end
            end
        end

        if sum > 0 then
            count = count + 1
        end
    end

    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = count_nums
    lu.assertEquals(candidate({}), 0)
    lu.assertEquals(candidate({-1, -2, 0}), 0)
    lu.assertEquals(candidate({1, 1, 2, -2, 3, 4, 5}), 6)
    lu.assertEquals(candidate({1, 6, 9, -6, 0, 1, 5}), 5)
    lu.assertEquals(candidate({1, 100, 98, -7, 1, -1}), 4)
    lu.assertEquals(candidate({12, 23, 34, -45, -56, 0}), 5)
    lu.assertEquals(candidate({0, 1}), 1)
    lu.assertEquals(candidate({1}), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 110 (LUA) - HumanEval_110_exchange
================================================================================

PROMPT:
----------------------------------------
-- In this problem, you will implement a function that takes two tables of numbers,
-- and determines whether it is possible to perform an exchange of elements
-- between them to make lst1 a table of only even numbers.
-- There is no limit on the number of exchanged elements between lst1 and lst2.
-- If it is possible to exchange elements between the lst1 and lst2 to make
-- all the elements of lst1 to be even, return "YES".
-- Otherwise, return "NO".
-- For example:
-- >>> exchange({1, 2, 3, 4}, {1, 2, 3, 4})
-- 'YES'
-- >>> exchange({1, 2, 3, 4}, {1, 5, 3, 4})
-- 'NO'
-- It is assumed that the input tables will be non-empty.

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = exchange
    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 2, 3, 4}), 'YES')
    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 5, 3, 4}), 'NO')
    lu.assertEquals(candidate({1, 2, 3, 4}, {2, 1, 4, 3}), 'YES')
    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 4}), 'YES')
    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 3}), 'NO')
    lu.assertEquals(candidate({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}), 'NO')
    lu.assertEquals(candidate({100, 200}, {200, 200}), 'YES')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- In this problem, you will implement a function that takes two tables of numbers,
-- and determines whether it is possible to perform an exchange of elements
-- between them to make lst1 a table of only even numbers.
-- There is no limit on the number of exchanged elements between lst1 and lst2.
-- If it is possible to exchange elements between the lst1 and lst2 to make
-- all the elements of lst1 to be even, return "YES".
-- Otherwise, return "NO".
-- For example:
-- >>> exchange({1, 2, 3, 4}, {1, 2, 3, 4})
-- 'YES'
-- >>> exchange({1, 2, 3, 4}, {1, 5, 3, 4})
-- 'NO'
-- It is assumed that the input tables will be non-empty.
-- Function to determine if lst1 can become all even by swapping elements with lst2
local function exchange(lst1, lst2)
    local len1 = #lst1          -- Number of elements that must become even
    local even_count = 0        -- Count of even numbers across both lists

    -- Count evens in lst1
    for _, v in ipairs(lst1) do
        if v % 2 == 0 then
            even_count = even_count + 1
        end
    end

    -- Count evens in lst2
    for _, v in ipairs(lst2) do
        if v % 2 == 0 then
            even_count = even_count + 1
        end
    end

    -- We can fill lst1 with evens if we have enough evens in total
    if even_count >= len1 then
        return "YES"
    else
        return "NO"
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = exchange
    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 2, 3, 4}), 'YES')
    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 5, 3, 4}), 'NO')
    lu.assertEquals(candidate({1, 2, 3, 4}, {2, 1, 4, 3}), 'YES')
    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 4}), 'YES')
    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 3}), 'NO')
    lu.assertEquals(candidate({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}), 'NO')
    lu.assertEquals(candidate({100, 200}, {200, 200}), 'YES')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- In this problem, you will implement a function that takes two tables of numbers,
-- and determines whether it is possible to perform an exchange of elements
-- between them to make lst1 a table of only even numbers.
-- There is no limit on the number of exchanged elements between lst1 and lst2.
-- If it is possible to exchange elements between the lst1 and lst2 to make
-- all the elements of lst1 to be even, return "YES".
-- Otherwise, return "NO".
-- For example:
-- >>> exchange({1, 2, 3, 4}, {1, 2, 3, 4})
-- 'YES'
-- >>> exchange({1, 2, 3, 4}, {1, 5, 3, 4})
-- 'NO'
-- It is assumed that the input tables will be non-empty.
-- Function to determine if lst1 can become all even by exchanging elements with lst2
local function exchange(lst1, lst2)
    -- Count the total number of even numbers in both lists
    local evens = 0
    for _, v in ipairs(lst1) do
        if v % 2 == 0 then evens = evens + 1 end
    end
    for _, v in ipairs(lst2) do
        if v % 2 == 0 then evens = evens + 1 end
    end

    -- lst1 can be all even iff we have at least |lst1| even numbers available
    if evens >= #lst1 then
        return "YES"
    else
        return "NO"
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = exchange
    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 2, 3, 4}), 'YES')
    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 5, 3, 4}), 'NO')
    lu.assertEquals(candidate({1, 2, 3, 4}, {2, 1, 4, 3}), 'YES')
    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 4}), 'YES')
    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 3}), 'NO')
    lu.assertEquals(candidate({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}), 'NO')
    lu.assertEquals(candidate({100, 200}, {200, 200}), 'YES')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- In this problem, you will implement a function that takes two tables of numbers,
-- and determines whether it is possible to perform an exchange of elements
-- between them to make lst1 a table of only even numbers.
-- There is no limit on the number of exchanged elements between lst1 and lst2.
-- If it is possible to exchange elements between the lst1 and lst2 to make
-- all the elements of lst1 to be even, return "YES".
-- Otherwise, return "NO".
-- For example:
-- >>> exchange({1, 2, 3, 4}, {1, 2, 3, 4})
-- 'YES'
-- >>> exchange({1, 2, 3, 4}, {1, 5, 3, 4})
-- 'NO'
-- It is assumed that the input tables will be non-empty.
-- Determine if we can exchange elements between two tables so that all elements
-- in lst1 become even.  We can perform any number of swaps, each swapping one
-- element from lst1 with one from lst2.
--
-- The key observation is that after any number of swaps, the multiset of
-- elements in lst1 is just a selection of size |lst1| from the combined
-- multiset of lst1 ∪ lst2.  Therefore we only need to check whether there
-- are at least |lst1| even numbers in that union.
--
-- Complexity: O(|lst1| + |lst2|) time, O(1) extra space.

local function exchange(lst1, lst2)
    -- Count even numbers in lst1
    local even_count = 0
    for _, v in ipairs(lst1) do
        if v % 2 == 0 then
            even_count = even_count + 1
        end
    end

    -- Count even numbers in lst2 and add to the total
    for _, v in ipairs(lst2) do
        if v % 2 == 0 then
            even_count = even_count + 1
        end
    end

    -- If we can pick |lst1| evens from the union, answer is YES
    if even_count >= #lst1 then
        return "YES"
    else
        return "NO"
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = exchange
    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 2, 3, 4}), 'YES')
    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 5, 3, 4}), 'NO')
    lu.assertEquals(candidate({1, 2, 3, 4}, {2, 1, 4, 3}), 'YES')
    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 4}), 'YES')
    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 3}), 'NO')
    lu.assertEquals(candidate({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}), 'NO')
    lu.assertEquals(candidate({100, 200}, {200, 200}), 'YES')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- In this problem, you will implement a function that takes two tables of numbers,
-- and determines whether it is possible to perform an exchange of elements
-- between them to make lst1 a table of only even numbers.
-- There is no limit on the number of exchanged elements between lst1 and lst2.
-- If it is possible to exchange elements between the lst1 and lst2 to make
-- all the elements of lst1 to be even, return "YES".
-- Otherwise, return "NO".
-- For example:
-- >>> exchange({1, 2, 3, 4}, {1, 2, 3, 4})
-- 'YES'
-- >>> exchange({1, 2, 3, 4}, {1, 5, 3, 4})
-- 'NO'
-- It is assumed that the input tables will be non-empty.
-- Implementation of the exchange function
local function exchange(lst1, lst2)
  -- Count odd numbers in lst1
  local odd_in_lst1 = 0
  for _, v in ipairs(lst1) do
    if v % 2 ~= 0 then
      odd_in_lst1 = odd_in_lst1 + 1
    end
  end

  -- Count even numbers in lst2
  local even_in_lst2 = 0
  for _, v in ipairs(lst2) do
    if v % 2 == 0 then
      even_in_lst2 = even_in_lst2 + 1
    end
  end

  -- We can replace each odd in lst1 with an even from lst2
  if odd_in_lst1 <= even_in_lst2 then
    return "YES"
  else
    return "NO"
  end
end

-- Example usage:
-- print(exchange({1, 2, 3, 4}, {1, 2, 3, 4}))  --> YES
-- print(exchange({1, 2, 3, 4}, {1, 5, 3, 4}))  --> NO
lu = require('luaunit')

function test_humaneval()
local candidate = exchange
    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 2, 3, 4}), 'YES')
    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 5, 3, 4}), 'NO')
    lu.assertEquals(candidate({1, 2, 3, 4}, {2, 1, 4, 3}), 'YES')
    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 4}), 'YES')
    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 3}), 'NO')
    lu.assertEquals(candidate({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}), 'NO')
    lu.assertEquals(candidate({100, 200}, {200, 200}), 'YES')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154476
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 111 (LUA) - HumanEval_111_histogram
================================================================================

PROMPT:
----------------------------------------
-- Given a string representing a space separated lowercase letters, return a table
-- of the letter with the most repetition and containing the corresponding count.
-- If several letters have the same occurrence, return all of them.
-- Example:
-- >>> histogram('a b c')
-- {['a'] = 1, ['b'] = 1, ['c'] = 1}
-- >>> histogram('a b b a')
-- {['a'] = 2, ['b'] = 2}
-- >>> histogram('a b c a b')
-- {['a'] = 2, ['b'] = 2}
-- >>> histogram('b b b b a')
-- {['b'] = 4}
-- >>> histogram('')
-- {}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = histogram
    lu.assertEquals(candidate('a b b a'), {['a'] = 2, ['b'] = 2})
    lu.assertEquals(candidate('a b c a b'), {['a'] = 2, ['b'] = 2})
    lu.assertEquals(candidate('a b c d g'), {['a'] = 1, ['b'] = 1, ['c'] = 1, ['d'] = 1, ['g'] = 1})
    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})
    lu.assertEquals(candidate('b b b b a'), {['b'] = 4})
    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('a'), {['a'] = 1})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a string representing a space separated lowercase letters, return a table
-- of the letter with the most repetition and containing the corresponding count.
-- If several letters have the same occurrence, return all of them.
-- Example:
-- >>> histogram('a b c')
-- {['a'] = 1, ['b'] = 1, ['c'] = 1}
-- >>> histogram('a b b a')
-- {['a'] = 2, ['b'] = 2}
-- >>> histogram('a b c a b')
-- {['a'] = 2, ['b'] = 2}
-- >>> histogram('b b b b a')
-- {['b'] = 4}
-- >>> histogram('')
-- {}
-- Histogram: return a table of the most frequent letters and their count
local function histogram(test)
    -- Count occurrences of each letter
    local freq = {}
    for letter in string.gmatch(test, "%S+") do
        freq[letter] = (freq[letter] or 0) + 1
    end

    -- Find the maximum count
    local maxCount = 0
    for _, count in pairs(freq) do
        if count > maxCount then
            maxCount = count
        end
    end

    -- Build the result table containing only the letters with the maximum count
    local result = {}
    for letter, count in pairs(freq) do
        if count == maxCount then
            result[letter] = count
        end
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = histogram
    lu.assertEquals(candidate('a b b a'), {['a'] = 2, ['b'] = 2})
    lu.assertEquals(candidate('a b c a b'), {['a'] = 2, ['b'] = 2})
    lu.assertEquals(candidate('a b c d g'), {['a'] = 1, ['b'] = 1, ['c'] = 1, ['d'] = 1, ['g'] = 1})
    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})
    lu.assertEquals(candidate('b b b b a'), {['b'] = 4})
    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('a'), {['a'] = 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154477
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a string representing a space separated lowercase letters, return a table
-- of the letter with the most repetition and containing the corresponding count.
-- If several letters have the same occurrence, return all of them.
-- Example:
-- >>> histogram('a b c')
-- {['a'] = 1, ['b'] = 1, ['c'] = 1}
-- >>> histogram('a b b a')
-- {['a'] = 2, ['b'] = 2}
-- >>> histogram('a b c a b')
-- {['a'] = 2, ['b'] = 2}
-- >>> histogram('b b b b a')
-- {['b'] = 4}
-- >>> histogram('')
-- {}
-- Histogram: return a table of the most frequent letters and their count.
-- Example:
-- >>> histogram('a b c')
-- {['a'] = 1, ['b'] = 1, ['c'] = 1}
-- >>> histogram('a b b a')
-- {['a'] = 2, ['b'] = 2}
-- >>> histogram('a b c a b')
-- {['a'] = 2, ['b'] = 2}
-- >>> histogram('b b b b a')
-- {['b'] = 4}
-- >>> histogram('')
-- {}
local function histogram(test)
    -- Count occurrences of each letter
    local freq = {}
    for letter in string.gmatch(test, "%S+") do
        freq[letter] = (freq[letter] or 0) + 1
    end

    -- If no letters were found, return an empty table
    if next(freq) == nil then
        return {}
    end

    -- Find the maximum count
    local maxCount = 0
    for _, count in pairs(freq) do
        if count > maxCount then
            maxCount = count
        end
    end

    -- Build result table with letters that have the maximum count
    local result = {}
    for letter, count in pairs(freq) do
        if count == maxCount then
            result[letter] = count
        end
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = histogram
    lu.assertEquals(candidate('a b b a'), {['a'] = 2, ['b'] = 2})
    lu.assertEquals(candidate('a b c a b'), {['a'] = 2, ['b'] = 2})
    lu.assertEquals(candidate('a b c d g'), {['a'] = 1, ['b'] = 1, ['c'] = 1, ['d'] = 1, ['g'] = 1})
    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})
    lu.assertEquals(candidate('b b b b a'), {['b'] = 4})
    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('a'), {['a'] = 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154477
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a string representing a space separated lowercase letters, return a table
-- of the letter with the most repetition and containing the corresponding count.
-- If several letters have the same occurrence, return all of them.
-- Example:
-- >>> histogram('a b c')
-- {['a'] = 1, ['b'] = 1, ['c'] = 1}
-- >>> histogram('a b b a')
-- {['a'] = 2, ['b'] = 2}
-- >>> histogram('a b c a b')
-- {['a'] = 2, ['b'] = 2}
-- >>> histogram('b b b b a')
-- {['b'] = 4}
-- >>> histogram('')
-- {}
-- Returns a table containing the most frequently occurring letter(s)
-- and their count.  If the input string is empty, an empty table is returned.
local function histogram(test)
    -- 1. Count occurrences of each letter
    local counts = {}
    for letter in string.gmatch(test, "%S+") do
        counts[letter] = (counts[letter] or 0) + 1
    end

    -- 2. Find the maximum count
    local max = 0
    for _, cnt in pairs(counts) do
        if cnt > max then
            max = cnt
        end
    end

    -- 3. Build the result table with all letters that reach the maximum
    local result = {}
    if max > 0 then
        for letter, cnt in pairs(counts) do
            if cnt == max then
                result[letter] = cnt
            end
        end
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = histogram
    lu.assertEquals(candidate('a b b a'), {['a'] = 2, ['b'] = 2})
    lu.assertEquals(candidate('a b c a b'), {['a'] = 2, ['b'] = 2})
    lu.assertEquals(candidate('a b c d g'), {['a'] = 1, ['b'] = 1, ['c'] = 1, ['d'] = 1, ['g'] = 1})
    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})
    lu.assertEquals(candidate('b b b b a'), {['b'] = 4})
    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('a'), {['a'] = 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154477
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a string representing a space separated lowercase letters, return a table
-- of the letter with the most repetition and containing the corresponding count.
-- If several letters have the same occurrence, return all of them.
-- Example:
-- >>> histogram('a b c')
-- {['a'] = 1, ['b'] = 1, ['c'] = 1}
-- >>> histogram('a b b a')
-- {['a'] = 2, ['b'] = 2}
-- >>> histogram('a b c a b')
-- {['a'] = 2, ['b'] = 2}
-- >>> histogram('b b b b a')
-- {['b'] = 4}
-- >>> histogram('')
-- {}
local function histogram(test)
    -- Handle empty input
    if test == "" then
        return {}
    end

    local freq = {}
    -- Count occurrences of each letter
    for letter in string.gmatch(test, "%S+") do
        freq[letter] = (freq[letter] or 0) + 1
    end

    -- Find the maximum frequency
    local max = 0
    for _, count in pairs(freq) do
        if count > max then
            max = count
        end
    end

    -- Build result table with only the letters that have the max frequency
    local result = {}
    for letter, count in pairs(freq) do
        if count == max then
            result[letter] = count
        end
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = histogram
    lu.assertEquals(candidate('a b b a'), {['a'] = 2, ['b'] = 2})
    lu.assertEquals(candidate('a b c a b'), {['a'] = 2, ['b'] = 2})
    lu.assertEquals(candidate('a b c d g'), {['a'] = 1, ['b'] = 1, ['c'] = 1, ['d'] = 1, ['g'] = 1})
    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})
    lu.assertEquals(candidate('b b b b a'), {['b'] = 4})
    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})
    lu.assertEquals(candidate(''), {})
    lu.assertEquals(candidate('a'), {['a'] = 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154477
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 112 (LUA) - HumanEval_112_reverse_delete
================================================================================

PROMPT:
----------------------------------------
-- Task
-- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
-- then check if the result string is palindrome.
-- A string is called palindrome if it reads the same backward as forward.
-- You should return a table containing the result string and true/false for the check.
-- Example
-- >>> reverse_delete('abcde', 'ae')
-- {'bcd', false}
-- >>> reverse_delete('abcdef', 'b')
-- {'acdef', false}
-- >>> reverse_delete('abcdedcba', 'ab')
-- {'cdedc', true}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = reverse_delete
    lu.assertEquals(candidate('abcde', 'ae'), {'bcd', false})
    lu.assertEquals(candidate('abcdef', 'b'), {'acdef', false})
    lu.assertEquals(candidate('abcdedcba', 'ab'), {'cdedc', true})
    lu.assertEquals(candidate('dwik', 'w'), {'dik', false})
    lu.assertEquals(candidate('a', 'a'), {'', true})
    lu.assertEquals(candidate('abcdedcba', ''), {'abcdedcba', true})
    lu.assertEquals(candidate('abcdedcba', 'v'), {'abcdedcba', true})
    lu.assertEquals(candidate('vabba', 'v'), {'abba', true})
    lu.assertEquals(candidate('mamma', 'mia'), {'', true})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Task
-- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
-- then check if the result string is palindrome.
-- A string is called palindrome if it reads the same backward as forward.
-- You should return a table containing the result string and true/false for the check.
-- Example
-- >>> reverse_delete('abcde', 'ae')
-- {'bcd', false}
-- >>> reverse_delete('abcdef', 'b')
-- {'acdef', false}
-- >>> reverse_delete('abcdedcba', 'ab')
-- {'cdedc', true}
local function reverse_delete(s, c)
  -- Build a lookup table for characters to delete
  local delete_set = {}
  for i = 1, #c do
    delete_set[c:sub(i, i)] = true
  end

  -- Construct the new string without the deleted characters
  local result_parts = {}
  for i = 1, #s do
    local ch = s:sub(i, i)
    if not delete_set[ch] then
      result_parts[#result_parts + 1] = ch
    end
  end
  local result = table.concat(result_parts)

  -- Check if the resulting string is a palindrome
  local is_palindrome = (result == result:reverse())

  -- Return the result string and the palindrome flag
  return {result, is_palindrome}
end
lu = require('luaunit')

function test_humaneval()
local candidate = reverse_delete
    lu.assertEquals(candidate('abcde', 'ae'), {'bcd', false})
    lu.assertEquals(candidate('abcdef', 'b'), {'acdef', false})
    lu.assertEquals(candidate('abcdedcba', 'ab'), {'cdedc', true})
    lu.assertEquals(candidate('dwik', 'w'), {'dik', false})
    lu.assertEquals(candidate('a', 'a'), {'', true})
    lu.assertEquals(candidate('abcdedcba', ''), {'abcdedcba', true})
    lu.assertEquals(candidate('abcdedcba', 'v'), {'abcdedcba', true})
    lu.assertEquals(candidate('vabba', 'v'), {'abba', true})
    lu.assertEquals(candidate('mamma', 'mia'), {'', true})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154477
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Task
-- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
-- then check if the result string is palindrome.
-- A string is called palindrome if it reads the same backward as forward.
-- You should return a table containing the result string and true/false for the check.
-- Example
-- >>> reverse_delete('abcde', 'ae')
-- {'bcd', false}
-- >>> reverse_delete('abcdef', 'b')
-- {'acdef', false}
-- >>> reverse_delete('abcdedcba', 'ab')
-- {'cdedc', true}
-- Delete every character from `s` that appears in `c` and check if the
-- resulting string is a palindrome.  Return a table containing the
-- cleaned string and a boolean indicating whether it is a palindrome.
local function reverse_delete(s, c)
  -- Build a set of characters that must be removed
  local to_remove = {}
  for i = 1, #c do
    to_remove[c:sub(i, i)] = true
  end

  -- Construct the filtered string
  local result_parts = {}
  for i = 1, #s do
    local ch = s:sub(i, i)
    if not to_remove[ch] then
      result_parts[#result_parts + 1] = ch
    end
  end
  local result = table.concat(result_parts)

  -- Check if the result is a palindrome
  local is_palindrome = (result == string.reverse(result))

  return {result, is_palindrome}
end
lu = require('luaunit')

function test_humaneval()
local candidate = reverse_delete
    lu.assertEquals(candidate('abcde', 'ae'), {'bcd', false})
    lu.assertEquals(candidate('abcdef', 'b'), {'acdef', false})
    lu.assertEquals(candidate('abcdedcba', 'ab'), {'cdedc', true})
    lu.assertEquals(candidate('dwik', 'w'), {'dik', false})
    lu.assertEquals(candidate('a', 'a'), {'', true})
    lu.assertEquals(candidate('abcdedcba', ''), {'abcdedcba', true})
    lu.assertEquals(candidate('abcdedcba', 'v'), {'abcdedcba', true})
    lu.assertEquals(candidate('vabba', 'v'), {'abba', true})
    lu.assertEquals(candidate('mamma', 'mia'), {'', true})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154477
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Task
-- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
-- then check if the result string is palindrome.
-- A string is called palindrome if it reads the same backward as forward.
-- You should return a table containing the result string and true/false for the check.
-- Example
-- >>> reverse_delete('abcde', 'ae')
-- {'bcd', false}
-- >>> reverse_delete('abcdef', 'b')
-- {'acdef', false}
-- >>> reverse_delete('abcdedcba', 'ab')
-- {'cdedc', true}
local function reverse_delete(s, c)
  -- Build a set of characters to delete
  local delete_set = {}
  for i = 1, #c do
    delete_set[c:sub(i, i)] = true
  end

  -- Construct the resulting string
  local res = {}
  for i = 1, #s do
    local ch = s:sub(i, i)
    if not delete_set[ch] then
      res[#res + 1] = ch
    end
  end
  local result_str = table.concat(res)

  -- Check if the resulting string is a palindrome
  local is_palindrome = result_str == string.reverse(result_str)

  return {result_str, is_palindrome}
end
lu = require('luaunit')

function test_humaneval()
local candidate = reverse_delete
    lu.assertEquals(candidate('abcde', 'ae'), {'bcd', false})
    lu.assertEquals(candidate('abcdef', 'b'), {'acdef', false})
    lu.assertEquals(candidate('abcdedcba', 'ab'), {'cdedc', true})
    lu.assertEquals(candidate('dwik', 'w'), {'dik', false})
    lu.assertEquals(candidate('a', 'a'), {'', true})
    lu.assertEquals(candidate('abcdedcba', ''), {'abcdedcba', true})
    lu.assertEquals(candidate('abcdedcba', 'v'), {'abcdedcba', true})
    lu.assertEquals(candidate('vabba', 'v'), {'abba', true})
    lu.assertEquals(candidate('mamma', 'mia'), {'', true})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154477
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Task
-- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
-- then check if the result string is palindrome.
-- A string is called palindrome if it reads the same backward as forward.
-- You should return a table containing the result string and true/false for the check.
-- Example
-- >>> reverse_delete('abcde', 'ae')
-- {'bcd', false}
-- >>> reverse_delete('abcdef', 'b')
-- {'acdef', false}
-- >>> reverse_delete('abcdedcba', 'ab')
-- {'cdedc', true}
local function reverse_delete(s, c)
  -- Build a lookup table for characters that need to be deleted
  local toDelete = {}
  for i = 1, #c do
    toDelete[c:sub(i,i)] = true
  end

  -- Construct the new string by keeping only allowed characters
  local parts = {}
  for i = 1, #s do
    local ch = s:sub(i,i)
    if not toDelete[ch] then
      table.insert(parts, ch)
    end
  end
  local result = table.concat(parts)

  -- Check if the resulting string is a palindrome
  local isPal = result == string.reverse(result)

  return {result, isPal}
end
lu = require('luaunit')

function test_humaneval()
local candidate = reverse_delete
    lu.assertEquals(candidate('abcde', 'ae'), {'bcd', false})
    lu.assertEquals(candidate('abcdef', 'b'), {'acdef', false})
    lu.assertEquals(candidate('abcdedcba', 'ab'), {'cdedc', true})
    lu.assertEquals(candidate('dwik', 'w'), {'dik', false})
    lu.assertEquals(candidate('a', 'a'), {'', true})
    lu.assertEquals(candidate('abcdedcba', ''), {'abcdedcba', true})
    lu.assertEquals(candidate('abcdedcba', 'v'), {'abcdedcba', true})
    lu.assertEquals(candidate('vabba', 'v'), {'abba', true})
    lu.assertEquals(candidate('mamma', 'mia'), {'', true})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154477
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------
