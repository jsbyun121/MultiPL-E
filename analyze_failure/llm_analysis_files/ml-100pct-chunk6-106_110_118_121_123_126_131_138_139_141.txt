As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 106 (ML) - HumanEval_106_f
================================================================================

PROMPT:
----------------------------------------
(**Implement the function f that takes n as a parameter,
 * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
 * or the sum of numbers from 1 to i otherwise.
 * i starts from 1.
 * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
 * Example:
 * >>> f 5
 * [1; 2; 6; 24; 15]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = f in
  (assert ((candidate 5) = [1; 2; 6; 24; 15]));
  (assert ((candidate 7) = [1; 2; 6; 24; 15; 720; 28]));
  (assert ((candidate 1) = [1]));
  (assert ((candidate 3) = [1; 2; 6]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Implement the function f that takes n as a parameter,
 * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
 * or the sum of numbers from 1 to i otherwise.
 * i starts from 1.
 * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
 * Example:
 * >>> f 5
 * [1; 2; 6; 24; 15]
*)
let rec fact n =
  if n <= 1 then 1 else n * fact (n - 1)

let sum n =
  n * (n + 1) / 2

let f (n : int) : int list =
  let rec aux i acc =
    if i > n then List.rev acc
    else
      let v = if i mod 2 = 0 then fact i else sum i in
      aux (i + 1) (v :: acc)
  in
  aux 1 []

let assertions =
 let candidate = f in
  (assert ((candidate 5) = [1; 2; 6; 24; 15]));
  (assert ((candidate 7) = [1; 2; 6; 24; 15; 720; 28]));
  (assert ((candidate 1) = [1]));
  (assert ((candidate 3) = [1; 2; 6]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183723
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Implement the function f that takes n as a parameter,
 * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
 * or the sum of numbers from 1 to i otherwise.
 * i starts from 1.
 * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
 * Example:
 * >>> f 5
 * [1; 2; 6; 24; 15]
*)
(* Computes the factorial of a positive integer n *)
let rec fact n =
  if n <= 1 then 1
  else n * fact (n - 1)

(* Computes the sum of all integers from 1 to n *)
let rec sum n =
  if n <= 1 then 1
  else n + sum (n - 1)

(* Main function: builds a list of size n with the required rule *)
let f (n : int) : int list =
  (* Use List.init for a concise implementation *)
  List.init n (fun i ->
    let idx = i + 1 in                (* i starts at 1 *)
    if idx mod 2 = 0 then fact idx    (* even index → factorial *)
    else sum idx)                     (* odd index  → sum from 1 to idx *)

let assertions =
 let candidate = f in
  (assert ((candidate 5) = [1; 2; 6; 24; 15]));
  (assert ((candidate 7) = [1; 2; 6; 24; 15; 720; 28]));
  (assert ((candidate 1) = [1]));
  (assert ((candidate 3) = [1; 2; 6]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183723
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Implement the function f that takes n as a parameter,
 * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
 * or the sum of numbers from 1 to i otherwise.
 * i starts from 1.
 * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
 * Example:
 * >>> f 5
 * [1; 2; 6; 24; 15]
*)
(* Computes the required list according to the specification *)
let f (n : int) : int list =
  (* Helper to compute factorial of a positive integer *)
  let rec factorial k =
    if k <= 1 then 1
    else k * factorial (k - 1)
  in
  (* Helper to compute the sum 1 + 2 + … + i *)
  let sum_to i = i * (i + 1) / 2 in
  (* Build the list for indices 1 .. n *)
  List.init n (fun idx ->
    let i = idx + 1 in
    if i mod 2 = 0 then factorial i else sum_to i)

let assertions =
 let candidate = f in
  (assert ((candidate 5) = [1; 2; 6; 24; 15]));
  (assert ((candidate 7) = [1; 2; 6; 24; 15; 720; 28]));
  (assert ((candidate 1) = [1]));
  (assert ((candidate 3) = [1; 2; 6]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183723
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Implement the function f that takes n as a parameter,
 * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
 * or the sum of numbers from 1 to i otherwise.
 * i starts from 1.
 * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
 * Example:
 * >>> f 5
 * [1; 2; 6; 24; 15]
*)
(* Compute factorial of a positive integer *)
let rec fact m =
  if m <= 1 then 1 else m * fact (m - 1)

(* Compute the sum of all integers from 1 to m *)
let rec sum m =
  if m <= 0 then 0 else m + sum (m - 1)

(* Main function *)
let f (n : int) : int list =
  if n <= 0 then []
  else
    List.init n (fun i ->
      let idx = i + 1 in          (* indices start at 1 *)
      if idx mod 2 = 0 then fact idx
      else sum idx)

let assertions =
 let candidate = f in
  (assert ((candidate 5) = [1; 2; 6; 24; 15]));
  (assert ((candidate 7) = [1; 2; 6; 24; 15; 720; 28]));
  (assert ((candidate 1) = [1]));
  (assert ((candidate 3) = [1; 2; 6]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183723
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 110 (ML) - HumanEval_110_exchange
================================================================================

PROMPT:
----------------------------------------
(**In this problem, you will implement a function that takes two lists of numbers,
 * and determines whether it is possible to perform an exchange of elements
 * between them to make lst1 a list of only even numbers.
 * There is no limit on the number of exchanged elements between lst1 and lst2.
 * If it is possible to exchange elements between the lst1 and lst2 to make
 * all the elements of lst1 to be even, return "YES".
 * Otherwise, return "NO".
 * For example:
 * >>> exchange [1; 2; 3; 4] [1; 2; 3; 4]
 * "YES"
 * >>> exchange [1; 2; 3; 4] [1; 5; 3; 4]
 * "NO"
 * It is assumed that the input lists will be non-empty.
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = exchange in
  (assert ((candidate [1; 2; 3; 4] [1; 2; 3; 4]) = "YES"));
  (assert ((candidate [1; 2; 3; 4] [1; 5; 3; 4]) = "NO"));
  (assert ((candidate [1; 2; 3; 4] [2; 1; 4; 3]) = "YES"));
  (assert ((candidate [5; 7; 3] [2; 6; 4]) = "YES"));
  (assert ((candidate [5; 7; 3] [2; 6; 3]) = "NO"));
  (assert ((candidate [3; 2; 6; 1; 8; 9] [3; 5; 5; 1; 1; 1]) = "NO"));
  (assert ((candidate [100; 200] [200; 200]) = "YES"));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**In this problem, you will implement a function that takes two lists of numbers,
 * and determines whether it is possible to perform an exchange of elements
 * between them to make lst1 a list of only even numbers.
 * There is no limit on the number of exchanged elements between lst1 and lst2.
 * If it is possible to exchange elements between the lst1 and lst2 to make
 * all the elements of lst1 to be even, return "YES".
 * Otherwise, return "NO".
 * For example:
 * >>> exchange [1; 2; 3; 4] [1; 2; 3; 4]
 * "YES"
 * >>> exchange [1; 2; 3; 4] [1; 5; 3; 4]
 * "NO"
 * It is assumed that the input lists will be non-empty.
*)
let exchange (lst1 : int list) (lst2 : int list) : string =
  (* Helper to count even numbers in a list *)
  let count_even lst =
    List.fold_left (fun acc x -> if x mod 2 = 0 then acc + 1 else acc) 0 lst
  in
  let evens_in_lst1 = count_even lst1 in
  let evens_in_lst2 = count_even lst2 in
  let total_evens = evens_in_lst1 + evens_in_lst2 in
  let needed = List.length lst1 in
  if total_evens >= needed then "YES" else "NO"

let assertions =
 let candidate = exchange in
  (assert ((candidate [1; 2; 3; 4] [1; 2; 3; 4]) = "YES"));
  (assert ((candidate [1; 2; 3; 4] [1; 5; 3; 4]) = "NO"));
  (assert ((candidate [1; 2; 3; 4] [2; 1; 4; 3]) = "YES"));
  (assert ((candidate [5; 7; 3] [2; 6; 4]) = "YES"));
  (assert ((candidate [5; 7; 3] [2; 6; 3]) = "NO"));
  (assert ((candidate [3; 2; 6; 1; 8; 9] [3; 5; 5; 1; 1; 1]) = "NO"));
  (assert ((candidate [100; 200] [200; 200]) = "YES"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183723
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**In this problem, you will implement a function that takes two lists of numbers,
 * and determines whether it is possible to perform an exchange of elements
 * between them to make lst1 a list of only even numbers.
 * There is no limit on the number of exchanged elements between lst1 and lst2.
 * If it is possible to exchange elements between the lst1 and lst2 to make
 * all the elements of lst1 to be even, return "YES".
 * Otherwise, return "NO".
 * For example:
 * >>> exchange [1; 2; 3; 4] [1; 2; 3; 4]
 * "YES"
 * >>> exchange [1; 2; 3; 4] [1; 5; 3; 4]
 * "NO"
 * It is assumed that the input lists will be non-empty.
*)
(* Determine whether we can make all elements of lst1 even by swapping elements
   with lst2. We can swap any number of elements, each element can be used
   at most once. The necessary and sufficient condition is that lst2 contains
   at least as many even numbers as the number of odd numbers in lst1. *)
let exchange (lst1 : int list) (lst2 : int list) : string =
  (* Count odd numbers in lst1 *)
  let odd_in_lst1 =
    List.fold_left (fun acc x -> if x mod 2 <> 0 then acc + 1 else acc) 0 lst1
  in
  (* Count even numbers in lst2 *)
  let even_in_lst2 =
    List.fold_left (fun acc x -> if x mod 2 = 0 then acc + 1 else acc) 0 lst2
  in
  if even_in_lst2 >= odd_in_lst1 then "YES" else "NO"

let assertions =
 let candidate = exchange in
  (assert ((candidate [1; 2; 3; 4] [1; 2; 3; 4]) = "YES"));
  (assert ((candidate [1; 2; 3; 4] [1; 5; 3; 4]) = "NO"));
  (assert ((candidate [1; 2; 3; 4] [2; 1; 4; 3]) = "YES"));
  (assert ((candidate [5; 7; 3] [2; 6; 4]) = "YES"));
  (assert ((candidate [5; 7; 3] [2; 6; 3]) = "NO"));
  (assert ((candidate [3; 2; 6; 1; 8; 9] [3; 5; 5; 1; 1; 1]) = "NO"));
  (assert ((candidate [100; 200] [200; 200]) = "YES"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183723
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**In this problem, you will implement a function that takes two lists of numbers,
 * and determines whether it is possible to perform an exchange of elements
 * between them to make lst1 a list of only even numbers.
 * There is no limit on the number of exchanged elements between lst1 and lst2.
 * If it is possible to exchange elements between the lst1 and lst2 to make
 * all the elements of lst1 to be even, return "YES".
 * Otherwise, return "NO".
 * For example:
 * >>> exchange [1; 2; 3; 4] [1; 2; 3; 4]
 * "YES"
 * >>> exchange [1; 2; 3; 4] [1; 5; 3; 4]
 * "NO"
 * It is assumed that the input lists will be non-empty.
*)
let exchange (lst1 : int list) (lst2 : int list) : string =
  let odds  = List.fold_left (fun acc x -> if x mod 2 <> 0 then acc + 1 else acc) 0 lst1 in
  let evens = List.fold_left (fun acc x -> if x mod 2 = 0 then acc + 1 else acc) 0 lst2 in
  if evens >= odds then "YES" else "NO"

let assertions =
 let candidate = exchange in
  (assert ((candidate [1; 2; 3; 4] [1; 2; 3; 4]) = "YES"));
  (assert ((candidate [1; 2; 3; 4] [1; 5; 3; 4]) = "NO"));
  (assert ((candidate [1; 2; 3; 4] [2; 1; 4; 3]) = "YES"));
  (assert ((candidate [5; 7; 3] [2; 6; 4]) = "YES"));
  (assert ((candidate [5; 7; 3] [2; 6; 3]) = "NO"));
  (assert ((candidate [3; 2; 6; 1; 8; 9] [3; 5; 5; 1; 1; 1]) = "NO"));
  (assert ((candidate [100; 200] [200; 200]) = "YES"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183723
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**In this problem, you will implement a function that takes two lists of numbers,
 * and determines whether it is possible to perform an exchange of elements
 * between them to make lst1 a list of only even numbers.
 * There is no limit on the number of exchanged elements between lst1 and lst2.
 * If it is possible to exchange elements between the lst1 and lst2 to make
 * all the elements of lst1 to be even, return "YES".
 * Otherwise, return "NO".
 * For example:
 * >>> exchange [1; 2; 3; 4] [1; 2; 3; 4]
 * "YES"
 * >>> exchange [1; 2; 3; 4] [1; 5; 3; 4]
 * "NO"
 * It is assumed that the input lists will be non-empty.
*)
let exchange (lst1 : int list) (lst2 : int list) : string =
  (* Count odd numbers in lst1 *)
  let odd_count =
    List.fold_left (fun acc x -> if x mod 2 <> 0 then acc + 1 else acc) 0 lst1
  in
  (* Count even numbers in lst2 *)
  let even_count =
    List.fold_left (fun acc x -> if x mod 2 = 0 then acc + 1 else acc) 0 lst2
  in
  if odd_count <= even_count then "YES" else "NO"

let assertions =
 let candidate = exchange in
  (assert ((candidate [1; 2; 3; 4] [1; 2; 3; 4]) = "YES"));
  (assert ((candidate [1; 2; 3; 4] [1; 5; 3; 4]) = "NO"));
  (assert ((candidate [1; 2; 3; 4] [2; 1; 4; 3]) = "YES"));
  (assert ((candidate [5; 7; 3] [2; 6; 4]) = "YES"));
  (assert ((candidate [5; 7; 3] [2; 6; 3]) = "NO"));
  (assert ((candidate [3; 2; 6; 1; 8; 9] [3; 5; 5; 1; 1; 1]) = "NO"));
  (assert ((candidate [100; 200] [200; 200]) = "YES"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183723
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 118 (ML) - HumanEval_118_get_closest_vowel
================================================================================

PROMPT:
----------------------------------------
(**You are given a word. Your task is to find the closest vowel that stands between 
 * two consonants from the right side of the word (case sensitive).
 * Vowels in the beginning and ending doesn't count. Return empty string if you didn't
 * find any vowel met the above condition. 
 * You may assume that the given string contains English letter only.
 * Example:
 * >>> get_closest_vowel "yogurt"
 * "u"
 * >>> get_closest_vowel "FULL"
 * "U"
 * >>> get_closest_vowel "quick"
 * ""
 * >>> get_closest_vowel "ab"
 * ""
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = get_closest_vowel in
  (assert ((candidate "yogurt") = "u"));
  (assert ((candidate "full") = "u"));
  (assert ((candidate "easy") = ""));
  (assert ((candidate "eAsy") = ""));
  (assert ((candidate "ali") = ""));
  (assert ((candidate "bad") = "a"));
  (assert ((candidate "most") = "o"));
  (assert ((candidate "ab") = ""));
  (assert ((candidate "ba") = ""));
  (assert ((candidate "quick") = ""));
  (assert ((candidate "anime") = "i"));
  (assert ((candidate "Asia") = ""));
  (assert ((candidate "Above") = "o"));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**You are given a word. Your task is to find the closest vowel that stands between 
 * two consonants from the right side of the word (case sensitive).
 * Vowels in the beginning and ending doesn't count. Return empty string if you didn't
 * find any vowel met the above condition. 
 * You may assume that the given string contains English letter only.
 * Example:
 * >>> get_closest_vowel "yogurt"
 * "u"
 * >>> get_closest_vowel "FULL"
 * "U"
 * >>> get_closest_vowel "quick"
 * ""
 * >>> get_closest_vowel "ab"
 * ""
*)
(* Helper function to check if a character is a vowel (case‑sensitive) *)
let is_vowel (c : char) : bool =
  match c with
  | 'a' | 'e' | 'i' | 'o' | 'u'
  | 'A' | 'E' | 'I' | 'O' | 'U' -> true
  | _ -> false

let get_closest_vowel (word : string) : string =
  let len = String.length word in
  (* Recursive helper scanning from right to left *)
  let rec aux i =
    if i < 0 then
      ""  (* no vowel found *)
    else
      let c = word.[i] in
      if is_vowel c && i > 0 && i < len - 1 then
        (* check that both neighbours are consonants *)
        let left  = word.[i - 1] in
        let right = word.[i + 1] in
        if not (is_vowel left) && not (is_vowel right) then
          String.make 1 c  (* found the closest vowel from the right *)
        else
          aux (i - 1)      (* continue searching *)
      else
        aux (i - 1)        (* current char not a valid vowel, keep searching *)
  in
  aux (len - 1)

let assertions =
 let candidate = get_closest_vowel in
  (assert ((candidate "yogurt") = "u"));
  (assert ((candidate "full") = "u"));
  (assert ((candidate "easy") = ""));
  (assert ((candidate "eAsy") = ""));
  (assert ((candidate "ali") = ""));
  (assert ((candidate "bad") = "a"));
  (assert ((candidate "most") = "o"));
  (assert ((candidate "ab") = ""));
  (assert ((candidate "ba") = ""));
  (assert ((candidate "quick") = ""));
  (assert ((candidate "anime") = "i"));
  (assert ((candidate "Asia") = ""));
  (assert ((candidate "Above") = "o"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**You are given a word. Your task is to find the closest vowel that stands between 
 * two consonants from the right side of the word (case sensitive).
 * Vowels in the beginning and ending doesn't count. Return empty string if you didn't
 * find any vowel met the above condition. 
 * You may assume that the given string contains English letter only.
 * Example:
 * >>> get_closest_vowel "yogurt"
 * "u"
 * >>> get_closest_vowel "FULL"
 * "U"
 * >>> get_closest_vowel "quick"
 * ""
 * >>> get_closest_vowel "ab"
 * ""
*)
let get_closest_vowel (word : string) : string =
  let is_vowel c =
    match c with
    | 'A' | 'E' | 'I' | 'O' | 'U'
    | 'a' | 'e' | 'i' | 'o' | 'u' -> true
    | _ -> false
  in
  let is_consonant c = not (is_vowel c) in
  let len = String.length word in
  if len < 3 then
    ""  (* Not enough characters to have a vowel between two consonants *)
  else
    let rec aux i =
      if i < 1 then
        ""  (* No vowel found *)
      else
        let c = word.[i] in
        if is_vowel c && is_consonant word.[i-1] && is_consonant word.[i+1] then
          String.make 1 c
        else
          aux (i - 1)
    in
    aux (len - 2)  (* Start from the rightmost possible vowel position *)

let assertions =
 let candidate = get_closest_vowel in
  (assert ((candidate "yogurt") = "u"));
  (assert ((candidate "full") = "u"));
  (assert ((candidate "easy") = ""));
  (assert ((candidate "eAsy") = ""));
  (assert ((candidate "ali") = ""));
  (assert ((candidate "bad") = "a"));
  (assert ((candidate "most") = "o"));
  (assert ((candidate "ab") = ""));
  (assert ((candidate "ba") = ""));
  (assert ((candidate "quick") = ""));
  (assert ((candidate "anime") = "i"));
  (assert ((candidate "Asia") = ""));
  (assert ((candidate "Above") = "o"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**You are given a word. Your task is to find the closest vowel that stands between 
 * two consonants from the right side of the word (case sensitive).
 * Vowels in the beginning and ending doesn't count. Return empty string if you didn't
 * find any vowel met the above condition. 
 * You may assume that the given string contains English letter only.
 * Example:
 * >>> get_closest_vowel "yogurt"
 * "u"
 * >>> get_closest_vowel "FULL"
 * "U"
 * >>> get_closest_vowel "quick"
 * ""
 * >>> get_closest_vowel "ab"
 * ""
*)
let get_closest_vowel (word : string) : string =
  (* Helper to determine if a character is a vowel (case‑sensitive). *)
  let is_vowel c =
    match c with
    | 'a' | 'e' | 'i' | 'o' | 'u'
    | 'A' | 'E' | 'I' | 'O' | 'U' -> true
    | _ -> false
  in
  let len = String.length word in
  (* If the word is too short to contain a vowel surrounded by two consonants,
     we can immediately return the empty string. *)
  if len < 3 then ""
  else
    (* Scan from the rightmost index to the left. *)
    let rec aux i =
      if i <= 0 then ""  (* reached the beginning without a match *)
      else
        let c = word.[i] in
        if is_vowel c
           && not (is_vowel word.[i-1])
           && not (is_vowel word.[i+1])
        then String.make 1 c
        else aux (i-1)
    in
    aux (len - 2)  (* start at len-2 because i+1 must be in bounds *)

let assertions =
 let candidate = get_closest_vowel in
  (assert ((candidate "yogurt") = "u"));
  (assert ((candidate "full") = "u"));
  (assert ((candidate "easy") = ""));
  (assert ((candidate "eAsy") = ""));
  (assert ((candidate "ali") = ""));
  (assert ((candidate "bad") = "a"));
  (assert ((candidate "most") = "o"));
  (assert ((candidate "ab") = ""));
  (assert ((candidate "ba") = ""));
  (assert ((candidate "quick") = ""));
  (assert ((candidate "anime") = "i"));
  (assert ((candidate "Asia") = ""));
  (assert ((candidate "Above") = "o"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**You are given a word. Your task is to find the closest vowel that stands between 
 * two consonants from the right side of the word (case sensitive).
 * Vowels in the beginning and ending doesn't count. Return empty string if you didn't
 * find any vowel met the above condition. 
 * You may assume that the given string contains English letter only.
 * Example:
 * >>> get_closest_vowel "yogurt"
 * "u"
 * >>> get_closest_vowel "FULL"
 * "U"
 * >>> get_closest_vowel "quick"
 * ""
 * >>> get_closest_vowel "ab"
 * ""
*)
let get_closest_vowel (word : string) : string =
  let len = String.length word in
  let is_vowel c =
    match c with
    | 'a' | 'e' | 'i' | 'o' | 'u' | 'A' | 'E' | 'I' | 'O' | 'U' -> true
    | _ -> false
  in
  if len < 3 then
    ""
  else
    let result = ref "" in
    try
      for i = len - 2 downto 1 do
        let c = word.[i] in
        if is_vowel c then
          let left  = word.[i - 1] in
          let right = word.[i + 1] in
          if not (is_vowel left) && not (is_vowel right) then (
            result := String.make 1 c;
            raise Exit
          )
      done;
      !result
    with Exit -> !result

let assertions =
 let candidate = get_closest_vowel in
  (assert ((candidate "yogurt") = "u"));
  (assert ((candidate "full") = "u"));
  (assert ((candidate "easy") = ""));
  (assert ((candidate "eAsy") = ""));
  (assert ((candidate "ali") = ""));
  (assert ((candidate "bad") = "a"));
  (assert ((candidate "most") = "o"));
  (assert ((candidate "ab") = ""));
  (assert ((candidate "ba") = ""));
  (assert ((candidate "quick") = ""));
  (assert ((candidate "anime") = "i"));
  (assert ((candidate "Asia") = ""));
  (assert ((candidate "Above") = "o"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 121 (ML) - HumanEval_121_solution
================================================================================

PROMPT:
----------------------------------------
(**Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
 * Examples
 * >>> solution [5; 8; 7; 1]
 * 12
 * >>> solution [3; 3; 3; 3; 3]
 * 9
 * >>> solution [30; 13; 24; 321]
 * 0
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = solution in
  (assert ((candidate [5; 8; 7; 1]) = 12));
  (assert ((candidate [3; 3; 3; 3; 3]) = 9));
  (assert ((candidate [30; 13; 24; 321]) = 0));
  (assert ((candidate [5; 9]) = 5));
  (assert ((candidate [2; 4; 8]) = 0));
  (assert ((candidate [30; 13; 23; 32]) = 23));
  (assert ((candidate [3; 13; 2; 9]) = 3));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
 * Examples
 * >>> solution [5; 8; 7; 1]
 * 12
 * >>> solution [3; 3; 3; 3; 3]
 * 9
 * >>> solution [30; 13; 24; 321]
 * 0
*)
let solution (lst : int list) : int =
  let rec aux i acc = function
    | [] -> acc
    | x :: xs ->
        if i mod 2 = 0 && x mod 2 <> 0 then
          aux (i + 1) (acc + x) xs
        else
          aux (i + 1) acc xs
  in
  aux 0 0 lst

let assertions =
 let candidate = solution in
  (assert ((candidate [5; 8; 7; 1]) = 12));
  (assert ((candidate [3; 3; 3; 3; 3]) = 9));
  (assert ((candidate [30; 13; 24; 321]) = 0));
  (assert ((candidate [5; 9]) = 5));
  (assert ((candidate [2; 4; 8]) = 0));
  (assert ((candidate [30; 13; 23; 32]) = 23));
  (assert ((candidate [3; 13; 2; 9]) = 3));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
 * Examples
 * >>> solution [5; 8; 7; 1]
 * 12
 * >>> solution [3; 3; 3; 3; 3]
 * 9
 * >>> solution [30; 13; 24; 321]
 * 0
*)
let solution (lst : int list) : int =
  (* Helper function that walks the list, carrying the current index and
     the running total. *)
  let rec aux l idx acc =
    match l with
    | [] -> acc
    | h :: t ->
        (* If the current index is even and the head is odd, add it. *)
        let acc' =
          if idx mod 2 = 0 && h mod 2 <> 0 then acc + h else acc
        in
        aux t (idx + 1) acc'
  in
  aux lst 0 0

let assertions =
 let candidate = solution in
  (assert ((candidate [5; 8; 7; 1]) = 12));
  (assert ((candidate [3; 3; 3; 3; 3]) = 9));
  (assert ((candidate [30; 13; 24; 321]) = 0));
  (assert ((candidate [5; 9]) = 5));
  (assert ((candidate [2; 4; 8]) = 0));
  (assert ((candidate [30; 13; 23; 32]) = 23));
  (assert ((candidate [3; 13; 2; 9]) = 3));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
 * Examples
 * >>> solution [5; 8; 7; 1]
 * 12
 * >>> solution [3; 3; 3; 3; 3]
 * 9
 * >>> solution [30; 13; 24; 321]
 * 0
*)
let solution (lst : int list) : int =
  let rec aux l idx acc =
    match l with
    | [] -> acc
    | x :: xs ->
        let acc =
          if idx mod 2 = 0 && x mod 2 <> 0 then acc + x else acc
        in
        aux xs (idx + 1) acc
  in
  aux lst 0 0

let assertions =
 let candidate = solution in
  (assert ((candidate [5; 8; 7; 1]) = 12));
  (assert ((candidate [3; 3; 3; 3; 3]) = 9));
  (assert ((candidate [30; 13; 24; 321]) = 0));
  (assert ((candidate [5; 9]) = 5));
  (assert ((candidate [2; 4; 8]) = 0));
  (assert ((candidate [30; 13; 23; 32]) = 23));
  (assert ((candidate [3; 13; 2; 9]) = 3));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
 * Examples
 * >>> solution [5; 8; 7; 1]
 * 12
 * >>> solution [3; 3; 3; 3; 3]
 * 9
 * >>> solution [30; 13; 24; 321]
 * 0
*)
let solution (lst : int list) : int =
  let rec aux acc idx = function
    | [] -> acc
    | x :: xs ->
        let acc' =
          if idx mod 2 = 0 && x mod 2 <> 0 then acc + x else acc
        in
        aux acc' (idx + 1) xs
  in
  aux 0 0 lst

let assertions =
 let candidate = solution in
  (assert ((candidate [5; 8; 7; 1]) = 12));
  (assert ((candidate [3; 3; 3; 3; 3]) = 9));
  (assert ((candidate [30; 13; 24; 321]) = 0));
  (assert ((candidate [5; 9]) = 5));
  (assert ((candidate [2; 4; 8]) = 0));
  (assert ((candidate [30; 13; 23; 32]) = 23));
  (assert ((candidate [3; 13; 2; 9]) = 3));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 123 (ML) - HumanEval_123_get_odd_collatz
================================================================================

PROMPT:
----------------------------------------
(**Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.
 * The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
 * as follows: start with any positive integer n. Then each term is obtained from the 
 * previous term as follows: if the previous term is even, the next term is one half of 
 * the previous term. If the previous term is odd, the next term is 3 times the previous
 * term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
 * Note: 
 * 1. Collatz(1) is [1].
 * 2. returned list sorted in increasing order.
 * For example:
 * get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
 * >>> get_odd_collatz 5
 * [1; 5]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = get_odd_collatz in
  (assert ((candidate 14) = [1; 5; 7; 11; 13; 17]));
  (assert ((candidate 5) = [1; 5]));
  (assert ((candidate 12) = [1; 3; 5]));
  (assert ((candidate 1) = [1]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.
 * The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
 * as follows: start with any positive integer n. Then each term is obtained from the 
 * previous term as follows: if the previous term is even, the next term is one half of 
 * the previous term. If the previous term is odd, the next term is 3 times the previous
 * term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
 * Note: 
 * 1. Collatz(1) is [1].
 * 2. returned list sorted in increasing order.
 * For example:
 * get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
 * >>> get_odd_collatz 5
 * [1; 5]
*)
(* Return a sorted list of the odd numbers that appear in the Collatz sequence
   starting from n. *)
let get_odd_collatz (n : int) : int list =
  (* Helper that builds the list of odd numbers in reverse order. *)
  let rec aux current odds =
    if current = 1 then 1 :: odds          (* 1 is always part of the sequence *)
    else
      let odds' =
        if current mod 2 = 1 then current :: odds
        else odds
      in
      let next =
        if current mod 2 = 0 then current / 2
        else 3 * current + 1
      in
      aux next odds'
  in
  (* Build the list, then sort it (and remove duplicates if any). *)
  let odds = aux n [] in
  List.sort_uniq compare odds

let assertions =
 let candidate = get_odd_collatz in
  (assert ((candidate 14) = [1; 5; 7; 11; 13; 17]));
  (assert ((candidate 5) = [1; 5]));
  (assert ((candidate 12) = [1; 3; 5]));
  (assert ((candidate 1) = [1]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.
 * The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
 * as follows: start with any positive integer n. Then each term is obtained from the 
 * previous term as follows: if the previous term is even, the next term is one half of 
 * the previous term. If the previous term is odd, the next term is 3 times the previous
 * term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
 * Note: 
 * 1. Collatz(1) is [1].
 * 2. returned list sorted in increasing order.
 * For example:
 * get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
 * >>> get_odd_collatz 5
 * [1; 5]
*)
let get_odd_collatz (n : int) : int list =
  let rec aux cur acc =
    (* add current term if it is odd *)
    let acc' = if cur mod 2 = 1 then cur :: acc else acc in
    if cur = 1 then acc'                 (* reached the end of the sequence *)
    else
      let next = if cur mod 2 = 0 then cur / 2 else 3 * cur + 1 in
      aux next acc'
  in
  List.sort compare (aux n [])

let assertions =
 let candidate = get_odd_collatz in
  (assert ((candidate 14) = [1; 5; 7; 11; 13; 17]));
  (assert ((candidate 5) = [1; 5]));
  (assert ((candidate 12) = [1; 3; 5]));
  (assert ((candidate 1) = [1]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.
 * The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
 * as follows: start with any positive integer n. Then each term is obtained from the 
 * previous term as follows: if the previous term is even, the next term is one half of 
 * the previous term. If the previous term is odd, the next term is 3 times the previous
 * term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
 * Note: 
 * 1. Collatz(1) is [1].
 * 2. returned list sorted in increasing order.
 * For example:
 * get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
 * >>> get_odd_collatz 5
 * [1; 5]
*)
let get_odd_collatz (n : int) : int list =
  (* Tail‑recursive helper that accumulates the odd numbers in reverse order *)
  let rec collatz m acc =
    let acc = if m mod 2 <> 0 then m :: acc else acc in
    if m = 1 then acc
    else
      let next = if m mod 2 = 0 then m / 2 else 3 * m + 1 in
      collatz next acc
  in
  (* Collect odd numbers, then sort them in increasing order *)
  List.sort compare (collatz n [])

let assertions =
 let candidate = get_odd_collatz in
  (assert ((candidate 14) = [1; 5; 7; 11; 13; 17]));
  (assert ((candidate 5) = [1; 5]));
  (assert ((candidate 12) = [1; 3; 5]));
  (assert ((candidate 1) = [1]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.
 * The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
 * as follows: start with any positive integer n. Then each term is obtained from the 
 * previous term as follows: if the previous term is even, the next term is one half of 
 * the previous term. If the previous term is odd, the next term is 3 times the previous
 * term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
 * Note: 
 * 1. Collatz(1) is [1].
 * 2. returned list sorted in increasing order.
 * For example:
 * get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
 * >>> get_odd_collatz 5
 * [1; 5]
*)
(* Return the sorted list of odd numbers appearing in the Collatz sequence of n *)
let get_odd_collatz (n : int) : int list =
  (* Recursive helper that walks the sequence, collecting odd values *)
  let rec aux current acc =
    (* If current is odd, prepend it to the accumulator *)
    let acc' = if current mod 2 <> 0 then current :: acc else acc in
    (* Stop when we reach 1 (which is already handled above) *)
    if current = 1 then acc'
    else
      (* Compute the next term of the Collatz sequence *)
      let next =
        if current mod 2 = 0 then current / 2 else 3 * current + 1
      in
      aux next acc'
  in
  (* Build the list of odds and then sort it in ascending order *)
  List.sort compare (aux n [])

let assertions =
 let candidate = get_odd_collatz in
  (assert ((candidate 14) = [1; 5; 7; 11; 13; 17]));
  (assert ((candidate 5) = [1; 5]));
  (assert ((candidate 12) = [1; 3; 5]));
  (assert ((candidate 1) = [1]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183725
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 126 (ML) - HumanEval_126_is_sorted
================================================================================

PROMPT:
----------------------------------------
(**Given a list of numbers, return whether or not they are sorted
 * in ascending order. If list has more than 1 duplicate of the same
 * number, return false. Assume no negative numbers and only integers.
 * Examples
 * >>> is_sorted [5]
 * true
 * >>> is_sorted [1; 2; 3; 4; 5]
 * true
 * >>> is_sorted [1; 3; 2; 4; 5]
 * false
 * >>> is_sorted [1; 2; 3; 4; 5; 6]
 * true
 * >>> is_sorted [1; 2; 3; 4; 5; 6; 7]
 * true
 * >>> is_sorted [1; 3; 2; 4; 5; 6; 7]
 * false
 * >>> is_sorted [1; 2; 2; 3; 3; 4]
 * true
 * >>> is_sorted [1; 2; 2; 2; 3; 4]
 * false
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = is_sorted in
  (assert ((candidate [5]) = true));
  (assert ((candidate [1; 2; 3; 4; 5]) = true));
  (assert ((candidate [1; 3; 2; 4; 5]) = false));
  (assert ((candidate [1; 2; 3; 4; 5; 6]) = true));
  (assert ((candidate [1; 2; 3; 4; 5; 6; 7]) = true));
  (assert ((candidate [1; 3; 2; 4; 5; 6; 7]) = false));
  (assert ((candidate []) = true));
  (assert ((candidate [1]) = true));
  (assert ((candidate [3; 2; 1]) = false));
  (assert ((candidate [1; 2; 2; 2; 3; 4]) = false));
  (assert ((candidate [1; 2; 3; 3; 3; 4]) = false));
  (assert ((candidate [1; 2; 2; 3; 3; 4]) = true));
  (assert ((candidate [1; 2; 3; 4]) = true));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given a list of numbers, return whether or not they are sorted
 * in ascending order. If list has more than 1 duplicate of the same
 * number, return false. Assume no negative numbers and only integers.
 * Examples
 * >>> is_sorted [5]
 * true
 * >>> is_sorted [1; 2; 3; 4; 5]
 * true
 * >>> is_sorted [1; 3; 2; 4; 5]
 * false
 * >>> is_sorted [1; 2; 3; 4; 5; 6]
 * true
 * >>> is_sorted [1; 2; 3; 4; 5; 6; 7]
 * true
 * >>> is_sorted [1; 3; 2; 4; 5; 6; 7]
 * false
 * >>> is_sorted [1; 2; 2; 3; 3; 4]
 * true
 * >>> is_sorted [1; 2; 2; 2; 3; 4]
 * false
*)
let is_sorted (lst : int list) : bool =
  (* Helper that keeps the previous element and how many times it has
     appeared consecutively. *)
  let rec aux prev count = function
    | [] -> true
    | x :: xs ->
        if x < prev then
          (* Not ascending *)
          false
        else if x = prev then
          (* Duplicate of the previous element *)
          if count + 1 > 2 then
            (* More than one duplicate → invalid *)
            false
          else
            aux prev (count + 1) xs
        else
          (* New value – reset count *)
          aux x 1 xs
  in
  match lst with
  | [] -> true           (* Empty list is trivially sorted *)
  | h :: t -> aux h 1 t  (* Start with first element, count = 1 *)

let assertions =
 let candidate = is_sorted in
  (assert ((candidate [5]) = true));
  (assert ((candidate [1; 2; 3; 4; 5]) = true));
  (assert ((candidate [1; 3; 2; 4; 5]) = false));
  (assert ((candidate [1; 2; 3; 4; 5; 6]) = true));
  (assert ((candidate [1; 2; 3; 4; 5; 6; 7]) = true));
  (assert ((candidate [1; 3; 2; 4; 5; 6; 7]) = false));
  (assert ((candidate []) = true));
  (assert ((candidate [1]) = true));
  (assert ((candidate [3; 2; 1]) = false));
  (assert ((candidate [1; 2; 2; 2; 3; 4]) = false));
  (assert ((candidate [1; 2; 3; 3; 3; 4]) = false));
  (assert ((candidate [1; 2; 2; 3; 3; 4]) = true));
  (assert ((candidate [1; 2; 3; 4]) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183726
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given a list of numbers, return whether or not they are sorted
 * in ascending order. If list has more than 1 duplicate of the same
 * number, return false. Assume no negative numbers and only integers.
 * Examples
 * >>> is_sorted [5]
 * true
 * >>> is_sorted [1; 2; 3; 4; 5]
 * true
 * >>> is_sorted [1; 3; 2; 4; 5]
 * false
 * >>> is_sorted [1; 2; 3; 4; 5; 6]
 * true
 * >>> is_sorted [1; 2; 3; 4; 5; 6; 7]
 * true
 * >>> is_sorted [1; 3; 2; 4; 5; 6; 7]
 * false
 * >>> is_sorted [1; 2; 2; 3; 3; 4]
 * true
 * >>> is_sorted [1; 2; 2; 2; 3; 4]
 * false
*)
let is_sorted (lst : int list) : bool =
  (* Helper function that keeps track of the previous element and
     how many times the current element has been seen consecutively. *)
  let rec aux prev count = function
    | [] -> true
    | x :: xs ->
        if x < prev then
          (* Current element is smaller than the previous one → not sorted. *)
          false
        else if x = prev then
          (* Duplicate of the previous element.  We allow at most one duplicate. *)
          if count >= 1 then
            false
          else
            aux prev (count + 1) xs
        else
          (* New element, reset duplicate counter. *)
          aux x 0 xs
  in
  match lst with
  | [] -> true                     (* Empty list is considered sorted. *)
  | x :: xs -> aux x 0 xs          (* Start recursion with first element. *)

let assertions =
 let candidate = is_sorted in
  (assert ((candidate [5]) = true));
  (assert ((candidate [1; 2; 3; 4; 5]) = true));
  (assert ((candidate [1; 3; 2; 4; 5]) = false));
  (assert ((candidate [1; 2; 3; 4; 5; 6]) = true));
  (assert ((candidate [1; 2; 3; 4; 5; 6; 7]) = true));
  (assert ((candidate [1; 3; 2; 4; 5; 6; 7]) = false));
  (assert ((candidate []) = true));
  (assert ((candidate [1]) = true));
  (assert ((candidate [3; 2; 1]) = false));
  (assert ((candidate [1; 2; 2; 2; 3; 4]) = false));
  (assert ((candidate [1; 2; 3; 3; 3; 4]) = false));
  (assert ((candidate [1; 2; 2; 3; 3; 4]) = true));
  (assert ((candidate [1; 2; 3; 4]) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183726
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given a list of numbers, return whether or not they are sorted
 * in ascending order. If list has more than 1 duplicate of the same
 * number, return false. Assume no negative numbers and only integers.
 * Examples
 * >>> is_sorted [5]
 * true
 * >>> is_sorted [1; 2; 3; 4; 5]
 * true
 * >>> is_sorted [1; 3; 2; 4; 5]
 * false
 * >>> is_sorted [1; 2; 3; 4; 5; 6]
 * true
 * >>> is_sorted [1; 2; 3; 4; 5; 6; 7]
 * true
 * >>> is_sorted [1; 3; 2; 4; 5; 6; 7]
 * false
 * >>> is_sorted [1; 2; 2; 3; 3; 4]
 * true
 * >>> is_sorted [1; 2; 2; 2; 3; 4]
 * false
*)
(* Returns true if the list is sorted in ascending order and
   no element appears more than twice. *)
let is_sorted (lst : int list) : bool =
  (* Helper that keeps the previous element and how many times it
     has been seen consecutively. *)
  let rec aux prev count = function
    | [] -> true
    | x :: xs ->
        if x < prev then
          (* Not ascending *)
          false
        else if x = prev then
          (* Same element again – check duplicate limit *)
          if count + 1 > 2 then
            false
          else
            aux prev (count + 1) xs
        else
          (* New element – reset count *)
          aux x 1 xs
  in
  match lst with
  | [] -> true
  | x :: xs -> aux x 1 xs

let assertions =
 let candidate = is_sorted in
  (assert ((candidate [5]) = true));
  (assert ((candidate [1; 2; 3; 4; 5]) = true));
  (assert ((candidate [1; 3; 2; 4; 5]) = false));
  (assert ((candidate [1; 2; 3; 4; 5; 6]) = true));
  (assert ((candidate [1; 2; 3; 4; 5; 6; 7]) = true));
  (assert ((candidate [1; 3; 2; 4; 5; 6; 7]) = false));
  (assert ((candidate []) = true));
  (assert ((candidate [1]) = true));
  (assert ((candidate [3; 2; 1]) = false));
  (assert ((candidate [1; 2; 2; 2; 3; 4]) = false));
  (assert ((candidate [1; 2; 3; 3; 3; 4]) = false));
  (assert ((candidate [1; 2; 2; 3; 3; 4]) = true));
  (assert ((candidate [1; 2; 3; 4]) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183726
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given a list of numbers, return whether or not they are sorted
 * in ascending order. If list has more than 1 duplicate of the same
 * number, return false. Assume no negative numbers and only integers.
 * Examples
 * >>> is_sorted [5]
 * true
 * >>> is_sorted [1; 2; 3; 4; 5]
 * true
 * >>> is_sorted [1; 3; 2; 4; 5]
 * false
 * >>> is_sorted [1; 2; 3; 4; 5; 6]
 * true
 * >>> is_sorted [1; 2; 3; 4; 5; 6; 7]
 * true
 * >>> is_sorted [1; 3; 2; 4; 5; 6; 7]
 * false
 * >>> is_sorted [1; 2; 2; 3; 3; 4]
 * true
 * >>> is_sorted [1; 2; 2; 2; 3; 4]
 * false
*)
let is_sorted (lst : int list) : bool =
  (* Helper that walks through the list keeping track of the previous element
     and the current duplicate count. *)
  let rec aux prev dup_count = function
    | [] -> true
    | x :: xs ->
        if x < prev then
          false  (* not ascending *)
        else if x = prev then
          (* duplicate: ensure we don't exceed 2 occurrences *)
          if dup_count + 1 > 2 then
            false
          else
            aux prev (dup_count + 1) xs
        else
          (* new value, reset duplicate count *)
          aux x 1 xs
  in
  (* Handle empty or single‑element lists separately. *)
  match lst with
  | [] | [_] -> true
  | h :: t -> aux h 1 t

let assertions =
 let candidate = is_sorted in
  (assert ((candidate [5]) = true));
  (assert ((candidate [1; 2; 3; 4; 5]) = true));
  (assert ((candidate [1; 3; 2; 4; 5]) = false));
  (assert ((candidate [1; 2; 3; 4; 5; 6]) = true));
  (assert ((candidate [1; 2; 3; 4; 5; 6; 7]) = true));
  (assert ((candidate [1; 3; 2; 4; 5; 6; 7]) = false));
  (assert ((candidate []) = true));
  (assert ((candidate [1]) = true));
  (assert ((candidate [3; 2; 1]) = false));
  (assert ((candidate [1; 2; 2; 2; 3; 4]) = false));
  (assert ((candidate [1; 2; 3; 3; 3; 4]) = false));
  (assert ((candidate [1; 2; 2; 3; 3; 4]) = true));
  (assert ((candidate [1; 2; 3; 4]) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183726
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 131 (ML) - HumanEval_131_digits
================================================================================

PROMPT:
----------------------------------------
(**Given a positive integer n, return the product of the odd digits.
 * Return 0 if all digits are even.
 * For example:
 * >>> digits 1
 * 1
 * >>> digits 4
 * 0
 * >>> digits 235
 * 15
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = digits in
  (assert ((candidate 5) = 5));
  (assert ((candidate 54) = 5));
  (assert ((candidate 120) = 1));
  (assert ((candidate 5014) = 5));
  (assert ((candidate 98765) = 315));
  (assert ((candidate 5576543) = 2625));
  (assert ((candidate 2468) = 0));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given a positive integer n, return the product of the odd digits.
 * Return 0 if all digits are even.
 * For example:
 * >>> digits 1
 * 1
 * >>> digits 4
 * 0
 * >>> digits 235
 * 15
*)
let digits (n : int) : int =
  let rec aux n prod seen =
    if n = 0 then
      if seen then prod else 0
    else
      let d = n mod 10 in
      if d mod 2 = 1 then
        aux (n / 10) (prod * d) true
      else
        aux (n / 10) prod seen
  in
  aux n 1 false

let assertions =
 let candidate = digits in
  (assert ((candidate 5) = 5));
  (assert ((candidate 54) = 5));
  (assert ((candidate 120) = 1));
  (assert ((candidate 5014) = 5));
  (assert ((candidate 98765) = 315));
  (assert ((candidate 5576543) = 2625));
  (assert ((candidate 2468) = 0));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183727
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given a positive integer n, return the product of the odd digits.
 * Return 0 if all digits are even.
 * For example:
 * >>> digits 1
 * 1
 * >>> digits 4
 * 0
 * >>> digits 235
 * 15
*)
let digits (n : int) : int =
  let rec loop n acc found =
    if n = 0 then
      if found then acc else 0
    else
      let d = n mod 10 in
      if d mod 2 = 1 then
        loop (n / 10) (acc * d) true
      else
        loop (n / 10) acc found
  in
  loop n 1 false

let assertions =
 let candidate = digits in
  (assert ((candidate 5) = 5));
  (assert ((candidate 54) = 5));
  (assert ((candidate 120) = 1));
  (assert ((candidate 5014) = 5));
  (assert ((candidate 98765) = 315));
  (assert ((candidate 5576543) = 2625));
  (assert ((candidate 2468) = 0));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183727
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given a positive integer n, return the product of the odd digits.
 * Return 0 if all digits are even.
 * For example:
 * >>> digits 1
 * 1
 * >>> digits 4
 * 0
 * >>> digits 235
 * 15
*)
let digits (n : int) : int =
  let rec aux n acc has_odd =
    if n = 0 then
      if has_odd then acc else 0
    else
      let d = n mod 10 in
      if d mod 2 = 1 then
        aux (n / 10) (acc * d) true
      else
        aux (n / 10) acc has_odd
  in
  aux n 1 false

let assertions =
 let candidate = digits in
  (assert ((candidate 5) = 5));
  (assert ((candidate 54) = 5));
  (assert ((candidate 120) = 1));
  (assert ((candidate 5014) = 5));
  (assert ((candidate 98765) = 315));
  (assert ((candidate 5576543) = 2625));
  (assert ((candidate 2468) = 0));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183727
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given a positive integer n, return the product of the odd digits.
 * Return 0 if all digits are even.
 * For example:
 * >>> digits 1
 * 1
 * >>> digits 4
 * 0
 * >>> digits 235
 * 15
*)
(* Return the product of the odd digits of a positive integer n.
   If n contains no odd digits, return 0. *)
let digits (n : int) : int =
  let rec aux n acc found =
    if n = 0 then
      if found then acc else 0
    else
      let d = n mod 10 in
      if d mod 2 = 1 then
        aux (n / 10) (acc * d) true
      else
        aux (n / 10) acc found
  in
  aux n 1 false

let assertions =
 let candidate = digits in
  (assert ((candidate 5) = 5));
  (assert ((candidate 54) = 5));
  (assert ((candidate 120) = 1));
  (assert ((candidate 5014) = 5));
  (assert ((candidate 98765) = 315));
  (assert ((candidate 5576543) = 2625));
  (assert ((candidate 2468) = 0));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183727
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 138 (ML) - HumanEval_138_is_equal_to_sum_even
================================================================================

PROMPT:
----------------------------------------
(**Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
 * Example
 * >>> is_equal_to_sum_even 4
 * false
 * >>> is_equal_to_sum_even 6
 * false
 * >>> is_equal_to_sum_even 8
 * true
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = is_equal_to_sum_even in
  (assert ((candidate 4) = false));
  (assert ((candidate 6) = false));
  (assert ((candidate 8) = true));
  (assert ((candidate 10) = true));
  (assert ((candidate 11) = false));
  (assert ((candidate 12) = true));
  (assert ((candidate 13) = false));
  (assert ((candidate 16) = true));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
 * Example
 * >>> is_equal_to_sum_even 4
 * false
 * >>> is_equal_to_sum_even 6
 * false
 * >>> is_equal_to_sum_even 8
 * true
*)
(* Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
 * Example
 * >>> is_equal_to_sum_even 4
 * false
 * >>> is_equal_to_sum_even 6
 * false
 * >>> is_equal_to_sum_even 8
 * true
*)
let is_equal_to_sum_even (n : int) : bool =
  (* The smallest sum of four positive even numbers is 2 + 2 + 2 + 2 = 8.
     Therefore, n must be at least 8 and even. *)
  n >= 8 && n mod 2 = 0

let assertions =
 let candidate = is_equal_to_sum_even in
  (assert ((candidate 4) = false));
  (assert ((candidate 6) = false));
  (assert ((candidate 8) = true));
  (assert ((candidate 10) = true));
  (assert ((candidate 11) = false));
  (assert ((candidate 12) = true));
  (assert ((candidate 13) = false));
  (assert ((candidate 16) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183728
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
 * Example
 * >>> is_equal_to_sum_even 4
 * false
 * >>> is_equal_to_sum_even 6
 * false
 * >>> is_equal_to_sum_even 8
 * true
*)
(* Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
 * Example
 * >>> is_equal_to_sum_even 4
 * false
 * >>> is_equal_to_sum_even 6
 * false
 * >>> is_equal_to_sum_even 8
 * true
*)
let is_equal_to_sum_even (n : int) : bool =
  (* The sum of four positive even numbers is always even and at least 2*4 = 8.
     Therefore n must be even and n >= 8. *)
  n >= 8 && n mod 2 = 0

let assertions =
 let candidate = is_equal_to_sum_even in
  (assert ((candidate 4) = false));
  (assert ((candidate 6) = false));
  (assert ((candidate 8) = true));
  (assert ((candidate 10) = true));
  (assert ((candidate 11) = false));
  (assert ((candidate 12) = true));
  (assert ((candidate 13) = false));
  (assert ((candidate 16) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183728
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
 * Example
 * >>> is_equal_to_sum_even 4
 * false
 * >>> is_equal_to_sum_even 6
 * false
 * >>> is_equal_to_sum_even 8
 * true
*)
(* Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers *)
let is_equal_to_sum_even (n : int) : bool =
  (* Minimum sum of four positive even numbers is 2+2+2+2 = 8.
     Any even number ≥ 8 can be expressed as 2+2+2+(n-6), which is a valid
     decomposition into four positive even numbers. *)
  n >= 8 && n mod 2 = 0

let assertions =
 let candidate = is_equal_to_sum_even in
  (assert ((candidate 4) = false));
  (assert ((candidate 6) = false));
  (assert ((candidate 8) = true));
  (assert ((candidate 10) = true));
  (assert ((candidate 11) = false));
  (assert ((candidate 12) = true));
  (assert ((candidate 13) = false));
  (assert ((candidate 16) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183728
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
 * Example
 * >>> is_equal_to_sum_even 4
 * false
 * >>> is_equal_to_sum_even 6
 * false
 * >>> is_equal_to_sum_even 8
 * true
*)
let is_equal_to_sum_even (n : int) : bool =
  n >= 8 && n mod 2 = 0

let assertions =
 let candidate = is_equal_to_sum_even in
  (assert ((candidate 4) = false));
  (assert ((candidate 6) = false));
  (assert ((candidate 8) = true));
  (assert ((candidate 10) = true));
  (assert ((candidate 11) = false));
  (assert ((candidate 12) = true));
  (assert ((candidate 13) = false));
  (assert ((candidate 16) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183728
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 139 (ML) - HumanEval_139_special_factorial
================================================================================

PROMPT:
----------------------------------------
(**The Brazilian factorial is defined as:
 * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
 * where n > 0
 * For example:
 * >>> special_factorial 4
 * 288
 * The function will receive an integer as input and should return the special
 * factorial of this integer.
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = special_factorial in
  (assert ((candidate 4) = 288));
  (assert ((candidate 5) = 34560));
  (assert ((candidate 7) = 125411328000));
  (assert ((candidate 1) = 1));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**The Brazilian factorial is defined as:
 * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
 * where n > 0
 * For example:
 * >>> special_factorial 4
 * 288
 * The function will receive an integer as input and should return the special
 * factorial of this integer.
*)
(* Brazilian factorial: n! * (n-1)! * … * 1! *)
let special_factorial (n : int) : int =
  (* Helper to compute a normal factorial *)
  let rec fact m =
    if m <= 1 then 1 else m * fact (m - 1)
  in
  (* Recursive computation of the Brazilian factorial *)
  let rec sf k =
    if k <= 1 then fact k else fact k * sf (k - 1)
  in
  sf n

let assertions =
 let candidate = special_factorial in
  (assert ((candidate 4) = 288));
  (assert ((candidate 5) = 34560));
  (assert ((candidate 7) = 125411328000));
  (assert ((candidate 1) = 1));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183728
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**The Brazilian factorial is defined as:
 * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
 * where n > 0
 * For example:
 * >>> special_factorial 4
 * 288
 * The function will receive an integer as input and should return the special
 * factorial of this integer.
*)
(* Brazilian factorial: n! * (n-1)! * … * 1! *)
let special_factorial (n : int) : int =
  (* Helper to compute the factorial of a single number *)
  let rec fact k acc =
    if k = 0 then acc
    else fact (k - 1) (k * acc)
  in
  (* Accumulate the product of factorials from n down to 1 *)
  let rec loop i acc =
    if i = 0 then acc
    else loop (i - 1) (fact i 1 * acc)
  in
  loop n 1

let assertions =
 let candidate = special_factorial in
  (assert ((candidate 4) = 288));
  (assert ((candidate 5) = 34560));
  (assert ((candidate 7) = 125411328000));
  (assert ((candidate 1) = 1));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183728
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**The Brazilian factorial is defined as:
 * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
 * where n > 0
 * For example:
 * >>> special_factorial 4
 * 288
 * The function will receive an integer as input and should return the special
 * factorial of this integer.
*)
(* Compute the factorial of an integer *)
let rec factorial n =
  if n <= 1 then 1
  else n * factorial (n - 1)

(* Brazilian factorial: product of all factorials from 1! up to n! *)
let special_factorial (n : int) : int =
  let rec loop i acc =
    if i > n then acc
    else loop (i + 1) (acc * factorial i)
  in
  loop 1 1

let assertions =
 let candidate = special_factorial in
  (assert ((candidate 4) = 288));
  (assert ((candidate 5) = 34560));
  (assert ((candidate 7) = 125411328000));
  (assert ((candidate 1) = 1));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183728
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**The Brazilian factorial is defined as:
 * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
 * where n > 0
 * For example:
 * >>> special_factorial 4
 * 288
 * The function will receive an integer as input and should return the special
 * factorial of this integer.
*)
let rec fact n =
  if n <= 1 then 1
  else n * fact (n - 1)

let special_factorial (n : int) : int =
  let rec loop acc k =
    if k > n then acc
    else loop (acc * fact k) (k + 1)
  in
  if n <= 0 then 1
  else loop 1 1

let assertions =
 let candidate = special_factorial in
  (assert ((candidate 4) = 288));
  (assert ((candidate 5) = 34560));
  (assert ((candidate 7) = 125411328000));
  (assert ((candidate 1) = 1));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183728
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 141 (ML) - HumanEval_141_file_name_check
================================================================================

PROMPT:
----------------------------------------
(**Create a function which takes a string representing a file's name, and returns
 * 'Yes' if the the file's name is valid, and returns 'No' otherwise.
 * A file's name is considered to be valid if and only if all the following conditions 
 * are met:
 * - There should not be more than three digits ('0'-'9') in the file's name.
 * - The file's name contains exactly one dot '.'
 * - The substring before the dot should not be empty, and it starts with a letter from 
 * the latin alphapet ('a'-'z' and 'A'-'Z').
 * - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
 * Examples:
 * >>> file_name_check "example.txt"
 * "Yes"
 * >>> file_name_check "1example.dll"
 * "No"
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = file_name_check in
  (assert ((candidate "example.txt") = "Yes"));
  (assert ((candidate "1example.dll") = "No"));
  (assert ((candidate "s1sdf3.asd") = "No"));
  (assert ((candidate "K.dll") = "Yes"));
  (assert ((candidate "MY16FILE3.exe") = "Yes"));
  (assert ((candidate "His12FILE94.exe") = "No"));
  (assert ((candidate "_Y.txt") = "No"));
  (assert ((candidate "?aREYA.exe") = "No"));
  (assert ((candidate "/this_is_valid.dll") = "No"));
  (assert ((candidate "this_is_valid.wow") = "No"));
  (assert ((candidate "this_is_valid.txt") = "Yes"));
  (assert ((candidate "this_is_valid.txtexe") = "No"));
  (assert ((candidate "#this2_i4s_5valid.ten") = "No"));
  (assert ((candidate "@this1_is6_valid.exe") = "No"));
  (assert ((candidate "this_is_12valid.6exe4.txt") = "No"));
  (assert ((candidate "all.exe.txt") = "No"));
  (assert ((candidate "I563_No.exe") = "Yes"));
  (assert ((candidate "Is3youfault.txt") = "Yes"));
  (assert ((candidate "no_one#knows.dll") = "Yes"));
  (assert ((candidate "1I563_Yes3.exe") = "No"));
  (assert ((candidate "I563_Yes3.txtt") = "No"));
  (assert ((candidate "final..txt") = "No"));
  (assert ((candidate "final132") = "No"));
  (assert ((candidate "_f4indsartal132.") = "No"));
  (assert ((candidate ".txt") = "No"));
  (assert ((candidate "s.") = "No"));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Create a function which takes a string representing a file's name, and returns
 * 'Yes' if the the file's name is valid, and returns 'No' otherwise.
 * A file's name is considered to be valid if and only if all the following conditions 
 * are met:
 * - There should not be more than three digits ('0'-'9') in the file's name.
 * - The file's name contains exactly one dot '.'
 * - The substring before the dot should not be empty, and it starts with a letter from 
 * the latin alphapet ('a'-'z' and 'A'-'Z').
 * - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
 * Examples:
 * >>> file_name_check "example.txt"
 * "Yes"
 * >>> file_name_check "1example.dll"
 * "No"
*)
let file_name_check (file_name : string) : string =
  (* Count the digits in the whole file name *)
  let digit_count =
    String.fold_left
      (fun acc c -> if '0' <= c && c <= '9' then acc + 1 else acc)
      0
      file_name
  in
  if digit_count > 3 then
    "No"
  else
    (* Split the name on the dot and check that we have exactly two parts *)
    let parts = String.split_on_char '.' file_name in
    match parts with
    | [before; after] ->
        (* before must be non‑empty and start with a latin letter *)
        let valid_before =
          before <> ""
          && (let c = String.get before 0 in
              ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'))
        in
        (* after must be one of the allowed extensions *)
        let valid_after =
          List.mem after ["txt"; "exe"; "dll"]
        in
        if valid_before && valid_after then "Yes" else "No"
    | _ -> "No"

let assertions =
 let candidate = file_name_check in
  (assert ((candidate "example.txt") = "Yes"));
  (assert ((candidate "1example.dll") = "No"));
  (assert ((candidate "s1sdf3.asd") = "No"));
  (assert ((candidate "K.dll") = "Yes"));
  (assert ((candidate "MY16FILE3.exe") = "Yes"));
  (assert ((candidate "His12FILE94.exe") = "No"));
  (assert ((candidate "_Y.txt") = "No"));
  (assert ((candidate "?aREYA.exe") = "No"));
  (assert ((candidate "/this_is_valid.dll") = "No"));
  (assert ((candidate "this_is_valid.wow") = "No"));
  (assert ((candidate "this_is_valid.txt") = "Yes"));
  (assert ((candidate "this_is_valid.txtexe") = "No"));
  (assert ((candidate "#this2_i4s_5valid.ten") = "No"));
  (assert ((candidate "@this1_is6_valid.exe") = "No"));
  (assert ((candidate "this_is_12valid.6exe4.txt") = "No"));
  (assert ((candidate "all.exe.txt") = "No"));
  (assert ((candidate "I563_No.exe") = "Yes"));
  (assert ((candidate "Is3youfault.txt") = "Yes"));
  (assert ((candidate "no_one#knows.dll") = "Yes"));
  (assert ((candidate "1I563_Yes3.exe") = "No"));
  (assert ((candidate "I563_Yes3.txtt") = "No"));
  (assert ((candidate "final..txt") = "No"));
  (assert ((candidate "final132") = "No"));
  (assert ((candidate "_f4indsartal132.") = "No"));
  (assert ((candidate ".txt") = "No"));
  (assert ((candidate "s.") = "No"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183728
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Create a function which takes a string representing a file's name, and returns
 * 'Yes' if the the file's name is valid, and returns 'No' otherwise.
 * A file's name is considered to be valid if and only if all the following conditions 
 * are met:
 * - There should not be more than three digits ('0'-'9') in the file's name.
 * - The file's name contains exactly one dot '.'
 * - The substring before the dot should not be empty, and it starts with a letter from 
 * the latin alphapet ('a'-'z' and 'A'-'Z').
 * - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
 * Examples:
 * >>> file_name_check "example.txt"
 * "Yes"
 * >>> file_name_check "1example.dll"
 * "No"
*)
let file_name_check (file_name : string) : string =
  (* Helper to count digits in a string *)
  let count_digits s =
    String.fold_left
      (fun acc c -> if '0' <= c && c <= '9' then acc + 1 else acc)
      0 s
  in

  (* Check number of digits *)
  if count_digits file_name > 3 then "No"
  else
    (* Split by '.' and ensure exactly one dot *)
    let parts = String.split_on_char '.' file_name in
    match parts with
    | [name; ext] ->
        (* name must be non‑empty and start with a Latin letter *)
        let valid_name =
          name <> ""
          && (let c = name.[0] in
              ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'))
        in
        (* extension must be one of the allowed ones *)
        let valid_ext = List.mem ext ["txt"; "exe"; "dll"] in
        if valid_name && valid_ext then "Yes" else "No"
    | _ -> "No"

let assertions =
 let candidate = file_name_check in
  (assert ((candidate "example.txt") = "Yes"));
  (assert ((candidate "1example.dll") = "No"));
  (assert ((candidate "s1sdf3.asd") = "No"));
  (assert ((candidate "K.dll") = "Yes"));
  (assert ((candidate "MY16FILE3.exe") = "Yes"));
  (assert ((candidate "His12FILE94.exe") = "No"));
  (assert ((candidate "_Y.txt") = "No"));
  (assert ((candidate "?aREYA.exe") = "No"));
  (assert ((candidate "/this_is_valid.dll") = "No"));
  (assert ((candidate "this_is_valid.wow") = "No"));
  (assert ((candidate "this_is_valid.txt") = "Yes"));
  (assert ((candidate "this_is_valid.txtexe") = "No"));
  (assert ((candidate "#this2_i4s_5valid.ten") = "No"));
  (assert ((candidate "@this1_is6_valid.exe") = "No"));
  (assert ((candidate "this_is_12valid.6exe4.txt") = "No"));
  (assert ((candidate "all.exe.txt") = "No"));
  (assert ((candidate "I563_No.exe") = "Yes"));
  (assert ((candidate "Is3youfault.txt") = "Yes"));
  (assert ((candidate "no_one#knows.dll") = "Yes"));
  (assert ((candidate "1I563_Yes3.exe") = "No"));
  (assert ((candidate "I563_Yes3.txtt") = "No"));
  (assert ((candidate "final..txt") = "No"));
  (assert ((candidate "final132") = "No"));
  (assert ((candidate "_f4indsartal132.") = "No"));
  (assert ((candidate ".txt") = "No"));
  (assert ((candidate "s.") = "No"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183728
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Create a function which takes a string representing a file's name, and returns
 * 'Yes' if the the file's name is valid, and returns 'No' otherwise.
 * A file's name is considered to be valid if and only if all the following conditions 
 * are met:
 * - There should not be more than three digits ('0'-'9') in the file's name.
 * - The file's name contains exactly one dot '.'
 * - The substring before the dot should not be empty, and it starts with a letter from 
 * the latin alphapet ('a'-'z' and 'A'-'Z').
 * - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
 * Examples:
 * >>> file_name_check "example.txt"
 * "Yes"
 * >>> file_name_check "1example.dll"
 * "No"
*)
let file_name_check (file_name : string) : string =
  (* Count how many digits appear in the whole file name *)
  let digit_count =
    String.fold_left
      (fun acc c -> if '0' <= c && c <= '9' then acc + 1 else acc)
      0
      file_name
  in
  (* If there are more than three digits, the name is invalid *)
  if digit_count > 3 then
    "No"
  else
    (* Split the name on the dot; there must be exactly one dot *)
    match String.split_on_char '.' file_name with
    | [name; ext] ->
        (* Check that the part before the dot is non‑empty and starts with a letter *)
        let valid_name =
          name <> ""
          && (
            ('a' <= name.[0] && name.[0] <= 'z')
            || ('A' <= name.[0] && name.[0] <= 'Z')
          )
        in
        (* Check that the extension is one of the allowed ones *)
        let valid_ext = List.mem ext ["txt"; "exe"; "dll"] in
        if valid_name && valid_ext then "Yes" else "No"
    | _ -> "No"  (* Not exactly one dot *)

let assertions =
 let candidate = file_name_check in
  (assert ((candidate "example.txt") = "Yes"));
  (assert ((candidate "1example.dll") = "No"));
  (assert ((candidate "s1sdf3.asd") = "No"));
  (assert ((candidate "K.dll") = "Yes"));
  (assert ((candidate "MY16FILE3.exe") = "Yes"));
  (assert ((candidate "His12FILE94.exe") = "No"));
  (assert ((candidate "_Y.txt") = "No"));
  (assert ((candidate "?aREYA.exe") = "No"));
  (assert ((candidate "/this_is_valid.dll") = "No"));
  (assert ((candidate "this_is_valid.wow") = "No"));
  (assert ((candidate "this_is_valid.txt") = "Yes"));
  (assert ((candidate "this_is_valid.txtexe") = "No"));
  (assert ((candidate "#this2_i4s_5valid.ten") = "No"));
  (assert ((candidate "@this1_is6_valid.exe") = "No"));
  (assert ((candidate "this_is_12valid.6exe4.txt") = "No"));
  (assert ((candidate "all.exe.txt") = "No"));
  (assert ((candidate "I563_No.exe") = "Yes"));
  (assert ((candidate "Is3youfault.txt") = "Yes"));
  (assert ((candidate "no_one#knows.dll") = "Yes"));
  (assert ((candidate "1I563_Yes3.exe") = "No"));
  (assert ((candidate "I563_Yes3.txtt") = "No"));
  (assert ((candidate "final..txt") = "No"));
  (assert ((candidate "final132") = "No"));
  (assert ((candidate "_f4indsartal132.") = "No"));
  (assert ((candidate ".txt") = "No"));
  (assert ((candidate "s.") = "No"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183728
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Create a function which takes a string representing a file's name, and returns
 * 'Yes' if the the file's name is valid, and returns 'No' otherwise.
 * A file's name is considered to be valid if and only if all the following conditions 
 * are met:
 * - There should not be more than three digits ('0'-'9') in the file's name.
 * - The file's name contains exactly one dot '.'
 * - The substring before the dot should not be empty, and it starts with a letter from 
 * the latin alphapet ('a'-'z' and 'A'-'Z').
 * - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
 * Examples:
 * >>> file_name_check "example.txt"
 * "Yes"
 * >>> file_name_check "1example.dll"
 * "No"
*)
let file_name_check (file_name : string) : string =
  let len = String.length file_name in
  let digit_count = ref 0 in
  let dot_count   = ref 0 in
  let dot_pos     = ref (-1) in

  (* Scan the string once *)
  for i = 0 to len - 1 do
    let c = file_name.[i] in
    if c >= '0' && c <= '9' then incr digit_count;
    if c = '.' then begin
      incr dot_count;
      dot_pos := i
    end
  done;

  (* Condition 1: no more than three digits *)
  if !digit_count > 3 then "No"
  (* Condition 2: exactly one dot *)
  else if !dot_count <> 1 then "No"
  else
    let before = String.sub file_name 0 !dot_pos in
    let after  = String.sub file_name (!dot_pos + 1) (len - !dot_pos - 1) in

    (* Condition 3: non‑empty prefix that starts with a letter *)
    let valid_prefix =
      String.length before > 0 &&
      (('a' <= before.[0] && before.[0] <= 'z') ||
       ('A' <= before.[0] && before.[0] <= 'Z'))
    in
    (* Condition 4: valid extension *)
    let valid_ext = List.mem after ["txt"; "exe"; "dll"] in

    if valid_prefix && valid_ext then "Yes" else "No"

let assertions =
 let candidate = file_name_check in
  (assert ((candidate "example.txt") = "Yes"));
  (assert ((candidate "1example.dll") = "No"));
  (assert ((candidate "s1sdf3.asd") = "No"));
  (assert ((candidate "K.dll") = "Yes"));
  (assert ((candidate "MY16FILE3.exe") = "Yes"));
  (assert ((candidate "His12FILE94.exe") = "No"));
  (assert ((candidate "_Y.txt") = "No"));
  (assert ((candidate "?aREYA.exe") = "No"));
  (assert ((candidate "/this_is_valid.dll") = "No"));
  (assert ((candidate "this_is_valid.wow") = "No"));
  (assert ((candidate "this_is_valid.txt") = "Yes"));
  (assert ((candidate "this_is_valid.txtexe") = "No"));
  (assert ((candidate "#this2_i4s_5valid.ten") = "No"));
  (assert ((candidate "@this1_is6_valid.exe") = "No"));
  (assert ((candidate "this_is_12valid.6exe4.txt") = "No"));
  (assert ((candidate "all.exe.txt") = "No"));
  (assert ((candidate "I563_No.exe") = "Yes"));
  (assert ((candidate "Is3youfault.txt") = "Yes"));
  (assert ((candidate "no_one#knows.dll") = "Yes"));
  (assert ((candidate "1I563_Yes3.exe") = "No"));
  (assert ((candidate "I563_Yes3.txtt") = "No"));
  (assert ((candidate "final..txt") = "No"));
  (assert ((candidate "final132") = "No"));
  (assert ((candidate "_f4indsartal132.") = "No"));
  (assert ((candidate ".txt") = "No"));
  (assert ((candidate "s.") = "No"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183728
STDOUT: (empty)
STDERR: (empty)
--------------------
