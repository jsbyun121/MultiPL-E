As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 95 (R) - HumanEval_95_check_dict_case
================================================================================

PROMPT:
----------------------------------------
# Given a named list, return TRUE if all keys are strings in lower 
# case or all keys are strings in upper case, else return FALSE.
# The function should return FALSE is the given named list is empty.
# Examples:
# >>> check_dict_case(list('a' = 'apple', 'b' = 'banana'))
# TRUE
# >>> check_dict_case(list('a' = 'apple', 'A' = 'banana', 'B' = 'banana'))
# FALSE
# >>> check_dict_case(list('a' = 'apple', 8 = 'banana', 'a' = 'apple'))
# FALSE
# >>> check_dict_case(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston'))
# FALSE
# >>> check_dict_case(list('STATE' = 'NC', 'ZIP' = '12345'))
# TRUE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- check_dict_case
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'b' = 'banana')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'A' = 'banana', 'B' = 'banana')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', '5' = 'banana', 'a' = 'apple')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('STATE' = 'NC', 'ZIP' = '12345')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list('fruit' = 'Orange', 'taste' = 'Sweet')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list()), FALSE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given a named list, return TRUE if all keys are strings in lower 
# case or all keys are strings in upper case, else return FALSE.
# The function should return FALSE is the given named list is empty.
# Examples:
# >>> check_dict_case(list('a' = 'apple', 'b' = 'banana'))
# TRUE
# >>> check_dict_case(list('a' = 'apple', 'A' = 'banana', 'B' = 'banana'))
# FALSE
# >>> check_dict_case(list('a' = 'apple', 8 = 'banana', 'a' = 'apple'))
# FALSE
# >>> check_dict_case(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston'))
# FALSE
# >>> check_dict_case(list('STATE' = 'NC', 'ZIP' = '12345'))
# TRUE
check_dict_case <- function(dict) {
  # Return FALSE if the list is empty or has no names
  nm <- names(dict)
  if (is.null(nm) || length(nm) == 0) return(FALSE)
  
  # All names must consist only of alphabetic characters
  if (any(!grepl("^[A-Za-z]+$", nm))) return(FALSE)
  
  # Check if all names are lower‑case or all are upper‑case
  all_lower <- all(grepl("^[a-z]+$", nm))
  all_upper <- all(grepl("^[A-Z]+$", nm))
  
  return(all_lower || all_upper)
}
test_humaneval <- function() {
    candidate <- check_dict_case
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'b' = 'banana')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'A' = 'banana', 'B' = 'banana')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', '5' = 'banana', 'a' = 'apple')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('STATE' = 'NC', 'ZIP' = '12345')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list('fruit' = 'Orange', 'taste' = 'Sweet')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list()), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183779
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given a named list, return TRUE if all keys are strings in lower 
# case or all keys are strings in upper case, else return FALSE.
# The function should return FALSE is the given named list is empty.
# Examples:
# >>> check_dict_case(list('a' = 'apple', 'b' = 'banana'))
# TRUE
# >>> check_dict_case(list('a' = 'apple', 'A' = 'banana', 'B' = 'banana'))
# FALSE
# >>> check_dict_case(list('a' = 'apple', 8 = 'banana', 'a' = 'apple'))
# FALSE
# >>> check_dict_case(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston'))
# FALSE
# >>> check_dict_case(list('STATE' = 'NC', 'ZIP' = '12345'))
# TRUE
check_dict_case <- function(dict) {
  # Return FALSE if the list is empty or has no names
  if (length(dict) == 0 || is.null(names(dict))) {
    return(FALSE)
  }
  
  # Extract the names of the list
  key_names <- names(dict)
  
  # If any name is missing or not a string of letters, return FALSE
  if (any(is.na(key_names)) || any(!grepl("^[A-Za-z]+$", key_names))) {
    return(FALSE)
  }
  
  # Check if all names are lowercase or all are uppercase
  all_lower <- all(grepl("^[a-z]+$", key_names))
  all_upper <- all(grepl("^[A-Z]+$", key_names))
  
  return(all_lower || all_upper)
}
test_humaneval <- function() {
    candidate <- check_dict_case
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'b' = 'banana')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'A' = 'banana', 'B' = 'banana')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', '5' = 'banana', 'a' = 'apple')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('STATE' = 'NC', 'ZIP' = '12345')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list('fruit' = 'Orange', 'taste' = 'Sweet')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list()), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183779
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given a named list, return TRUE if all keys are strings in lower 
# case or all keys are strings in upper case, else return FALSE.
# The function should return FALSE is the given named list is empty.
# Examples:
# >>> check_dict_case(list('a' = 'apple', 'b' = 'banana'))
# TRUE
# >>> check_dict_case(list('a' = 'apple', 'A' = 'banana', 'B' = 'banana'))
# FALSE
# >>> check_dict_case(list('a' = 'apple', 8 = 'banana', 'a' = 'apple'))
# FALSE
# >>> check_dict_case(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston'))
# FALSE
# >>> check_dict_case(list('STATE' = 'NC', 'ZIP' = '12345'))
# TRUE
check_dict_case <- function(dict) {
  # Return FALSE if the list is empty
  if (length(dict) == 0) {
    return(FALSE)
  }

  # Get the names (keys) of the list
  keys <- names(dict)

  # If any key is missing or empty, treat as invalid
  if (is.null(keys) || any(keys == "")) {
    return(FALSE)
  }

  # Regular expressions for all‑lowercase and all‑uppercase keys
  lower_pattern <- "^[a-z]+$"
  upper_pattern <- "^[A-Z]+$"

  # Check if all keys are lower case or all keys are upper case
  all_lower <- all(grepl(lower_pattern, keys))
  all_upper <- all(grepl(upper_pattern, keys))

  # Return TRUE only if one of the conditions holds
  return(all_lower || all_upper)
}
test_humaneval <- function() {
    candidate <- check_dict_case
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'b' = 'banana')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'A' = 'banana', 'B' = 'banana')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', '5' = 'banana', 'a' = 'apple')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('STATE' = 'NC', 'ZIP' = '12345')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list('fruit' = 'Orange', 'taste' = 'Sweet')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list()), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183779
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given a named list, return TRUE if all keys are strings in lower 
# case or all keys are strings in upper case, else return FALSE.
# The function should return FALSE is the given named list is empty.
# Examples:
# >>> check_dict_case(list('a' = 'apple', 'b' = 'banana'))
# TRUE
# >>> check_dict_case(list('a' = 'apple', 'A' = 'banana', 'B' = 'banana'))
# FALSE
# >>> check_dict_case(list('a' = 'apple', 8 = 'banana', 'a' = 'apple'))
# FALSE
# >>> check_dict_case(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston'))
# FALSE
# >>> check_dict_case(list('STATE' = 'NC', 'ZIP' = '12345'))
# TRUE
check_dict_case <- function(dict) {
  # Return FALSE if the list is empty
  if (length(dict) == 0) return(FALSE)

  # Get the names of the list
  nms <- names(dict)

  # If there are no names or any name is missing, return FALSE
  if (is.null(nms) || any(is.na(nms) | nms == "")) return(FALSE)

  # Check if all names are strictly lower‑case letters
  all_lower <- all(grepl("^[a-z]+$", nms))

  # Check if all names are strictly upper‑case letters
  all_upper <- all(grepl("^[A-Z]+$", nms))

  # Return TRUE only if all are lower or all are upper
  return(all_lower || all_upper)
}
test_humaneval <- function() {
    candidate <- check_dict_case
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'b' = 'banana')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'A' = 'banana', 'B' = 'banana')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', '5' = 'banana', 'a' = 'apple')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston')), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(list('STATE' = 'NC', 'ZIP' = '12345')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list('fruit' = 'Orange', 'taste' = 'Sweet')), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(list()), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183779
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 97 (R) - HumanEval_97_multiply
================================================================================

PROMPT:
----------------------------------------
# Complete the function that takes two integers and returns 
# the product of their unit digits.
# Assume the input is always valid.
# Examples:
# >>> multiply(148, 412)
# 16
# >>> multiply(19, 28)
# 72
# >>> multiply(2020, 1851)
# 0
# >>> multiply(14, -15)
# 20

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- multiply
    stopifnot(isTRUE(all.equal(candidate(148, 412), 16)))
    stopifnot(isTRUE(all.equal(candidate(19, 28), 72)))
    stopifnot(isTRUE(all.equal(candidate(2020, 1851), 0)))
    stopifnot(isTRUE(all.equal(candidate(14, -15), 20)))
    stopifnot(isTRUE(all.equal(candidate(76, 67), 42)))
    stopifnot(isTRUE(all.equal(candidate(17, 27), 49)))
    stopifnot(isTRUE(all.equal(candidate(0, 1), 0)))
    stopifnot(isTRUE(all.equal(candidate(0, 0), 0)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Complete the function that takes two integers and returns 
# the product of their unit digits.
# Assume the input is always valid.
# Examples:
# >>> multiply(148, 412)
# 16
# >>> multiply(19, 28)
# 72
# >>> multiply(2020, 1851)
# 0
# >>> multiply(14, -15)
# 20
multiply <- function(a, b) {
  # Extract the unit digit of each number (positive remainder)
  unit_a <- abs(a) %% 10
  unit_b <- abs(b) %% 10
  
  # Return the product of the unit digits
  unit_a * unit_b
}
test_humaneval <- function() {
    candidate <- multiply
    stopifnot(isTRUE(all.equal(candidate(148, 412), 16)))
    stopifnot(isTRUE(all.equal(candidate(19, 28), 72)))
    stopifnot(isTRUE(all.equal(candidate(2020, 1851), 0)))
    stopifnot(isTRUE(all.equal(candidate(14, -15), 20)))
    stopifnot(isTRUE(all.equal(candidate(76, 67), 42)))
    stopifnot(isTRUE(all.equal(candidate(17, 27), 49)))
    stopifnot(isTRUE(all.equal(candidate(0, 1), 0)))
    stopifnot(isTRUE(all.equal(candidate(0, 0), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183780
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Complete the function that takes two integers and returns 
# the product of their unit digits.
# Assume the input is always valid.
# Examples:
# >>> multiply(148, 412)
# 16
# >>> multiply(19, 28)
# 72
# >>> multiply(2020, 1851)
# 0
# >>> multiply(14, -15)
# 20
multiply <- function(a, b) {
  # Extract the unit digit of each number (ignoring sign)
  unit_a <- abs(a) %% 10
  unit_b <- abs(b) %% 10
  
  # Return the product of the unit digits
  unit_a * unit_b
}
test_humaneval <- function() {
    candidate <- multiply
    stopifnot(isTRUE(all.equal(candidate(148, 412), 16)))
    stopifnot(isTRUE(all.equal(candidate(19, 28), 72)))
    stopifnot(isTRUE(all.equal(candidate(2020, 1851), 0)))
    stopifnot(isTRUE(all.equal(candidate(14, -15), 20)))
    stopifnot(isTRUE(all.equal(candidate(76, 67), 42)))
    stopifnot(isTRUE(all.equal(candidate(17, 27), 49)))
    stopifnot(isTRUE(all.equal(candidate(0, 1), 0)))
    stopifnot(isTRUE(all.equal(candidate(0, 0), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183780
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Complete the function that takes two integers and returns 
# the product of their unit digits.
# Assume the input is always valid.
# Examples:
# >>> multiply(148, 412)
# 16
# >>> multiply(19, 28)
# 72
# >>> multiply(2020, 1851)
# 0
# >>> multiply(14, -15)
# 20
# Complete the function that takes two integers and returns 
# the product of their unit digits.
# Assume the input is always valid.
# Examples:
# >>> multiply(148, 412)
# 16
# >>> multiply(19, 28)
# 72
# >>> multiply(2020, 1851)
# 0
# >>> multiply(14, -15)
# 20

multiply <- function(a, b) {
  # Extract the unit (ones) digit of each number.
  # Use abs() to handle negative inputs, then %% 10 for the last digit.
  unit_a <- abs(a) %% 10
  unit_b <- abs(b) %% 10
  
  # Return the product of the two unit digits.
  unit_a * unit_b
}
test_humaneval <- function() {
    candidate <- multiply
    stopifnot(isTRUE(all.equal(candidate(148, 412), 16)))
    stopifnot(isTRUE(all.equal(candidate(19, 28), 72)))
    stopifnot(isTRUE(all.equal(candidate(2020, 1851), 0)))
    stopifnot(isTRUE(all.equal(candidate(14, -15), 20)))
    stopifnot(isTRUE(all.equal(candidate(76, 67), 42)))
    stopifnot(isTRUE(all.equal(candidate(17, 27), 49)))
    stopifnot(isTRUE(all.equal(candidate(0, 1), 0)))
    stopifnot(isTRUE(all.equal(candidate(0, 0), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183780
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Complete the function that takes two integers and returns 
# the product of their unit digits.
# Assume the input is always valid.
# Examples:
# >>> multiply(148, 412)
# 16
# >>> multiply(19, 28)
# 72
# >>> multiply(2020, 1851)
# 0
# >>> multiply(14, -15)
# 20
multiply <- function(a, b) {
  # Extract the unit digits of both numbers (ignore sign)
  unit_a <- abs(a) %% 10
  unit_b <- abs(b) %% 10
  
  # Return the product of the unit digits
  unit_a * unit_b
}
test_humaneval <- function() {
    candidate <- multiply
    stopifnot(isTRUE(all.equal(candidate(148, 412), 16)))
    stopifnot(isTRUE(all.equal(candidate(19, 28), 72)))
    stopifnot(isTRUE(all.equal(candidate(2020, 1851), 0)))
    stopifnot(isTRUE(all.equal(candidate(14, -15), 20)))
    stopifnot(isTRUE(all.equal(candidate(76, 67), 42)))
    stopifnot(isTRUE(all.equal(candidate(17, 27), 49)))
    stopifnot(isTRUE(all.equal(candidate(0, 1), 0)))
    stopifnot(isTRUE(all.equal(candidate(0, 0), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183780
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 99 (R) - HumanEval_99_closest_integer
================================================================================

PROMPT:
----------------------------------------
# Create a function that takes a value (string) representing a number
# and returns the closest integer to it. If the number is equidistant
# from two integers, round it away from zero.
# Examples
# >>> closest_integer('10')
# 10
# >>> closest_integer('15.3')
# 15
# Note:
# Rounding away from zero means that if the given number is equidistant
# from two integers, the one you should return is the one that is the
# farthest from zero. For example closest_integer("14.5") should
# return 15 and closest_integer("-14.5") should return -15.

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- closest_integer
    stopifnot(isTRUE(all.equal(candidate('10'), 10)))
    stopifnot(isTRUE(all.equal(candidate('14.5'), 15)))
    stopifnot(isTRUE(all.equal(candidate('-15.5'), -16)))
    stopifnot(isTRUE(all.equal(candidate('15.3'), 15)))
    stopifnot(isTRUE(all.equal(candidate('0'), 0)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Create a function that takes a value (string) representing a number
# and returns the closest integer to it. If the number is equidistant
# from two integers, round it away from zero.
# Examples
# >>> closest_integer('10')
# 10
# >>> closest_integer('15.3')
# 15
# Note:
# Rounding away from zero means that if the given number is equidistant
# from two integers, the one you should return is the one that is the
# farthest from zero. For example closest_integer("14.5") should
# return 15 and closest_integer("-14.5") should return -15.
# Create a function that takes a value (string) representing a number
# and returns the closest integer to it. If the number is equidistant
# from two integers, round it away from zero.
# Examples
# >>> closest_integer('10')
# 10
# >>> closest_integer('15.3')
# 15
# Note:
# Rounding away from zero means that if the given number is equidistant
# from two integers, the one you should return is the one that is the
# farthest from zero. For example closest_integer("14.5") should
# return 15 and closest_integer("-14.5") should return -15.
closest_integer <- function(value) {
  # Convert the string to numeric
  num <- as.numeric(value)
  
  # If conversion failed, return NA
  if (is.na(num)) return(NA_integer_)
  
  # If the number is already an integer, just return it
  if (num == floor(num)) {
    return(as.integer(num))
  }
  
  # Compute floor and ceiling
  fl <- floor(num)
  cl <- ceiling(num)
  
  # Distances to the two nearest integers
  d_fl <- abs(num - fl)
  d_cl <- abs(cl - num)
  
  # Decide which integer is closer
  if (d_fl < d_cl) {
    return(as.integer(fl))
  } else if (d_cl < d_fl) {
    return(as.integer(cl))
  } else {
    # Tie: round away from zero
    if (num > 0) {
      return(as.integer(cl))
    } else if (num < 0) {
      return(as.integer(fl))
    } else {
      # num is exactly zero
      return(0L)
    }
  }
}
test_humaneval <- function() {
    candidate <- closest_integer
    stopifnot(isTRUE(all.equal(candidate('10'), 10)))
    stopifnot(isTRUE(all.equal(candidate('14.5'), 15)))
    stopifnot(isTRUE(all.equal(candidate('-15.5'), -16)))
    stopifnot(isTRUE(all.equal(candidate('15.3'), 15)))
    stopifnot(isTRUE(all.equal(candidate('0'), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183781
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Create a function that takes a value (string) representing a number
# and returns the closest integer to it. If the number is equidistant
# from two integers, round it away from zero.
# Examples
# >>> closest_integer('10')
# 10
# >>> closest_integer('15.3')
# 15
# Note:
# Rounding away from zero means that if the given number is equidistant
# from two integers, the one you should return is the one that is the
# farthest from zero. For example closest_integer("14.5") should
# return 15 and closest_integer("-14.5") should return -15.
closest_integer <- function(value) {
  # Convert the string to a numeric value
  num <- as.numeric(value)
  
  # Handle the case where the input is already an integer
  if (num == floor(num)) {
    return(as.integer(num))
  }
  
  # Compute the floor and ceiling integers
  lower <- floor(num)
  upper <- ceiling(num)
  
  # Distances to the nearest integers
  dist_lower <- abs(num - lower)
  dist_upper <- abs(upper - num)
  
  # Choose the closest integer
  if (dist_lower < dist_upper) {
    result <- lower
  } else if (dist_upper < dist_lower) {
    result <- upper
  } else {
    # Tie: round away from zero
    if (num >= 0) {
      result <- upper
    } else {
      result <- lower
    }
  }
  
  # Return as an integer
  return(as.integer(result))
}
test_humaneval <- function() {
    candidate <- closest_integer
    stopifnot(isTRUE(all.equal(candidate('10'), 10)))
    stopifnot(isTRUE(all.equal(candidate('14.5'), 15)))
    stopifnot(isTRUE(all.equal(candidate('-15.5'), -16)))
    stopifnot(isTRUE(all.equal(candidate('15.3'), 15)))
    stopifnot(isTRUE(all.equal(candidate('0'), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183781
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Create a function that takes a value (string) representing a number
# and returns the closest integer to it. If the number is equidistant
# from two integers, round it away from zero.
# Examples
# >>> closest_integer('10')
# 10
# >>> closest_integer('15.3')
# 15
# Note:
# Rounding away from zero means that if the given number is equidistant
# from two integers, the one you should return is the one that is the
# farthest from zero. For example closest_integer("14.5") should
# return 15 and closest_integer("-14.5") should return -15.
closest_integer <- function(value) {
  # Convert the input string to a numeric value
  num <- as.numeric(value)
  
  # Handle NA or non-numeric input
  if (is.na(num)) {
    stop("Input must be a numeric string.")
  }
  
  # Determine the two nearest integers
  lower <- floor(num)
  upper <- ceiling(num)
  
  # Compute absolute distances to each integer
  diff_lower <- abs(num - lower)
  diff_upper <- abs(num - upper)
  
  # Decide which integer to return
  if (diff_lower < diff_upper) {
    result <- lower
  } else if (diff_lower > diff_upper) {
    result <- upper
  } else {  # equidistant case
    # Round away from zero
    if (num >= 0) {
      result <- upper
    } else {
      result <- lower
    }
  }
  
  # Return as an integer
  as.integer(result)
}
test_humaneval <- function() {
    candidate <- closest_integer
    stopifnot(isTRUE(all.equal(candidate('10'), 10)))
    stopifnot(isTRUE(all.equal(candidate('14.5'), 15)))
    stopifnot(isTRUE(all.equal(candidate('-15.5'), -16)))
    stopifnot(isTRUE(all.equal(candidate('15.3'), 15)))
    stopifnot(isTRUE(all.equal(candidate('0'), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183781
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Create a function that takes a value (string) representing a number
# and returns the closest integer to it. If the number is equidistant
# from two integers, round it away from zero.
# Examples
# >>> closest_integer('10')
# 10
# >>> closest_integer('15.3')
# 15
# Note:
# Rounding away from zero means that if the given number is equidistant
# from two integers, the one you should return is the one that is the
# farthest from zero. For example closest_integer("14.5") should
# return 15 and closest_integer("-14.5") should return -15.
# Create a function that takes a value (string) representing a number
# and returns the closest integer to it. If the number is equidistant
# from two integers, round it away from zero.
# Examples
# >>> closest_integer('10')
# 10
# >>> closest_integer('15.3')
# 15
# Note:
# Rounding away from zero means that if the given number is equidistant
# from two integers, the one you should return is the one that is the
# farthest from zero. For example closest_integer("14.5") should
# return 15 and closest_integer("-14.5") should return -15.

closest_integer <- function(value) {
  # Convert the string to numeric
  num <- as.numeric(value)
  if (is.na(num)) {
    stop("Input must be a numeric string.")
  }
  
  # Compute floor and ceiling
  lo <- floor(num)
  hi <- ceiling(num)
  
  # Distances to the nearest integers
  d_lo <- abs(num - lo)
  d_hi <- abs(hi - num)
  
  # Decide which integer to return
  if (d_lo < d_hi) {
    result <- lo
  } else if (d_hi < d_lo) {
    result <- hi
  } else {  # tie – round away from zero
    if (num >= 0) {
      result <- hi
    } else {
      result <- lo
    }
  }
  
  # Return as integer
  as.integer(result)
}
test_humaneval <- function() {
    candidate <- closest_integer
    stopifnot(isTRUE(all.equal(candidate('10'), 10)))
    stopifnot(isTRUE(all.equal(candidate('14.5'), 15)))
    stopifnot(isTRUE(all.equal(candidate('-15.5'), -16)))
    stopifnot(isTRUE(all.equal(candidate('15.3'), 15)))
    stopifnot(isTRUE(all.equal(candidate('0'), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183781
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 100 (R) - HumanEval_100_make_a_pile
================================================================================

PROMPT:
----------------------------------------
# Given a positive integer n, you have to make a pile of n levels of stones.
# The first level has n stones.
# The number of stones in the next level is:
#     - the next odd number if n is odd.
#     - the next even number if n is even.
# Return the number of stones in each level in a list, where element at index
# i represents the number of stones in the level (i+1).
# Examples:
# >>> make_a_pile(3)
# c(3, 5, 7)

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- make_a_pile
    stopifnot(isTRUE(all.equal(candidate(3), c(3, 5, 7))))
    stopifnot(isTRUE(all.equal(candidate(4), c(4, 6, 8, 10))))
    stopifnot(isTRUE(all.equal(candidate(5), c(5, 7, 9, 11, 13))))
    stopifnot(isTRUE(all.equal(candidate(6), c(6, 8, 10, 12, 14, 16))))
    stopifnot(isTRUE(all.equal(candidate(8), c(8, 10, 12, 14, 16, 18, 20, 22))))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given a positive integer n, you have to make a pile of n levels of stones.
# The first level has n stones.
# The number of stones in the next level is:
#     - the next odd number if n is odd.
#     - the next even number if n is even.
# Return the number of stones in each level in a list, where element at index
# i represents the number of stones in the level (i+1).
# Examples:
# >>> make_a_pile(3)
# c(3, 5, 7)
make_a_pile <- function(n) {
  # Ensure n is a positive integer
  if (!is.numeric(n) || length(n) != 1 || n <= 0 || n != floor(n)) {
    stop("n must be a positive integer")
  }
  
  # Generate the sequence: start at n, increment by 2, length n
  seq(n, by = 2, length.out = n)
}
test_humaneval <- function() {
    candidate <- make_a_pile
    stopifnot(isTRUE(all.equal(candidate(3), c(3, 5, 7))))
    stopifnot(isTRUE(all.equal(candidate(4), c(4, 6, 8, 10))))
    stopifnot(isTRUE(all.equal(candidate(5), c(5, 7, 9, 11, 13))))
    stopifnot(isTRUE(all.equal(candidate(6), c(6, 8, 10, 12, 14, 16))))
    stopifnot(isTRUE(all.equal(candidate(8), c(8, 10, 12, 14, 16, 18, 20, 22))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183781
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given a positive integer n, you have to make a pile of n levels of stones.
# The first level has n stones.
# The number of stones in the next level is:
#     - the next odd number if n is odd.
#     - the next even number if n is even.
# Return the number of stones in each level in a list, where element at index
# i represents the number of stones in the level (i+1).
# Examples:
# >>> make_a_pile(3)
# c(3, 5, 7)
make_a_pile <- function(n) {
  # Basic sanity check
  if (length(n) != 1 || !is.numeric(n) || n <= 0 || n != floor(n)) {
    stop("n must be a positive integer")
  }
  
  # Generate the sequence: start at n, step by 2, and take n elements
  seq(n, by = 2, length.out = n)
}
test_humaneval <- function() {
    candidate <- make_a_pile
    stopifnot(isTRUE(all.equal(candidate(3), c(3, 5, 7))))
    stopifnot(isTRUE(all.equal(candidate(4), c(4, 6, 8, 10))))
    stopifnot(isTRUE(all.equal(candidate(5), c(5, 7, 9, 11, 13))))
    stopifnot(isTRUE(all.equal(candidate(6), c(6, 8, 10, 12, 14, 16))))
    stopifnot(isTRUE(all.equal(candidate(8), c(8, 10, 12, 14, 16, 18, 20, 22))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183781
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given a positive integer n, you have to make a pile of n levels of stones.
# The first level has n stones.
# The number of stones in the next level is:
#     - the next odd number if n is odd.
#     - the next even number if n is even.
# Return the number of stones in each level in a list, where element at index
# i represents the number of stones in the level (i+1).
# Examples:
# >>> make_a_pile(3)
# c(3, 5, 7)
make_a_pile <- function(n) {
  # The pile starts with n stones and each subsequent level
  # adds the next number of the same parity (odd if n is odd,
  # even if n is even). This is simply a sequence starting at n
  # with step size 2 and length n.
  seq(from = n, by = 2, length.out = n)
}
test_humaneval <- function() {
    candidate <- make_a_pile
    stopifnot(isTRUE(all.equal(candidate(3), c(3, 5, 7))))
    stopifnot(isTRUE(all.equal(candidate(4), c(4, 6, 8, 10))))
    stopifnot(isTRUE(all.equal(candidate(5), c(5, 7, 9, 11, 13))))
    stopifnot(isTRUE(all.equal(candidate(6), c(6, 8, 10, 12, 14, 16))))
    stopifnot(isTRUE(all.equal(candidate(8), c(8, 10, 12, 14, 16, 18, 20, 22))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183781
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given a positive integer n, you have to make a pile of n levels of stones.
# The first level has n stones.
# The number of stones in the next level is:
#     - the next odd number if n is odd.
#     - the next even number if n is even.
# Return the number of stones in each level in a list, where element at index
# i represents the number of stones in the level (i+1).
# Examples:
# >>> make_a_pile(3)
# c(3, 5, 7)
make_a_pile <- function(n) {
  # Validate input
  if (!is.numeric(n) || length(n) != 1 || n <= 0 || n != floor(n)) {
    stop("n must be a positive integer")
  }
  
  # Generate the sequence: start at n, step by 2, length n
  seq(n, by = 2, length.out = n)
}
test_humaneval <- function() {
    candidate <- make_a_pile
    stopifnot(isTRUE(all.equal(candidate(3), c(3, 5, 7))))
    stopifnot(isTRUE(all.equal(candidate(4), c(4, 6, 8, 10))))
    stopifnot(isTRUE(all.equal(candidate(5), c(5, 7, 9, 11, 13))))
    stopifnot(isTRUE(all.equal(candidate(6), c(6, 8, 10, 12, 14, 16))))
    stopifnot(isTRUE(all.equal(candidate(8), c(8, 10, 12, 14, 16, 18, 20, 22))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183781
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 102 (R) - HumanEval_102_choose_num
================================================================================

PROMPT:
----------------------------------------
# This function takes two positive numbers x and y and returns the
# biggest even integer number that is in the range [x, y] inclusive. If 
# there's no such number, then the function should return -1.
# For example:
# >>> choose_num(12, 15)
# 14
# >>> choose_num(13, 12)
# -1

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- choose_num
    stopifnot(isTRUE(all.equal(candidate(12, 15), 14)))
    stopifnot(isTRUE(all.equal(candidate(13, 12), -1)))
    stopifnot(isTRUE(all.equal(candidate(33, 12354), 12354)))
    stopifnot(isTRUE(all.equal(candidate(5234, 5233), -1)))
    stopifnot(isTRUE(all.equal(candidate(6, 29), 28)))
    stopifnot(isTRUE(all.equal(candidate(27, 10), -1)))
    stopifnot(isTRUE(all.equal(candidate(7, 7), -1)))
    stopifnot(isTRUE(all.equal(candidate(546, 546), 546)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# This function takes two positive numbers x and y and returns the
# biggest even integer number that is in the range [x, y] inclusive. If 
# there's no such number, then the function should return -1.
# For example:
# >>> choose_num(12, 15)
# 14
# >>> choose_num(13, 12)
# -1
# This function takes two positive numbers x and y and returns the
# biggest even integer number that is in the range [x, y] inclusive. If 
# there's no such number, then the function should return -1.
# For example:
# >>> choose_num(12, 15)
# 14
# >>> choose_num(13, 12)
# -1
choose_num <- function(x, y) {
  # If the lower bound is greater than the upper bound, no number can be chosen.
  if (x > y) {
    return(-1)
  }

  # Find the largest even integer that is <= y.
  # If y is odd, subtract 1 to make it even.
  max_even <- if (y %% 2 == 0) y else y - 1

  # If that even number is still within the interval, return it.
  # Otherwise, there is no even integer in the range.
  if (max_even >= x) {
    return(max_even)
  } else {
    return(-1)
  }
}
test_humaneval <- function() {
    candidate <- choose_num
    stopifnot(isTRUE(all.equal(candidate(12, 15), 14)))
    stopifnot(isTRUE(all.equal(candidate(13, 12), -1)))
    stopifnot(isTRUE(all.equal(candidate(33, 12354), 12354)))
    stopifnot(isTRUE(all.equal(candidate(5234, 5233), -1)))
    stopifnot(isTRUE(all.equal(candidate(6, 29), 28)))
    stopifnot(isTRUE(all.equal(candidate(27, 10), -1)))
    stopifnot(isTRUE(all.equal(candidate(7, 7), -1)))
    stopifnot(isTRUE(all.equal(candidate(546, 546), 546)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183782
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# This function takes two positive numbers x and y and returns the
# biggest even integer number that is in the range [x, y] inclusive. If 
# there's no such number, then the function should return -1.
# For example:
# >>> choose_num(12, 15)
# 14
# >>> choose_num(13, 12)
# -1
# This function takes two positive numbers x and y and returns the
# biggest even integer number that is in the range [x, y] inclusive.
# If there's no such number, then the function should return -1.
# For example:
# >>> choose_num(12, 15)
# 14
# >>> choose_num(13, 12)
# -1
choose_num <- function(x, y) {
  # If the lower bound is greater than the upper bound, no range exists
  if (x > y) {
    return(-1)
  }
  
  # Determine the smallest integer >= x and the largest integer <= y
  start <- ceiling(x)
  end   <- floor(y)
  
  # If there are no integers in the range, return -1
  if (start > end) {
    return(-1)
  }
  
  # Find the largest even integer <= end
  candidate <- if (end %% 2 == 0) {
    end
  } else {
    end - 1
  }
  
  # Check if the candidate is within the valid range
  if (candidate >= start) {
    return(candidate)
  } else {
    return(-1)
  }
}
test_humaneval <- function() {
    candidate <- choose_num
    stopifnot(isTRUE(all.equal(candidate(12, 15), 14)))
    stopifnot(isTRUE(all.equal(candidate(13, 12), -1)))
    stopifnot(isTRUE(all.equal(candidate(33, 12354), 12354)))
    stopifnot(isTRUE(all.equal(candidate(5234, 5233), -1)))
    stopifnot(isTRUE(all.equal(candidate(6, 29), 28)))
    stopifnot(isTRUE(all.equal(candidate(27, 10), -1)))
    stopifnot(isTRUE(all.equal(candidate(7, 7), -1)))
    stopifnot(isTRUE(all.equal(candidate(546, 546), 546)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183782
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# This function takes two positive numbers x and y and returns the
# biggest even integer number that is in the range [x, y] inclusive. If 
# there's no such number, then the function should return -1.
# For example:
# >>> choose_num(12, 15)
# 14
# >>> choose_num(13, 12)
# -1
choose_num <- function(x, y) {
  # If the interval is invalid, return -1
  if (x > y) return(-1)
  
  # Find the largest integer not exceeding y
  yi <- floor(y)
  
  # Adjust to the nearest even integer ≤ y
  if (yi %% 2 != 0) yi <- yi - 1
  
  # If this even integer lies within [x, y], return it; otherwise, no such number
  if (yi >= x) {
    return(yi)
  } else {
    return(-1)
  }
}
test_humaneval <- function() {
    candidate <- choose_num
    stopifnot(isTRUE(all.equal(candidate(12, 15), 14)))
    stopifnot(isTRUE(all.equal(candidate(13, 12), -1)))
    stopifnot(isTRUE(all.equal(candidate(33, 12354), 12354)))
    stopifnot(isTRUE(all.equal(candidate(5234, 5233), -1)))
    stopifnot(isTRUE(all.equal(candidate(6, 29), 28)))
    stopifnot(isTRUE(all.equal(candidate(27, 10), -1)))
    stopifnot(isTRUE(all.equal(candidate(7, 7), -1)))
    stopifnot(isTRUE(all.equal(candidate(546, 546), 546)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183782
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# This function takes two positive numbers x and y and returns the
# biggest even integer number that is in the range [x, y] inclusive. If 
# there's no such number, then the function should return -1.
# For example:
# >>> choose_num(12, 15)
# 14
# >>> choose_num(13, 12)
# -1
choose_num <- function(x, y) {
  # If the range is invalid, return -1
  if (x > y) {
    return(-1)
  }
  
  # Find the largest even integer that is <= y
  candidate <- floor(y / 2) * 2
  
  # Check if this candidate lies within the range [x, y]
  if (candidate >= x) {
    return(candidate)
  } else {
    return(-1)
  }
}
test_humaneval <- function() {
    candidate <- choose_num
    stopifnot(isTRUE(all.equal(candidate(12, 15), 14)))
    stopifnot(isTRUE(all.equal(candidate(13, 12), -1)))
    stopifnot(isTRUE(all.equal(candidate(33, 12354), 12354)))
    stopifnot(isTRUE(all.equal(candidate(5234, 5233), -1)))
    stopifnot(isTRUE(all.equal(candidate(6, 29), 28)))
    stopifnot(isTRUE(all.equal(candidate(27, 10), -1)))
    stopifnot(isTRUE(all.equal(candidate(7, 7), -1)))
    stopifnot(isTRUE(all.equal(candidate(546, 546), 546)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183782
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 106 (R) - HumanEval_106_f
================================================================================

PROMPT:
----------------------------------------
# Implement the function f that takes n as a parameter,
# and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
# or the sum of numbers from 1 to i otherwise.
# i starts from 1.
# the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
# Example:
# >>> f(5)
# c(1, 2, 6, 24, 15)

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- f
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 2, 6, 24, 15))))
    stopifnot(isTRUE(all.equal(candidate(7), c(1, 2, 6, 24, 15, 720, 28))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1))))
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2, 6))))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Implement the function f that takes n as a parameter,
# and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
# or the sum of numbers from 1 to i otherwise.
# i starts from 1.
# the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
# Example:
# >>> f(5)
# c(1, 2, 6, 24, 15)
# Implement the function f that takes n as a parameter,
# and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
# or the sum of numbers from 1 to i otherwise.
# i starts from 1.
# the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
# Example:
# >>> f(5)
# c(1, 2, 6, 24, 15)
f <- function(n) {
  if (n <= 0) return(numeric(0))
  i <- seq_len(n)
  # For odd i: sum 1..i = i*(i+1)/2
  # For even i: factorial(i)
  result <- ifelse(i %% 2 == 0,
                   factorial(i),
                   i * (i + 1) / 2)
  return(result)
}
test_humaneval <- function() {
    candidate <- f
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 2, 6, 24, 15))))
    stopifnot(isTRUE(all.equal(candidate(7), c(1, 2, 6, 24, 15, 720, 28))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1))))
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2, 6))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183784
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Implement the function f that takes n as a parameter,
# and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
# or the sum of numbers from 1 to i otherwise.
# i starts from 1.
# the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
# Example:
# >>> f(5)
# c(1, 2, 6, 24, 15)
# Implement the function f that takes n as a parameter,
# and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
# or the sum of numbers from 1 to i otherwise.
# i starts from 1.
# the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
# Example:
# >>> f(5)
# c(1, 2, 6, 24, 15)
f <- function(n) {
  # Pre‑allocate a numeric vector of length n
  res <- numeric(n)
  
  # Loop over all indices 1..n
  for (i in seq_len(n)) {
    if (i %% 2 == 0) {          # even index → factorial
      res[i] <- prod(1:i)
    } else {                    # odd index → sum 1..i
      res[i] <- sum(1:i)
    }
  }
  
  # Return the resulting vector
  res
}
test_humaneval <- function() {
    candidate <- f
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 2, 6, 24, 15))))
    stopifnot(isTRUE(all.equal(candidate(7), c(1, 2, 6, 24, 15, 720, 28))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1))))
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2, 6))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183784
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Implement the function f that takes n as a parameter,
# and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
# or the sum of numbers from 1 to i otherwise.
# i starts from 1.
# the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
# Example:
# >>> f(5)
# c(1, 2, 6, 24, 15)
f <- function(n) {
  # Create a vector to hold the results
  result <- integer(n)
  
  # Loop over each index from 1 to n
  for (i in seq_len(n)) {
    if (i %% 2 == 0) {
      # Even index: factorial of i
      result[i] <- factorial(i)
    } else {
      # Odd index: sum of numbers from 1 to i
      result[i] <- sum(1:i)
    }
  }
  
  # Return the computed vector
  result
}
test_humaneval <- function() {
    candidate <- f
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 2, 6, 24, 15))))
    stopifnot(isTRUE(all.equal(candidate(7), c(1, 2, 6, 24, 15, 720, 28))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1))))
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2, 6))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183784
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Implement the function f that takes n as a parameter,
# and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
# or the sum of numbers from 1 to i otherwise.
# i starts from 1.
# the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
# Example:
# >>> f(5)
# c(1, 2, 6, 24, 15)
# Implement the function f that takes n as a parameter,
# and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
# or the sum of numbers from 1 to i otherwise.
# i starts from 1.
# the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
# Example:
# >>> f(5)
# c(1, 2, 6, 24, 15)
f <- function(n) {
  if (n <= 0) return(numeric(0))          # handle non‑positive input
  
  res <- numeric(n)                       # preallocate result vector
  
  for (i in seq_len(n)) {
    if (i %% 2 == 0) {                    # even index → factorial
      res[i] <- prod(seq_len(i))          # factorial of i
    } else {                              # odd index → sum
      res[i] <- sum(seq_len(i))           # sum from 1 to i
    }
  }
  
  res
}
test_humaneval <- function() {
    candidate <- f
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 2, 6, 24, 15))))
    stopifnot(isTRUE(all.equal(candidate(7), c(1, 2, 6, 24, 15, 720, 28))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1))))
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2, 6))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183784
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 108 (R) - HumanEval_108_count_nums
================================================================================

PROMPT:
----------------------------------------
# Write a function count_nums which takes a vector of integers and returns
# the number of elements which has a sum of digits > 0.
# If a number is negative, then its first signed digit will be negative:
# e.g. -123 has signed digits -1, 2, and 3.
# >>> count_nums(c())
# 0
# >>> count_nums(c(-1, 11, -11))
# 1
# >>> count_nums(c(1, 1, 2))
# 3

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- count_nums
    stopifnot(isTRUE(all.equal(candidate(c()), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 2, -2, 3, 4, 5)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 9, -6, 0, 1, 5)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 100, 98, -7, 1, -1)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(12, 23, 34, -45, -56, 0)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Write a function count_nums which takes a vector of integers and returns
# the number of elements which has a sum of digits > 0.
# If a number is negative, then its first signed digit will be negative:
# e.g. -123 has signed digits -1, 2, and 3.
# >>> count_nums(c())
# 0
# >>> count_nums(c(-1, 11, -11))
# 1
# >>> count_nums(c(1, 1, 2))
# 3
count_nums <- function(arr) {
  # Handle empty input
  if (length(arr) == 0) return(0)
  
  # Helper to compute digit sum with signed first digit
  digit_sum <- function(x) {
    s <- as.character(x)
    if (substr(s, 1, 1) == "-") {          # negative number
      digits <- as.numeric(unlist(strsplit(sub("^-", "", s), "")))
      if (length(digits) > 0) digits[1] <- -digits[1]
    } else {                               # non‑negative number
      digits <- as.numeric(unlist(strsplit(s, "")))
    }
    sum(digits)
  }
  
  # Apply to each element and count those with sum > 0
  sum(sapply(arr, digit_sum) > 0)
}
test_humaneval <- function() {
    candidate <- count_nums
    stopifnot(isTRUE(all.equal(candidate(c()), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 2, -2, 3, 4, 5)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 9, -6, 0, 1, 5)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 100, 98, -7, 1, -1)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(12, 23, 34, -45, -56, 0)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183785
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Write a function count_nums which takes a vector of integers and returns
# the number of elements which has a sum of digits > 0.
# If a number is negative, then its first signed digit will be negative:
# e.g. -123 has signed digits -1, 2, and 3.
# >>> count_nums(c())
# 0
# >>> count_nums(c(-1, 11, -11))
# 1
# >>> count_nums(c(1, 1, 2))
# 3
# Write a function count_nums which takes a vector of integers and returns
# the number of elements which has a sum of digits > 0.
# If a number is negative, then its first signed digit will be negative:
# e.g. -123 has signed digits -1, 2, and 3.
# >>> count_nums(c())
# 0
# >>> count_nums(c(-1, 11, -11))
# 1
# >>> count_nums(c(1, 1, 2))
# 3
count_nums <- function(arr) {
  # Helper function to compute the signed sum of digits for a single number
  signed_digit_sum <- function(x) {
    # Handle zero explicitly
    if (x == 0) return(0)
    # Determine sign of the first digit
    is_neg <- x < 0
    abs_x <- abs(x)
    # Extract digits as integers
    digits <- as.integer(strsplit(as.character(abs_x), "")[[1]])
    # Sum digits with sign on the first digit if negative
    if (is_neg) {
      # First digit is negative
      sum(digits[-1]) - digits[1]
    } else {
      sum(digits)
    }
  }
  
  # Apply to all elements and count those > 0
  sum(sapply(arr, signed_digit_sum) > 0)
}
test_humaneval <- function() {
    candidate <- count_nums
    stopifnot(isTRUE(all.equal(candidate(c()), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 2, -2, 3, 4, 5)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 9, -6, 0, 1, 5)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 100, 98, -7, 1, -1)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(12, 23, 34, -45, -56, 0)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183785
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Write a function count_nums which takes a vector of integers and returns
# the number of elements which has a sum of digits > 0.
# If a number is negative, then its first signed digit will be negative:
# e.g. -123 has signed digits -1, 2, and 3.
# >>> count_nums(c())
# 0
# >>> count_nums(c(-1, 11, -11))
# 1
# >>> count_nums(c(1, 1, 2))
# 3
# Write a function count_nums which takes a vector of integers and returns
# the number of elements which has a sum of digits > 0.
# If a number is negative, then its first signed digit will be negative:
# e.g. -123 has signed digits -1, 2, and 3.
# >>> count_nums(c())
# 0
# >>> count_nums(c(-1, 11, -11))
# 1
# >>> count_nums(c(1, 1, 2))
# 3
count_nums <- function(arr) {
  # Empty vector → 0
  if (length(arr) == 0) return(0)
  
  # Helper to compute the signed sum of digits for a single number
  digit_sum <- function(x) {
    # Split number into characters
    chars <- strsplit(as.character(x), "")[[1]]
    
    # Handle negative numbers: first digit is signed negative
    if (chars[1] == "-") {
      # The first digit is the second character
      first_digit <- as.numeric(chars[2])
      # Remaining digits (if any)
      if (length(chars) > 2) {
        rest_digits <- as.numeric(chars[-c(1, 2)])
      } else {
        rest_digits <- numeric(0)
      }
      sum_val <- -first_digit + sum(rest_digits)
    } else {
      sum_val <- sum(as.numeric(chars))
    }
    sum_val
  }
  
  # Count how many elements have a positive digit sum
  sum(sapply(arr, function(x) digit_sum(x) > 0))
}
test_humaneval <- function() {
    candidate <- count_nums
    stopifnot(isTRUE(all.equal(candidate(c()), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 2, -2, 3, 4, 5)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 9, -6, 0, 1, 5)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 100, 98, -7, 1, -1)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(12, 23, 34, -45, -56, 0)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183785
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Write a function count_nums which takes a vector of integers and returns
# the number of elements which has a sum of digits > 0.
# If a number is negative, then its first signed digit will be negative:
# e.g. -123 has signed digits -1, 2, and 3.
# >>> count_nums(c())
# 0
# >>> count_nums(c(-1, 11, -11))
# 1
# >>> count_nums(c(1, 1, 2))
# 3
# Write a function count_nums which takes a vector of integers and returns
# the number of elements which has a sum of digits > 0.
# If a number is negative, then its first signed digit will be negative:
# e.g. -123 has signed digits -1, 2, and 3.
# >>> count_nums(c())
# 0
# >>> count_nums(c(-1, 11, -11))
# 1
# >>> count_nums(c(1, 1, 2))
# 3
count_nums <- function(arr) {
  if (length(arr) == 0) return(0)

  sum(
    sapply(arr, function(n) {
      if (n == 0) return(FALSE)

      # Get the absolute value's digits as integers
      digits <- as.integer(strsplit(as.character(abs(n)), "")[[1]])

      # If the original number was negative, make the first digit negative
      if (n < 0) digits[1] <- -digits[1]

      # Return TRUE if the sum of signed digits is > 0
      sum(digits) > 0
    })
  )
}
test_humaneval <- function() {
    candidate <- count_nums
    stopifnot(isTRUE(all.equal(candidate(c()), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 2, -2, 3, 4, 5)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 9, -6, 0, 1, 5)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 100, 98, -7, 1, -1)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c(12, 23, 34, -45, -56, 0)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183785
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 109 (R) - HumanEval_109_move_one_ball
================================================================================

PROMPT:
----------------------------------------
# We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The
# numbers in the vector will be randomly ordered. Your task is to determine if
# it is possible to get a vector sorted in non-decreasing order by performing 
# the following operation on the given vector:
#     You are allowed to perform right shift operation any number of times.
# One right shift operation means shifting all elements of the vector by one
# position in the right direction. The last element of the vector will be moved to
# the starting position in the vector i.e. 0th index. 
# If it is possible to obtain the sorted vector by performing the above operation
# then return TRUE else return FALSE.
# If the given vector is empty then return TRUE.
# Note: The given list is guaranteed to have unique elements.
# For Example:
# >>> move_one_ball(c(3, 4, 5, 1, 2))
# TRUE
# Explanation: By performin 2 right shift operations, non-decreasing order can
#              be achieved for the given vector.
# >>> move_one_ball(c(3, 5, 4, 1, 2))
# FALSE
# Explanation:It is not possible to get non-decreasing order for the given
#             vector by performing any number of right shift operations.

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- move_one_ball
    stopifnot(isTRUE(all.equal(candidate(c(3, 4, 5, 1, 2)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 10, 1, 2)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 1, 2)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 4, 1, 2)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The
# numbers in the vector will be randomly ordered. Your task is to determine if
# it is possible to get a vector sorted in non-decreasing order by performing 
# the following operation on the given vector:
#     You are allowed to perform right shift operation any number of times.
# One right shift operation means shifting all elements of the vector by one
# position in the right direction. The last element of the vector will be moved to
# the starting position in the vector i.e. 0th index. 
# If it is possible to obtain the sorted vector by performing the above operation
# then return TRUE else return FALSE.
# If the given vector is empty then return TRUE.
# Note: The given list is guaranteed to have unique elements.
# For Example:
# >>> move_one_ball(c(3, 4, 5, 1, 2))
# TRUE
# Explanation: By performin 2 right shift operations, non-decreasing order can
#              be achieved for the given vector.
# >>> move_one_ball(c(3, 5, 4, 1, 2))
# FALSE
# Explanation:It is not possible to get non-decreasing order for the given
#             vector by performing any number of right shift operations.
move_one_ball <- function(arr) {
  # Empty vector is considered sorted
  if (length(arr) == 0) return(TRUE)
  
  # Find the position of the minimum element
  min_idx <- which.min(arr)
  
  # Rotate the vector so that the minimum element comes first
  rotated <- c(arr[min_idx:length(arr)], arr[1:(min_idx - 1)])
  
  # Check if the rotated vector is non‑decreasing
  all(diff(rotated) >= 0)
}
test_humaneval <- function() {
    candidate <- move_one_ball
    stopifnot(isTRUE(all.equal(candidate(c(3, 4, 5, 1, 2)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 10, 1, 2)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 1, 2)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 4, 1, 2)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183786
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The
# numbers in the vector will be randomly ordered. Your task is to determine if
# it is possible to get a vector sorted in non-decreasing order by performing 
# the following operation on the given vector:
#     You are allowed to perform right shift operation any number of times.
# One right shift operation means shifting all elements of the vector by one
# position in the right direction. The last element of the vector will be moved to
# the starting position in the vector i.e. 0th index. 
# If it is possible to obtain the sorted vector by performing the above operation
# then return TRUE else return FALSE.
# If the given vector is empty then return TRUE.
# Note: The given list is guaranteed to have unique elements.
# For Example:
# >>> move_one_ball(c(3, 4, 5, 1, 2))
# TRUE
# Explanation: By performin 2 right shift operations, non-decreasing order can
#              be achieved for the given vector.
# >>> move_one_ball(c(3, 5, 4, 1, 2))
# FALSE
# Explanation:It is not possible to get non-decreasing order for the given
#             vector by performing any number of right shift operations.
move_one_ball <- function(arr) {
  # Empty vector is considered sorted
  if (length(arr) == 0) return(TRUE)
  
  n <- length(arr)
  
  # Count the number of "descents" where an element is greater than the next one
  # (cyclically, so the last element is compared with the first).
  descents <- sum(arr[1:(n-1)] > arr[2:n]) + (arr[n] > arr[1])
  
  # The array can be sorted by right shifts iff it has at most one descent
  return(descents <= 1)
}
test_humaneval <- function() {
    candidate <- move_one_ball
    stopifnot(isTRUE(all.equal(candidate(c(3, 4, 5, 1, 2)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 10, 1, 2)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 1, 2)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 4, 1, 2)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183786
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The
# numbers in the vector will be randomly ordered. Your task is to determine if
# it is possible to get a vector sorted in non-decreasing order by performing 
# the following operation on the given vector:
#     You are allowed to perform right shift operation any number of times.
# One right shift operation means shifting all elements of the vector by one
# position in the right direction. The last element of the vector will be moved to
# the starting position in the vector i.e. 0th index. 
# If it is possible to obtain the sorted vector by performing the above operation
# then return TRUE else return FALSE.
# If the given vector is empty then return TRUE.
# Note: The given list is guaranteed to have unique elements.
# For Example:
# >>> move_one_ball(c(3, 4, 5, 1, 2))
# TRUE
# Explanation: By performin 2 right shift operations, non-decreasing order can
#              be achieved for the given vector.
# >>> move_one_ball(c(3, 5, 4, 1, 2))
# FALSE
# Explanation:It is not possible to get non-decreasing order for the given
#             vector by performing any number of right shift operations.
move_one_ball <- function(arr) {
  # Empty vector is considered sorted
  if (length(arr) == 0) return(TRUE)
  
  n <- length(arr)
  break_count <- 0
  
  # Check for breaks in the linear part
  for (i in seq_len(n - 1)) {
    if (arr[i] > arr[i + 1]) {
      break_count <- break_count + 1
    }
  }
  
  # Check the wrap‑around break (last element to first)
  if (arr[n] > arr[1]) {
    break_count <- break_count + 1
  }
  
  # If there are 0 or 1 break points, the array is a rotation of a sorted vector
  return(break_count <= 1)
}
test_humaneval <- function() {
    candidate <- move_one_ball
    stopifnot(isTRUE(all.equal(candidate(c(3, 4, 5, 1, 2)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 10, 1, 2)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 1, 2)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 4, 1, 2)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183786
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The
# numbers in the vector will be randomly ordered. Your task is to determine if
# it is possible to get a vector sorted in non-decreasing order by performing 
# the following operation on the given vector:
#     You are allowed to perform right shift operation any number of times.
# One right shift operation means shifting all elements of the vector by one
# position in the right direction. The last element of the vector will be moved to
# the starting position in the vector i.e. 0th index. 
# If it is possible to obtain the sorted vector by performing the above operation
# then return TRUE else return FALSE.
# If the given vector is empty then return TRUE.
# Note: The given list is guaranteed to have unique elements.
# For Example:
# >>> move_one_ball(c(3, 4, 5, 1, 2))
# TRUE
# Explanation: By performin 2 right shift operations, non-decreasing order can
#              be achieved for the given vector.
# >>> move_one_ball(c(3, 5, 4, 1, 2))
# FALSE
# Explanation:It is not possible to get non-decreasing order for the given
#             vector by performing any number of right shift operations.
move_one_ball <- function(arr) {
  # Empty vector is already sorted
  if (length(arr) == 0) return(TRUE)
  
  # Sorted version of the vector
  sorted_arr <- sort(arr)
  
  # Find where the first element of the sorted vector occurs in the original
  start_idx <- match(sorted_arr[1], arr)
  
  # Rotate the original vector starting from that index
  rotated <- c(arr[start_idx:length(arr)], arr[1:(start_idx-1)])
  
  # Compare the rotated vector with the sorted one
  all(rotated == sorted_arr)
}
test_humaneval <- function() {
    candidate <- move_one_ball
    stopifnot(isTRUE(all.equal(candidate(c(3, 4, 5, 1, 2)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 10, 1, 2)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 1, 2)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 4, 1, 2)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183786
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 110 (R) - HumanEval_110_exchange
================================================================================

PROMPT:
----------------------------------------
# In this problem, you will implement a function that takes two lists of numbers,
# and determines whether it is possible to perform an exchange of elements
# between them to make lst1 a list of only even numbers.
# There is no limit on the number of exchanged elements between lst1 and lst2.
# If it is possible to exchange elements between the lst1 and lst2 to make
# all the elements of lst1 to be even, return "YES".
# Otherwise, return "NO".
# For example:
# >>> exchange(c(1, 2, 3, 4), c(1, 2, 3, 4))
# 'YES'
# >>> exchange(c(1, 2, 3, 4), c(1, 5, 3, 4))
# 'NO'
# It is assumed that the input lists will be non-empty.

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- exchange
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 2, 3, 4)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 5, 3, 4)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(2, 1, 4, 3)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 4)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 3)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 6, 1, 8, 9), c(3, 5, 5, 1, 1, 1)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(100, 200), c(200, 200)), 'YES')))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# In this problem, you will implement a function that takes two lists of numbers,
# and determines whether it is possible to perform an exchange of elements
# between them to make lst1 a list of only even numbers.
# There is no limit on the number of exchanged elements between lst1 and lst2.
# If it is possible to exchange elements between the lst1 and lst2 to make
# all the elements of lst1 to be even, return "YES".
# Otherwise, return "NO".
# For example:
# >>> exchange(c(1, 2, 3, 4), c(1, 2, 3, 4))
# 'YES'
# >>> exchange(c(1, 2, 3, 4), c(1, 5, 3, 4))
# 'NO'
# It is assumed that the input lists will be non-empty.
exchange <- function(lst1, lst2) {
  # Count the number of even elements in each list
  evens1 <- sum(lst1 %% 2 == 0)
  evens2 <- sum(lst2 %% 2 == 0)
  
  # Total even elements available across both lists
  total_evens <- evens1 + evens2
  
  # We can make lst1 all even if we have at least as many evens
  # as there are positions in lst1
  if (total_evens >= length(lst1)) {
    return("YES")
  } else {
    return("NO")
  }
}
test_humaneval <- function() {
    candidate <- exchange
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 2, 3, 4)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 5, 3, 4)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(2, 1, 4, 3)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 4)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 3)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 6, 1, 8, 9), c(3, 5, 5, 1, 1, 1)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(100, 200), c(200, 200)), 'YES')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183786
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# In this problem, you will implement a function that takes two lists of numbers,
# and determines whether it is possible to perform an exchange of elements
# between them to make lst1 a list of only even numbers.
# There is no limit on the number of exchanged elements between lst1 and lst2.
# If it is possible to exchange elements between the lst1 and lst2 to make
# all the elements of lst1 to be even, return "YES".
# Otherwise, return "NO".
# For example:
# >>> exchange(c(1, 2, 3, 4), c(1, 2, 3, 4))
# 'YES'
# >>> exchange(c(1, 2, 3, 4), c(1, 5, 3, 4))
# 'NO'
# It is assumed that the input lists will be non-empty.
exchange <- function(lst1, lst2) {
  # Count even numbers in each list
  even_count <- function(x) sum(x %% 2 == 0)
  
  # Total number of evens available in both lists
  total_evens <- even_count(lst1) + even_count(lst2)
  
  # We need at least as many evens as the length of lst1
  if (total_evens >= length(lst1)) {
    return("YES")
  } else {
    return("NO")
  }
}
test_humaneval <- function() {
    candidate <- exchange
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 2, 3, 4)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 5, 3, 4)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(2, 1, 4, 3)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 4)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 3)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 6, 1, 8, 9), c(3, 5, 5, 1, 1, 1)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(100, 200), c(200, 200)), 'YES')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183786
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# In this problem, you will implement a function that takes two lists of numbers,
# and determines whether it is possible to perform an exchange of elements
# between them to make lst1 a list of only even numbers.
# There is no limit on the number of exchanged elements between lst1 and lst2.
# If it is possible to exchange elements between the lst1 and lst2 to make
# all the elements of lst1 to be even, return "YES".
# Otherwise, return "NO".
# For example:
# >>> exchange(c(1, 2, 3, 4), c(1, 2, 3, 4))
# 'YES'
# >>> exchange(c(1, 2, 3, 4), c(1, 5, 3, 4))
# 'NO'
# It is assumed that the input lists will be non-empty.
exchange <- function(lst1, lst2) {
  # Count even numbers in both lists
  total_even <- sum(lst1 %% 2 == 0) + sum(lst2 %% 2 == 0)
  
  # We need at least length(lst1) even numbers to fill lst1
  if (total_even >= length(lst1)) {
    return("YES")
  } else {
    return("NO")
  }
}
test_humaneval <- function() {
    candidate <- exchange
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 2, 3, 4)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 5, 3, 4)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(2, 1, 4, 3)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 4)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 3)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 6, 1, 8, 9), c(3, 5, 5, 1, 1, 1)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(100, 200), c(200, 200)), 'YES')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183786
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# In this problem, you will implement a function that takes two lists of numbers,
# and determines whether it is possible to perform an exchange of elements
# between them to make lst1 a list of only even numbers.
# There is no limit on the number of exchanged elements between lst1 and lst2.
# If it is possible to exchange elements between the lst1 and lst2 to make
# all the elements of lst1 to be even, return "YES".
# Otherwise, return "NO".
# For example:
# >>> exchange(c(1, 2, 3, 4), c(1, 2, 3, 4))
# 'YES'
# >>> exchange(c(1, 2, 3, 4), c(1, 5, 3, 4))
# 'NO'
# It is assumed that the input lists will be non-empty.
exchange <- function(lst1, lst2) {
  # total number of elements that must end up in lst1
  n <- length(lst1)
  
  # Count how many even numbers exist in the combined lists
  total_evens <- sum((c(lst1, lst2) %% 2) == 0)
  
  # If we can pick n evens from the combined pool, the answer is YES
  if (total_evens >= n) {
    return("YES")
  } else {
    return("NO")
  }
}
test_humaneval <- function() {
    candidate <- exchange
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 2, 3, 4)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 5, 3, 4)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(2, 1, 4, 3)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 4)), 'YES')))
    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 3)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 6, 1, 8, 9), c(3, 5, 5, 1, 1, 1)), 'NO')))
    stopifnot(isTRUE(all.equal(candidate(c(100, 200), c(200, 200)), 'YES')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183786
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 118 (R) - HumanEval_118_get_closest_vowel
================================================================================

PROMPT:
----------------------------------------
# You are given a word. Your task is to find the closest vowel that stands between 
# two consonants from the right side of the word (case sensitive).
# Vowels in the beginning and ending doesn't count. Return empty string if you didn't
# find any vowel met the above condition. 
# You may assume that the given string contains English letter only.
# Example:
# >>> get_closest_vowel('yogurt')
# 'u'
# >>> get_closest_vowel('FULL')
# 'U'
# >>> get_closest_vowel('quick')
# ''
# >>> get_closest_vowel('ab')
# ''

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- get_closest_vowel
    stopifnot(isTRUE(all.equal(candidate('yogurt'), 'u')))
    stopifnot(isTRUE(all.equal(candidate('full'), 'u')))
    stopifnot(isTRUE(all.equal(candidate('easy'), '')))
    stopifnot(isTRUE(all.equal(candidate('eAsy'), '')))
    stopifnot(isTRUE(all.equal(candidate('ali'), '')))
    stopifnot(isTRUE(all.equal(candidate('bad'), 'a')))
    stopifnot(isTRUE(all.equal(candidate('most'), 'o')))
    stopifnot(isTRUE(all.equal(candidate('ab'), '')))
    stopifnot(isTRUE(all.equal(candidate('ba'), '')))
    stopifnot(isTRUE(all.equal(candidate('quick'), '')))
    stopifnot(isTRUE(all.equal(candidate('anime'), 'i')))
    stopifnot(isTRUE(all.equal(candidate('Asia'), '')))
    stopifnot(isTRUE(all.equal(candidate('Above'), 'o')))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# You are given a word. Your task is to find the closest vowel that stands between 
# two consonants from the right side of the word (case sensitive).
# Vowels in the beginning and ending doesn't count. Return empty string if you didn't
# find any vowel met the above condition. 
# You may assume that the given string contains English letter only.
# Example:
# >>> get_closest_vowel('yogurt')
# 'u'
# >>> get_closest_vowel('FULL')
# 'U'
# >>> get_closest_vowel('quick')
# ''
# >>> get_closest_vowel('ab')
# ''
get_closest_vowel <- function(word) {
  # Define vowels (both lower‑ and upper‑case)
  vowels <- c("a","e","i","o","u","A","E","I","O","U")
  
  n <- nchar(word)
  if (n < 3) return("")   # Need at least 3 characters to have a vowel between two consonants
  
  # Scan from right to left, skipping first and last positions
  for (i in seq(n - 1, 2, by = -1)) {
    ch <- substr(word, i, i)
    if (ch %in% vowels) {
      left  <- substr(word, i - 1, i - 1)
      right <- substr(word, i + 1, i + 1)
      if (!(left %in% vowels) && !(right %in% vowels)) {
        return(ch)
      }
    }
  }
  return("")   # No suitable vowel found
}
test_humaneval <- function() {
    candidate <- get_closest_vowel
    stopifnot(isTRUE(all.equal(candidate('yogurt'), 'u')))
    stopifnot(isTRUE(all.equal(candidate('full'), 'u')))
    stopifnot(isTRUE(all.equal(candidate('easy'), '')))
    stopifnot(isTRUE(all.equal(candidate('eAsy'), '')))
    stopifnot(isTRUE(all.equal(candidate('ali'), '')))
    stopifnot(isTRUE(all.equal(candidate('bad'), 'a')))
    stopifnot(isTRUE(all.equal(candidate('most'), 'o')))
    stopifnot(isTRUE(all.equal(candidate('ab'), '')))
    stopifnot(isTRUE(all.equal(candidate('ba'), '')))
    stopifnot(isTRUE(all.equal(candidate('quick'), '')))
    stopifnot(isTRUE(all.equal(candidate('anime'), 'i')))
    stopifnot(isTRUE(all.equal(candidate('Asia'), '')))
    stopifnot(isTRUE(all.equal(candidate('Above'), 'o')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183790
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# You are given a word. Your task is to find the closest vowel that stands between 
# two consonants from the right side of the word (case sensitive).
# Vowels in the beginning and ending doesn't count. Return empty string if you didn't
# find any vowel met the above condition. 
# You may assume that the given string contains English letter only.
# Example:
# >>> get_closest_vowel('yogurt')
# 'u'
# >>> get_closest_vowel('FULL')
# 'U'
# >>> get_closest_vowel('quick')
# ''
# >>> get_closest_vowel('ab')
# ''
get_closest_vowel <- function(word) {
  # Helper: set of vowels (case‑sensitive)
  vowels <- c("A","E","I","O","U","a","e","i","o","u")
  
  # Length of the word
  n <- nchar(word)
  
  # If the word is too short to contain a vowel between two consonants
  if (n < 3) {
    return("")
  }
  
  # Split the word into individual characters
  chars <- strsplit(word, "")[[1]]
  
  # Variable to keep track of the rightmost qualifying vowel
  best_index <- NA
  
  # Iterate over all positions that are not the first or last character
  for (i in 2:(n - 1)) {
    current_char <- chars[i]
    
    # Check if current character is a vowel
    if (current_char %in% vowels) {
      left_char  <- chars[i - 1]
      right_char <- chars[i + 1]
      
      # Check that both neighbors are consonants (i.e., not vowels)
      if (!(left_char %in% vowels) && !(right_char %in% vowels)) {
        # Update best_index to the rightmost qualifying vowel found so far
        best_index <- i
      }
    }
  }
  
  # Return the vowel if found, otherwise an empty string
  if (!is.na(best_index)) {
    return(chars[best_index])
  } else {
    return("")
  }
}
test_humaneval <- function() {
    candidate <- get_closest_vowel
    stopifnot(isTRUE(all.equal(candidate('yogurt'), 'u')))
    stopifnot(isTRUE(all.equal(candidate('full'), 'u')))
    stopifnot(isTRUE(all.equal(candidate('easy'), '')))
    stopifnot(isTRUE(all.equal(candidate('eAsy'), '')))
    stopifnot(isTRUE(all.equal(candidate('ali'), '')))
    stopifnot(isTRUE(all.equal(candidate('bad'), 'a')))
    stopifnot(isTRUE(all.equal(candidate('most'), 'o')))
    stopifnot(isTRUE(all.equal(candidate('ab'), '')))
    stopifnot(isTRUE(all.equal(candidate('ba'), '')))
    stopifnot(isTRUE(all.equal(candidate('quick'), '')))
    stopifnot(isTRUE(all.equal(candidate('anime'), 'i')))
    stopifnot(isTRUE(all.equal(candidate('Asia'), '')))
    stopifnot(isTRUE(all.equal(candidate('Above'), 'o')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183790
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# You are given a word. Your task is to find the closest vowel that stands between 
# two consonants from the right side of the word (case sensitive).
# Vowels in the beginning and ending doesn't count. Return empty string if you didn't
# find any vowel met the above condition. 
# You may assume that the given string contains English letter only.
# Example:
# >>> get_closest_vowel('yogurt')
# 'u'
# >>> get_closest_vowel('FULL')
# 'U'
# >>> get_closest_vowel('quick')
# ''
# >>> get_closest_vowel('ab')
# ''
get_closest_vowel <- function(word) {
  # Define the set of vowels (case‑sensitive)
  vowels <- c('a', 'e', 'i', 'o', 'u',
              'A', 'E', 'I', 'O', 'U')
  
  # Split the word into individual characters
  chars <- strsplit(word, "")[[1]]
  n <- length(chars)
  
  # Need at least three characters to have a vowel between two consonants
  if (n < 3) {
    return("")
  }
  
  # Scan from right to left, starting from the second‑to‑last character
  for (i in seq(n - 1, 2)) {
    # Check if the current character is a vowel
    if (chars[i] %in% vowels) {
      # Check that both neighbors are consonants (i.e., not vowels)
      if (!(chars[i - 1] %in% vowels) && !(chars[i + 1] %in% vowels)) {
        return(chars[i])
      }
    }
  }
  
  # No qualifying vowel found
  return("")
}
test_humaneval <- function() {
    candidate <- get_closest_vowel
    stopifnot(isTRUE(all.equal(candidate('yogurt'), 'u')))
    stopifnot(isTRUE(all.equal(candidate('full'), 'u')))
    stopifnot(isTRUE(all.equal(candidate('easy'), '')))
    stopifnot(isTRUE(all.equal(candidate('eAsy'), '')))
    stopifnot(isTRUE(all.equal(candidate('ali'), '')))
    stopifnot(isTRUE(all.equal(candidate('bad'), 'a')))
    stopifnot(isTRUE(all.equal(candidate('most'), 'o')))
    stopifnot(isTRUE(all.equal(candidate('ab'), '')))
    stopifnot(isTRUE(all.equal(candidate('ba'), '')))
    stopifnot(isTRUE(all.equal(candidate('quick'), '')))
    stopifnot(isTRUE(all.equal(candidate('anime'), 'i')))
    stopifnot(isTRUE(all.equal(candidate('Asia'), '')))
    stopifnot(isTRUE(all.equal(candidate('Above'), 'o')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183790
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# You are given a word. Your task is to find the closest vowel that stands between 
# two consonants from the right side of the word (case sensitive).
# Vowels in the beginning and ending doesn't count. Return empty string if you didn't
# find any vowel met the above condition. 
# You may assume that the given string contains English letter only.
# Example:
# >>> get_closest_vowel('yogurt')
# 'u'
# >>> get_closest_vowel('FULL')
# 'U'
# >>> get_closest_vowel('quick')
# ''
# >>> get_closest_vowel('ab')
# ''
get_closest_vowel <- function(word) {
  # Define vowels (both lower‑ and upper‑case)
  vowels <- c('a', 'e', 'i', 'o', 'u',
              'A', 'E', 'I', 'O', 'U')
  
  # Split the word into individual characters
  chars <- strsplit(word, "")[[1]]
  n <- length(chars)
  
  # No possible vowel if word has fewer than 3 characters
  if (n < 3) return("")
  
  # Iterate from right to left, skipping first and last positions
  for (i in seq(n - 1, 2, by = -1)) {
    if (chars[i] %in% vowels) {
      left  <- chars[i - 1]
      right <- chars[i + 1]
      
      # Check that both neighbours are consonants
      if (!(left %in% vowels) && !(right %in% vowels)) {
        return(chars[i])   # closest vowel found
      }
    }
  }
  
  # No qualifying vowel found
  return("")
}
test_humaneval <- function() {
    candidate <- get_closest_vowel
    stopifnot(isTRUE(all.equal(candidate('yogurt'), 'u')))
    stopifnot(isTRUE(all.equal(candidate('full'), 'u')))
    stopifnot(isTRUE(all.equal(candidate('easy'), '')))
    stopifnot(isTRUE(all.equal(candidate('eAsy'), '')))
    stopifnot(isTRUE(all.equal(candidate('ali'), '')))
    stopifnot(isTRUE(all.equal(candidate('bad'), 'a')))
    stopifnot(isTRUE(all.equal(candidate('most'), 'o')))
    stopifnot(isTRUE(all.equal(candidate('ab'), '')))
    stopifnot(isTRUE(all.equal(candidate('ba'), '')))
    stopifnot(isTRUE(all.equal(candidate('quick'), '')))
    stopifnot(isTRUE(all.equal(candidate('anime'), 'i')))
    stopifnot(isTRUE(all.equal(candidate('Asia'), '')))
    stopifnot(isTRUE(all.equal(candidate('Above'), 'o')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183790
STDOUT: (empty)
STDERR: (empty)
--------------------
