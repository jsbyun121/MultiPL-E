As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 143 (RKT) - HumanEval_143_words_in_sentence
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;;     * 1 <= len(sentence) <= 100
;;     * sentence contains only letters

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-within (candidate "This is a test") "is" 0.001)
    (check-within (candidate "lets go for swimming") "go for" 0.001)
    (check-within (candidate "there is no place available here") "there is no place" 0.001)
    (check-within (candidate "Hi I am Hussein") "Hi am Hussein" 0.001)
    (check-within (candidate "go for it") "go for it" 0.001)
    (check-within (candidate "here") "" 0.001)
    (check-within (candidate "here is") "is" 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;;     * 1 <= len(sentence) <= 100
;;     * sentence contains only letters

;; --------------------------------------------------------------
;; Helper: test if a natural number is prime
;; --------------------------------------------------------------
(define (prime? n)
  (cond
    [(< n 2) #f]          ; 0 and 1 are not prime
    [(= n 2) #t]          ; 2 is the only even prime
    [(even? n) #f]        ; other even numbers are not prime
    [else
     (define (loop d)
       (cond
         [(> (* d d) n) #t]            ; no divisor found
         [(zero? (modulo n d)) #f]     ; divisor found
         [else (loop (+ d 2))]))       ; check next odd number
     (loop 3)])]                       ; start with 3

;; --------------------------------------------------------------
;; Main function: return words with prime lengths
;; --------------------------------------------------------------
(define (words_in_sentence sentence)
  (define words (string-split sentence))
  (define prime-words
    (filter (λ (w) (prime? (string-length w))) words))
  (string-join prime-words " "))

;; --------------------------------------------------------------
;; Example usage
;; --------------------------------------------------------------
(displayln (words_in_sentence "This is a test"))        ; → "is"
(displayln (words_in_sentence "lets go for swimming")) ; → "go for"
(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-within (candidate "This is a test") "is" 0.001)
    (check-within (candidate "lets go for swimming") "go for" 0.001)
    (check-within (candidate "there is no place available here") "there is no place" 0.001)
    (check-within (candidate "Hi I am Hussein") "Hi am Hussein" 0.001)
    (check-within (candidate "go for it") "go for it" 0.001)
    (check-within (candidate "here") "" 0.001)
    (check-within (candidate "here is") "is" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755183985
STDOUT: (empty)
STDERR:
/tmp/tmpeenawk3k.rkt:32:15: read-syntax: expected `)` to close `(` on line 21, found instead `]`
  context...:
   /usr/share/racket/collects/syntax/module-reader.rkt:186:17: body
   /usr/share/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /usr/share/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;;     * 1 <= len(sentence) <= 100
;;     * sentence contains only letters

;; Return a string containing only the words of `sentence`
;; whose lengths are prime numbers, preserving the original order.
(define (words_in_sentence sentence)
  ;; Helper: check if an integer > 1 is prime
  (define (prime? n)
    (and (> n 1)
         (not (for/or ([x (in-range 2 (add1 (floor (sqrt n))))])
                (= 0 (modulo n x))))))
  ;; Split the sentence into words
  (define words (string-split sentence))
  ;; Keep only words with a prime length
  (define prime-words (filter (lambda (w) (prime? (string-length w))) words))
  ;; Join them back into a single string
  (string-join prime-words " "))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-within (candidate "This is a test") "is" 0.001)
    (check-within (candidate "lets go for swimming") "go for" 0.001)
    (check-within (candidate "there is no place available here") "there is no place" 0.001)
    (check-within (candidate "Hi I am Hussein") "Hi am Hussein" 0.001)
    (check-within (candidate "go for it") "go for it" 0.001)
    (check-within (candidate "here") "" 0.001)
    (check-within (candidate "here is") "is" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183986
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;;     * 1 <= len(sentence) <= 100
;;     * sentence contains only letters

;; Return a string containing only the words whose lengths are prime numbers.
(define (words_in_sentence sentence)
  ;; Helper: test whether an integer n (> 0) is prime.
  (define (prime? n)
    (cond
      [(< n 2) #f]                     ; 0 and 1 are not prime
      [(= n 2) #t]                     ; 2 is the only even prime
      [(even? n) #f]                   ; other even numbers are not prime
      [else
       (let loop ((i 3))
         (cond
           [(> (* i i) n) #t]          ; no divisor found
           [(= (modulo n i) 0) #f]     ; divisor found
           [else (loop (+ i 2))]))]))  ; test next odd divisor

  ;; Split the sentence into words.
  (define words (string-split sentence))

  ;; Keep only the words whose lengths are prime.
  (define prime-words
    (filter (lambda (w) (prime? (string-length w))) words))

  ;; Join the selected words back into a string.
  (string-join prime-words " "))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-within (candidate "This is a test") "is" 0.001)
    (check-within (candidate "lets go for swimming") "go for" 0.001)
    (check-within (candidate "there is no place available here") "there is no place" 0.001)
    (check-within (candidate "Hi I am Hussein") "Hi am Hussein" 0.001)
    (check-within (candidate "go for it") "go for it" 0.001)
    (check-within (candidate "here") "" 0.001)
    (check-within (candidate "here is") "is" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183986
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;;     * 1 <= len(sentence) <= 100
;;     * sentence contains only letters

;; Check whether a number is prime
(define (prime? n)
  (cond
    [(<= n 1) #f]                     ; 0 and 1 are not prime
    [(= n 2) #t]                      ; 2 is the only even prime
    [(even? n) #f]                    ; other evens are not prime
    [else
     (let loop ([i 3])
       (cond
         [(> i (floor (sqrt n))) #t]   ; no divisor found
         [(zero? (remainder n i)) #f]   ; divisor found
         [else (loop (+ i 2))]))]))    ; test next odd number

;; Return a string with the words whose lengths are prime
(define (words_in_sentence sentence)
  (define words (string-split sentence))
  (define prime-words
    (filter (lambda (w) (prime? (string-length w))) words))
  (string-join prime-words " "))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-within (candidate "This is a test") "is" 0.001)
    (check-within (candidate "lets go for swimming") "go for" 0.001)
    (check-within (candidate "there is no place available here") "there is no place" 0.001)
    (check-within (candidate "Hi I am Hussein") "Hi am Hussein" 0.001)
    (check-within (candidate "go for it") "go for it" 0.001)
    (check-within (candidate "here") "" 0.001)
    (check-within (candidate "here is") "is" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183986
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 144 (RKT) - HumanEval_144_simplify
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Your task is to implement a function that will simplify the expression
;; x * n. The function returns #t if x * n evaluates to a whole number and #f
;; otherwise. Both x and n, are string representation of a fraction, and have the following format,
;; <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
;; You can assume that x, and n are valid fractions, and do not have zero as denominator.
;; >>> (simplify "1/5" "5/1")
;; #t
;; >>> (simplify "1/6" "2/1")
;; #f
;; >>> (simplify "7/10" "10/2")
;; #f

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate simplify))
    (check-within (candidate "1/5" "5/1") #t 0.001)
    (check-within (candidate "1/6" "2/1") #f 0.001)
    (check-within (candidate "5/1" "3/1") #t 0.001)
    (check-within (candidate "7/10" "10/2") #f 0.001)
    (check-within (candidate "2/10" "50/10") #t 0.001)
    (check-within (candidate "7/2" "4/2") #t 0.001)
    (check-within (candidate "11/6" "6/1") #t 0.001)
    (check-within (candidate "2/3" "5/2") #f 0.001)
    (check-within (candidate "5/2" "3/5") #f 0.001)
    (check-within (candidate "2/4" "8/4") #t 0.001)
    (check-within (candidate "2/4" "4/2") #t 0.001)
    (check-within (candidate "1/5" "5/1") #t 0.001)
    (check-within (candidate "1/5" "1/5") #f 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Your task is to implement a function that will simplify the expression
;; x * n. The function returns #t if x * n evaluates to a whole number and #f
;; otherwise. Both x and n, are string representation of a fraction, and have the following format,
;; <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
;; You can assume that x, and n are valid fractions, and do not have zero as denominator.
;; >>> (simplify "1/5" "5/1")
;; #t
;; >>> (simplify "1/6" "2/1")
;; #f
;; >>> (simplify "7/10" "10/2")
;; #f

(require racket/string)

;; Simplify the product of two fractions represented as strings.
;; Return #t if the product is a whole number, #f otherwise.
;;
;; Examples:
;;   (simplify "1/5" "5/1")  => #t
;;   (simplify "1/6" "2/1")  => #f
;;   (simplify "7/10" "10/2")=> #f
(define (simplify x n)
  ;; Parse a fraction string into its numerator and denominator.
  (define (parse frac)
    (define parts (string-split frac #\/))
    (define num   (string->number (first parts)))
    (define den   (string->number (second parts)))
    (values num den))

  ;; Get numerators and denominators of both fractions.
  (define-values (xnum xden) (parse x))
  (define-values (nnum nden) (parse n))

  ;; Compute the product numerator and denominator.
  (define num (* xnum nnum))
  (define den (* xden nden))

  ;; The product is a whole number iff num is divisible by den.
  (zero? (modulo num den)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate simplify))
    (check-within (candidate "1/5" "5/1") #t 0.001)
    (check-within (candidate "1/6" "2/1") #f 0.001)
    (check-within (candidate "5/1" "3/1") #t 0.001)
    (check-within (candidate "7/10" "10/2") #f 0.001)
    (check-within (candidate "2/10" "50/10") #t 0.001)
    (check-within (candidate "7/2" "4/2") #t 0.001)
    (check-within (candidate "11/6" "6/1") #t 0.001)
    (check-within (candidate "2/3" "5/2") #f 0.001)
    (check-within (candidate "5/2" "3/5") #f 0.001)
    (check-within (candidate "2/4" "8/4") #t 0.001)
    (check-within (candidate "2/4" "4/2") #t 0.001)
    (check-within (candidate "1/5" "5/1") #t 0.001)
    (check-within (candidate "1/5" "1/5") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: Exception
Timestamp: 1755183987
STDOUT: (empty)
STDERR:
--------------------
ERROR
name:       check-within
location:   /tmp/tmpoehwtifq.rkt:47:4

string-split: contract violation
  expected: (or/c string? regexp?)
  given: #\/
--------------------
--------------------
ERROR
name:       check-within
location:   /tmp/tmpoehwtifq.rkt:48:4

string-split: contract violation
  expected: (or/c string? regexp?)
  given: #\/
--------------------
--------------------
ERROR
name:       check-within
location:   /tmp/tmpoehwtifq.rkt:49:4

string-split: contract violation
  expected: (or/c string? regexp?)
  given: #\/
--------------------
--------------------
ERROR
name:       check-within
location:   /tmp/tmpoehwtifq.rkt:50:4

string-split: contract violation
  expected: (or/c string? regexp?)
  given: #\/
--------------------
--------------------
ERROR
name:       check-within
location:   /tmp/tmpoehwtifq.rkt:51:4

string-split: contract violation
  expected: (or/c string? regexp?)
  given: #\/
--------------------
--------------------
ERROR
name:       check-within
locatio
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Your task is to implement a function that will simplify the expression
;; x * n. The function returns #t if x * n evaluates to a whole number and #f
;; otherwise. Both x and n, are string representation of a fraction, and have the following format,
;; <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
;; You can assume that x, and n are valid fractions, and do not have zero as denominator.
;; >>> (simplify "1/5" "5/1")
;; #t
;; >>> (simplify "1/6" "2/1")
;; #f
;; >>> (simplify "7/10" "10/2")
;; #f

(require racket/string)

;; The function checks if the product of two fractions (given as strings)
;; results in a whole number.
(define (simplify x n)
  ;; Helper to parse a fraction string "a/b" into two integers
  (define (parse-fraction s)
    (define parts (string-split s "/"))
    (values (string->number (first parts))
            (string->number (second parts))))
  
  (define-values (numX denX) (parse-fraction x))
  (define-values (numN denN) (parse-fraction n))
  
  (define product-num (* numX numN))
  (define product-den (* denX denN))
  
  (zero? (modulo product-num product-den)))

;; Example usage:
;; (simplify "1/5" "5/1")   ; -> #t
;; (simplify "1/6" "2/1")   ; -> #f
;; (simplify "7/10" "10/2") ; -> #f
(require rackunit)

(define (test-humaneval) 

  (let (( candidate simplify))
    (check-within (candidate "1/5" "5/1") #t 0.001)
    (check-within (candidate "1/6" "2/1") #f 0.001)
    (check-within (candidate "5/1" "3/1") #t 0.001)
    (check-within (candidate "7/10" "10/2") #f 0.001)
    (check-within (candidate "2/10" "50/10") #t 0.001)
    (check-within (candidate "7/2" "4/2") #t 0.001)
    (check-within (candidate "11/6" "6/1") #t 0.001)
    (check-within (candidate "2/3" "5/2") #f 0.001)
    (check-within (candidate "5/2" "3/5") #f 0.001)
    (check-within (candidate "2/4" "8/4") #t 0.001)
    (check-within (candidate "2/4" "4/2") #t 0.001)
    (check-within (candidate "1/5" "5/1") #t 0.001)
    (check-within (candidate "1/5" "1/5") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183987
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Your task is to implement a function that will simplify the expression
;; x * n. The function returns #t if x * n evaluates to a whole number and #f
;; otherwise. Both x and n, are string representation of a fraction, and have the following format,
;; <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
;; You can assume that x, and n are valid fractions, and do not have zero as denominator.
;; >>> (simplify "1/5" "5/1")
;; #t
;; >>> (simplify "1/6" "2/1")
;; #f
;; >>> (simplify "7/10" "10/2")
;; #f

(require racket/string)

;; Return #t if (x * n) is a whole number, #f otherwise.
;; x and n are strings of the form "<numerator>/<denominator>".
(define (simplify x n)
  (let* ([parts-x (string-split x "/")]
         [num-x   (string->number (first parts-x))]
         [den-x   (string->number (second parts-x))]
         [parts-n (string-split n "/")]
         [num-n   (string->number (first parts-n))]
         [den-n   (string->number (second parts-n))]
         [num (* num-x num-n)]
         [den (* den-x den-n)])
    (zero? (modulo num den))))

;; Examples
#;(simplify "1/5" "5/1")   ; => #t
#;(simplify "1/6" "2/1")   ; => #f
#;(simplify "7/10" "10/2") ; => #f
(require rackunit)

(define (test-humaneval) 

  (let (( candidate simplify))
    (check-within (candidate "1/5" "5/1") #t 0.001)
    (check-within (candidate "1/6" "2/1") #f 0.001)
    (check-within (candidate "5/1" "3/1") #t 0.001)
    (check-within (candidate "7/10" "10/2") #f 0.001)
    (check-within (candidate "2/10" "50/10") #t 0.001)
    (check-within (candidate "7/2" "4/2") #t 0.001)
    (check-within (candidate "11/6" "6/1") #t 0.001)
    (check-within (candidate "2/3" "5/2") #f 0.001)
    (check-within (candidate "5/2" "3/5") #f 0.001)
    (check-within (candidate "2/4" "8/4") #t 0.001)
    (check-within (candidate "2/4" "4/2") #t 0.001)
    (check-within (candidate "1/5" "5/1") #t 0.001)
    (check-within (candidate "1/5" "1/5") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183987
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Your task is to implement a function that will simplify the expression
;; x * n. The function returns #t if x * n evaluates to a whole number and #f
;; otherwise. Both x and n, are string representation of a fraction, and have the following format,
;; <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
;; You can assume that x, and n are valid fractions, and do not have zero as denominator.
;; >>> (simplify "1/5" "5/1")
;; #t
;; >>> (simplify "1/6" "2/1")
;; #f
;; >>> (simplify "7/10" "10/2")
;; #f

;; Return #t if the product of the two fractions is an integer,
;; otherwise return #f.
(define (simplify x n)
  ;; Helper to parse a fraction string into a pair of integers
  (define (parse-frac s)
    (match (string-split s "/")
      [(list num den) (values (string->number num) (string->number den))]))

  ;; Parse both fractions
  (define-values (x-num x-den) (parse-frac x))
  (define-values (n-num n-den) (parse-frac n))

  ;; Compute the product numerator and denominator
  (define prod-num (* x-num n-num))
  (define prod-den (* x-den n-den))

  ;; Check if the product is a whole number
  (zero? (modulo prod-num prod-den)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate simplify))
    (check-within (candidate "1/5" "5/1") #t 0.001)
    (check-within (candidate "1/6" "2/1") #f 0.001)
    (check-within (candidate "5/1" "3/1") #t 0.001)
    (check-within (candidate "7/10" "10/2") #f 0.001)
    (check-within (candidate "2/10" "50/10") #t 0.001)
    (check-within (candidate "7/2" "4/2") #t 0.001)
    (check-within (candidate "11/6" "6/1") #t 0.001)
    (check-within (candidate "2/3" "5/2") #f 0.001)
    (check-within (candidate "5/2" "3/5") #f 0.001)
    (check-within (candidate "2/4" "8/4") #t 0.001)
    (check-within (candidate "2/4" "4/2") #t 0.001)
    (check-within (candidate "1/5" "5/1") #t 0.001)
    (check-within (candidate "1/5" "1/5") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183987
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 147 (RKT) - HumanEval_147_get_max_triples
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;;     and a[i] + a[j] + a[k] is a multiple of 3.
;;     Example :
;;     >>> (get_max_triples 5)
;;     1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-within (candidate 5) 1 0.001)
    (check-within (candidate 6) 4 0.001)
    (check-within (candidate 10) 36 0.001)
    (check-within (candidate 100) 53361 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;;     and a[i] + a[j] + a[k] is a multiple of 3.
;;     Example :
;;     >>> (get_max_triples 5)
;;     1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).

;; Return the number of triples (a[i], a[j], a[k]) with i < j < k
;; such that a[i] + a[j] + a[k] is a multiple of 3.
;; a[i] = i * i - i + 1.
(define (get_max_triples n)
  ;; helper: compute n choose 3 (returns 0 if n < 3)
  (define (comb3 k)
    (if (< k 3)
        0
        (/ (* k (- k 1) (- k 2)) 6)))

  ;; Count indices i (1 ≤ i ≤ n) for which a[i] mod 3 = 0.
  ;; From analysis, a[i] mod 3 = 0 iff i mod 3 = 2.
  (define count-B (quotient (+ n 1) 3))   ; indices with i mod 3 = 2
  (define count-A (- n count-B))         ; the rest (i mod 3 = 0 or 1)

  ;; All valid triples are either all from group A or all from group B.
  (+ (comb3 count-A)
     (comb3 count-B))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-within (candidate 5) 1 0.001)
    (check-within (candidate 6) 4 0.001)
    (check-within (candidate 10) 36 0.001)
    (check-within (candidate 100) 53361 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755828002
STDOUT: (empty)
STDERR:
/tmp/tmpz35zfydf.rkt:31:22: read-syntax: unexpected `)`
  context...:
   /usr/share/racket/collects/syntax/module-reader.rkt:186:17: body
   /usr/share/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /usr/share/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;;     and a[i] + a[j] + a[k] is a multiple of 3.
;;     Example :
;;     >>> (get_max_triples 5)
;;     1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).

;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,
;; and a[i] + a[j] + a[k] is a multiple of 3.
;; a[i] = i^2 - i + 1
(define (get_max_triples n)
  ;; Count of indices with a[i] ≡ 0 (mod 3)
  (define c0 (quotient (+ n 1) 3))
  ;; Count of indices with a[i] ≡ 1 (mod 3)
  (define c1 (- n c0))
  ;; Helper: binomial coefficient n choose 3
  (define (choose3 x)
    (if (< x 3)
        0
        (/ (* x (- x 1) (- x 2)) 6)))
  (+ (choose3 c0) (choose3 c1)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-within (candidate 5) 1 0.001)
    (check-within (candidate 6) 4 0.001)
    (check-within (candidate 10) 36 0.001)
    (check-within (candidate 100) 53361 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828002
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;;     and a[i] + a[j] + a[k] is a multiple of 3.
;;     Example :
;;     >>> (get_max_triples 5)
;;     1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).

;; Return the number of triples (a[i], a[j], a[k]) with i < j < k
;; such that a[i] + a[j] + a[k] is a multiple of 3.
;;
;; a[i] = i*i - i + 1
;;
;; Observation:
;;   a[i] mod 3 = 1 if i mod 3 = 0 or 1
;;   a[i] mod 3 = 0 if i mod 3 = 2
;; Therefore a valid triple must consist of either
;;   * three elements all ≡ 0 (mod 3)  or
;;   * three elements all ≡ 1 (mod 3).
;;
;; Count the indices with each residue and use the combinatorial
;; formula C(k,3) = k*(k-1)*(k-2)/6 for k ≥ 3.
(define (get_max_triples n)
  ;; Count of indices i (1 ≤ i ≤ n) with i mod 3 = 2
  (define c0 (quotient (+ n 1) 3))
  ;; Count of indices with residue 1 (i mod 3 = 0 or 1)
  (define c1 (- n c0))
  ;; Helper: compute C(k,3) safely
  (define (comb3 k)
    (if (< k 3)
        0
        (quotient (* k (- k 1) (- k 2)) 6)))
  (+ (comb3 c0) (comb3 c1)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-within (candidate 5) 1 0.001)
    (check-within (candidate 6) 4 0.001)
    (check-within (candidate 10) 36 0.001)
    (check-within (candidate 100) 53361 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828002
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;;     and a[i] + a[j] + a[k] is a multiple of 3.
;;     Example :
;;     >>> (get_max_triples 5)
;;     1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).

;; Count the number of triples (i < j < k) in the sequence
;; a[i] = i*i - i + 1 such that a[i] + a[j] + a[k] is divisible by 3.
;;
;; Observation:
;;   a[i] mod 3 = 1  if i mod 3 ≠ 2
;;   a[i] mod 3 = 0  if i mod 3 = 2
;;
;; Therefore only residues 0 and 1 appear.  
;; A sum of three residues is 0 mod 3 only when all three are 0 or all three are 1.
;;
;; Let count0 = number of indices i with i mod 3 = 2
;; Let count1 = n - count0
;;
;; The answer is C(count0, 3) + C(count1, 3).

(define (choose3 n)
  ;; Return n choose 3, zero if n < 3
  (if (< n 3)
      0
      (quotient (* n (- n 1) (- n 2)) 6)))

(define (get_max_triples n)
  (let* ([count0 (quotient (+ n 1) 3)]   ; indices ≡ 2 (mod 3)
         [count1 (- n count0)]
         [c0 (choose3 count0)]
         [c1 (choose3 count1)])
    (+ c0 c1)))

;; Example
;; (get_max_triples 5)  ; => 1
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-within (candidate 5) 1 0.001)
    (check-within (candidate 6) 4 0.001)
    (check-within (candidate 10) 36 0.001)
    (check-within (candidate 100) 53361 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828002
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 150 (RKT) - HumanEval_150_x_or_y
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; A simple program which should return the value of x if n is 
;; a prime number and should return the value of y otherwise.
;; Examples:
;; >>> (x_or_y 7 34 12)
;; 34
;; >>> (x_or_y 15 8 5)
;; 5

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate x_or_y))
    (check-within (candidate 7 34 12) 34 0.001)
    (check-within (candidate 15 8 5) 5 0.001)
    (check-within (candidate 3 33 5212) 33 0.001)
    (check-within (candidate 1259 3 52) 3 0.001)
    (check-within (candidate 7919 -1 12) -1 0.001)
    (check-within (candidate 3609 1245 583) 583 0.001)
    (check-within (candidate 91 56 129) 129 0.001)
    (check-within (candidate 6 34 1234) 1234 0.001)
    (check-within (candidate 1 2 0) 0 0.001)
    (check-within (candidate 2 2 0) 2 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; A simple program which should return the value of x if n is 
;; a prime number and should return the value of y otherwise.
;; Examples:
;; >>> (x_or_y 7 34 12)
;; 34
;; >>> (x_or_y 15 8 5)
;; 5

;; ------------------------------------------------------------------
;; Utility: check whether an integer is prime
;; ------------------------------------------------------------------
(define (prime? n)
  (cond
    [(< n 2) #f]                      ; 0 and 1 are not prime
    [(= n 2) #t]                      ; 2 is prime
    [(even? n) #f]                    ; even numbers >2 are not prime
    [else
     (let loop ([i 3]
                [limit (inexact->exact (floor (sqrt n)))])
       (cond
         [(> i limit) #t]             ; no divisor found
         [(zero? (modulo n i)) #f]    ; divisor found
         [else (loop (+ i 2) limit)]))]))

;; ------------------------------------------------------------------
;; Main function: return x if n is prime, otherwise return y
;; ------------------------------------------------------------------
(define (x_or_y n x y)
  (if (prime? n)
      x
      y))

;; ------------------------------------------------------------------
;; Examples
;; ------------------------------------------------------------------
(define test1 (x_or_y 7 34 12))   ; => 34
(define test2 (x_or_y 15 8 5))    ; => 5
(require rackunit)

(define (test-humaneval) 

  (let (( candidate x_or_y))
    (check-within (candidate 7 34 12) 34 0.001)
    (check-within (candidate 15 8 5) 5 0.001)
    (check-within (candidate 3 33 5212) 33 0.001)
    (check-within (candidate 1259 3 52) 3 0.001)
    (check-within (candidate 7919 -1 12) -1 0.001)
    (check-within (candidate 3609 1245 583) 583 0.001)
    (check-within (candidate 91 56 129) 129 0.001)
    (check-within (candidate 6 34 1234) 1234 0.001)
    (check-within (candidate 1 2 0) 0 0.001)
    (check-within (candidate 2 2 0) 2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828005
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; A simple program which should return the value of x if n is 
;; a prime number and should return the value of y otherwise.
;; Examples:
;; >>> (x_or_y 7 34 12)
;; 34
;; >>> (x_or_y 15 8 5)
;; 5

;; A simple program which should return the value of x if n is 
;; a prime number and should return the value of y otherwise.
;; Examples:
;; >>> (x_or_y 7 34 12)
;; 34
;; >>> (x_or_y 15 8 5)
;; 5

(define (x_or_y n x y)
  ;; Helper: test if n is prime
  (define (prime? m)
    (cond
      [(< m 2) #f]                      ; 0 and 1 are not prime
      [(= m 2) #t]                      ; 2 is prime
      [(even? m) #f]                    ; even numbers > 2 are not prime
      [else
       (let loop ([i 3]
                  [limit (inexact->exact (floor (sqrt m)))])
         (cond
           [(> i limit) #t]              ; no divisor found
           [(zero? (modulo m i)) #f]     ; divisor found
           [else (loop (+ i 2) limit)]))]))
  (if (prime? n) x y))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate x_or_y))
    (check-within (candidate 7 34 12) 34 0.001)
    (check-within (candidate 15 8 5) 5 0.001)
    (check-within (candidate 3 33 5212) 33 0.001)
    (check-within (candidate 1259 3 52) 3 0.001)
    (check-within (candidate 7919 -1 12) -1 0.001)
    (check-within (candidate 3609 1245 583) 583 0.001)
    (check-within (candidate 91 56 129) 129 0.001)
    (check-within (candidate 6 34 1234) 1234 0.001)
    (check-within (candidate 1 2 0) 0 0.001)
    (check-within (candidate 2 2 0) 2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828005
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; A simple program which should return the value of x if n is 
;; a prime number and should return the value of y otherwise.
;; Examples:
;; >>> (x_or_y 7 34 12)
;; 34
;; >>> (x_or_y 15 8 5)
;; 5

;; Return `x` if `n` is a prime number, otherwise return `y`.
(define (x_or_y n x y)
  (if (prime? n)
      x
      y))

;; Simple primality test.
(define (prime? n)
  (and (> n 1)
       (for/and ([i (in-range 2 (add1 (floor (sqrt n))))])
         (zero? (modulo n i)))))

;; Examples
(displayln (x_or_y 7 34 12))   ; => 34
(displayln (x_or_y 15 8 5))    ; => 5
(require rackunit)

(define (test-humaneval) 

  (let (( candidate x_or_y))
    (check-within (candidate 7 34 12) 34 0.001)
    (check-within (candidate 15 8 5) 5 0.001)
    (check-within (candidate 3 33 5212) 33 0.001)
    (check-within (candidate 1259 3 52) 3 0.001)
    (check-within (candidate 7919 -1 12) -1 0.001)
    (check-within (candidate 3609 1245 583) 583 0.001)
    (check-within (candidate 91 56 129) 129 0.001)
    (check-within (candidate 6 34 1234) 1234 0.001)
    (check-within (candidate 1 2 0) 0 0.001)
    (check-within (candidate 2 2 0) 2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: Exception
Timestamp: 1755828005
STDOUT:
12
5
STDERR:
--------------------
FAILURE
name:       check-within
location:   /tmp/tmp_d7cyx9h.rkt:31:4
actual:     12
expected:   34
--------------------
--------------------
FAILURE
name:       check-within
location:   /tmp/tmp_d7cyx9h.rkt:34:4
actual:     52
expected:   3
--------------------
--------------------
FAILURE
name:       check-within
location:   /tmp/tmp_d7cyx9h.rkt:35:4
actual:     12
expected:   -1
--------------------
--------------------
FAILURE
name:       check-within
location:   /tmp/tmp_d7cyx9h.rkt:38:4
actual:     34
expected:   1234
--------------------
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; A simple program which should return the value of x if n is 
;; a prime number and should return the value of y otherwise.
;; Examples:
;; >>> (x_or_y 7 34 12)
;; 34
;; >>> (x_or_y 15 8 5)
;; 5

;; A simple program which should return the value of x if n is 
;; a prime number and should return the value of y otherwise.
;; Examples:
;; >>> (x_or_y 7 34 12)
;; 34
;; >>> (x_or_y 15 8 5)
;; 5

(define (prime? n)
  (cond
    [(< n 2) #f]
    [(= n 2) #t]
    [(even? n) #f]
    [else
     (let loop ([i 3])
       (cond
         [(> (* i i) n) #t]
         [(zero? (modulo n i)) #f]
         [else (loop (+ i 2))]))]))

(define (x_or_y n x y)
  (if (prime? n) x y))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate x_or_y))
    (check-within (candidate 7 34 12) 34 0.001)
    (check-within (candidate 15 8 5) 5 0.001)
    (check-within (candidate 3 33 5212) 33 0.001)
    (check-within (candidate 1259 3 52) 3 0.001)
    (check-within (candidate 7919 -1 12) -1 0.001)
    (check-within (candidate 3609 1245 583) 583 0.001)
    (check-within (candidate 91 56 129) 129 0.001)
    (check-within (candidate 6 34 1234) 1234 0.001)
    (check-within (candidate 1 2 0) 0 0.001)
    (check-within (candidate 2 2 0) 2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828005
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 155 (RKT) - HumanEval_155_even_odd_count
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;;     >>> (even_odd_count -12)
;;     (list 1 1)
;;     >>> (even_odd_count 123)
;;     (list 1 2)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_count))
    (check-within (candidate 7) (list 0 1) 0.001)
    (check-within (candidate -78) (list 1 1) 0.001)
    (check-within (candidate 3452) (list 2 2) 0.001)
    (check-within (candidate 346211) (list 3 3) 0.001)
    (check-within (candidate -345821) (list 3 3) 0.001)
    (check-within (candidate -2) (list 1 0) 0.001)
    (check-within (candidate -45347) (list 2 3) 0.001)
    (check-within (candidate 0) (list 1 0) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;;     >>> (even_odd_count -12)
;;     (list 1 1)
;;     >>> (even_odd_count 123)
;;     (list 1 2)

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;;     >>> (even_odd_count -12)
;;     (list 1 1)
;;     >>> (even_odd_count 123)
;;     (list 1 2)
(define (even_odd_count num)
  ;; Convert the absolute value of the number to a list of its digit values
  (let* ([digits
          (map (lambda (c)
                 (- (char->integer c) (char->integer #\0)))
               (string->list (number->string (abs num))))] 
         [even-count
          (foldl (lambda (d acc) (if (even? d) (+ acc 1) acc))
                 0 digits)])
    (list even-count (- (length digits) even-count))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_count))
    (check-within (candidate 7) (list 0 1) 0.001)
    (check-within (candidate -78) (list 1 1) 0.001)
    (check-within (candidate 3452) (list 2 2) 0.001)
    (check-within (candidate 346211) (list 3 3) 0.001)
    (check-within (candidate -345821) (list 3 3) 0.001)
    (check-within (candidate -2) (list 1 0) 0.001)
    (check-within (candidate -45347) (list 2 3) 0.001)
    (check-within (candidate 0) (list 1 0) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828010
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;;     >>> (even_odd_count -12)
;;     (list 1 1)
;;     >>> (even_odd_count 123)
;;     (list 1 2)

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;;     >>> (even_odd_count -12)
;;     (list 1 1)
;;     >>> (even_odd_count 123)
;;     (list 1 2)
(define (even_odd_count num)
  (define n (abs num))
  ;; Handle the special case where the number is 0
  (if (= n 0)
      (list 1 0)          ; 0 is an even digit
      (let loop ([m n] [even 0] [odd 0])
        (if (= m 0)
            (list even odd)
            (let ([digit (modulo m 10)])
              (if (= (remainder digit 2) 0)
                  (loop (quotient m 10) (+ even 1) odd)
                  (loop (quotient m 10) even (+ odd 1))))))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_count))
    (check-within (candidate 7) (list 0 1) 0.001)
    (check-within (candidate -78) (list 1 1) 0.001)
    (check-within (candidate 3452) (list 2 2) 0.001)
    (check-within (candidate 346211) (list 3 3) 0.001)
    (check-within (candidate -345821) (list 3 3) 0.001)
    (check-within (candidate -2) (list 1 0) 0.001)
    (check-within (candidate -45347) (list 2 3) 0.001)
    (check-within (candidate 0) (list 1 0) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828010
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;;     >>> (even_odd_count -12)
;;     (list 1 1)
;;     >>> (even_odd_count 123)
;;     (list 1 2)

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;;     >>> (even_odd_count -12)
;;     (list 1 1)
;;     >>> (even_odd_count 123)
;;     (list 1 2)
(define (even_odd_count num)
  (let loop ((n (abs num))
             (even 0)
             (odd  0))
    (cond
      [(zero? n) (list even odd)]
      [else
       (let ((digit (modulo n 10)))
         (loop (quotient n 10)
               (if (member digit '(0 2 4 6 8)) (+ even 1) even)
               (if (member digit '(1 3 5 7 9)) (+ odd 1) odd)))])))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_count))
    (check-within (candidate 7) (list 0 1) 0.001)
    (check-within (candidate -78) (list 1 1) 0.001)
    (check-within (candidate 3452) (list 2 2) 0.001)
    (check-within (candidate 346211) (list 3 3) 0.001)
    (check-within (candidate -345821) (list 3 3) 0.001)
    (check-within (candidate -2) (list 1 0) 0.001)
    (check-within (candidate -45347) (list 2 3) 0.001)
    (check-within (candidate 0) (list 1 0) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: Exception
Timestamp: 1755828010
STDOUT: (empty)
STDERR:
--------------------
FAILURE
name:       check-within
location:   /tmp/tmpf3gp96nr.rkt:39:4
actual:     '(0 0)
expected:   '(1 0)
--------------------
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;;     >>> (even_odd_count -12)
;;     (list 1 1)
;;     >>> (even_odd_count 123)
;;     (list 1 2)

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;;     >>> (even_odd_count -12)
;;     (list 1 1)
;;     >>> (even_odd_count 123)
;;     (list 1 2)

(define (even_odd_count num)
  ;; Handle the special case where the number is 0
  (if (= num 0)
      (list 1 0)          ; 0 is an even digit
      (let loop ([n (abs num)]          ; work with the absolute value
                 [even 0]
                 [odd 0])
        (if (= n 0)
            (list even odd)
            (let* ([digit (modulo n 10)]
                   [is-even (zero? (modulo digit 2))])
              (loop (quotient n 10)
                    (+ even (if is-even 1 0))
                    (+ odd (if is-even 0 1))))))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_count))
    (check-within (candidate 7) (list 0 1) 0.001)
    (check-within (candidate -78) (list 1 1) 0.001)
    (check-within (candidate 3452) (list 2 2) 0.001)
    (check-within (candidate 346211) (list 3 3) 0.001)
    (check-within (candidate -345821) (list 3 3) 0.001)
    (check-within (candidate -2) (list 1 0) 0.001)
    (check-within (candidate -45347) (list 2 3) 0.001)
    (check-within (candidate 0) (list 1 0) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828010
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 156 (RKT) - HumanEval_156_int_to_mini_roman
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-within (candidate 19) "xix" 0.001)
    (check-within (candidate 152) "clii" 0.001)
    (check-within (candidate 251) "ccli" 0.001)
    (check-within (candidate 426) "cdxxvi" 0.001)
    (check-within (candidate 500) "d" 0.001)
    (check-within (candidate 1) "i" 0.001)
    (check-within (candidate 4) "iv" 0.001)
    (check-within (candidate 43) "xliii" 0.001)
    (check-within (candidate 90) "xc" 0.001)
    (check-within (candidate 94) "xciv" 0.001)
    (check-within (candidate 532) "dxxxii" 0.001)
    (check-within (candidate 900) "cm" 0.001)
    (check-within (candidate 994) "cmxciv" 0.001)
    (check-within (candidate 1000) "m" 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"

(define (int_to_mini_roman number)
  ;; A list of pairs (value . symbol) in descending order.
  (define roman-mapping
    '((1000 . "M")
      (900  . "CM")
      (500  . "D")
      (400  . "CD")
      (100  . "C")
      (90   . "XC")
      (50   . "L")
      (40   . "XL")
      (10   . "X")
      (9    . "IX")
      (5    . "V")
      (4    . "IV")
      (1    . "I")))
  
  (define (build-roman n acc)
    (cond
      [(zero? n) acc] ; finished
      [else
       (let* ([pair (findf (λ (p) (<= (car p) n)) roman-mapping)]
              [value (car pair)]
              [symbol (cdr pair)])
         (build-roman (- n value) (string-append acc symbol)))]))
  
  (string-downcase (build-roman number "")))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-within (candidate 19) "xix" 0.001)
    (check-within (candidate 152) "clii" 0.001)
    (check-within (candidate 251) "ccli" 0.001)
    (check-within (candidate 426) "cdxxvi" 0.001)
    (check-within (candidate 500) "d" 0.001)
    (check-within (candidate 1) "i" 0.001)
    (check-within (candidate 4) "iv" 0.001)
    (check-within (candidate 43) "xliii" 0.001)
    (check-within (candidate 90) "xc" 0.001)
    (check-within (candidate 94) "xciv" 0.001)
    (check-within (candidate 532) "dxxxii" 0.001)
    (check-within (candidate 900) "cm" 0.001)
    (check-within (candidate 994) "cmxciv" 0.001)
    (check-within (candidate 1000) "m" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828010
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"

(define (int_to_mini_roman number)
  (define mapping
    (list
     (cons 1000 "M")
     (cons 900  "CM")
     (cons 500  "D")
     (cons 400  "CD")
     (cons 100  "C")
     (cons 90   "XC")
     (cons 50   "L")
     (cons 40   "XL")
     (cons 10   "X")
     (cons 9    "IX")
     (cons 5    "V")
     (cons 4    "IV")
     (cons 1    "I")))
  
  (define (convert n pairs acc)
    (cond
      [(zero? n) (string-downcase acc)]
      [else
       (define pair (car pairs))
       (define val  (car pair))
       (define sym  (cdr pair))
       (if (>= n val)
           (convert (- n val) pairs (string-append acc sym))
           (convert n (cdr pairs) acc))]))
  
  (convert number mapping ""))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-within (candidate 19) "xix" 0.001)
    (check-within (candidate 152) "clii" 0.001)
    (check-within (candidate 251) "ccli" 0.001)
    (check-within (candidate 426) "cdxxvi" 0.001)
    (check-within (candidate 500) "d" 0.001)
    (check-within (candidate 1) "i" 0.001)
    (check-within (candidate 4) "iv" 0.001)
    (check-within (candidate 43) "xliii" 0.001)
    (check-within (candidate 90) "xc" 0.001)
    (check-within (candidate 94) "xciv" 0.001)
    (check-within (candidate 532) "dxxxii" 0.001)
    (check-within (candidate 900) "cm" 0.001)
    (check-within (candidate 994) "cmxciv" 0.001)
    (check-within (candidate 1000) "m" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828010
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"

(define (int_to_mini_roman number)
  (define roman-pairs
    (list
     (cons 1000 "M")
     (cons 900  "CM")
     (cons 500  "D")
     (cons 400  "CD")
     (cons 100  "C")
     (cons 90   "XC")
     (cons 50   "L")
     (cons 40   "XL")
     (cons 10   "X")
     (cons 9    "IX")
     (cons 5    "V")
     (cons 4    "IV")
     (cons 1    "I")))
  (define (build-roman n acc)
    (if (zero? n)
        acc
        (let loop ([pairs roman-pairs])
          (match pairs
            [(cons (cons val sym) rest)
             (if (>= n val)
                 (build-roman (- n val) (string-append acc sym))
                 (loop rest))])))
  (string-downcase (build-roman number "")))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-within (candidate 19) "xix" 0.001)
    (check-within (candidate 152) "clii" 0.001)
    (check-within (candidate 251) "ccli" 0.001)
    (check-within (candidate 426) "cdxxvi" 0.001)
    (check-within (candidate 500) "d" 0.001)
    (check-within (candidate 1) "i" 0.001)
    (check-within (candidate 4) "iv" 0.001)
    (check-within (candidate 43) "xliii" 0.001)
    (check-within (candidate 90) "xc" 0.001)
    (check-within (candidate 94) "xciv" 0.001)
    (check-within (candidate 532) "dxxxii" 0.001)
    (check-within (candidate 900) "cm" 0.001)
    (check-within (candidate 994) "cmxciv" 0.001)
    (check-within (candidate 1000) "m" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755828010
STDOUT: (empty)
STDERR:
/tmp/tmpi6vq4qbi.rkt:25:0: read-syntax: expected a `)` to close `(`
  possible cause: indentation suggests a missing `)` before line 51
  context...:
   /usr/share/racket/collects/syntax/module-reader.rkt:186:17: body
   /usr/share/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /usr/share/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"

(define (int_to_mini_roman number)
  ;; List of values and their corresponding Roman symbols (lower‑case)
  (define values '(1000 900 500 400 100 90 50 40 10 9 5 4 1))
  (define symbols '("m" "cm" "d" "cd" "c" "xc" "l" "xl" "x" "ix" "v" "iv" "i"))

  ;; Recursive helper that builds the result string
  (define (build n acc idx)
    (cond
      [(zero? n) acc]                                   ; finished
      [(>= n (list-ref values idx))
       (build (- n (list-ref values idx))
              (string-append acc (list-ref symbols idx))
              idx)]                                     ; stay on same idx
      [else
       (build n acc (+ idx 1))]))                       ; move to next value

  (build number "" 0))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-within (candidate 19) "xix" 0.001)
    (check-within (candidate 152) "clii" 0.001)
    (check-within (candidate 251) "ccli" 0.001)
    (check-within (candidate 426) "cdxxvi" 0.001)
    (check-within (candidate 500) "d" 0.001)
    (check-within (candidate 1) "i" 0.001)
    (check-within (candidate 4) "iv" 0.001)
    (check-within (candidate 43) "xliii" 0.001)
    (check-within (candidate 90) "xc" 0.001)
    (check-within (candidate 94) "xciv" 0.001)
    (check-within (candidate 532) "dxxxii" 0.001)
    (check-within (candidate 900) "cm" 0.001)
    (check-within (candidate 994) "cmxciv" 0.001)
    (check-within (candidate 1000) "m" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828010
STDOUT: (empty)
STDERR: (empty)
--------------------
