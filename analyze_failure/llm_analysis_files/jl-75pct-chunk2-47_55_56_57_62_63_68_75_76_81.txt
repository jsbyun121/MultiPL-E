As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 47 (JL) - HumanEval_47_median
================================================================================

PROMPT:
----------------------------------------
"""Return median of elements in the vector l.
>>> median([3, 1, 2, 4, 5])
3
>>> median([-10, 4, 6, 1000, 10, 20])
15.0"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = median;
	@test(candidate([3, 1, 2, 4, 5]) == 3)
	@test(candidate([-10, 4, 6, 1000, 10, 20]) == 8.0)
	@test(candidate([5]) == 5)
	@test(candidate([6, 5]) == 5.5)
	@test(candidate([8, 1, 3, 9, 9, 2, 7]) == 7)
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""Return median of elements in the vector l.
>>> median([3, 1, 2, 4, 5])
3
>>> median([-10, 4, 6, 1000, 10, 20])
15.0"""
"""
    median(l::Vector{Int64})::Float64

Return the median of the elements in the vector `l`.

# Examples
using Test

@testset begin

candidate = median;
	@test(candidate([3, 1, 2, 4, 5]) == 3)
	@test(candidate([-10, 4, 6, 1000, 10, 20]) == 8.0)
	@test(candidate([5]) == 5)
	@test(candidate([6, 5]) == 5.5)
	@test(candidate([8, 1, 3, 9, 9, 2, 7]) == 7)
end


EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755154562
STDOUT: (empty)
STDERR:
ERROR: LoadError: syntax: incomplete: invalid string syntax
Stacktrace:
 [1] top-level scope
   @ ~/tmp/tmpjanob1aj.jl:1
in expression starting at /tmp/tmpjanob1aj.jl:1
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""Return median of elements in the vector l.
>>> median([3, 1, 2, 4, 5])
3
>>> median([-10, 4, 6, 1000, 10, 20])
15.0"""
function median(l::Vector{Int64})::Float64
    # Sort the input vector
    sorted = sort(l)
    n = length(sorted)

    # If the number of elements is odd, return the middle element
    if isodd(n)
        return Float64(sorted[(n + 1) ÷ 2])
    end

    # If even, return the average of the two middle elements
    mid1 = sorted[n ÷ 2]
    mid2 = sorted[(n ÷ 2) + 1]
    return (mid1 + mid2) / 2.0
end
using Test

@testset begin

candidate = median;
	@test(candidate([3, 1, 2, 4, 5]) == 3)
	@test(candidate([-10, 4, 6, 1000, 10, 20]) == 8.0)
	@test(candidate([5]) == 5)
	@test(candidate([6, 5]) == 5.5)
	@test(candidate([8, 1, 3, 9, 9, 2, 7]) == 7)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154560
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    5      5  0.1s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""Return median of elements in the vector l.
>>> median([3, 1, 2, 4, 5])
3
>>> median([-10, 4, 6, 1000, 10, 20])
15.0"""
function median(l::Vector{Int64})::Float64
    # Sort the vector to bring elements in order
    sorted = sort(l)

    n = length(sorted)
    if n == 0
        error("Cannot compute median of an empty vector")
    end

    if isodd(n)
        # For odd length, return the middle element
        return Float64(sorted[(n + 1) ÷ 2])
    else
        # For even length, return the average of the two middle elements
        mid1 = sorted[n ÷ 2]
        mid2 = sorted[(n ÷ 2) + 1]
        return (Float64(mid1) + Float64(mid2)) / 2.0
    end
end
using Test

@testset begin

candidate = median;
	@test(candidate([3, 1, 2, 4, 5]) == 3)
	@test(candidate([-10, 4, 6, 1000, 10, 20]) == 8.0)
	@test(candidate([5]) == 5)
	@test(candidate([6, 5]) == 5.5)
	@test(candidate([8, 1, 3, 9, 9, 2, 7]) == 7)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154560
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    5      5  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""Return median of elements in the vector l.
>>> median([3, 1, 2, 4, 5])
3
>>> median([-10, 4, 6, 1000, 10, 20])
15.0"""
function median(l::Vector{Int64})::Float64
    # Sort a copy so we don't mutate the original vector
    sorted = sort(l)

    n = length(sorted)
    @assert n > 0 "median of an empty vector is undefined"

    if isodd(n)
        # For odd length, return the middle element as Float64
        return Float64(sorted[(n + 1) ÷ 2])
    else
        # For even length, average the two middle elements
        mid1 = sorted[n ÷ 2]
        mid2 = sorted[n ÷ 2 + 1]
        return (mid1 + mid2) / 2.0
    end
end
using Test

@testset begin

candidate = median;
	@test(candidate([3, 1, 2, 4, 5]) == 3)
	@test(candidate([-10, 4, 6, 1000, 10, 20]) == 8.0)
	@test(candidate([5]) == 5)
	@test(candidate([6, 5]) == 5.5)
	@test(candidate([8, 1, 3, 9, 9, 2, 7]) == 7)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154560
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    5      5  0.1s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 55 (JL) - HumanEval_55_fib
================================================================================

PROMPT:
----------------------------------------
"""Return n-th Fibonacci number.
>>> fib(10)
55
>>> fib(1)
1
>>> fib(8)
21"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = fib;
	@test(candidate(10) == 55)
	@test(candidate(1) == 1)
	@test(candidate(8) == 21)
	@test(candidate(11) == 89)
	@test(candidate(12) == 144)
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""Return n-th Fibonacci number.
>>> fib(10)
55
>>> fib(1)
1
>>> fib(8)
21"""
function fib(n::Int64)::Int64
    # Handle the base cases
    if n <= 0
        return 0
    elseif n == 1
        return 1
    end

    # Iteratively compute Fibonacci numbers
    a::Int64 = 0
    b::Int64 = 1
    for _ in 2:n
        a, b = b, a + b
    end
    return b
end
using Test

@testset begin

candidate = fib;
	@test(candidate(10) == 55)
	@test(candidate(1) == 1)
	@test(candidate(8) == 21)
	@test(candidate(11) == 89)
	@test(candidate(12) == 144)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154576
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    5      5  0.1s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""Return n-th Fibonacci number.
>>> fib(10)
55
>>> fib(1)
1
>>> fib(8)
21"""
function fib(n::Int64)::Int64
    # Return the n‑th Fibonacci number (1‑based indexing).
    # F(1) = 1, F(2) = 1, F(3) = 2, ...
    if n <= 0
        return 0
    elseif n == 1
        return 1
    end

    a = Int64(0)   # F(0)
    b = Int64(1)   # F(1)

    for _ in 2:n
        a, b = b, a + b
    end

    return b
end
using Test

@testset begin

candidate = fib;
	@test(candidate(10) == 55)
	@test(candidate(1) == 1)
	@test(candidate(8) == 21)
	@test(candidate(11) == 89)
	@test(candidate(12) == 144)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154576
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    5      5  0.1s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""Return n-th Fibonacci number.
>>> fib(10)
55
>>> fib(1)
1
>>> fib(8)
21"""
function fib(n::Int64)::Int64
    if n <= 0
        error("n must be a positive integer")
    elseif n == 1 || n == 2
        return 1
    else
        a, b = 1, 1
        for _ in 3:n
            a, b = b, a + b
        end
        return b
    end
end
using Test

@testset begin

candidate = fib;
	@test(candidate(10) == 55)
	@test(candidate(1) == 1)
	@test(candidate(8) == 21)
	@test(candidate(11) == 89)
	@test(candidate(12) == 144)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154576
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    5      5  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""Return n-th Fibonacci number.
>>> fib(10)
55
>>> fib(1)
1
>>> fib(8)
21"""
"""
Return n-th Fibonacci number.
>>> fib(10)
55
>>> fib(1)
1
>>> fib(8)
21
"""
function fib(n::Int64)::Int64
    if n <= 0
        error("n must be a positive integer")
    elseif n == 1 || n == 2
        return 1
    end

    a, b = 1, 1
    for _ in 3:n
        a, b = b, a + b
    end
    return b
end
using Test

@testset begin

candidate = fib;
	@test(candidate(10) == 55)
	@test(candidate(1) == 1)
	@test(candidate(8) == 21)
	@test(candidate(11) == 89)
	@test(candidate(12) == 144)
end


EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755154578
STDOUT: (empty)
STDERR:
ERROR: LoadError: cannot document the following expression:

"Return n-th Fibonacci number.\n>>> fib(10)\n55\n>>> fib(1)\n1\n>>> fib(8)\n21\n"

Stacktrace:
 [1] error(::String, ::String)
   @ Base ./error.jl:44
 [2] top-level scope
   @ ~/tmp/tmpzj69ozyo.jl:1
in expression starting at /tmp/tmpzj69ozyo.jl:1
--------------------

================================================================================
PROBLEM 56 (JL) - HumanEval_56_correct_bracketing
================================================================================

PROMPT:
----------------------------------------
""" brackets is a string of "<" and ">".
return true if every opening bracket has a corresponding closing bracket.
>>> correct_bracketing("<")
false
>>> correct_bracketing("<>")
true
>>> correct_bracketing("<<><>>")
true
>>> correct_bracketing("><<>")
false"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = correct_bracketing;
	@test(candidate("<>") == true)
	@test(candidate("<<><>>") == true)
	@test(candidate("<><><<><>><>") == true)
	@test(candidate("<><><<<><><>><>><<><><<>>>") == true)
	@test(candidate("<<<><>>>>") == false)
	@test(candidate("><<>") == false)
	@test(candidate("<") == false)
	@test(candidate("<<<<") == false)
	@test(candidate(">") == false)
	@test(candidate("<<>") == false)
	@test(candidate("<><><<><>><>><<>") == false)
	@test(candidate("<><><<><>><>>><>") == false)
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
""" brackets is a string of "<" and ">".
return true if every opening bracket has a corresponding closing bracket.
>>> correct_bracketing("<")
false
>>> correct_bracketing("<>")
true
>>> correct_bracketing("<<><>>")
true
>>> correct_bracketing("><<>")
false"""
function correct_bracketing(brackets::String)::Bool
    # Count of unmatched opening brackets
    balance = 0

    for ch in brackets
        if ch == '<'
            balance += 1
        elseif ch == '>'
            balance -= 1
            # A closing bracket without a matching opening one
            if balance < 0
                return false
            end
        else
            # The problem statement guarantees only '<' and '>' are present,
            # but we ignore any other characters just in case.
            continue
        end
    end

    # All opening brackets must have been closed
    return balance == 0
end
using Test

@testset begin

candidate = correct_bracketing;
	@test(candidate("<>") == true)
	@test(candidate("<<><>>") == true)
	@test(candidate("<><><<><>><>") == true)
	@test(candidate("<><><<<><><>><>><<><><<>>>") == true)
	@test(candidate("<<<><>>>>") == false)
	@test(candidate("><<>") == false)
	@test(candidate("<") == false)
	@test(candidate("<<<<") == false)
	@test(candidate(">") == false)
	@test(candidate("<<>") == false)
	@test(candidate("<><><<><>><>><<>") == false)
	@test(candidate("<><><<><>><>>><>") == false)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154579
STDOUT:
Test Summary: | Pass  Total  Time
test set      |   12     12  0.1s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
""" brackets is a string of "<" and ">".
return true if every opening bracket has a corresponding closing bracket.
>>> correct_bracketing("<")
false
>>> correct_bracketing("<>")
true
>>> correct_bracketing("<<><>>")
true
>>> correct_bracketing("><<>")
false"""
"""
    correct_bracketing(brackets::String)::Bool

Return `true` if every opening bracket `<` has a corresponding closing bracket `>`.  
The function checks that the brackets are properly nested and that no closing
bracket appears before its matching opening bracket.

# Examples
using Test

@testset begin

candidate = correct_bracketing;
	@test(candidate("<>") == true)
	@test(candidate("<<><>>") == true)
	@test(candidate("<><><<><>><>") == true)
	@test(candidate("<><><<<><><>><>><<><><<>>>") == true)
	@test(candidate("<<<><>>>>") == false)
	@test(candidate("><<>") == false)
	@test(candidate("<") == false)
	@test(candidate("<<<<") == false)
	@test(candidate(">") == false)
	@test(candidate("<<>") == false)
	@test(candidate("<><><<><>><>><<>") == false)
	@test(candidate("<><><<><>><>>><>") == false)
end


EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755154582
STDOUT: (empty)
STDERR:
ERROR: LoadError: syntax: incomplete: invalid string syntax
Stacktrace:
 [1] top-level scope
   @ ~/tmp/tmpxypfnp_f.jl:1
in expression starting at /tmp/tmpxypfnp_f.jl:1
--------------------

COMPLETION 3:
--------------------
PROGRAM:
""" brackets is a string of "<" and ">".
return true if every opening bracket has a corresponding closing bracket.
>>> correct_bracketing("<")
false
>>> correct_bracketing("<>")
true
>>> correct_bracketing("<<><>>")
true
>>> correct_bracketing("><<>")
false"""
function correct_bracketing(brackets::String)::Bool
    balance = 0
    for ch in brackets
        if ch == '<'
            balance += 1
        elseif ch == '>'
            balance -= 1
            # If we close more brackets than we have opened, it's invalid
            if balance < 0
                return false
            end
        else
            # Any other character makes the input invalid (optional)
            return false
        end
    end
    # All opening brackets must be closed
    return balance == 0
end
using Test

@testset begin

candidate = correct_bracketing;
	@test(candidate("<>") == true)
	@test(candidate("<<><>>") == true)
	@test(candidate("<><><<><>><>") == true)
	@test(candidate("<><><<<><><>><>><<><><<>>>") == true)
	@test(candidate("<<<><>>>>") == false)
	@test(candidate("><<>") == false)
	@test(candidate("<") == false)
	@test(candidate("<<<<") == false)
	@test(candidate(">") == false)
	@test(candidate("<<>") == false)
	@test(candidate("<><><<><>><>><<>") == false)
	@test(candidate("<><><<><>><>>><>") == false)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154579
STDOUT:
Test Summary: | Pass  Total  Time
test set      |   12     12  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
""" brackets is a string of "<" and ">".
return true if every opening bracket has a corresponding closing bracket.
>>> correct_bracketing("<")
false
>>> correct_bracketing("<>")
true
>>> correct_bracketing("<<><>>")
true
>>> correct_bracketing("><<>")
false"""
function correct_bracketing(brackets::String)::Bool
    balance = 0
    for ch in brackets
        if ch == '<'
            balance += 1
        elseif ch == '>'
            balance -= 1
            if balance < 0
                return false
            end
        else
            # Input should only contain '<' and '>'
            return false
        end
    end
    return balance == 0
end
using Test

@testset begin

candidate = correct_bracketing;
	@test(candidate("<>") == true)
	@test(candidate("<<><>>") == true)
	@test(candidate("<><><<><>><>") == true)
	@test(candidate("<><><<<><><>><>><<><><<>>>") == true)
	@test(candidate("<<<><>>>>") == false)
	@test(candidate("><<>") == false)
	@test(candidate("<") == false)
	@test(candidate("<<<<") == false)
	@test(candidate(">") == false)
	@test(candidate("<<>") == false)
	@test(candidate("<><><<><>><>><<>") == false)
	@test(candidate("<><><<><>><>>><>") == false)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154579
STDOUT:
Test Summary: | Pass  Total  Time
test set      |   12     12  0.1s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 57 (JL) - HumanEval_57_monotonic
================================================================================

PROMPT:
----------------------------------------
"""Return true is vector elements are monotonically increasing or decreasing.
>>> monotonic([1, 2, 4, 20])
true
>>> monotonic([1, 20, 4, 10])
false
>>> monotonic([4, 1, 0, -10])
true"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = monotonic;
	@test(candidate([1, 2, 4, 10]) == true)
	@test(candidate([1, 2, 4, 20]) == true)
	@test(candidate([1, 20, 4, 10]) == false)
	@test(candidate([4, 1, 0, -10]) == true)
	@test(candidate([4, 1, 1, 0]) == true)
	@test(candidate([1, 2, 3, 2, 5, 60]) == false)
	@test(candidate([1, 2, 3, 4, 5, 60]) == true)
	@test(candidate([9, 9, 9, 9]) == true)
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""Return true is vector elements are monotonically increasing or decreasing.
>>> monotonic([1, 2, 4, 20])
true
>>> monotonic([1, 20, 4, 10])
false
>>> monotonic([4, 1, 0, -10])
true"""
function monotonic(l::Vector{Int64})::Bool
    n = length(l)
    if n <= 1
        return true
    end
    inc = true   # assume increasing
    dec = true   # assume decreasing
    for i in 2:n
        if l[i] > l[i-1]
            dec = false          # cannot be decreasing
        elseif l[i] < l[i-1]
            inc = false          # cannot be increasing
        else
            # equal elements break strict monotonicity
            inc = false
            dec = false
        end
    end
    return inc || dec
end
using Test

@testset begin

candidate = monotonic;
	@test(candidate([1, 2, 4, 10]) == true)
	@test(candidate([1, 2, 4, 20]) == true)
	@test(candidate([1, 20, 4, 10]) == false)
	@test(candidate([4, 1, 0, -10]) == true)
	@test(candidate([4, 1, 1, 0]) == true)
	@test(candidate([1, 2, 3, 2, 5, 60]) == false)
	@test(candidate([1, 2, 3, 4, 5, 60]) == true)
	@test(candidate([9, 9, 9, 9]) == true)
end


EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755154586
STDOUT:
test set: Test Failed at /tmp/tmpiddsfgb2.jl:37
  Expression: candidate([4, 1, 1, 0]) == true
   Evaluated: false == true
Stacktrace:
 [1] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]
 [2] macro expansion
   @ ~/tmp/tmpiddsfgb2.jl:37 [inlined]
 [3] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]
 [4] top-level scope
   @ ~/tmp/tmpiddsfgb2.jl:32
test set: Test Failed at /tmp/tmpiddsfgb2.jl:40
  Expression: candidate([9, 9, 9, 9]) == true
   Evaluated: false == true
Stacktrace:
 [1] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]
 [2] macro expansion
   @ ~/tmp/tmpiddsfgb2.jl:40 [inlined]
 [3] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]
 [4] top-level scope
   @ ~/tmp/tmpiddsfgb2.jl:32
Test Summary: | Pass  Fail  Total  Time
test set      |    6     2      8  2.9s
STDERR:
ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored, 0 broken.
in expression starting at /tmp/tmpiddsfgb2.jl:30
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""Return true is vector elements are monotonically increasing or decreasing.
>>> monotonic([1, 2, 4, 20])
true
>>> monotonic([1, 20, 4, 10])
false
>>> monotonic([4, 1, 0, -10])
true"""
function monotonic(l::Vector{Int64})::Bool
    # Trivially true for empty or single‑element vectors
    length(l) <= 1 && return true

    inc = true   # flag for non‑decreasing
    dec = true   # flag for non‑increasing

    for i in 2:length(l)
        if l[i] > l[i-1]
            dec = false   # cannot be decreasing
        elseif l[i] < l[i-1]
            inc = false   # cannot be increasing
        end
    end

    # Return true if either monotonic direction holds
    return inc || dec
end
using Test

@testset begin

candidate = monotonic;
	@test(candidate([1, 2, 4, 10]) == true)
	@test(candidate([1, 2, 4, 20]) == true)
	@test(candidate([1, 20, 4, 10]) == false)
	@test(candidate([4, 1, 0, -10]) == true)
	@test(candidate([4, 1, 1, 0]) == true)
	@test(candidate([1, 2, 3, 2, 5, 60]) == false)
	@test(candidate([1, 2, 3, 4, 5, 60]) == true)
	@test(candidate([9, 9, 9, 9]) == true)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154583
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.1s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""Return true is vector elements are monotonically increasing or decreasing.
>>> monotonic([1, 2, 4, 20])
true
>>> monotonic([1, 20, 4, 10])
false
>>> monotonic([4, 1, 0, -10])
true"""
function monotonic(l::Vector{Int64})::Bool
    n = length(l)
    # Empty or single‑element vectors are trivially monotonic
    if n <= 1
        return true
    end

    inc = true   # flag for strictly increasing
    dec = true   # flag for strictly decreasing

    for i in 2:n
        if l[i] > l[i-1]
            dec = false          # cannot be decreasing
        elseif l[i] < l[i-1]
            inc = false          # cannot be increasing
        end
    end

    return inc || dec
end
using Test

@testset begin

candidate = monotonic;
	@test(candidate([1, 2, 4, 10]) == true)
	@test(candidate([1, 2, 4, 20]) == true)
	@test(candidate([1, 20, 4, 10]) == false)
	@test(candidate([4, 1, 0, -10]) == true)
	@test(candidate([4, 1, 1, 0]) == true)
	@test(candidate([1, 2, 3, 2, 5, 60]) == false)
	@test(candidate([1, 2, 3, 4, 5, 60]) == true)
	@test(candidate([9, 9, 9, 9]) == true)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154583
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""Return true is vector elements are monotonically increasing or decreasing.
>>> monotonic([1, 2, 4, 20])
true
>>> monotonic([1, 20, 4, 10])
false
>>> monotonic([4, 1, 0, -10])
true"""
function monotonic(l::Vector{Int64})::Bool
    # A vector with 0 or 1 element is trivially monotonic
    if length(l) <= 1
        return true
    end

    # Determine the overall trend based on the first non‑zero difference
    trend = 0   # 0 = not yet determined, 1 = increasing, -1 = decreasing
    for i in 1:(length(l)-1)
        d = l[i+1] - l[i]
        if d > 0
            if trend == -1
                return false
            end
            trend = 1
        elseif d < 0
            if trend == 1
                return false
            end
            trend = -1
        end
        # if d == 0 we simply ignore it
    end
    return true
end
using Test

@testset begin

candidate = monotonic;
	@test(candidate([1, 2, 4, 10]) == true)
	@test(candidate([1, 2, 4, 20]) == true)
	@test(candidate([1, 20, 4, 10]) == false)
	@test(candidate([4, 1, 0, -10]) == true)
	@test(candidate([4, 1, 1, 0]) == true)
	@test(candidate([1, 2, 3, 2, 5, 60]) == false)
	@test(candidate([1, 2, 3, 4, 5, 60]) == true)
	@test(candidate([9, 9, 9, 9]) == true)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154583
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.1s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 62 (JL) - HumanEval_62_derivative
================================================================================

PROMPT:
----------------------------------------
""" xs represent coefficients of a polynomial.
xs[0] + xs[1] * x + xs[2] * x^2 + ....
 Return derivative of this polynomial in the same form.
>>> derivative([3, 1, 2, 4, 5])
[1, 4, 12, 20]
>>> derivative([1, 2, 3])
[2, 6]"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = derivative;
	@test(candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20])
	@test(candidate([1, 2, 3]) == [2, 6])
	@test(candidate([3, 2, 1]) == [2, 2])
	@test(candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16])
	@test(candidate([1]) == Vector{Int64}([]))
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
""" xs represent coefficients of a polynomial.
xs[0] + xs[1] * x + xs[2] * x^2 + ....
 Return derivative of this polynomial in the same form.
>>> derivative([3, 1, 2, 4, 5])
[1, 4, 12, 20]
>>> derivative([1, 2, 3])
[2, 6]"""
function derivative(xs::Vector{Int64})::Vector{Int64}
    # If the polynomial has no terms or only a constant term, the derivative is empty
    n = length(xs)
    if n <= 1
        return Int64[]
    end

    # Preallocate the result vector for efficiency
    result = Vector{Int64}(undef, n - 1)

    # Compute each derivative coefficient: (i-1) * xs[i]
    for i in 2:n
        result[i - 1] = (i - 1) * xs[i]
    end

    return result
end
using Test

@testset begin

candidate = derivative;
	@test(candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20])
	@test(candidate([1, 2, 3]) == [2, 6])
	@test(candidate([3, 2, 1]) == [2, 2])
	@test(candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16])
	@test(candidate([1]) == Vector{Int64}([]))
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154594
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    5      5  0.1s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
""" xs represent coefficients of a polynomial.
xs[0] + xs[1] * x + xs[2] * x^2 + ....
 Return derivative of this polynomial in the same form.
>>> derivative([3, 1, 2, 4, 5])
[1, 4, 12, 20]
>>> derivative([1, 2, 3])
[2, 6]"""
function derivative(xs::Vector{Int64})::Vector{Int64}
    n = length(xs)
    # The derivative of a constant or empty polynomial is the empty vector
    return Int64[] if n <= 1

    # For each power k (starting from 1), multiply the coefficient by k
    return [k * xs[k + 1] for k in 1:n-1]
end
using Test

@testset begin

candidate = derivative;
	@test(candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20])
	@test(candidate([1, 2, 3]) == [2, 6])
	@test(candidate([3, 2, 1]) == [2, 2])
	@test(candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16])
	@test(candidate([1]) == Vector{Int64}([]))
end


EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755154596
STDOUT: (empty)
STDERR:
ERROR: LoadError: syntax: "function" at /tmp/tmpm0_f81hl.jl:8 expected "end", got "if"
Stacktrace:
 [1] top-level scope
   @ ~/tmp/tmpm0_f81hl.jl:11
in expression starting at /tmp/tmpm0_f81hl.jl:11
--------------------

COMPLETION 3:
--------------------
PROGRAM:
""" xs represent coefficients of a polynomial.
xs[0] + xs[1] * x + xs[2] * x^2 + ....
 Return derivative of this polynomial in the same form.
>>> derivative([3, 1, 2, 4, 5])
[1, 4, 12, 20]
>>> derivative([1, 2, 3])
[2, 6]"""
function derivative(xs::Vector{Int64})::Vector{Int64}
    n = length(xs)
    if n <= 1
        return Int64[]
    end
    res = Vector{Int64}(undef, n - 1)
    for i in 1:n - 1
        res[i] = xs[i + 1] * i
    end
    return res
end
using Test

@testset begin

candidate = derivative;
	@test(candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20])
	@test(candidate([1, 2, 3]) == [2, 6])
	@test(candidate([3, 2, 1]) == [2, 2])
	@test(candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16])
	@test(candidate([1]) == Vector{Int64}([]))
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154594
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    5      5  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
""" xs represent coefficients of a polynomial.
xs[0] + xs[1] * x + xs[2] * x^2 + ....
 Return derivative of this polynomial in the same form.
>>> derivative([3, 1, 2, 4, 5])
[1, 4, 12, 20]
>>> derivative([1, 2, 3])
[2, 6]"""
function derivative(xs::Vector{Int64})::Vector{Int64}
    n = length(xs)
    if n <= 1
        return Int64[]
    end
    res = Vector{Int64}(undef, n - 1)
    for i in 2:n
        res[i - 1] = xs[i] * (i - 1)
    end
    return res
end
using Test

@testset begin

candidate = derivative;
	@test(candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20])
	@test(candidate([1, 2, 3]) == [2, 6])
	@test(candidate([3, 2, 1]) == [2, 2])
	@test(candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16])
	@test(candidate([1]) == Vector{Int64}([]))
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154594
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    5      5  0.1s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 63 (JL) - HumanEval_63_fibfib
================================================================================

PROMPT:
----------------------------------------
"""The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
fibfib(0) == 0
fibfib(1) == 0
fibfib(2) == 1
fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
Please write a function to efficiently compute the n-th element of the fibfib number sequence.
>>> fibfib(1)
0
>>> fibfib(5)
4
>>> fibfib(8)
24"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = fibfib;
	@test(candidate(2) == 1)
	@test(candidate(1) == 0)
	@test(candidate(5) == 4)
	@test(candidate(8) == 24)
	@test(candidate(10) == 81)
	@test(candidate(12) == 274)
	@test(candidate(14) == 927)
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
fibfib(0) == 0
fibfib(1) == 0
fibfib(2) == 1
fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
Please write a function to efficiently compute the n-th element of the fibfib number sequence.
>>> fibfib(1)
0
>>> fibfib(5)
4
>>> fibfib(8)
24"""
"""
    fibfib(n::Int64)::Int64

Compute the n‑th element of the FibFib sequence defined by
using Test

@testset begin

candidate = fibfib;
	@test(candidate(2) == 1)
	@test(candidate(1) == 0)
	@test(candidate(5) == 4)
	@test(candidate(8) == 24)
	@test(candidate(10) == 81)
	@test(candidate(12) == 274)
	@test(candidate(14) == 927)
end


EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755154599
STDOUT: (empty)
STDERR:
ERROR: LoadError: syntax: incomplete: invalid string syntax
Stacktrace:
 [1] top-level scope
   @ ~/tmp/tmp8wlyat09.jl:1
in expression starting at /tmp/tmp8wlyat09.jl:1
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
fibfib(0) == 0
fibfib(1) == 0
fibfib(2) == 1
fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
Please write a function to efficiently compute the n-th element of the fibfib number sequence.
>>> fibfib(1)
0
>>> fibfib(5)
4
>>> fibfib(8)
24"""
# FibFib sequence: fibfib(0)=0, fibfib(1)=0, fibfib(2)=1,
# fibfib(n)=fibfib(n-1)+fibfib(n-2)+fibfib(n-3)
function fibfib(n::Int64)::Int64
    @assert n ≥ 0 "n must be non‑negative"

    # Handle the base cases directly
    if n == 0 || n == 1
        return 0
    elseif n == 2
        return 1
    end

    # Use three rolling variables to keep the last three values
    a, b, c = 0, 0, 1   # fibfib(0), fibfib(1), fibfib(2)
    for _ in 3:n
        a, b, c = b, c, a + b + c
    end
    return c
end
using Test

@testset begin

candidate = fibfib;
	@test(candidate(2) == 1)
	@test(candidate(1) == 0)
	@test(candidate(5) == 4)
	@test(candidate(8) == 24)
	@test(candidate(10) == 81)
	@test(candidate(12) == 274)
	@test(candidate(14) == 927)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154597
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    7      7  0.1s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
fibfib(0) == 0
fibfib(1) == 0
fibfib(2) == 1
fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
Please write a function to efficiently compute the n-th element of the fibfib number sequence.
>>> fibfib(1)
0
>>> fibfib(5)
4
>>> fibfib(8)
24"""
function fibfib(n::Int64)::Int64
    if n < 0
        error("n must be non‑negative")
    elseif n == 0 || n == 1
        return 0
    elseif n == 2
        return 1
    end

    # Iterative dynamic programming
    a, b, c = 0, 0, 1          # fibfib(0), fibfib(1), fibfib(2)
    for i in 3:n
        d = a + b + c
        a, b, c = b, c, d
    end
    return c
end
using Test

@testset begin

candidate = fibfib;
	@test(candidate(2) == 1)
	@test(candidate(1) == 0)
	@test(candidate(5) == 4)
	@test(candidate(8) == 24)
	@test(candidate(10) == 81)
	@test(candidate(12) == 274)
	@test(candidate(14) == 927)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154597
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    7      7  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
fibfib(0) == 0
fibfib(1) == 0
fibfib(2) == 1
fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
Please write a function to efficiently compute the n-th element of the fibfib number sequence.
>>> fibfib(1)
0
>>> fibfib(5)
4
>>> fibfib(8)
24"""
function fibfib(n::Int64)::Int64
    if n < 0
        throw(ArgumentError("n must be non‑negative"))
    end
    if n == 0 || n == 1
        return 0
    elseif n == 2
        return 1
    end

    a, b, c = 0, 0, 1
    for _ in 3:n
        a, b, c = b, c, a + b + c
    end
    return c
end
using Test

@testset begin

candidate = fibfib;
	@test(candidate(2) == 1)
	@test(candidate(1) == 0)
	@test(candidate(5) == 4)
	@test(candidate(8) == 24)
	@test(candidate(10) == 81)
	@test(candidate(12) == 274)
	@test(candidate(14) == 927)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154597
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    7      7  0.1s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 68 (JL) - HumanEval_68_pluck
================================================================================

PROMPT:
----------------------------------------
""""Given a vector representing a branch of a tree that has non-negative integer nodes
your task is to pluck one of the nodes and return it.
The plucked node should be the node with the smallest even value.
If multiple nodes with the same smallest even value are found return the node that has smallest index.
The plucked node should be returned in a vector, [ smalest_value, its index ],
If there are no even values or the given vector is empty, return [].
Example 1:
>>> pluck([4, 2, 3])
[2, 1]
Explanation: 2 has the smallest even value, and 2 has the smallest index.
Example 2:
>>> pluck([1, 2, 3])
[2, 1]
Explanation: 2 has the smallest even value, and 2 has the smallest index.
Example 3:
>>> pluck([])
[]
Example 4:
>>> pluck([5, 0, 3, 0, 4, 2])
[0, 1]
Explanation: 0 is the smallest value, but  there are two zeros,
             so we will choose the first zero, which has the smallest index.
Constraints:
    * 1 <= nodes.length <= 10000
    * 0 <= node.value"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = pluck;
	@test(candidate([4, 2, 3]) == [2, 1])
	@test(candidate([1, 2, 3]) == [2, 1])
	@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))
	@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])
	@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])
	@test(candidate([5, 4, 8, 4, 8]) == [4, 1])
	@test(candidate([7, 6, 7, 1]) == [6, 1])
	@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
""""Given a vector representing a branch of a tree that has non-negative integer nodes
your task is to pluck one of the nodes and return it.
The plucked node should be the node with the smallest even value.
If multiple nodes with the same smallest even value are found return the node that has smallest index.
The plucked node should be returned in a vector, [ smalest_value, its index ],
If there are no even values or the given vector is empty, return [].
Example 1:
>>> pluck([4, 2, 3])
[2, 1]
Explanation: 2 has the smallest even value, and 2 has the smallest index.
Example 2:
>>> pluck([1, 2, 3])
[2, 1]
Explanation: 2 has the smallest even value, and 2 has the smallest index.
Example 3:
>>> pluck([])
[]
Example 4:
>>> pluck([5, 0, 3, 0, 4, 2])
[0, 1]
Explanation: 0 is the smallest value, but  there are two zeros,
             so we will choose the first zero, which has the smallest index.
Constraints:
    * 1 <= nodes.length <= 10000
    * 0 <= node.value"""
function pluck(arr::Vector{Int64})::Vector{Int64}
    # If the vector is empty, immediately return an empty vector
    if isempty(arr)
        return Int64[]
    end

    # Initialise with maximum possible value and an invalid index
    min_val = typemax(Int64)
    min_idx = -1  # 0‑based index, -1 indicates "not found"

    # Iterate over the array with 1‑based indices
    for (i, v) in enumerate(arr)
        # Check for even values (including zero)
        if v % 2 == 0
            # Convert to 0‑based index for comparison
            idx0 = i - 1
            if v < min_val || (v == min_val && idx0 < min_idx)
                min_val = v
                min_idx = idx0
            end
        end
    end

    # If no even value was found, return an empty vector
    if min_idx == -1
        return Int64[]
    end

    # Return the smallest even value and its 0‑based index
    return [min_val, min_idx]
end
using Test

@testset begin

candidate = pluck;
	@test(candidate([4, 2, 3]) == [2, 1])
	@test(candidate([1, 2, 3]) == [2, 1])
	@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))
	@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])
	@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])
	@test(candidate([5, 4, 8, 4, 8]) == [4, 1])
	@test(candidate([7, 6, 7, 1]) == [6, 1])
	@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154611
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.1s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
""""Given a vector representing a branch of a tree that has non-negative integer nodes
your task is to pluck one of the nodes and return it.
The plucked node should be the node with the smallest even value.
If multiple nodes with the same smallest even value are found return the node that has smallest index.
The plucked node should be returned in a vector, [ smalest_value, its index ],
If there are no even values or the given vector is empty, return [].
Example 1:
>>> pluck([4, 2, 3])
[2, 1]
Explanation: 2 has the smallest even value, and 2 has the smallest index.
Example 2:
>>> pluck([1, 2, 3])
[2, 1]
Explanation: 2 has the smallest even value, and 2 has the smallest index.
Example 3:
>>> pluck([])
[]
Example 4:
>>> pluck([5, 0, 3, 0, 4, 2])
[0, 1]
Explanation: 0 is the smallest value, but  there are two zeros,
             so we will choose the first zero, which has the smallest index.
Constraints:
    * 1 <= nodes.length <= 10000
    * 0 <= node.value"""
function pluck(arr::Vector{Int64})::Vector{Int64}
    # If the input is empty, return an empty vector
    if isempty(arr)
        return Int64[]
    end

    min_even = nothing   # will hold the smallest even value found
    min_index = -1       # will hold the index of that value

    for (idx, val) in enumerate(arr)
        if iseven(val)          # check for evenness (includes 0)
            if isnothing(min_even) || val < min_even
                min_even = val
                min_index = idx - 1   # convert to 0‑based index
            end
            # If val == min_even we keep the earlier index, so no update
        end
    end

    # If no even value was found, return an empty vector
    if isnothing(min_even)
        return Int64[]
    end

    return [min_even, Int64(min_index)]
end
using Test

@testset begin

candidate = pluck;
	@test(candidate([4, 2, 3]) == [2, 1])
	@test(candidate([1, 2, 3]) == [2, 1])
	@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))
	@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])
	@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])
	@test(candidate([5, 4, 8, 4, 8]) == [4, 1])
	@test(candidate([7, 6, 7, 1]) == [6, 1])
	@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154611
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.1s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
""""Given a vector representing a branch of a tree that has non-negative integer nodes
your task is to pluck one of the nodes and return it.
The plucked node should be the node with the smallest even value.
If multiple nodes with the same smallest even value are found return the node that has smallest index.
The plucked node should be returned in a vector, [ smalest_value, its index ],
If there are no even values or the given vector is empty, return [].
Example 1:
>>> pluck([4, 2, 3])
[2, 1]
Explanation: 2 has the smallest even value, and 2 has the smallest index.
Example 2:
>>> pluck([1, 2, 3])
[2, 1]
Explanation: 2 has the smallest even value, and 2 has the smallest index.
Example 3:
>>> pluck([])
[]
Example 4:
>>> pluck([5, 0, 3, 0, 4, 2])
[0, 1]
Explanation: 0 is the smallest value, but  there are two zeros,
             so we will choose the first zero, which has the smallest index.
Constraints:
    * 1 <= nodes.length <= 10000
    * 0 <= node.value"""
function pluck(arr::Vector{Int64})::Vector{Int64}
    # Track the smallest even value and its zero‑based index
    min_val  = typemax(Int64)
    min_idx  = -1

    for (i, v) in enumerate(arr)          # i is 1‑based
        if v % 2 == 0 && v < min_val      # even and smaller than current min
            min_val = v
            min_idx = i - 1               # convert to zero‑based index
        end
    end

    return min_idx == -1 ? Int64[] : [min_val, min_idx]
end
using Test

@testset begin

candidate = pluck;
	@test(candidate([4, 2, 3]) == [2, 1])
	@test(candidate([1, 2, 3]) == [2, 1])
	@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))
	@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])
	@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])
	@test(candidate([5, 4, 8, 4, 8]) == [4, 1])
	@test(candidate([7, 6, 7, 1]) == [6, 1])
	@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154611
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
""""Given a vector representing a branch of a tree that has non-negative integer nodes
your task is to pluck one of the nodes and return it.
The plucked node should be the node with the smallest even value.
If multiple nodes with the same smallest even value are found return the node that has smallest index.
The plucked node should be returned in a vector, [ smalest_value, its index ],
If there are no even values or the given vector is empty, return [].
Example 1:
>>> pluck([4, 2, 3])
[2, 1]
Explanation: 2 has the smallest even value, and 2 has the smallest index.
Example 2:
>>> pluck([1, 2, 3])
[2, 1]
Explanation: 2 has the smallest even value, and 2 has the smallest index.
Example 3:
>>> pluck([])
[]
Example 4:
>>> pluck([5, 0, 3, 0, 4, 2])
[0, 1]
Explanation: 0 is the smallest value, but  there are two zeros,
             so we will choose the first zero, which has the smallest index.
Constraints:
    * 1 <= nodes.length <= 10000
    * 0 <= node.value"""
function pluck(arr::Vector{Int64})::Vector{Int64}
    # Track the best candidate
    best_val = typemax(Int64)   # largest possible Int64
    best_idx = 0
    found = false

    for (i, v) in enumerate(arr)
        if iseven(v)
            if !found || v < best_val || (v == best_val && i < best_idx)
                best_val = v
                best_idx = i
                found = true
            end
        end
    end

    return found ? [best_val, best_idx] : Int64[]
end
using Test

@testset begin

candidate = pluck;
	@test(candidate([4, 2, 3]) == [2, 1])
	@test(candidate([1, 2, 3]) == [2, 1])
	@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))
	@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])
	@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])
	@test(candidate([5, 4, 8, 4, 8]) == [4, 1])
	@test(candidate([7, 6, 7, 1]) == [6, 1])
	@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))
end


EXECUTION RESULTS:
Exit Code: -1
Status: Timeout
Timestamp: 1755154615
STDOUT:
test set: Test Failed at /tmp/tmpk73ydd3c.jl:49
  Expression: candidate([4, 2, 3]) == [2, 1]
   Evaluated: [2, 2] == [2, 1]
Stacktrace:
 [1] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]
 [2] macro expansion
   @ ~/tmp/tmpk73ydd3c.jl:49 [inlined]
 [3] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]
 [4] top-level scope
   @ ~/tmp/tmpk73ydd3c.jl:48
test set: Test Failed at /tmp/tmpk73ydd3c.jl:50
  Expression: candidate([1, 2, 3]) == [2, 1]
   Evaluated: [2, 2] == [2, 1]
Stacktrace:
 [1] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]
 [2] macro expansion
   @ ~/tmp/tmpk73ydd3c.jl:50 [inlined]
 [3] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]
 [4] top-level scope
   @ ~/tmp/tmpk73ydd3c.jl:48
test set: Test Failed at /tmp/tmpk73ydd3c.jl:52
  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]
   Evaluated: [0, 2] == [0, 1]
Stacktrace:
 [1] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]
 [2] macro expansion
   @ ~/tmp/tmpk73ydd3c.jl:52 [inlined]
 [3] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]
 [4] top-level scope
   @ ~/tmp/tmpk73ydd3c.jl:48
test set: Test Failed at /tmp/tmpk73ydd3c.jl:53
  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]
   Evaluated: [0, 4] == [0, 3]
Stacktrace:
 [1] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]
 [2] macro expansion
   @ ~/tmp/tmpk73ydd3c.jl:53 [inlined]
 [3] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]
 [4] top-level scope
   @ ~/tmp/tmpk73ydd3c.jl:48
test set: Test Failed at /tmp/tmpk73ydd3c.jl:54
  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]
   Evaluated: [4, 2] == [4, 1]
Stacktrace:
 [1] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]
 [2] macro expansion
   @ ~/tmp/tmpk73ydd3c.j
STDERR:
ERROR: LoadError:
--------------------

================================================================================
PROBLEM 75 (JL) - HumanEval_75_is_multiply_prime
================================================================================

PROMPT:
----------------------------------------
"""Write a function that returns true if the given number is the multiplication of 3 prime numbers
and false otherwise.
Knowing that (a) is less then 100. 
Example:
>>> is_multiply_prime(30)
true
30 = 2 * 3 * 5"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = is_multiply_prime;
	@test(candidate(5) == false)
	@test(candidate(30) == true)
	@test(candidate(8) == true)
	@test(candidate(10) == false)
	@test(candidate(125) == true)
	@test(candidate(105) == true)
	@test(candidate(126) == false)
	@test(candidate(729) == false)
	@test(candidate(891) == false)
	@test(candidate(1001) == true)
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""Write a function that returns true if the given number is the multiplication of 3 prime numbers
and false otherwise.
Knowing that (a) is less then 100. 
Example:
>>> is_multiply_prime(30)
true
30 = 2 * 3 * 5"""
# Write a function that returns true if the given number is the multiplication of 3 prime numbers
# and false otherwise.
# Knowing that (a) is less then 100. 
# Example:
# >>> is_multiply_prime(30)
# true
# 30 = 2 * 3 * 5

function is_multiply_prime(a::Int64)::Bool
    # Negative numbers, 0, and 1 cannot be expressed as a product of primes
    if a <= 1
        return false
    end

    # Count prime factors (with multiplicity)
    count = 0
    n = a

    # Check divisibility by 2 first
    while n % 2 == 0
        count += 1
        n ÷= 2
    end

    # Check odd factors up to sqrt(n)
    p = 3
    while p * p <= n
        while n % p == 0
            count += 1
            n ÷= p
        end
        p += 2
    end

    # If n > 1, it is a prime factor larger than sqrt(original a)
    if n > 1
        count += 1
    end

    # Return true only if exactly three prime factors were found
    return count == 3
end
using Test

@testset begin

candidate = is_multiply_prime;
	@test(candidate(5) == false)
	@test(candidate(30) == true)
	@test(candidate(8) == true)
	@test(candidate(10) == false)
	@test(candidate(125) == true)
	@test(candidate(105) == true)
	@test(candidate(126) == false)
	@test(candidate(729) == false)
	@test(candidate(891) == false)
	@test(candidate(1001) == true)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154626
STDOUT:
Test Summary: | Pass  Total  Time
test set      |   10     10  0.1s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""Write a function that returns true if the given number is the multiplication of 3 prime numbers
and false otherwise.
Knowing that (a) is less then 100. 
Example:
>>> is_multiply_prime(30)
true
30 = 2 * 3 * 5"""
function is_multiply_prime(a::Int64)::Bool
    # A product of three primes must have at least 2 as a factor
    if a <= 1
        return false
    end

    count = 0          # total number of prime factors (with multiplicity)
    n = a
    i = 2
    while i * i <= n
        while n % i == 0
            count += 1
            n ÷= i
            # If we already have more than 3 factors, we can stop early
            if count > 3
                return false
            end
        end
        i += 1
    end

    # If after the loop n > 1, it is a prime factor left
    if n > 1
        count += 1
    end

    return count == 3
end
using Test

@testset begin

candidate = is_multiply_prime;
	@test(candidate(5) == false)
	@test(candidate(30) == true)
	@test(candidate(8) == true)
	@test(candidate(10) == false)
	@test(candidate(125) == true)
	@test(candidate(105) == true)
	@test(candidate(126) == false)
	@test(candidate(729) == false)
	@test(candidate(891) == false)
	@test(candidate(1001) == true)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154626
STDOUT:
Test Summary: | Pass  Total  Time
test set      |   10     10  0.1s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""Write a function that returns true if the given number is the multiplication of 3 prime numbers
and false otherwise.
Knowing that (a) is less then 100. 
Example:
>>> is_multiply_prime(30)
true
30 = 2 * 3 * 5"""
"""
    is_multiply_prime(a::Int64)::Bool

Return `true` if `a` can be expressed as the product of **exactly three prime numbers**  
(allowing repetitions), and `false` otherwise.  

The function works for any positive integer, but the problem statement guarantees `a < 100`.  
Examples
using Test

@testset begin

candidate = is_multiply_prime;
	@test(candidate(5) == false)
	@test(candidate(30) == true)
	@test(candidate(8) == true)
	@test(candidate(10) == false)
	@test(candidate(125) == true)
	@test(candidate(105) == true)
	@test(candidate(126) == false)
	@test(candidate(729) == false)
	@test(candidate(891) == false)
	@test(candidate(1001) == true)
end


EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755154628
STDOUT: (empty)
STDERR:
ERROR: LoadError: syntax: incomplete: invalid string syntax
Stacktrace:
 [1] top-level scope
   @ ~/tmp/tmpq8y670t3.jl:1
in expression starting at /tmp/tmpq8y670t3.jl:1
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""Write a function that returns true if the given number is the multiplication of 3 prime numbers
and false otherwise.
Knowing that (a) is less then 100. 
Example:
>>> is_multiply_prime(30)
true
30 = 2 * 3 * 5"""
function is_multiply_prime(a::Int64)::Bool
    # Numbers less than 2 cannot be product of primes
    if a < 2
        return false
    end

    n = a
    prime_factor_count = 0

    # Check divisibility by 2 first to handle even numbers efficiently
    while n % 2 == 0
        prime_factor_count += 1
        n ÷= 2
    end

    # Check odd divisors up to sqrt(n)
    p = 3
    while p * p <= n
        while n % p == 0
            prime_factor_count += 1
            n ÷= p
        end
        p += 2
    end

    # If there's any remaining prime factor > sqrt(original n)
    if n > 1
        prime_factor_count += 1
    end

    # Return true only if exactly three prime factors were found
    return prime_factor_count == 3
end
using Test

@testset begin

candidate = is_multiply_prime;
	@test(candidate(5) == false)
	@test(candidate(30) == true)
	@test(candidate(8) == true)
	@test(candidate(10) == false)
	@test(candidate(125) == true)
	@test(candidate(105) == true)
	@test(candidate(126) == false)
	@test(candidate(729) == false)
	@test(candidate(891) == false)
	@test(candidate(1001) == true)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154626
STDOUT:
Test Summary: | Pass  Total  Time
test set      |   10     10  0.1s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 76 (JL) - HumanEval_76_is_simple_power
================================================================================

PROMPT:
----------------------------------------
"""Your task is to write a function that returns true if a number x is a simple
power of n and false in other cases.
x is a simple power of n if n**int=x
For example:
>>> is_simple_power(1, 4)
true
>>> is_simple_power(2, 2)
true
>>> is_simple_power(8, 2)
true
>>> is_simple_power(3, 2)
false
>>> is_simple_power(3, 1)
false
>>> is_simple_power(5, 3)
false"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = is_simple_power;
	@test(candidate(16, 2) == true)
	@test(candidate(143214, 16) == false)
	@test(candidate(4, 2) == true)
	@test(candidate(9, 3) == true)
	@test(candidate(16, 4) == true)
	@test(candidate(24, 2) == false)
	@test(candidate(128, 4) == false)
	@test(candidate(12, 6) == false)
	@test(candidate(1, 1) == true)
	@test(candidate(1, 12) == true)
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""Your task is to write a function that returns true if a number x is a simple
power of n and false in other cases.
x is a simple power of n if n**int=x
For example:
>>> is_simple_power(1, 4)
true
>>> is_simple_power(2, 2)
true
>>> is_simple_power(8, 2)
true
>>> is_simple_power(3, 2)
false
>>> is_simple_power(3, 1)
false
>>> is_simple_power(5, 3)
false"""
# Return true if x is a simple power of n (i.e. x == n^k for some integer k ≥ 0)
function is_simple_power(x::Int64, n::Int64)::Bool
    # 0 is a power of n only when n == 0 (0^k = 0 for k > 0)
    if x == 0
        return n == 0
    end

    # 1 is a power of n for any n ≠ 0 (n^0 = 1)
    if x == 1
        return n != 0
    end

    # Handle trivial bases
    if n == 1
        return x == 1
    elseif n == -1
        return x == 1 || x == -1
    elseif n == 0
        # n == 0 and x != 0 already handled above
        return false
    end

    # For other bases, iterate multiplying until we reach or exceed x
    power = 1
    while abs(power) <= abs(x)
        if power == x
            return true
        end
        # Prevent overflow: if next multiplication would exceed abs(x), break
        if abs(power) > abs(x) ÷ abs(n)
            break
        end
        power *= n
    end
    return false
end
using Test

@testset begin

candidate = is_simple_power;
	@test(candidate(16, 2) == true)
	@test(candidate(143214, 16) == false)
	@test(candidate(4, 2) == true)
	@test(candidate(9, 3) == true)
	@test(candidate(16, 4) == true)
	@test(candidate(24, 2) == false)
	@test(candidate(128, 4) == false)
	@test(candidate(12, 6) == false)
	@test(candidate(1, 1) == true)
	@test(candidate(1, 12) == true)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154630
STDOUT:
Test Summary: | Pass  Total  Time
test set      |   10     10  0.1s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""Your task is to write a function that returns true if a number x is a simple
power of n and false in other cases.
x is a simple power of n if n**int=x
For example:
>>> is_simple_power(1, 4)
true
>>> is_simple_power(2, 2)
true
>>> is_simple_power(8, 2)
true
>>> is_simple_power(3, 2)
false
>>> is_simple_power(3, 1)
false
>>> is_simple_power(5, 3)
false"""
function is_simple_power(x::Int64, n::Int64)::Bool
    # Handle trivial and special cases
    if n == 0
        # 0^k is 0 for k>0, undefined for k=0, so only x==0 could be considered,
        # but we treat it as false for simplicity.
        return false
    elseif n == 1
        # 1^k == 1 for any integer k, so only x==1 is a simple power.
        return x == 1
    elseif n == -1
        # (-1)^k alternates between 1 and -1.
        return x == 1 || x == -1
    end

    # For positive n > 1
    if x == 1
        return true          # n^0 == 1
    elseif x < 1
        return false          # n^k > 0 for n>1, so cannot reach negative or zero
    end

    # Repeatedly divide x by n; if at any step it's not divisible, it's not a power.
    while x > 1 && n > 1
        if x % n != 0
            return false
        end
        x ÷= n
    end

    # If we ended up with 1, x was a perfect power of n.
    return x == 1
end
using Test

@testset begin

candidate = is_simple_power;
	@test(candidate(16, 2) == true)
	@test(candidate(143214, 16) == false)
	@test(candidate(4, 2) == true)
	@test(candidate(9, 3) == true)
	@test(candidate(16, 4) == true)
	@test(candidate(24, 2) == false)
	@test(candidate(128, 4) == false)
	@test(candidate(12, 6) == false)
	@test(candidate(1, 1) == true)
	@test(candidate(1, 12) == true)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154630
STDOUT:
Test Summary: | Pass  Total  Time
test set      |   10     10  0.1s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""Your task is to write a function that returns true if a number x is a simple
power of n and false in other cases.
x is a simple power of n if n**int=x
For example:
>>> is_simple_power(1, 4)
true
>>> is_simple_power(2, 2)
true
>>> is_simple_power(8, 2)
true
>>> is_simple_power(3, 2)
false
>>> is_simple_power(3, 1)
false
>>> is_simple_power(5, 3)
false"""
function is_simple_power(x::Int64, n::Int64)::Bool
    # Basic sanity checks
    if x <= 0 || n <= 0
        return false
    end

    # Special case: only 1 can be a power of 1
    if n == 1
        return x == 1
    end

    # Repeatedly multiply by n until we reach or exceed x
    p = 1
    while p < x
        # Prevent overflow: if multiplying would exceed the Int64 range, stop
        if p > typemax(Int64) ÷ n
            break
        end
        p *= n
        if p == x
            return true
        end
    end

    return false
end
using Test

@testset begin

candidate = is_simple_power;
	@test(candidate(16, 2) == true)
	@test(candidate(143214, 16) == false)
	@test(candidate(4, 2) == true)
	@test(candidate(9, 3) == true)
	@test(candidate(16, 4) == true)
	@test(candidate(24, 2) == false)
	@test(candidate(128, 4) == false)
	@test(candidate(12, 6) == false)
	@test(candidate(1, 1) == true)
	@test(candidate(1, 12) == true)
end


EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755154633
STDOUT:
test set: Test Failed at /tmp/tmphfra35b4.jl:57
  Expression: candidate(1, 12) == true
   Evaluated: false == true
Stacktrace:
 [1] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]
 [2] macro expansion
   @ ~/tmp/tmphfra35b4.jl:57 [inlined]
 [3] macro expansion
   @ ~/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]
 [4] top-level scope
   @ ~/tmp/tmphfra35b4.jl:47
Test Summary: | Pass  Fail  Total  Time
test set      |    9     1     10  2.7s
STDERR:
ERROR: LoadError: Some tests did not pass: 9 passed, 1 failed, 0 errored, 0 broken.
in expression starting at /tmp/tmphfra35b4.jl:45
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""Your task is to write a function that returns true if a number x is a simple
power of n and false in other cases.
x is a simple power of n if n**int=x
For example:
>>> is_simple_power(1, 4)
true
>>> is_simple_power(2, 2)
true
>>> is_simple_power(8, 2)
true
>>> is_simple_power(3, 2)
false
>>> is_simple_power(3, 1)
false
>>> is_simple_power(5, 3)
false"""
function is_simple_power(x::Int64, n::Int64)::Bool
    # 1 is a power of any n (n^0)
    if x == 1
        return true
    end

    # Special case: n == 1 can only produce 1
    if n == 1
        return false
    end

    # n == 0 only yields 0 (for positive exponent)
    if n == 0
        return x == 0
    end

    # Negative numbers are not considered simple powers in this context
    if x <= 0
        return false
    end

    # Repeatedly divide by n while divisible
    while x > 1 && x % n == 0
        x ÷= n
    end

    # If we reduced to 1, x was a power of n
    return x == 1
end
using Test

@testset begin

candidate = is_simple_power;
	@test(candidate(16, 2) == true)
	@test(candidate(143214, 16) == false)
	@test(candidate(4, 2) == true)
	@test(candidate(9, 3) == true)
	@test(candidate(16, 4) == true)
	@test(candidate(24, 2) == false)
	@test(candidate(128, 4) == false)
	@test(candidate(12, 6) == false)
	@test(candidate(1, 1) == true)
	@test(candidate(1, 12) == true)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154630
STDOUT:
Test Summary: | Pass  Total  Time
test set      |   10     10  0.1s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 81 (JL) - HumanEval_81_numerical_letter_grade
================================================================================

PROMPT:
----------------------------------------
"""It is the last week of the semester and the teacher has to give the grades
to students. The teacher has been making her own algorithm for grading.
The only problem is, she has lost the code she used for grading.
She has given you a vector of GPAs for some students and you have to write 
a function that can output a vector of letter grades using the following table:
         GPA       |    Letter grade
          4.0                A+
        > 3.7                A 
        > 3.3                A- 
        > 3.0                B+
        > 2.7                B 
        > 2.3                B-
        > 2.0                C+
        > 1.7                C
        > 1.3                C-
        > 1.0                D+ 
        > 0.7                D 
        > 0.0                D-
          0.0                E
Example:
>>> grade_equation([4.0, 3, 1.7, 2, 3.5])
["A+", "B", "C-", "C", "A-"]"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = numerical_letter_grade;
	@test(candidate([4.0, 3, 1.7, 2, 3.5]) == ["A+", "B", "C-", "C", "A-"])
	@test(candidate([1.2]) == ["D+"])
	@test(candidate([0.5]) == ["D-"])
	@test(candidate([0.0]) == ["E"])
	@test(candidate([1.0, 0.3, 1.5, 2.8, 3.3]) == ["D", "D-", "C-", "B", "B+"])
	@test(candidate([0.0, 0.7]) == ["E", "D-"])
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""It is the last week of the semester and the teacher has to give the grades
to students. The teacher has been making her own algorithm for grading.
The only problem is, she has lost the code she used for grading.
She has given you a vector of GPAs for some students and you have to write 
a function that can output a vector of letter grades using the following table:
         GPA       |    Letter grade
          4.0                A+
        > 3.7                A 
        > 3.3                A- 
        > 3.0                B+
        > 2.7                B 
        > 2.3                B-
        > 2.0                C+
        > 1.7                C
        > 1.3                C-
        > 1.0                D+ 
        > 0.7                D 
        > 0.0                D-
          0.0                E
Example:
>>> grade_equation([4.0, 3, 1.7, 2, 3.5])
["A+", "B", "C-", "C", "A-"]"""
function numerical_letter_grade(grades::Vector{Float64})::Vector{String}
    # Preallocate the result vector for speed
    result = Vector{String}(undef, length(grades))

    for (i, g) in enumerate(grades)
        if g == 4.0
            result[i] = "A+"
        elseif g > 3.7
            result[i] = "A"
        elseif g > 3.3
            result[i] = "A-"
        elseif g > 3.0
            result[i] = "B+"
        elseif g > 2.7
            result[i] = "B"
        elseif g > 2.3
            result[i] = "B-"
        elseif g > 2.0
            result[i] = "C+"
        elseif g > 1.7
            result[i] = "C"
        elseif g > 1.3
            result[i] = "C-"
        elseif g > 1.0
            result[i] = "D+"
        elseif g > 0.7
            result[i] = "D"
        elseif g > 0.0
            result[i] = "D-"
        else
            result[i] = "E"
        end
    end

    return result
end
using Test

@testset begin

candidate = numerical_letter_grade;
	@test(candidate([4.0, 3, 1.7, 2, 3.5]) == ["A+", "B", "C-", "C", "A-"])
	@test(candidate([1.2]) == ["D+"])
	@test(candidate([0.5]) == ["D-"])
	@test(candidate([0.0]) == ["E"])
	@test(candidate([1.0, 0.3, 1.5, 2.8, 3.3]) == ["D", "D-", "C-", "B", "B+"])
	@test(candidate([0.0, 0.7]) == ["E", "D-"])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154643
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    6      6  0.2s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""It is the last week of the semester and the teacher has to give the grades
to students. The teacher has been making her own algorithm for grading.
The only problem is, she has lost the code she used for grading.
She has given you a vector of GPAs for some students and you have to write 
a function that can output a vector of letter grades using the following table:
         GPA       |    Letter grade
          4.0                A+
        > 3.7                A 
        > 3.3                A- 
        > 3.0                B+
        > 2.7                B 
        > 2.3                B-
        > 2.0                C+
        > 1.7                C
        > 1.3                C-
        > 1.0                D+ 
        > 0.7                D 
        > 0.0                D-
          0.0                E
Example:
>>> grade_equation([4.0, 3, 1.7, 2, 3.5])
["A+", "B", "C-", "C", "A-"]"""
function numerical_letter_grade(grades::Vector{Float64})::Vector{String}
    # Preallocate the result vector for efficiency
    result = Vector{String}(undef, length(grades))

    for (i, g) in enumerate(grades)
        if g >= 4.0
            result[i] = "A+"
        elseif g > 3.7
            result[i] = "A"
        elseif g > 3.3
            result[i] = "A-"
        elseif g > 3.0
            result[i] = "B+"
        elseif g > 2.7
            result[i] = "B"
        elseif g > 2.3
            result[i] = "B-"
        elseif g > 2.0
            result[i] = "C+"
        elseif g > 1.7
            result[i] = "C"
        elseif g > 1.3
            result[i] = "C-"
        elseif g > 1.0
            result[i] = "D+"
        elseif g > 0.7
            result[i] = "D"
        elseif g > 0.0
            result[i] = "D-"
        else
            result[i] = "E"
        end
    end

    return result
end
using Test

@testset begin

candidate = numerical_letter_grade;
	@test(candidate([4.0, 3, 1.7, 2, 3.5]) == ["A+", "B", "C-", "C", "A-"])
	@test(candidate([1.2]) == ["D+"])
	@test(candidate([0.5]) == ["D-"])
	@test(candidate([0.0]) == ["E"])
	@test(candidate([1.0, 0.3, 1.5, 2.8, 3.3]) == ["D", "D-", "C-", "B", "B+"])
	@test(candidate([0.0, 0.7]) == ["E", "D-"])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154643
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    6      6  0.2s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""It is the last week of the semester and the teacher has to give the grades
to students. The teacher has been making her own algorithm for grading.
The only problem is, she has lost the code she used for grading.
She has given you a vector of GPAs for some students and you have to write 
a function that can output a vector of letter grades using the following table:
         GPA       |    Letter grade
          4.0                A+
        > 3.7                A 
        > 3.3                A- 
        > 3.0                B+
        > 2.7                B 
        > 2.3                B-
        > 2.0                C+
        > 1.7                C
        > 1.3                C-
        > 1.0                D+ 
        > 0.7                D 
        > 0.0                D-
          0.0                E
Example:
>>> grade_equation([4.0, 3, 1.7, 2, 3.5])
["A+", "B", "C-", "C", "A-"]"""
"""
    numerical_letter_grade(grades::Vector{Float64})::Vector{String}

Convert a vector of numeric GPAs into their corresponding letter grades
according to the following table:

| GPA | Letter grade |
|-----|--------------|
| 4.0 | A+           |
| > 3.7 | A       |
| > 3.3 | A-       |
| > 3.0 | B+       |
| > 2.7 | B        |
| > 2.3 | B-       |
| > 2.0 | C+       |
| > 1.7 | C        |
| > 1.3 | C-       |
| > 1.0 | D+       |
| > 0.7 | D        |
| > 0.0 | D-       |
| 0.0 | E          |

# Examples
using Test

@testset begin

candidate = numerical_letter_grade;
	@test(candidate([4.0, 3, 1.7, 2, 3.5]) == ["A+", "B", "C-", "C", "A-"])
	@test(candidate([1.2]) == ["D+"])
	@test(candidate([0.5]) == ["D-"])
	@test(candidate([0.0]) == ["E"])
	@test(candidate([1.0, 0.3, 1.5, 2.8, 3.3]) == ["D", "D-", "C-", "B", "B+"])
	@test(candidate([0.0, 0.7]) == ["E", "D-"])
end


EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755154645
STDOUT: (empty)
STDERR:
ERROR: LoadError: syntax: incomplete: invalid string syntax
Stacktrace:
 [1] top-level scope
   @ ~/tmp/tmp74yy_g2w.jl:1
in expression starting at /tmp/tmp74yy_g2w.jl:1
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""It is the last week of the semester and the teacher has to give the grades
to students. The teacher has been making her own algorithm for grading.
The only problem is, she has lost the code she used for grading.
She has given you a vector of GPAs for some students and you have to write 
a function that can output a vector of letter grades using the following table:
         GPA       |    Letter grade
          4.0                A+
        > 3.7                A 
        > 3.3                A- 
        > 3.0                B+
        > 2.7                B 
        > 2.3                B-
        > 2.0                C+
        > 1.7                C
        > 1.3                C-
        > 1.0                D+ 
        > 0.7                D 
        > 0.0                D-
          0.0                E
Example:
>>> grade_equation([4.0, 3, 1.7, 2, 3.5])
["A+", "B", "C-", "C", "A-"]"""
function numerical_letter_grade(grades::Vector{Float64})::Vector{String}
    result = Vector{String}(undef, length(grades))
    for (i, g) in pairs(grades)
        if g == 4.0
            result[i] = "A+"
        elseif g > 3.7
            result[i] = "A"
        elseif g > 3.3
            result[i] = "A-"
        elseif g > 3.0
            result[i] = "B+"
        elseif g > 2.7
            result[i] = "B"
        elseif g > 2.3
            result[i] = "B-"
        elseif g > 2.0
            result[i] = "C+"
        elseif g > 1.7
            result[i] = "C"
        elseif g > 1.3
            result[i] = "C-"
        elseif g > 1.0
            result[i] = "D+"
        elseif g > 0.7
            result[i] = "D"
        elseif g > 0.0
            result[i] = "D-"
        else
            result[i] = "E"
        end
    end
    return result
end
using Test

@testset begin

candidate = numerical_letter_grade;
	@test(candidate([4.0, 3, 1.7, 2, 3.5]) == ["A+", "B", "C-", "C", "A-"])
	@test(candidate([1.2]) == ["D+"])
	@test(candidate([0.5]) == ["D-"])
	@test(candidate([0.0]) == ["E"])
	@test(candidate([1.0, 0.3, 1.5, 2.8, 3.3]) == ["D", "D-", "C-", "B", "B+"])
	@test(candidate([0.0, 0.7]) == ["E", "D-"])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154643
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    6      6  0.2s
STDERR: (empty)
--------------------
