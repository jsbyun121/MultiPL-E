As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 76 (R) - HumanEval_76_is_simple_power
================================================================================

PROMPT:
----------------------------------------
# Your task is to write a function that returns true if a number x is a simple
# power of n and false in other cases.
# x is a simple power of n if n**int=x
# For example:
# >>> is_simple_power(1, 4)
# TRUE
# >>> is_simple_power(2, 2)
# TRUE
# >>> is_simple_power(8, 2)
# TRUE
# >>> is_simple_power(3, 2)
# FALSE
# >>> is_simple_power(3, 1)
# FALSE
# >>> is_simple_power(5, 3)
# FALSE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- is_simple_power
    stopifnot(isTRUE(all.equal(candidate(16, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(143214, 16), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(4, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(9, 3), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(16, 4), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(24, 2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(128, 4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(12, 6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1, 1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1, 12), TRUE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Your task is to write a function that returns true if a number x is a simple
# power of n and false in other cases.
# x is a simple power of n if n**int=x
# For example:
# >>> is_simple_power(1, 4)
# TRUE
# >>> is_simple_power(2, 2)
# TRUE
# >>> is_simple_power(8, 2)
# TRUE
# >>> is_simple_power(3, 2)
# FALSE
# >>> is_simple_power(3, 1)
# FALSE
# >>> is_simple_power(5, 3)
# FALSE
# Returns TRUE if x is a simple power of n (i.e. x = n^k for some integer k ≥ 0),
# and FALSE otherwise.
is_simple_power <- function(x, n) {
  # Handle the special case n == 1
  if (n == 1) {
    return(x == 1)
  }
  
  # Negative bases are not considered in the problem statement.
  # For robustness, we treat them as invalid and return FALSE.
  if (n < 0) {
    return(FALSE)
  }
  
  # Use a loop to multiply n until we reach or exceed x.
  power <- 1L
  while (power < x) {
    power <- power * n
    # Prevent infinite loops for n == 0 or n == 1 (handled above)
    if (power == 0) break
  }
  
  return(power == x)
}
test_humaneval <- function() {
    candidate <- is_simple_power
    stopifnot(isTRUE(all.equal(candidate(16, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(143214, 16), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(4, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(9, 3), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(16, 4), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(24, 2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(128, 4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(12, 6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1, 1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1, 12), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183769
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Your task is to write a function that returns true if a number x is a simple
# power of n and false in other cases.
# x is a simple power of n if n**int=x
# For example:
# >>> is_simple_power(1, 4)
# TRUE
# >>> is_simple_power(2, 2)
# TRUE
# >>> is_simple_power(8, 2)
# TRUE
# >>> is_simple_power(3, 2)
# FALSE
# >>> is_simple_power(3, 1)
# FALSE
# >>> is_simple_power(5, 3)
# FALSE
#' Check if a number is a simple power of another
#'
#' @param x The number to test (positive integer).
#' @param n The base (positive integer).
#' @return `TRUE` if `x` equals `n` raised to an integer power, `FALSE` otherwise.
#' @examples
#' is_simple_power(1, 4)   # TRUE
#' is_simple_power(2, 2)   # TRUE
#' is_simple_power(8, 2)   # TRUE
#' is_simple_power(3, 2)   # FALSE
#' is_simple_power(3, 1)   # FALSE
#' is_simple_power(5, 3)   # FALSE
is_simple_power <- function(x, n) {
  # Basic sanity checks
  if (!is.numeric(x) || !is.numeric(n) || length(x) != 1 || length(n) != 1) {
    stop("Both x and n must be single numeric values.")
  }
  if (x <= 0 || n <= 0) {
    return(FALSE)
  }
  # 1 is always a power (n^0)
  if (x == 1) return(TRUE)
  # For base 1, only 1 is a power
  if (n == 1) return(FALSE)

  # Iteratively multiply until we reach or exceed x
  prod <- 1
  while (prod < x) {
    prod <- prod * n
    # Avoid infinite loops in case of overflow
    if (prod > .Machine$integer.max) break
  }
  return(prod == x)
}
test_humaneval <- function() {
    candidate <- is_simple_power
    stopifnot(isTRUE(all.equal(candidate(16, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(143214, 16), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(4, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(9, 3), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(16, 4), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(24, 2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(128, 4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(12, 6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1, 1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1, 12), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183769
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Your task is to write a function that returns true if a number x is a simple
# power of n and false in other cases.
# x is a simple power of n if n**int=x
# For example:
# >>> is_simple_power(1, 4)
# TRUE
# >>> is_simple_power(2, 2)
# TRUE
# >>> is_simple_power(8, 2)
# TRUE
# >>> is_simple_power(3, 2)
# FALSE
# >>> is_simple_power(3, 1)
# FALSE
# >>> is_simple_power(5, 3)
# FALSE
# Returns TRUE if `x` is a simple power of `n`, FALSE otherwise.
# A simple power means there exists an integer k ≥ 0 such that n^k == x.
# 1 is considered a power of any n (n^0 = 1). For n == 1, only x == 1 is valid.

is_simple_power <- function(x, n) {
  # Basic sanity checks: inputs must be single numeric values
  if (!is.numeric(x) || !is.numeric(n) ||
      length(x) != 1 || length(n) != 1) {
    return(FALSE)
  }
  
  # 1 is a power of any n (n^0 = 1)
  if (x == 1) {
    return(TRUE)
  }
  
  # For n <= 1, no other positive integer x can be a power
  if (n <= 1) {
    return(FALSE)
  }
  
  # Iterate multiplying by n until we reach or exceed x
  power <- 1
  while (power < x) {
    power <- power * n
    if (power == x) {
      return(TRUE)
    }
  }
  
  # If we exit the loop, power > x and x was never reached
  return(FALSE)
}
test_humaneval <- function() {
    candidate <- is_simple_power
    stopifnot(isTRUE(all.equal(candidate(16, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(143214, 16), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(4, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(9, 3), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(16, 4), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(24, 2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(128, 4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(12, 6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1, 1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1, 12), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183769
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Your task is to write a function that returns true if a number x is a simple
# power of n and false in other cases.
# x is a simple power of n if n**int=x
# For example:
# >>> is_simple_power(1, 4)
# TRUE
# >>> is_simple_power(2, 2)
# TRUE
# >>> is_simple_power(8, 2)
# TRUE
# >>> is_simple_power(3, 2)
# FALSE
# >>> is_simple_power(3, 1)
# FALSE
# >>> is_simple_power(5, 3)
# FALSE
is_simple_power <- function(x, n) {
  # Basic sanity checks
  if (!is.numeric(x) || !is.numeric(n) || length(x) != 1 || length(n) != 1) {
    stop("Both x and n must be single numeric values.")
  }
  
  # Handle negative or zero values
  if (x <= 0 || n <= 0) {
    return(FALSE)
  }
  
  # Special case: n == 1
  if (n == 1) {
    return(x == 1)
  }
  
  # Special case: x == 1 (any n > 1 gives n^0 = 1)
  if (x == 1) {
    return(TRUE)
  }
  
  # Use integer division to avoid floating‑point errors
  # Repeatedly divide x by n while it is divisible
  current <- x
  while (current > 1 && current %% n == 0) {
    current <- current / n
  }
  
  return(current == 1)
}
test_humaneval <- function() {
    candidate <- is_simple_power
    stopifnot(isTRUE(all.equal(candidate(16, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(143214, 16), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(4, 2), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(9, 3), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(16, 4), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(24, 2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(128, 4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(12, 6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1, 1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1, 12), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183769
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 77 (R) - HumanEval_77_iscube
================================================================================

PROMPT:
----------------------------------------
# Write a function that takes an integer a and returns TRUE 
# if this ingeger is a cube of some integer number.
# Note: you may assume the input is always valid.
# Examples:
# >>> iscube(1)
# TRUE
# >>> iscube(2)
# FALSE
# >>> iscube(-1)
# TRUE
# >>> iscube(64)
# TRUE
# >>> iscube(0)
# TRUE
# >>> iscube(180)
# FALSE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- iscube
    stopifnot(isTRUE(all.equal(candidate(1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(-1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(64), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(180), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1000), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(0), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1729), FALSE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Write a function that takes an integer a and returns TRUE 
# if this ingeger is a cube of some integer number.
# Note: you may assume the input is always valid.
# Examples:
# >>> iscube(1)
# TRUE
# >>> iscube(2)
# FALSE
# >>> iscube(-1)
# TRUE
# >>> iscube(64)
# TRUE
# >>> iscube(0)
# TRUE
# >>> iscube(180)
# FALSE
iscube <- function(a) {
  # Ensure a single numeric value is supplied
  if (!is.numeric(a) || length(a) != 1) {
    stop("Input must be a single numeric value")
  }
  
  # Zero is a perfect cube (0^3 = 0)
  if (a == 0) return(TRUE)
  
  # Compute the integer cube root (rounded) of the absolute value
  n_abs <- round(abs(a)^(1/3))
  
  # Apply the correct sign for negative numbers
  n <- if (a > 0) n_abs else -n_abs
  
  # Check if the cube of n equals the original number
  return(n^3 == a)
}
test_humaneval <- function() {
    candidate <- iscube
    stopifnot(isTRUE(all.equal(candidate(1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(-1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(64), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(180), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1000), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(0), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1729), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183770
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Write a function that takes an integer a and returns TRUE 
# if this ingeger is a cube of some integer number.
# Note: you may assume the input is always valid.
# Examples:
# >>> iscube(1)
# TRUE
# >>> iscube(2)
# FALSE
# >>> iscube(-1)
# TRUE
# >>> iscube(64)
# TRUE
# >>> iscube(0)
# TRUE
# >>> iscube(180)
# FALSE
iscube <- function(a) {
  # Compute the cube root taking the sign into account
  root <- sign(a) * abs(a)^(1/3)
  # Round to the nearest integer
  n <- round(root)
  # Check if the rounded integer cubed equals the original number
  return(n^3 == a)
}
test_humaneval <- function() {
    candidate <- iscube
    stopifnot(isTRUE(all.equal(candidate(1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(-1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(64), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(180), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1000), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(0), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1729), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183770
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Write a function that takes an integer a and returns TRUE 
# if this ingeger is a cube of some integer number.
# Note: you may assume the input is always valid.
# Examples:
# >>> iscube(1)
# TRUE
# >>> iscube(2)
# FALSE
# >>> iscube(-1)
# TRUE
# >>> iscube(64)
# TRUE
# >>> iscube(0)
# TRUE
# >>> iscube(180)
# FALSE
iscube <- function(a) {
  # Ensure a is a single numeric value
  if (!is.numeric(a) || length(a) != 1) {
    stop("Input must be a single numeric value")
  }
  
  # Compute the real cube root (handles negative values correctly)
  root <- sign(a) * abs(a)^(1/3)
  
  # Round to the nearest integer
  n <- round(root)
  
  # Return TRUE if the integer cube matches the original number
  return(n^3 == a)
}
test_humaneval <- function() {
    candidate <- iscube
    stopifnot(isTRUE(all.equal(candidate(1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(-1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(64), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(180), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1000), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(0), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1729), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183770
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Write a function that takes an integer a and returns TRUE 
# if this ingeger is a cube of some integer number.
# Note: you may assume the input is always valid.
# Examples:
# >>> iscube(1)
# TRUE
# >>> iscube(2)
# FALSE
# >>> iscube(-1)
# TRUE
# >>> iscube(64)
# TRUE
# >>> iscube(0)
# TRUE
# >>> iscube(180)
# FALSE
iscube <- function(a) {
  # Compute the integer cube root (rounded) taking sign into account
  n <- round(sign(a) * abs(a)^(1/3))
  # Check if the cube of this integer equals the original number
  return(n^3 == a)
}
test_humaneval <- function() {
    candidate <- iscube
    stopifnot(isTRUE(all.equal(candidate(1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(2), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(-1), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(64), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(180), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1000), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(0), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(1729), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183770
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 78 (R) - HumanEval_78_hex_key
================================================================================

PROMPT:
----------------------------------------
# You have been tasked to write a function that receives 
# a hexadecimal number as a string and counts the number of hexadecimal 
# digits that are primes (prime number, or a prime, is a natural number 
# greater than 1 that is not a product of two smaller natural numbers).
# Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
# Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
# So you have to determine a number of the following digits: 2, 3, 5, 7, 
# B (=decimal 11), D (=decimal 13).
# Note: you may assume the input is always correct or empty string, 
# and symbols A,B,C,D,E,F are always uppercase.
# Examples:
# >>> hex_key('AB')
# 1
# >>> hex_key('1077E')
# 2
# >>> hex_key('ABED1A33')
# 4
# >>> hex_key('123456789ABCDEF0')
# 6
# >>> hex_key('2020')
# 2

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- hex_key
    stopifnot(isTRUE(all.equal(candidate('AB'), 1)))
    stopifnot(isTRUE(all.equal(candidate('1077E'), 2)))
    stopifnot(isTRUE(all.equal(candidate('ABED1A33'), 4)))
    stopifnot(isTRUE(all.equal(candidate('2020'), 2)))
    stopifnot(isTRUE(all.equal(candidate('123456789ABCDEF0'), 6)))
    stopifnot(isTRUE(all.equal(candidate('112233445566778899AABBCCDDEEFF00'), 12)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# You have been tasked to write a function that receives 
# a hexadecimal number as a string and counts the number of hexadecimal 
# digits that are primes (prime number, or a prime, is a natural number 
# greater than 1 that is not a product of two smaller natural numbers).
# Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
# Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
# So you have to determine a number of the following digits: 2, 3, 5, 7, 
# B (=decimal 11), D (=decimal 13).
# Note: you may assume the input is always correct or empty string, 
# and symbols A,B,C,D,E,F are always uppercase.
# Examples:
# >>> hex_key('AB')
# 1
# >>> hex_key('1077E')
# 2
# >>> hex_key('ABED1A33')
# 4
# >>> hex_key('123456789ABCDEF0')
# 6
# >>> hex_key('2020')
# 2
hex_key <- function(num) {
  # Return 0 for an empty string
  if (nchar(num) == 0) return(0)
  
  # Define the hexadecimal digits that are prime numbers
  prime_digits <- c("2", "3", "5", "7", "B", "D")
  
  # Split the string into individual characters
  chars <- strsplit(num, "")[[1]]
  
  # Count how many characters are in the prime list
  sum(chars %in% prime_digits)
}
test_humaneval <- function() {
    candidate <- hex_key
    stopifnot(isTRUE(all.equal(candidate('AB'), 1)))
    stopifnot(isTRUE(all.equal(candidate('1077E'), 2)))
    stopifnot(isTRUE(all.equal(candidate('ABED1A33'), 4)))
    stopifnot(isTRUE(all.equal(candidate('2020'), 2)))
    stopifnot(isTRUE(all.equal(candidate('123456789ABCDEF0'), 6)))
    stopifnot(isTRUE(all.equal(candidate('112233445566778899AABBCCDDEEFF00'), 12)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183770
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# You have been tasked to write a function that receives 
# a hexadecimal number as a string and counts the number of hexadecimal 
# digits that are primes (prime number, or a prime, is a natural number 
# greater than 1 that is not a product of two smaller natural numbers).
# Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
# Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
# So you have to determine a number of the following digits: 2, 3, 5, 7, 
# B (=decimal 11), D (=decimal 13).
# Note: you may assume the input is always correct or empty string, 
# and symbols A,B,C,D,E,F are always uppercase.
# Examples:
# >>> hex_key('AB')
# 1
# >>> hex_key('1077E')
# 2
# >>> hex_key('ABED1A33')
# 4
# >>> hex_key('123456789ABCDEF0')
# 6
# >>> hex_key('2020')
# 2
hex_key <- function(num) {
  # Return 0 immediately for an empty string
  if (nchar(num) == 0) return(0)

  # Hexadecimal digits that are prime numbers
  prime_digits <- c('2', '3', '5', '7', 'B', 'D')

  # Split the string into individual characters
  chars <- strsplit(num, "")[[1]]

  # Count how many characters are in the prime set
  sum(chars %in% prime_digits)
}
test_humaneval <- function() {
    candidate <- hex_key
    stopifnot(isTRUE(all.equal(candidate('AB'), 1)))
    stopifnot(isTRUE(all.equal(candidate('1077E'), 2)))
    stopifnot(isTRUE(all.equal(candidate('ABED1A33'), 4)))
    stopifnot(isTRUE(all.equal(candidate('2020'), 2)))
    stopifnot(isTRUE(all.equal(candidate('123456789ABCDEF0'), 6)))
    stopifnot(isTRUE(all.equal(candidate('112233445566778899AABBCCDDEEFF00'), 12)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183770
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# You have been tasked to write a function that receives 
# a hexadecimal number as a string and counts the number of hexadecimal 
# digits that are primes (prime number, or a prime, is a natural number 
# greater than 1 that is not a product of two smaller natural numbers).
# Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
# Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
# So you have to determine a number of the following digits: 2, 3, 5, 7, 
# B (=decimal 11), D (=decimal 13).
# Note: you may assume the input is always correct or empty string, 
# and symbols A,B,C,D,E,F are always uppercase.
# Examples:
# >>> hex_key('AB')
# 1
# >>> hex_key('1077E')
# 2
# >>> hex_key('ABED1A33')
# 4
# >>> hex_key('123456789ABCDEF0')
# 6
# >>> hex_key('2020')
# 2
hex_key <- function(num) {
  # Define the set of hexadecimal digits that are prime numbers
  prime_digits <- c("2", "3", "5", "7", "B", "D")
  
  # If the input string is empty, return 0
  if (nchar(num) == 0) {
    return(0L)
  }
  
  # Split the string into individual characters
  chars <- strsplit(num, "")[[1]]
  
  # Count how many of those characters are in the prime set
  count <- sum(chars %in% prime_digits)
  
  # Return the count as an integer
  return(as.integer(count))
}
test_humaneval <- function() {
    candidate <- hex_key
    stopifnot(isTRUE(all.equal(candidate('AB'), 1)))
    stopifnot(isTRUE(all.equal(candidate('1077E'), 2)))
    stopifnot(isTRUE(all.equal(candidate('ABED1A33'), 4)))
    stopifnot(isTRUE(all.equal(candidate('2020'), 2)))
    stopifnot(isTRUE(all.equal(candidate('123456789ABCDEF0'), 6)))
    stopifnot(isTRUE(all.equal(candidate('112233445566778899AABBCCDDEEFF00'), 12)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183770
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# You have been tasked to write a function that receives 
# a hexadecimal number as a string and counts the number of hexadecimal 
# digits that are primes (prime number, or a prime, is a natural number 
# greater than 1 that is not a product of two smaller natural numbers).
# Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
# Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
# So you have to determine a number of the following digits: 2, 3, 5, 7, 
# B (=decimal 11), D (=decimal 13).
# Note: you may assume the input is always correct or empty string, 
# and symbols A,B,C,D,E,F are always uppercase.
# Examples:
# >>> hex_key('AB')
# 1
# >>> hex_key('1077E')
# 2
# >>> hex_key('ABED1A33')
# 4
# >>> hex_key('123456789ABCDEF0')
# 6
# >>> hex_key('2020')
# 2
hex_key <- function(num) {
  # Return 0 for an empty string
  if (num == "") return(0)

  # Split the string into individual characters
  chars <- strsplit(num, "")[[1]]

  # Define the set of hexadecimal digits that are prime numbers
  prime_digits <- c("2", "3", "5", "7", "B", "D")

  # Count how many characters belong to the prime set
  sum(chars %in% prime_digits)
}
test_humaneval <- function() {
    candidate <- hex_key
    stopifnot(isTRUE(all.equal(candidate('AB'), 1)))
    stopifnot(isTRUE(all.equal(candidate('1077E'), 2)))
    stopifnot(isTRUE(all.equal(candidate('ABED1A33'), 4)))
    stopifnot(isTRUE(all.equal(candidate('2020'), 2)))
    stopifnot(isTRUE(all.equal(candidate('123456789ABCDEF0'), 6)))
    stopifnot(isTRUE(all.equal(candidate('112233445566778899AABBCCDDEEFF00'), 12)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183770
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 79 (R) - HumanEval_79_decimal_to_binary
================================================================================

PROMPT:
----------------------------------------
# You will be given a number in decimal form and your task is to convert it to
# binary format. The function should return a string, with each character representing a binary
# number. Each character in the string will be '0' or '1'.
# There will be an extra couple of characters 'db' at the beginning and at the end of the string.
# The extra characters are there to help with the format.
# Examples:
# >>> decimal_to_binary(15)
# 'db1111db'
# >>> decimal_to_binary(32)
# 'db100000db'

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- decimal_to_binary
    stopifnot(isTRUE(all.equal(candidate(0), 'db0db')))
    stopifnot(isTRUE(all.equal(candidate(32), 'db100000db')))
    stopifnot(isTRUE(all.equal(candidate(103), 'db1100111db')))
    stopifnot(isTRUE(all.equal(candidate(15), 'db1111db')))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# You will be given a number in decimal form and your task is to convert it to
# binary format. The function should return a string, with each character representing a binary
# number. Each character in the string will be '0' or '1'.
# There will be an extra couple of characters 'db' at the beginning and at the end of the string.
# The extra characters are there to help with the format.
# Examples:
# >>> decimal_to_binary(15)
# 'db1111db'
# >>> decimal_to_binary(32)
# 'db100000db'
decimal_to_binary <- function(decimal) {
  # Ensure the input is an integer
  decimal <- as.integer(decimal)

  # Handle the special case of 0
  if (decimal == 0) {
    bin_str <- "0"
  } else {
    # Convert to raw bits (least‑significant bit first)
    raw_bits <- intToBits(decimal)
    # Convert to numeric 0/1 and reverse so that the most‑significant bit is first
    bits <- rev(as.integer(raw_bits))
    # Find the index of the first '1' (most‑significant set bit)
    first_one <- which(bits == 1)[1]
    # Extract the binary representation from that bit to the end
    bin_str <- paste(bits[first_one:length(bits)], collapse = "")
  }

  # Wrap with the required 'db' markers
  paste0("db", bin_str, "db")
}
test_humaneval <- function() {
    candidate <- decimal_to_binary
    stopifnot(isTRUE(all.equal(candidate(0), 'db0db')))
    stopifnot(isTRUE(all.equal(candidate(32), 'db100000db')))
    stopifnot(isTRUE(all.equal(candidate(103), 'db1100111db')))
    stopifnot(isTRUE(all.equal(candidate(15), 'db1111db')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183771
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# You will be given a number in decimal form and your task is to convert it to
# binary format. The function should return a string, with each character representing a binary
# number. Each character in the string will be '0' or '1'.
# There will be an extra couple of characters 'db' at the beginning and at the end of the string.
# The extra characters are there to help with the format.
# Examples:
# >>> decimal_to_binary(15)
# 'db1111db'
# >>> decimal_to_binary(32)
# 'db100000db'
# Converts a decimal number to a binary string with 'db' markers
decimal_to_binary <- function(decimal) {
  # Basic sanity checks
  if (!is.numeric(decimal) || length(decimal) != 1) {
    stop("Input must be a single numeric value")
  }
  if (decimal < 0) {
    stop("Negative numbers are not supported")
  }
  if (decimal == 0) {
    return("db0db")          # special case for zero
  }

  # Convert to integer (intToBits expects an integer)
  int_val <- as.integer(decimal)

  # Get the binary representation as a vector of 0/1
  bits <- rev(as.integer(intToBits(int_val)))

  # Remove leading zeros
  first_one <- which(bits == 1)[1]
  binary_str <- paste(bits[first_one:length(bits)], collapse = "")

  # Wrap with 'db'
  paste0("db", binary_str, "db")
}
test_humaneval <- function() {
    candidate <- decimal_to_binary
    stopifnot(isTRUE(all.equal(candidate(0), 'db0db')))
    stopifnot(isTRUE(all.equal(candidate(32), 'db100000db')))
    stopifnot(isTRUE(all.equal(candidate(103), 'db1100111db')))
    stopifnot(isTRUE(all.equal(candidate(15), 'db1111db')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183771
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# You will be given a number in decimal form and your task is to convert it to
# binary format. The function should return a string, with each character representing a binary
# number. Each character in the string will be '0' or '1'.
# There will be an extra couple of characters 'db' at the beginning and at the end of the string.
# The extra characters are there to help with the format.
# Examples:
# >>> decimal_to_binary(15)
# 'db1111db'
# >>> decimal_to_binary(32)
# 'db100000db'
decimal_to_binary <- function(decimal) {
  # Handle the special case of 0 explicitly
  if (decimal == 0) {
    return("db0db")
  }
  
  # Convert the integer to a vector of bits (least‑significant bit first)
  bits <- rev(as.integer(intToBits(decimal)))
  
  # Find the position of the most significant 1
  msb_index <- which(bits == 1)[1]
  
  # Build the binary string from the most significant bit to the least
  binary_str <- paste0(bits[msb_index:length(bits)], collapse = "")
  
  # Add the required 'db' prefix and suffix
  paste0("db", binary_str, "db")
}
test_humaneval <- function() {
    candidate <- decimal_to_binary
    stopifnot(isTRUE(all.equal(candidate(0), 'db0db')))
    stopifnot(isTRUE(all.equal(candidate(32), 'db100000db')))
    stopifnot(isTRUE(all.equal(candidate(103), 'db1100111db')))
    stopifnot(isTRUE(all.equal(candidate(15), 'db1111db')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183771
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# You will be given a number in decimal form and your task is to convert it to
# binary format. The function should return a string, with each character representing a binary
# number. Each character in the string will be '0' or '1'.
# There will be an extra couple of characters 'db' at the beginning and at the end of the string.
# The extra characters are there to help with the format.
# Examples:
# >>> decimal_to_binary(15)
# 'db1111db'
# >>> decimal_to_binary(32)
# 'db100000db'
decimal_to_binary <- function(decimal) {
  # Basic input validation
  if (!is.numeric(decimal) || length(decimal) != 1 ||
      decimal < 0 || decimal != as.integer(decimal)) {
    stop("Input must be a non‑negative integer.")
  }

  # Special case for zero
  if (decimal == 0) {
    return("db0db")
  }

  # Convert to binary
  bits_raw  <- intToBits(decimal)          # 32‑bit raw vector, LSB first
  bits_int  <- as.integer(bits_raw)        # Convert to 0/1 integers
  bits_rev  <- rev(bits_int)               # MSB first
  bin_str   <- paste(bits_rev, collapse = "")  # Concatenate into string

  # Trim leading zeros (if any)
  bin_str   <- sub("^0+", "", bin_str)

  # Wrap with the required 'db' markers
  paste0("db", bin_str, "db")
}
test_humaneval <- function() {
    candidate <- decimal_to_binary
    stopifnot(isTRUE(all.equal(candidate(0), 'db0db')))
    stopifnot(isTRUE(all.equal(candidate(32), 'db100000db')))
    stopifnot(isTRUE(all.equal(candidate(103), 'db1100111db')))
    stopifnot(isTRUE(all.equal(candidate(15), 'db1111db')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183771
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 80 (R) - HumanEval_80_is_happy
================================================================================

PROMPT:
----------------------------------------
# You are given a string s.
# Your task is to check if the string is hapr or not.
# A string is hapr if its length is at least 3 and every 3 consecutive letters are distinct
# For example:
# >>> is_happy('a')
# FALSE
# >>> is_happy('aa')
# FALSE
# >>> is_happy('abcd')
# TRUE
# >>> is_happy('aabb')
# FALSE
# >>> is_happy('adb')
# TRUE
# >>> is_happy('xyy')
# FALSE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- is_happy
    stopifnot(isTRUE(all.equal(candidate('a'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aa'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('abcd'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('aabb'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('adb'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('xyy'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('iopaxpoi'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('iopaxioi'), FALSE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# You are given a string s.
# Your task is to check if the string is hapr or not.
# A string is hapr if its length is at least 3 and every 3 consecutive letters are distinct
# For example:
# >>> is_happy('a')
# FALSE
# >>> is_happy('aa')
# FALSE
# >>> is_happy('abcd')
# TRUE
# >>> is_happy('aabb')
# FALSE
# >>> is_happy('adb')
# TRUE
# >>> is_happy('xyy')
# FALSE
is_happy <- function(s) {
  # Convert the string into a vector of single characters
  chars <- strsplit(s, "")[[1]]
  n <- length(chars)
  
  # A hapr string must have at least 3 characters
  if (n < 3) {
    return(FALSE)
  }
  
  # Check every group of three consecutive characters
  for (i in seq_len(n - 2)) {
    triple <- chars[i:(i + 2)]
    # If any character repeats within the triple, it's not hapr
    if (length(unique(triple)) != 3) {
      return(FALSE)
    }
  }
  
  # All triples were distinct
  return(TRUE)
}
test_humaneval <- function() {
    candidate <- is_happy
    stopifnot(isTRUE(all.equal(candidate('a'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aa'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('abcd'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('aabb'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('adb'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('xyy'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('iopaxpoi'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('iopaxioi'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183771
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# You are given a string s.
# Your task is to check if the string is hapr or not.
# A string is hapr if its length is at least 3 and every 3 consecutive letters are distinct
# For example:
# >>> is_happy('a')
# FALSE
# >>> is_happy('aa')
# FALSE
# >>> is_happy('abcd')
# TRUE
# >>> is_happy('aabb')
# FALSE
# >>> is_happy('adb')
# TRUE
# >>> is_happy('xyy')
# FALSE
is_happy <- function(s) {
  # Check that the string has at least 3 characters
  if (nchar(s) < 3) {
    return(FALSE)
  }
  
  # Split the string into individual characters
  chars <- strsplit(s, "")[[1]]
  n <- length(chars)
  
  # Iterate over every group of 3 consecutive characters
  for (i in seq_len(n - 2)) {
    trio <- chars[i:(i + 2)]
    # If any two characters in the trio are the same, it's not hapr
    if (length(unique(trio)) != 3) {
      return(FALSE)
    }
  }
  
  # All checks passed
  return(TRUE)
}
test_humaneval <- function() {
    candidate <- is_happy
    stopifnot(isTRUE(all.equal(candidate('a'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aa'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('abcd'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('aabb'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('adb'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('xyy'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('iopaxpoi'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('iopaxioi'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183771
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# You are given a string s.
# Your task is to check if the string is hapr or not.
# A string is hapr if its length is at least 3 and every 3 consecutive letters are distinct
# For example:
# >>> is_happy('a')
# FALSE
# >>> is_happy('aa')
# FALSE
# >>> is_happy('abcd')
# TRUE
# >>> is_happy('aabb')
# FALSE
# >>> is_happy('adb')
# TRUE
# >>> is_happy('xyy')
# FALSE
is_happy <- function(s) {
  # Split the string into individual characters
  chars <- strsplit(s, "")[[1]]
  n <- length(chars)
  
  # A hapr string must have at least 3 characters
  if (n < 3) {
    return(FALSE)
  }
  
  # Check each window of 3 consecutive characters
  for (i in seq_len(n - 2)) {
    window <- chars[i:(i + 2)]
    if (length(unique(window)) < 3) {
      return(FALSE)
    }
  }
  
  # All windows passed the test
  return(TRUE)
}
test_humaneval <- function() {
    candidate <- is_happy
    stopifnot(isTRUE(all.equal(candidate('a'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aa'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('abcd'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('aabb'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('adb'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('xyy'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('iopaxpoi'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('iopaxioi'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183771
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# You are given a string s.
# Your task is to check if the string is hapr or not.
# A string is hapr if its length is at least 3 and every 3 consecutive letters are distinct
# For example:
# >>> is_happy('a')
# FALSE
# >>> is_happy('aa')
# FALSE
# >>> is_happy('abcd')
# TRUE
# >>> is_happy('aabb')
# FALSE
# >>> is_happy('adb')
# TRUE
# >>> is_happy('xyy')
# FALSE
is_happy <- function(s) {
  # length of the string
  n <- nchar(s)
  
  # must have at least 3 characters
  if (n < 3) {
    return(FALSE)
  }
  
  # split into individual characters
  chars <- strsplit(s, "")[[1]]
  
  # check every consecutive triple
  for (i in seq_len(n - 2)) {
    trio <- chars[i:(i + 2)]
    if (length(unique(trio)) != 3) {
      return(FALSE)
    }
  }
  
  # all triples were distinct
  return(TRUE)
}
test_humaneval <- function() {
    candidate <- is_happy
    stopifnot(isTRUE(all.equal(candidate('a'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('aa'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('abcd'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('aabb'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('adb'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('xyy'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('iopaxpoi'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('iopaxioi'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183771
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 83 (R) - HumanEval_83_starts_one_ends
================================================================================

PROMPT:
----------------------------------------
# Given a positive integer n, return the count of the numbers of n-digit
# positive integers that start or end with 1.

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- starts_one_ends
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(2), 18)))
    stopifnot(isTRUE(all.equal(candidate(3), 180)))
    stopifnot(isTRUE(all.equal(candidate(4), 1800)))
    stopifnot(isTRUE(all.equal(candidate(5), 18000)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given a positive integer n, return the count of the numbers of n-digit
# positive integers that start or end with 1.
# Given a positive integer n, return the count of the numbers of n-digit
# positive integers that start or end with 1.
starts_one_ends <- function(n) {
  # Input validation: n must be a positive integer
  if (!is.numeric(n) || length(n) != 1 || n <= 0 || floor(n) != n) {
    stop("n must be a positive integer")
  }
  
  # Special case for single‑digit numbers
  if (n == 1) {
    return(1L)  # only the number 1 satisfies the condition
  }
  
  # For n > 1:
  #   start‑with‑1 count  = 10^(n-1)
  #   end‑with‑1 count    = 9 * 10^(n-2)   (first digit cannot be 0)
  #   overlap (both)      = 10^(n-2)
  #
  # Result = start + end - overlap = 10^(n-1) + 9*10^(n-2) - 10^(n-2)
  #         = 10*10^(n-2) + 8*10^(n-2) = 18 * 10^(n-2)
  result <- 18L * 10^(n - 2)
  return(result)
}
test_humaneval <- function() {
    candidate <- starts_one_ends
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(2), 18)))
    stopifnot(isTRUE(all.equal(candidate(3), 180)))
    stopifnot(isTRUE(all.equal(candidate(4), 1800)))
    stopifnot(isTRUE(all.equal(candidate(5), 18000)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183773
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given a positive integer n, return the count of the numbers of n-digit
# positive integers that start or end with 1.
# Given a positive integer n, return the count of the numbers of n-digit
# positive integers that start or end with 1.
starts_one_ends <- function(n) {
  if (n == 1) {
    # Only the single digit 1 satisfies the condition
    return(1L)
  }
  # For n >= 2:
  #   start with 1: 10^(n-1) possibilities
  #   end   with 1: 9 * 10^(n-2) possibilities
  #   both start & end with 1: 10^(n-2) possibilities
  #   Total = 10^(n-1) + 9*10^(n-2) - 10^(n-2) = 18 * 10^(n-2)
  return(18L * 10^(n - 2))
}
test_humaneval <- function() {
    candidate <- starts_one_ends
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(2), 18)))
    stopifnot(isTRUE(all.equal(candidate(3), 180)))
    stopifnot(isTRUE(all.equal(candidate(4), 1800)))
    stopifnot(isTRUE(all.equal(candidate(5), 18000)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183773
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given a positive integer n, return the count of the numbers of n-digit
# positive integers that start or end with 1.
# Given a positive integer n, return the count of the numbers of n-digit
# positive integers that start or end with 1.
starts_one_ends <- function(n) {
  if (!is.numeric(n) || length(n) != 1 || n <= 0 || floor(n) != n) {
    stop("n must be a positive integer")
  }
  
  if (n == 1) {
    # Only the number 1 satisfies both conditions
    return(1L)
  }
  
  # For n >= 2:
  #   start with 1  -> 10^(n-1) numbers
  #   end with 1    -> 9 * 10^(n-2) numbers
  #   both start & end with 1 -> 10^(n-2) numbers
  #   total = start + end - both
  #          = 10^(n-1) + 9*10^(n-2) - 10^(n-2)
  #          = 18 * 10^(n-2)
  result <- 18 * 10^(n - 2)
  return(as.integer(result))
}
test_humaneval <- function() {
    candidate <- starts_one_ends
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(2), 18)))
    stopifnot(isTRUE(all.equal(candidate(3), 180)))
    stopifnot(isTRUE(all.equal(candidate(4), 1800)))
    stopifnot(isTRUE(all.equal(candidate(5), 18000)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183773
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given a positive integer n, return the count of the numbers of n-digit
# positive integers that start or end with 1.
# Given a positive integer n, return the count of the numbers of n-digit
# positive integers that start or end with 1.
starts_one_ends <- function(n) {
  # Handle the single‑digit case separately
  if (n == 1) {
    return(1L)          # only the number 1 qualifies
  }
  
  # For n ≥ 2:
  #   start with 1  → 10^(n-1) numbers
  #   end with 1    → 9 * 10^(n-2) numbers
  #   both start & end with 1 → 10^(n-2) numbers
  #
  # Inclusion–exclusion gives:
  #   10^(n-1) + 9*10^(n-2) - 10^(n-2) = 18 * 10^(n-2)
  #
  result <- 18L * 10^(n - 2)
  return(result)
}
test_humaneval <- function() {
    candidate <- starts_one_ends
    stopifnot(isTRUE(all.equal(candidate(1), 1)))
    stopifnot(isTRUE(all.equal(candidate(2), 18)))
    stopifnot(isTRUE(all.equal(candidate(3), 180)))
    stopifnot(isTRUE(all.equal(candidate(4), 1800)))
    stopifnot(isTRUE(all.equal(candidate(5), 18000)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183773
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 85 (R) - HumanEval_85_add
================================================================================

PROMPT:
----------------------------------------
# Given a non-empty list of integers lst. add the even elements that are at odd indices..
# Examples:
# >>> add(c(4, 2, 6, 7))
# 2

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- add
    stopifnot(isTRUE(all.equal(candidate(c(4, 88)), 88)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 6, 7, 2, 122)), 122)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 0, 6, 7)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 4, 6, 8)), 12)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given a non-empty list of integers lst. add the even elements that are at odd indices..
# Examples:
# >>> add(c(4, 2, 6, 7))
# 2
# add <- function(lst) {
#   # In R indices start at 1, but the problem statement uses 0‑based indices.
#   # "Odd indices" in 0‑based indexing correspond to even indices in R (i %% 2 == 0).
#   idx <- seq_along(lst)
#   sum(lst[idx %% 2 == 0 & lst %% 2 == 0])
# }

add <- function(lst) {
  idx <- seq_along(lst)
  sum(lst[idx %% 2 == 0 & lst %% 2 == 0])
}
test_humaneval <- function() {
    candidate <- add
    stopifnot(isTRUE(all.equal(candidate(c(4, 88)), 88)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 6, 7, 2, 122)), 122)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 0, 6, 7)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 4, 6, 8)), 12)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183774
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given a non-empty list of integers lst. add the even elements that are at odd indices..
# Examples:
# >>> add(c(4, 2, 6, 7))
# 2
# Given a non-empty list of integers lst. add the even elements that are at odd indices..
# Examples:
# >>> add(c(4, 2, 6, 7))
# 2
add <- function(lst) {
  # Indices that correspond to odd indices in 0‑based counting (i.e., even R indices)
  even_indices <- seq(2, length(lst), by = 2)
  
  # Extract the values at those indices
  values_at_even_indices <- lst[even_indices]
  
  # Keep only the even values among them
  even_values <- values_at_even_indices[values_at_even_indices %% 2 == 0]
  
  # Sum and return
  sum(even_values)
}
test_humaneval <- function() {
    candidate <- add
    stopifnot(isTRUE(all.equal(candidate(c(4, 88)), 88)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 6, 7, 2, 122)), 122)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 0, 6, 7)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 4, 6, 8)), 12)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183774
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given a non-empty list of integers lst. add the even elements that are at odd indices..
# Examples:
# >>> add(c(4, 2, 6, 7))
# 2
add <- function(lst) {
  # Get indices that are even in 1‑based indexing (i.e., odd indices in 0‑based)
  even_idx <- seq(2, length(lst), by = 2)
  # Filter those elements that are also even
  even_elements_at_even_idx <- lst[even_idx][lst[even_idx] %% 2 == 0]
  # Sum them (sum of an empty vector returns 0)
  sum(even_elements_at_even_idx)
}
test_humaneval <- function() {
    candidate <- add
    stopifnot(isTRUE(all.equal(candidate(c(4, 88)), 88)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 6, 7, 2, 122)), 122)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 0, 6, 7)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 4, 6, 8)), 12)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183774
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given a non-empty list of integers lst. add the even elements that are at odd indices..
# Examples:
# >>> add(c(4, 2, 6, 7))
# 2
# Given a non-empty list of integers lst. add the even elements that are at odd indices..
# Examples:
# >>> add(c(4, 2, 6, 7))
# 2
add <- function(lst) {
  # In R, indices start at 1, but the problem uses zero‑based indexing.
  # Therefore, "odd indices" correspond to the 2nd, 4th, 6th, … elements.
  odd_index_positions <- seq(2, length(lst), by = 2)
  # Extract the elements at those positions
  odd_index_elements <- lst[odd_index_positions]
  # Keep only the even ones
  even_odd_elements <- odd_index_elements[odd_index_elements %% 2 == 0]
  # Sum them (returns 0 if the vector is empty)
  sum(even_odd_elements)
}
test_humaneval <- function() {
    candidate <- add
    stopifnot(isTRUE(all.equal(candidate(c(4, 88)), 88)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 6, 7, 2, 122)), 122)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 0, 6, 7)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 4, 6, 8)), 12)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183774
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 88 (R) - HumanEval_88_sort_array
================================================================================

PROMPT:
----------------------------------------
# Given a vector of non-negative integers, return a cor of the given vector after sorting,
# you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,
# or sort it in descending order if the sum( first index value, last index value) is even.
# Note:
# * don't change the given vector.
# Examples:
# >>> sort_array(c())
# c()
# >>> sort_array(c(5))
# c(5)
# >>> sort_array(c(2, 4, 3, 0, 1, 5))
# c(0, 1, 2, 3, 4, 5)
# >>> sort_array(c(2, 4, 3, 0, 1, 5, 6))
# c(6, 5, 4, 3, 2, 1, 0)

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- sort_array
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5)), c(5))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5)), c(0, 1, 2, 3, 4, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5, 6)), c(6, 5, 4, 3, 2, 1, 0))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 1)), c(1, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(15, 42, 87, 32, 11, 0)), c(0, 11, 15, 32, 42, 87))))
    stopifnot(isTRUE(all.equal(candidate(c(21, 14, 23, 11)), c(23, 21, 14, 11))))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given a vector of non-negative integers, return a cor of the given vector after sorting,
# you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,
# or sort it in descending order if the sum( first index value, last index value) is even.
# Note:
# * don't change the given vector.
# Examples:
# >>> sort_array(c())
# c()
# >>> sort_array(c(5))
# c(5)
# >>> sort_array(c(2, 4, 3, 0, 1, 5))
# c(0, 1, 2, 3, 4, 5)
# >>> sort_array(c(2, 4, 3, 0, 1, 5, 6))
# c(6, 5, 4, 3, 2, 1, 0)
sort_array <- function(array) {
  # Return the original vector unchanged for empty or single‑element cases
  if (length(array) <= 1) {
    return(array)
  }
  
  # Determine whether the sum of the first and last elements is odd or even
  sum_first_last <- array[1] + array[length(array)]
  
  # Sort accordingly
  if (sum_first_last %% 2 == 1) {
    # Odd sum – ascending order
    return(sort(array))
  } else {
    # Even sum – descending order
    return(sort(array, decreasing = TRUE))
  }
}
test_humaneval <- function() {
    candidate <- sort_array
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5)), c(5))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5)), c(0, 1, 2, 3, 4, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5, 6)), c(6, 5, 4, 3, 2, 1, 0))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 1)), c(1, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(15, 42, 87, 32, 11, 0)), c(0, 11, 15, 32, 42, 87))))
    stopifnot(isTRUE(all.equal(candidate(c(21, 14, 23, 11)), c(23, 21, 14, 11))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183775
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given a vector of non-negative integers, return a cor of the given vector after sorting,
# you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,
# or sort it in descending order if the sum( first index value, last index value) is even.
# Note:
# * don't change the given vector.
# Examples:
# >>> sort_array(c())
# c()
# >>> sort_array(c(5))
# c(5)
# >>> sort_array(c(2, 4, 3, 0, 1, 5))
# c(0, 1, 2, 3, 4, 5)
# >>> sort_array(c(2, 4, 3, 0, 1, 5, 6))
# c(6, 5, 4, 3, 2, 1, 0)
sort_array <- function(array) {
  # If the vector has 0 or 1 element, just return it unchanged
  if (length(array) <= 1) {
    return(array)
  }
  
  # Compute the sum of the first and last elements
  s <- array[1] + array[length(array)]
  
  # Sort ascending if the sum is odd, otherwise sort descending
  if (s %% 2 == 1) {
    return(sort(array, decreasing = FALSE))
  } else {
    return(sort(array, decreasing = TRUE))
  }
}
test_humaneval <- function() {
    candidate <- sort_array
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5)), c(5))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5)), c(0, 1, 2, 3, 4, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5, 6)), c(6, 5, 4, 3, 2, 1, 0))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 1)), c(1, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(15, 42, 87, 32, 11, 0)), c(0, 11, 15, 32, 42, 87))))
    stopifnot(isTRUE(all.equal(candidate(c(21, 14, 23, 11)), c(23, 21, 14, 11))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183775
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given a vector of non-negative integers, return a cor of the given vector after sorting,
# you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,
# or sort it in descending order if the sum( first index value, last index value) is even.
# Note:
# * don't change the given vector.
# Examples:
# >>> sort_array(c())
# c()
# >>> sort_array(c(5))
# c(5)
# >>> sort_array(c(2, 4, 3, 0, 1, 5))
# c(0, 1, 2, 3, 4, 5)
# >>> sort_array(c(2, 4, 3, 0, 1, 5, 6))
# c(6, 5, 4, 3, 2, 1, 0)
sort_array <- function(array) {
  # If the vector is empty or has a single element, just return it
  if (length(array) <= 1) {
    return(array)
  }
  
  # Compute the sum of the first and last elements
  s <- array[1] + array[length(array)]
  
  # Decide sorting order based on the parity of the sum
  if (s %% 2 == 1) {
    # Sum is odd → ascending order
    sorted_vec <- sort(array, decreasing = FALSE)
  } else {
    # Sum is even → descending order
    sorted_vec <- sort(array, decreasing = TRUE)
  }
  
  return(sorted_vec)
}
test_humaneval <- function() {
    candidate <- sort_array
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5)), c(5))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5)), c(0, 1, 2, 3, 4, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5, 6)), c(6, 5, 4, 3, 2, 1, 0))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 1)), c(1, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(15, 42, 87, 32, 11, 0)), c(0, 11, 15, 32, 42, 87))))
    stopifnot(isTRUE(all.equal(candidate(c(21, 14, 23, 11)), c(23, 21, 14, 11))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183775
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given a vector of non-negative integers, return a cor of the given vector after sorting,
# you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,
# or sort it in descending order if the sum( first index value, last index value) is even.
# Note:
# * don't change the given vector.
# Examples:
# >>> sort_array(c())
# c()
# >>> sort_array(c(5))
# c(5)
# >>> sort_array(c(2, 4, 3, 0, 1, 5))
# c(0, 1, 2, 3, 4, 5)
# >>> sort_array(c(2, 4, 3, 0, 1, 5, 6))
# c(6, 5, 4, 3, 2, 1, 0)
sort_array <- function(array) {
  # Return the original vector if it has 0 or 1 elements
  if (length(array) <= 1) {
    return(array)
  }
  
  # Compute the sum of the first and last elements
  sum_first_last <- array[1] + array[length(array)]
  
  # Determine the sorting order based on the parity of the sum
  if (sum_first_last %% 2 == 0) {
    # Even sum → descending order
    sorted_vec <- sort(array, decreasing = TRUE)
  } else {
    # Odd sum → ascending order
    sorted_vec <- sort(array, decreasing = FALSE)
  }
  
  return(sorted_vec)
}
test_humaneval <- function() {
    candidate <- sort_array
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5)), c(5))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5)), c(0, 1, 2, 3, 4, 5))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5, 6)), c(6, 5, 4, 3, 2, 1, 0))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 1)), c(1, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(15, 42, 87, 32, 11, 0)), c(0, 11, 15, 32, 42, 87))))
    stopifnot(isTRUE(all.equal(candidate(c(21, 14, 23, 11)), c(23, 21, 14, 11))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183775
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 91 (R) - HumanEval_91_is_bored
================================================================================

PROMPT:
----------------------------------------
# You'll be given a string of words, and your task is to count the number
# of boredoms. A boredom is a sentence that starts with the word "I".
# Sentences are delimited by '.', '?' or '!'.
# For example:
# >>> is_bored('Hello world')
# 0
# >>> is_bored('The sky is blue. The sun is shining. I love this weather')
# 1

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- is_bored
    stopifnot(isTRUE(all.equal(candidate('Hello world'), 0)))
    stopifnot(isTRUE(all.equal(candidate('Is the sky blue?'), 0)))
    stopifnot(isTRUE(all.equal(candidate('I love It !'), 1)))
    stopifnot(isTRUE(all.equal(candidate('bIt'), 0)))
    stopifnot(isTRUE(all.equal(candidate('I feel good today. I will be productive. will kill It'), 2)))
    stopifnot(isTRUE(all.equal(candidate('You and I are going for a walk'), 0)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# You'll be given a string of words, and your task is to count the number
# of boredoms. A boredom is a sentence that starts with the word "I".
# Sentences are delimited by '.', '?' or '!'.
# For example:
# >>> is_bored('Hello world')
# 0
# >>> is_bored('The sky is blue. The sun is shining. I love this weather')
# 1
is_bored <- function(S) {
  # If the string is empty, no sentences exist
  if (nchar(S) == 0) return(0L)
  
  # Split the string into sentences using '.', '?' or '!' as delimiters
  # The regex includes all three characters; use perl=TRUE for robust handling
  sentences <- unlist(strsplit(S, "[.!?]", perl = TRUE))
  
  # Remove leading/trailing whitespace from each sentence
  sentences <- trimws(sentences)
  
  # Count sentences that start with the word "I"
  # ^I\\b ensures "I" is a whole word at the beginning
  count <- sum(grepl("^I\\b", sentences, perl = TRUE))
  
  # Return an integer count
  as.integer(count)
}
test_humaneval <- function() {
    candidate <- is_bored
    stopifnot(isTRUE(all.equal(candidate('Hello world'), 0)))
    stopifnot(isTRUE(all.equal(candidate('Is the sky blue?'), 0)))
    stopifnot(isTRUE(all.equal(candidate('I love It !'), 1)))
    stopifnot(isTRUE(all.equal(candidate('bIt'), 0)))
    stopifnot(isTRUE(all.equal(candidate('I feel good today. I will be productive. will kill It'), 2)))
    stopifnot(isTRUE(all.equal(candidate('You and I are going for a walk'), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183777
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# You'll be given a string of words, and your task is to count the number
# of boredoms. A boredom is a sentence that starts with the word "I".
# Sentences are delimited by '.', '?' or '!'.
# For example:
# >>> is_bored('Hello world')
# 0
# >>> is_bored('The sky is blue. The sun is shining. I love this weather')
# 1
is_bored <- function(S) {
  # Handle empty input
  if (nchar(S) == 0) return(0)
  
  # Split the text into sentences using '.', '?' or '!' as delimiters
  # The regex keeps the delimiters out of the resulting pieces
  sentences <- unlist(strsplit(S, "[.!?]"))
  
  # Trim whitespace from each sentence
  sentences <- trimws(sentences)
  
  # Count sentences that start with the word "I"
  # Use word boundary to avoid matching "I" inside another word
  boredoms <- sum(grepl("^I\\b", sentences))
  
  return(boredoms)
}
test_humaneval <- function() {
    candidate <- is_bored
    stopifnot(isTRUE(all.equal(candidate('Hello world'), 0)))
    stopifnot(isTRUE(all.equal(candidate('Is the sky blue?'), 0)))
    stopifnot(isTRUE(all.equal(candidate('I love It !'), 1)))
    stopifnot(isTRUE(all.equal(candidate('bIt'), 0)))
    stopifnot(isTRUE(all.equal(candidate('I feel good today. I will be productive. will kill It'), 2)))
    stopifnot(isTRUE(all.equal(candidate('You and I are going for a walk'), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183777
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# You'll be given a string of words, and your task is to count the number
# of boredoms. A boredom is a sentence that starts with the word "I".
# Sentences are delimited by '.', '?' or '!'.
# For example:
# >>> is_bored('Hello world')
# 0
# >>> is_bored('The sky is blue. The sun is shining. I love this weather')
# 1
is_bored <- function(S) {
  # Guard against empty input
  if (is.null(S) || nchar(S) == 0) return(0)
  
  # Split the string into sentences using '.', '?', or '!'
  # The regex keeps the delimiters out of the result.
  sentences <- unlist(strsplit(S, "[.!?]"))
  
  # Count sentences that start with the word "I"
  boredoms <- sum(grepl("^I\\b", trimws(sentences)))
  
  return(boredoms)
}
test_humaneval <- function() {
    candidate <- is_bored
    stopifnot(isTRUE(all.equal(candidate('Hello world'), 0)))
    stopifnot(isTRUE(all.equal(candidate('Is the sky blue?'), 0)))
    stopifnot(isTRUE(all.equal(candidate('I love It !'), 1)))
    stopifnot(isTRUE(all.equal(candidate('bIt'), 0)))
    stopifnot(isTRUE(all.equal(candidate('I feel good today. I will be productive. will kill It'), 2)))
    stopifnot(isTRUE(all.equal(candidate('You and I are going for a walk'), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183777
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# You'll be given a string of words, and your task is to count the number
# of boredoms. A boredom is a sentence that starts with the word "I".
# Sentences are delimited by '.', '?' or '!'.
# For example:
# >>> is_bored('Hello world')
# 0
# >>> is_bored('The sky is blue. The sun is shining. I love this weather')
# 1
is_bored <- function(S) {
  # Split the input string into sentences using punctuation delimiters
  # The regex splits on a period, question mark, or exclamation mark
  # followed by any amount of whitespace.
  sentences <- strsplit(S, "(?<=[.?!])\\s*", perl = TRUE)[[1]]
  
  # Remove leading/trailing whitespace from each sentence
  sentences <- trimws(sentences)
  
  # Count how many sentences start with the word "I"
  # We use a word boundary to avoid matching "I" inside other words.
  boredoms <- sum(grepl("^I\\b", sentences))
  
  return(boredoms)
}
test_humaneval <- function() {
    candidate <- is_bored
    stopifnot(isTRUE(all.equal(candidate('Hello world'), 0)))
    stopifnot(isTRUE(all.equal(candidate('Is the sky blue?'), 0)))
    stopifnot(isTRUE(all.equal(candidate('I love It !'), 1)))
    stopifnot(isTRUE(all.equal(candidate('bIt'), 0)))
    stopifnot(isTRUE(all.equal(candidate('I feel good today. I will be productive. will kill It'), 2)))
    stopifnot(isTRUE(all.equal(candidate('You and I are going for a walk'), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183777
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 93 (R) - HumanEval_93_encode
================================================================================

PROMPT:
----------------------------------------
# Write a function that takes a message, and encodes in such a 
# way that it swaps case of all letters, replaces all vowels in 
# the message with the letter that appears 2 places ahead of that 
# vowel in the english alphabet. 
# Assume only letters. 
# Examples:
# >>> encode('test')
# 'TGST'
# >>> encode('This is a message')
# 'tHKS KS C MGSSCGG'

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- encode
    stopifnot(isTRUE(all.equal(candidate('TEST'), 'tgst')))
    stopifnot(isTRUE(all.equal(candidate('Mudasir'), 'mWDCSKR')))
    stopifnot(isTRUE(all.equal(candidate('YES'), 'ygs')))
    stopifnot(isTRUE(all.equal(candidate('This is a message'), 'tHKS KS C MGSSCGG')))
    stopifnot(isTRUE(all.equal(candidate('I DoNt KnOw WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Write a function that takes a message, and encodes in such a 
# way that it swaps case of all letters, replaces all vowels in 
# the message with the letter that appears 2 places ahead of that 
# vowel in the english alphabet. 
# Assume only letters. 
# Examples:
# >>> encode('test')
# 'TGST'
# >>> encode('This is a message')
# 'tHKS KS C MGSSCGG'
encode <- function(message) {
  # Define vowel replacement mapping
  vowel_map <- c(
    a = "c", e = "g", i = "k", o = "q", u = "w",
    A = "C", E = "G", I = "K", O = "Q", U = "W"
  )
  
  # Split the message into individual characters
  chars <- strsplit(message, "")[[1]]
  
  # Process each character
  out_chars <- sapply(chars, function(ch) {
    # Swap case
    swapped <- if (grepl("[A-Z]", ch)) tolower(ch) else toupper(ch)
    
    # Replace vowels if present
    if (swapped %in% names(vowel_map)) {
      return(vowel_map[swapped])
    } else {
      return(swapped)
    }
  })
  
  # Combine back into a single string
  paste0(out_chars, collapse = "")
}
test_humaneval <- function() {
    candidate <- encode
    stopifnot(isTRUE(all.equal(candidate('TEST'), 'tgst')))
    stopifnot(isTRUE(all.equal(candidate('Mudasir'), 'mWDCSKR')))
    stopifnot(isTRUE(all.equal(candidate('YES'), 'ygs')))
    stopifnot(isTRUE(all.equal(candidate('This is a message'), 'tHKS KS C MGSSCGG')))
    stopifnot(isTRUE(all.equal(candidate('I DoNt KnOw WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183778
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Write a function that takes a message, and encodes in such a 
# way that it swaps case of all letters, replaces all vowels in 
# the message with the letter that appears 2 places ahead of that 
# vowel in the english alphabet. 
# Assume only letters. 
# Examples:
# >>> encode('test')
# 'TGST'
# >>> encode('This is a message')
# 'tHKS KS C MGSSCGG'
# Encode function: swap case of all letters and replace each vowel
# with the letter that appears 2 places ahead in the alphabet.
# Only alphabetic characters are processed; other characters are left unchanged.

encode <- function(message) {
  # Split the message into individual characters
  chars <- strsplit(message, "")[[1]]
  
  # Vowel mappings (lowercase and uppercase)
  vowels_lower  <- c("a", "e", "i", "o", "u")
  vowels_upper  <- toupper(vowels_lower)
  replace_lower <- c("c", "g", "k", "q", "w")
  replace_upper <- toupper(replace_lower)
  
  # Process each character
  out <- sapply(chars, function(ch) {
    # If it's not a letter, keep it as is
    if (!grepl("[A-Za-z]", ch)) return(ch)
    
    # Swap the case
    if (grepl("[a-z]", ch)) {
      ch_swapped <- toupper(ch)
    } else {
      ch_swapped <- tolower(ch)
    }
    
    # Replace vowels with the letter 2 places ahead
    if (ch_swapped %in% vowels_lower) {
      idx <- match(ch_swapped, vowels_lower)
      ch_swapped <- replace_lower[idx]
    } else if (ch_swapped %in% vowels_upper) {
      idx <- match(ch_swapped, vowels_upper)
      ch_swapped <- replace_upper[idx]
    }
    
    ch_swapped
  })
  
  # Reassemble the processed characters into a single string
  paste(out, collapse = "")
}
test_humaneval <- function() {
    candidate <- encode
    stopifnot(isTRUE(all.equal(candidate('TEST'), 'tgst')))
    stopifnot(isTRUE(all.equal(candidate('Mudasir'), 'mWDCSKR')))
    stopifnot(isTRUE(all.equal(candidate('YES'), 'ygs')))
    stopifnot(isTRUE(all.equal(candidate('This is a message'), 'tHKS KS C MGSSCGG')))
    stopifnot(isTRUE(all.equal(candidate('I DoNt KnOw WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183778
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Write a function that takes a message, and encodes in such a 
# way that it swaps case of all letters, replaces all vowels in 
# the message with the letter that appears 2 places ahead of that 
# vowel in the english alphabet. 
# Assume only letters. 
# Examples:
# >>> encode('test')
# 'TGST'
# >>> encode('This is a message')
# 'tHKS KS C MGSSCGG'
encode <- function(message) {
  # Helper: shift a letter 2 positions forward in the alphabet
  shift2 <- function(ch) {
    # Convert to uppercase for easy arithmetic
    up <- toupper(ch)
    # ASCII code of the uppercase letter
    code <- as.integer(charToRaw(up))
    # Shift by 2
    new_code <- code + 2
    # Convert back to a character
    new_ch <- rawToChar(as.raw(new_code))
    # Preserve original case
    if (grepl("[A-Z]", ch)) new_ch else tolower(new_ch)
  }
  
  # Vowels (both cases)
  vowels <- c("a","e","i","o","u","A","E","I","O","U")
  
  # Split message into individual characters
  chars <- strsplit(message, NULL)[[1]]
  
  # Process each character
  encoded <- vapply(chars, function(ch) {
    # Only letters are expected, but we keep non-letters unchanged
    if (!grepl("[A-Za-z]", ch)) {
      return(ch)
    }
    
    # Step 1: swap case
    swapped <- if (grepl("[a-z]", ch)) toupper(ch) else tolower(ch)
    
    # Step 2: replace vowels
    if (swapped %in% vowels) {
      shift2(swapped)
    } else {
      swapped
    }
  }, character(1))
  
  # Concatenate back into a single string
  paste0(encoded, collapse = "")
}
test_humaneval <- function() {
    candidate <- encode
    stopifnot(isTRUE(all.equal(candidate('TEST'), 'tgst')))
    stopifnot(isTRUE(all.equal(candidate('Mudasir'), 'mWDCSKR')))
    stopifnot(isTRUE(all.equal(candidate('YES'), 'ygs')))
    stopifnot(isTRUE(all.equal(candidate('This is a message'), 'tHKS KS C MGSSCGG')))
    stopifnot(isTRUE(all.equal(candidate('I DoNt KnOw WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183778
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Write a function that takes a message, and encodes in such a 
# way that it swaps case of all letters, replaces all vowels in 
# the message with the letter that appears 2 places ahead of that 
# vowel in the english alphabet. 
# Assume only letters. 
# Examples:
# >>> encode('test')
# 'TGST'
# >>> encode('This is a message')
# 'tHKS KS C MGSSCGG'
encode <- function(message) {
  # Define vowel mappings for lower and upper case
  lower_map <- c(a = "c", e = "g", i = "k", o = "q", u = "w")
  upper_map <- c(A = "C", E = "G", I = "K", O = "Q", U = "W")
  
  # Split the message into individual characters
  chars <- strsplit(message, "")[[1]]
  
  # Process each character
  processed <- sapply(chars, function(ch) {
    if (grepl("[A-Za-z]", ch)) {          # Only letters are processed
      # Replace vowel if necessary
      if (ch %in% names(lower_map)) {
        ch2 <- lower_map[[ch]]
      } else if (ch %in% names(upper_map)) {
        ch2 <- upper_map[[ch]]
      } else {
        ch2 <- ch
      }
      # Swap case of the resulting character
      if (grepl("[a-z]", ch2)) {
        toupper(ch2)
      } else {
        tolower(ch2)
      }
    } else {
      # Non‑letters remain unchanged
      ch
    }
  })
  
  # Combine back into a single string
  paste0(processed, collapse = "")
}
test_humaneval <- function() {
    candidate <- encode
    stopifnot(isTRUE(all.equal(candidate('TEST'), 'tgst')))
    stopifnot(isTRUE(all.equal(candidate('Mudasir'), 'mWDCSKR')))
    stopifnot(isTRUE(all.equal(candidate('YES'), 'ygs')))
    stopifnot(isTRUE(all.equal(candidate('This is a message'), 'tHKS KS C MGSSCGG')))
    stopifnot(isTRUE(all.equal(candidate('I DoNt KnOw WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183778
STDOUT: (empty)
STDERR: (empty)
--------------------
