As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 85 (LUA) - HumanEval_85_add
================================================================================

PROMPT:
----------------------------------------
-- Given a non-empty table of integers lst. add the even elements that are at odd indices..
-- Examples:
-- >>> add({4, 2, 6, 7})
-- 2

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = add
    lu.assertEquals(candidate({4, 88}), 88)
    lu.assertEquals(candidate({4, 5, 6, 7, 2, 122}), 122)
    lu.assertEquals(candidate({4, 0, 6, 7}), 0)
    lu.assertEquals(candidate({4, 4, 6, 8}), 12)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a non-empty table of integers lst. add the even elements that are at odd indices..
-- Examples:
-- >>> add({4, 2, 6, 7})
-- 2
local function add(lst)
  local sum = 0
  for i, v in ipairs(lst) do
    local idx = i - 1          -- convert Lua 1‑based index to 0‑based
    if idx % 2 == 1 and v % 2 == 0 then
      sum = sum + v
    end
  end
  return sum
end
lu = require('luaunit')

function test_humaneval()
local candidate = add
    lu.assertEquals(candidate({4, 88}), 88)
    lu.assertEquals(candidate({4, 5, 6, 7, 2, 122}), 122)
    lu.assertEquals(candidate({4, 0, 6, 7}), 0)
    lu.assertEquals(candidate({4, 4, 6, 8}), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a non-empty table of integers lst. add the even elements that are at odd indices..
-- Examples:
-- >>> add({4, 2, 6, 7})
-- 2
-- add: sum the even elements that are at odd indices (0‑based indexing)
-- Example:
--   add({4, 2, 6, 7}) --> 2
local function add(lst)
  local sum = 0
  for i = 1, #lst do
    -- Treat the first element as index 0
    if ((i - 1) % 2 == 1) and (lst[i] % 2 == 0) then
      sum = sum + lst[i]
    end
  end
  return sum
end
lu = require('luaunit')

function test_humaneval()
local candidate = add
    lu.assertEquals(candidate({4, 88}), 88)
    lu.assertEquals(candidate({4, 5, 6, 7, 2, 122}), 122)
    lu.assertEquals(candidate({4, 0, 6, 7}), 0)
    lu.assertEquals(candidate({4, 4, 6, 8}), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a non-empty table of integers lst. add the even elements that are at odd indices..
-- Examples:
-- >>> add({4, 2, 6, 7})
-- 2
-- Add the even elements that are at odd indices (0‑based indexing)
local function add(lst)
    local sum = 0
    for i, v in ipairs(lst) do
        local idx = i - 1          -- convert Lua 1‑based index to 0‑based
        if idx % 2 == 1 and v % 2 == 0 then
            sum = sum + v
        end
    end
    return sum
end
lu = require('luaunit')

function test_humaneval()
local candidate = add
    lu.assertEquals(candidate({4, 88}), 88)
    lu.assertEquals(candidate({4, 5, 6, 7, 2, 122}), 122)
    lu.assertEquals(candidate({4, 0, 6, 7}), 0)
    lu.assertEquals(candidate({4, 4, 6, 8}), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a non-empty table of integers lst. add the even elements that are at odd indices..
-- Examples:
-- >>> add({4, 2, 6, 7})
-- 2
-- add the even elements that are at odd indices (0‑based indexing)
local function add(lst)
  local sum = 0
  for i = 1, #lst do
    local idx = i - 1          -- convert to 0‑based index
    if idx % 2 == 1 and lst[i] % 2 == 0 then
      sum = sum + lst[i]
    end
  end
  return sum
end
lu = require('luaunit')

function test_humaneval()
local candidate = add
    lu.assertEquals(candidate({4, 88}), 88)
    lu.assertEquals(candidate({4, 5, 6, 7, 2, 122}), 122)
    lu.assertEquals(candidate({4, 0, 6, 7}), 0)
    lu.assertEquals(candidate({4, 4, 6, 8}), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 86 (LUA) - HumanEval_86_anti_shuffle
================================================================================

PROMPT:
----------------------------------------
-- Write a function that takes a string and returns an ordered version of it.
-- Ordered version of string, is a string where all words (separated by space)
-- are replaced by a new word where all the characters arranged in
-- ascending order based on ascii value.
-- Note: You should keep the order of words and blank spaces in the sentence.
-- For example:
-- >>> anti_shuffle('Hi')
-- 'Hi'
-- >>> anti_shuffle('hello')
-- 'ehllo'
-- >>> anti_shuffle('Hello World!!!')
-- 'Hello !!!Wdlor'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = anti_shuffle
    lu.assertEquals(candidate('Hi'), 'Hi')
    lu.assertEquals(candidate('hello'), 'ehllo')
    lu.assertEquals(candidate('number'), 'bemnru')
    lu.assertEquals(candidate('abcd'), 'abcd')
    lu.assertEquals(candidate('Hello World!!!'), 'Hello !!!Wdlor')
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('Hi. My name is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Write a function that takes a string and returns an ordered version of it.
-- Ordered version of string, is a string where all words (separated by space)
-- are replaced by a new word where all the characters arranged in
-- ascending order based on ascii value.
-- Note: You should keep the order of words and blank spaces in the sentence.
-- For example:
-- >>> anti_shuffle('Hi')
-- 'Hi'
-- >>> anti_shuffle('hello')
-- 'ehllo'
-- >>> anti_shuffle('Hello World!!!')
-- 'Hello !!!Wdlor'
-- | anti_shuffle
-- Takes a string and returns a version where each word (separated by spaces)
-- has its characters sorted in ascending ASCII order.  Spaces are kept
-- exactly as they appear in the input.
--
-- Example:
--   anti_shuffle("Hello World!!!")  -->  "Hello !!!Wdlor"

local function anti_shuffle(s)
  -- Helper that sorts the characters of a single word
  local function sort_word(word)
    local chars = {}
    for i = 1, #word do
      chars[i] = word:sub(i, i)
    end
    table.sort(chars, function(a, b)
      return a:byte() < b:byte()
    end)
    return table.concat(chars)
  end

  -- Replace each non‑space sequence with its sorted form.
  return s:gsub("(%S+)", sort_word)
end
lu = require('luaunit')

function test_humaneval()
local candidate = anti_shuffle
    lu.assertEquals(candidate('Hi'), 'Hi')
    lu.assertEquals(candidate('hello'), 'ehllo')
    lu.assertEquals(candidate('number'), 'bemnru')
    lu.assertEquals(candidate('abcd'), 'abcd')
    lu.assertEquals(candidate('Hello World!!!'), 'Hello !!!Wdlor')
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('Hi. My name is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Write a function that takes a string and returns an ordered version of it.
-- Ordered version of string, is a string where all words (separated by space)
-- are replaced by a new word where all the characters arranged in
-- ascending order based on ascii value.
-- Note: You should keep the order of words and blank spaces in the sentence.
-- For example:
-- >>> anti_shuffle('Hi')
-- 'Hi'
-- >>> anti_shuffle('hello')
-- 'ehllo'
-- >>> anti_shuffle('Hello World!!!')
-- 'Hello !!!Wdlor'
-- | anti_shuffle
-- | -------------
-- | Takes a string `s` and returns a new string where each word (a
-- | sequence of non‑space characters) has its characters sorted in
-- | ascending ASCII order.  Spaces are preserved exactly as they
-- | appear in the original string.
--
-- | Example:
-- |   anti_shuffle('Hello World!!!')  -->  'Hello !!!Wdlor'
--
local function anti_shuffle(s)
  local result = {}   -- holds the final characters
  local word   = {}   -- buffer for the current word

  for i = 1, #s do
    local c = s:sub(i, i)
    if c == ' ' then
      -- Finish the current word: sort and append it to result
      if #word > 0 then
        table.sort(word)            -- sorts by ASCII value
        for _, ch in ipairs(word) do
          table.insert(result, ch)
        end
        word = {}                    -- reset word buffer
      end
      table.insert(result, c)        -- keep the space
    else
      table.insert(word, c)          -- accumulate characters of the word
    end
  end

  -- Handle the last word (if the string doesn't end with a space)
  if #word > 0 then
    table.sort(word)
    for _, ch in ipairs(word) do
      table.insert(result, ch)
    end
  end

  return table.concat(result)
end
lu = require('luaunit')

function test_humaneval()
local candidate = anti_shuffle
    lu.assertEquals(candidate('Hi'), 'Hi')
    lu.assertEquals(candidate('hello'), 'ehllo')
    lu.assertEquals(candidate('number'), 'bemnru')
    lu.assertEquals(candidate('abcd'), 'abcd')
    lu.assertEquals(candidate('Hello World!!!'), 'Hello !!!Wdlor')
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('Hi. My name is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Write a function that takes a string and returns an ordered version of it.
-- Ordered version of string, is a string where all words (separated by space)
-- are replaced by a new word where all the characters arranged in
-- ascending order based on ascii value.
-- Note: You should keep the order of words and blank spaces in the sentence.
-- For example:
-- >>> anti_shuffle('Hi')
-- 'Hi'
-- >>> anti_shuffle('hello')
-- 'ehllo'
-- >>> anti_shuffle('Hello World!!!')
-- 'Hello !!!Wdlor'
-- Returns an ordered version of the input string.
-- Each word (consecutive non‑space characters) is sorted
-- by ascending ASCII value, while the order of words and
-- spaces is preserved.
local function anti_shuffle(s)
    -- Helper to sort the characters of a word
    local function sort_word(word)
        local chars = {}
        for i = 1, #word do
            chars[i] = word:sub(i, i)
        end
        table.sort(chars)          -- default compares by ASCII
        return table.concat(chars)
    end

    -- Replace every word with its sorted version; spaces are untouched
    return s:gsub("%S+", sort_word)
end
lu = require('luaunit')

function test_humaneval()
local candidate = anti_shuffle
    lu.assertEquals(candidate('Hi'), 'Hi')
    lu.assertEquals(candidate('hello'), 'ehllo')
    lu.assertEquals(candidate('number'), 'bemnru')
    lu.assertEquals(candidate('abcd'), 'abcd')
    lu.assertEquals(candidate('Hello World!!!'), 'Hello !!!Wdlor')
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('Hi. My name is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Write a function that takes a string and returns an ordered version of it.
-- Ordered version of string, is a string where all words (separated by space)
-- are replaced by a new word where all the characters arranged in
-- ascending order based on ascii value.
-- Note: You should keep the order of words and blank spaces in the sentence.
-- For example:
-- >>> anti_shuffle('Hi')
-- 'Hi'
-- >>> anti_shuffle('hello')
-- 'ehllo'
-- >>> anti_shuffle('Hello World!!!')
-- 'Hello !!!Wdlor'
-- Write a function that takes a string and returns an ordered version of it.
-- Ordered version of string, is a string where all words (separated by space)
-- are replaced by a new word where all the characters arranged in
-- ascending order based on ascii value.
-- Note: You should keep the order of words and blank spaces in the sentence.
-- For example:
-- >>> anti_shuffle('Hi')
-- 'Hi'
-- >>> anti_shuffle('hello')
-- 'ehllo'
-- >>> anti_shuffle('Hello World!!!')
-- 'Hello !!!Wdlor'
local function anti_shuffle(s)
    local result = {}
    local i = 1
    local n = #s

    while i <= n do
        local c = s:sub(i, i)
        if c == ' ' then
            -- Preserve spaces exactly as they appear
            table.insert(result, c)
            i = i + 1
        else
            -- Gather a word (sequence of non-space characters)
            local j = i
            while j <= n and s:sub(j, j) ~= ' ' do
                j = j + 1
            end
            local word = s:sub(i, j - 1)

            -- Convert word to a table of bytes, sort, and rebuild string
            local bytes = {}
            for k = 1, #word do
                table.insert(bytes, string.byte(word, k))
            end
            table.sort(bytes)
            local sorted_word = ''
            for _, b in ipairs(bytes) do
                sorted_word = sorted_word .. string.char(b)
            end

            table.insert(result, sorted_word)
            i = j
        end
    end

    return table.concat(result)
end
lu = require('luaunit')

function test_humaneval()
local candidate = anti_shuffle
    lu.assertEquals(candidate('Hi'), 'Hi')
    lu.assertEquals(candidate('hello'), 'ehllo')
    lu.assertEquals(candidate('number'), 'bemnru')
    lu.assertEquals(candidate('abcd'), 'abcd')
    lu.assertEquals(candidate('Hello World!!!'), 'Hello !!!Wdlor')
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('Hi. My name is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 87 (LUA) - HumanEval_87_get_row
================================================================================

PROMPT:
----------------------------------------
-- You are given a 2 dimensional data, as a nested tables,
-- which is similar to matrix, however, unlike matrices,
-- each row may contain a different number of columns.
-- Given lst, and integer x, find integers x in the table,
-- and return table of tables, [(x1, y1), (x2, y2) ...] such that
-- each table is a coordinate - (row, columns), starting with 0.
-- Sort coordinates initially by rows in ascending order.
-- Also, sort coordinates of the row by columns in descending order.
-- Examples:
-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)
-- {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}
-- >>> get_row({}, 1)
-- {}
-- >>> get_row({{}, {1}, {1, 2, 3}}, 3)
-- {{2, 2}}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = get_row
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})
    lu.assertEquals(candidate({}, 1), {})
    lu.assertEquals(candidate({{1}}, 2), {})
    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You are given a 2 dimensional data, as a nested tables,
-- which is similar to matrix, however, unlike matrices,
-- each row may contain a different number of columns.
-- Given lst, and integer x, find integers x in the table,
-- and return table of tables, [(x1, y1), (x2, y2) ...] such that
-- each table is a coordinate - (row, columns), starting with 0.
-- Sort coordinates initially by rows in ascending order.
-- Also, sort coordinates of the row by columns in descending order.
-- Examples:
-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)
-- {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}
-- >>> get_row({}, 1)
-- {}
-- >>> get_row({{}, {1}, {1, 2, 3}}, 3)
-- {{2, 2}}
local function get_row(lst, x)
  local result = {}
  for i, row in ipairs(lst) do
    local cols = {}
    for j, val in ipairs(row) do
      if val == x then
        table.insert(cols, j - 1)   -- zero‑based column index
      end
    end
    -- sort columns in descending order
    table.sort(cols, function(a, b) return a > b end)
    for _, col in ipairs(cols) do
      table.insert(result, {i - 1, col})  -- zero‑based row index
    end
  end
  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = get_row
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})
    lu.assertEquals(candidate({}, 1), {})
    lu.assertEquals(candidate({{1}}, 2), {})
    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You are given a 2 dimensional data, as a nested tables,
-- which is similar to matrix, however, unlike matrices,
-- each row may contain a different number of columns.
-- Given lst, and integer x, find integers x in the table,
-- and return table of tables, [(x1, y1), (x2, y2) ...] such that
-- each table is a coordinate - (row, columns), starting with 0.
-- Sort coordinates initially by rows in ascending order.
-- Also, sort coordinates of the row by columns in descending order.
-- Examples:
-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)
-- {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}
-- >>> get_row({}, 1)
-- {}
-- >>> get_row({{}, {1}, {1, 2, 3}}, 3)
-- {{2, 2}}
local function get_row(lst, x)
    local result = {}

    -- iterate over each row (index starts at 1 in Lua)
    for i, row in ipairs(lst) do
        if type(row) == "table" then
            -- iterate over each column in the current row
            for j, val in ipairs(row) do
                if val == x then
                    -- store coordinates as {rowIndex, colIndex} starting from 0
                    table.insert(result, {i - 1, j - 1})
                end
            end
        end
    end

    -- sort first by row ascending, then by column descending
    table.sort(result, function(a, b)
        if a[1] ~= b[1] then
            return a[1] < b[1]
        else
            return a[2] > b[2]
        end
    end)

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = get_row
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})
    lu.assertEquals(candidate({}, 1), {})
    lu.assertEquals(candidate({{1}}, 2), {})
    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You are given a 2 dimensional data, as a nested tables,
-- which is similar to matrix, however, unlike matrices,
-- each row may contain a different number of columns.
-- Given lst, and integer x, find integers x in the table,
-- and return table of tables, [(x1, y1), (x2, y2) ...] such that
-- each table is a coordinate - (row, columns), starting with 0.
-- Sort coordinates initially by rows in ascending order.
-- Also, sort coordinates of the row by columns in descending order.
-- Examples:
-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)
-- {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}
-- >>> get_row({}, 1)
-- {}
-- >>> get_row({{}, {1}, {1, 2, 3}}, 3)
-- {{2, 2}}
-- Find all coordinates of value `x` in a ragged 2‑D table `lst`.
-- Coordinates are zero‑based: {row_index, column_index}.
-- The result is sorted by row ascending, and within each row by column descending.
local function get_row(lst, x)
    -- Collect all matching coordinates
    local coords = {}
    for r, row in ipairs(lst) do          -- r is 1‑based index
        if type(row) == "table" then
            for c, val in ipairs(row) do -- c is 1‑based index
                if val == x then
                    table.insert(coords, {r - 1, c - 1})  -- convert to 0‑based
                end
            end
        end
    end

    -- Sort: rows ascending, columns descending
    table.sort(coords, function(a, b)
        if a[1] ~= b[1] then
            return a[1] < b[1]          -- row ascending
        else
            return a[2] > b[2]          -- column descending
        end
    end)

    return coords
end
lu = require('luaunit')

function test_humaneval()
local candidate = get_row
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})
    lu.assertEquals(candidate({}, 1), {})
    lu.assertEquals(candidate({{1}}, 2), {})
    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You are given a 2 dimensional data, as a nested tables,
-- which is similar to matrix, however, unlike matrices,
-- each row may contain a different number of columns.
-- Given lst, and integer x, find integers x in the table,
-- and return table of tables, [(x1, y1), (x2, y2) ...] such that
-- each table is a coordinate - (row, columns), starting with 0.
-- Sort coordinates initially by rows in ascending order.
-- Also, sort coordinates of the row by columns in descending order.
-- Examples:
-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)
-- {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}
-- >>> get_row({}, 1)
-- {}
-- >>> get_row({{}, {1}, {1, 2, 3}}, 3)
-- {{2, 2}}
-- Find all coordinates of the value `x` in a ragged 2‑D table.
-- Rows and columns are zero‑based indices.
-- The result is sorted first by row (ascending) and then by column (descending).
local function get_row(lst, x)
    local result = {}

    -- Scan the ragged table
    for r, row in ipairs(lst) do
        for c, v in ipairs(row) do
            if v == x then
                table.insert(result, {r - 1, c - 1})  -- zero‑based indices
            end
        end
    end

    -- Sort by row ascending, column descending
    table.sort(result, function(a, b)
        if a[1] ~= b[1] then
            return a[1] < b[1]          -- row ascending
        else
            return a[2] > b[2]          -- column descending
        end
    end)

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = get_row
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})
    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})
    lu.assertEquals(candidate({}, 1), {})
    lu.assertEquals(candidate({{1}}, 2), {})
    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 88 (LUA) - HumanEval_88_sort_array
================================================================================

PROMPT:
----------------------------------------
-- Given a table of non-negative integers, return a colua of the given table after sorting,
-- you will sort the given table in ascending order if the sum( first index value, last index value) is odd,
-- or sort it in descending order if the sum( first index value, last index value) is even.
-- Note:
-- * don't change the given table.
-- Examples:
-- >>> sort_array({})
-- {}
-- >>> sort_array({5})
-- {5}
-- >>> sort_array({2, 4, 3, 0, 1, 5})
-- {0, 1, 2, 3, 4, 5}
-- >>> sort_array({2, 4, 3, 0, 1, 5, 6})
-- {6, 5, 4, 3, 2, 1, 0}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = sort_array
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({5}), {5})
    lu.assertEquals(candidate({2, 4, 3, 0, 1, 5}), {0, 1, 2, 3, 4, 5})
    lu.assertEquals(candidate({2, 4, 3, 0, 1, 5, 6}), {6, 5, 4, 3, 2, 1, 0})
    lu.assertEquals(candidate({2, 1}), {1, 2})
    lu.assertEquals(candidate({15, 42, 87, 32, 11, 0}), {0, 11, 15, 32, 42, 87})
    lu.assertEquals(candidate({21, 14, 23, 11}), {23, 21, 14, 11})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a table of non-negative integers, return a colua of the given table after sorting,
-- you will sort the given table in ascending order if the sum( first index value, last index value) is odd,
-- or sort it in descending order if the sum( first index value, last index value) is even.
-- Note:
-- * don't change the given table.
-- Examples:
-- >>> sort_array({})
-- {}
-- >>> sort_array({5})
-- {5}
-- >>> sort_array({2, 4, 3, 0, 1, 5})
-- {0, 1, 2, 3, 4, 5}
-- >>> sort_array({2, 4, 3, 0, 1, 5, 6})
-- {6, 5, 4, 3, 2, 1, 0}
local function sort_array(array)
    -- Handle nil or empty table
    if not array or #array == 0 then
        return {}
    end

    -- Create a shallow copy to avoid mutating the original table
    local result = {}
    for i = 1, #array do
        result[i] = array[i]
    end

    -- Determine sorting order based on the sum of first and last elements
    local sum = result[1] + result[#result]
    if sum % 2 == 1 then          -- odd sum → ascending
        table.sort(result)
    else                          -- even sum → descending
        table.sort(result, function(a, b) return a > b end)
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = sort_array
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({5}), {5})
    lu.assertEquals(candidate({2, 4, 3, 0, 1, 5}), {0, 1, 2, 3, 4, 5})
    lu.assertEquals(candidate({2, 4, 3, 0, 1, 5, 6}), {6, 5, 4, 3, 2, 1, 0})
    lu.assertEquals(candidate({2, 1}), {1, 2})
    lu.assertEquals(candidate({15, 42, 87, 32, 11, 0}), {0, 11, 15, 32, 42, 87})
    lu.assertEquals(candidate({21, 14, 23, 11}), {23, 21, 14, 11})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a table of non-negative integers, return a colua of the given table after sorting,
-- you will sort the given table in ascending order if the sum( first index value, last index value) is odd,
-- or sort it in descending order if the sum( first index value, last index value) is even.
-- Note:
-- * don't change the given table.
-- Examples:
-- >>> sort_array({})
-- {}
-- >>> sort_array({5})
-- {5}
-- >>> sort_array({2, 4, 3, 0, 1, 5})
-- {0, 1, 2, 3, 4, 5}
-- >>> sort_array({2, 4, 3, 0, 1, 5, 6})
-- {6, 5, 4, 3, 2, 1, 0}
local function sort_array(array)
  -- Make a shallow copy so the original table is not modified
  local copy = {}
  for i, v in ipairs(array) do
    copy[i] = v
  end

  local n = #copy
  if n == 0 then
    return {}
  end

  local first = copy[1]
  local last  = copy[n]
  local sum   = first + last

  -- Determine sort order: odd sum -> ascending, even sum -> descending
  local ascending = (sum % 2) == 1

  table.sort(copy, function(a, b)
    if ascending then
      return a < b
    else
      return a > b
    end
  end)

  return copy
end
lu = require('luaunit')

function test_humaneval()
local candidate = sort_array
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({5}), {5})
    lu.assertEquals(candidate({2, 4, 3, 0, 1, 5}), {0, 1, 2, 3, 4, 5})
    lu.assertEquals(candidate({2, 4, 3, 0, 1, 5, 6}), {6, 5, 4, 3, 2, 1, 0})
    lu.assertEquals(candidate({2, 1}), {1, 2})
    lu.assertEquals(candidate({15, 42, 87, 32, 11, 0}), {0, 11, 15, 32, 42, 87})
    lu.assertEquals(candidate({21, 14, 23, 11}), {23, 21, 14, 11})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a table of non-negative integers, return a colua of the given table after sorting,
-- you will sort the given table in ascending order if the sum( first index value, last index value) is odd,
-- or sort it in descending order if the sum( first index value, last index value) is even.
-- Note:
-- * don't change the given table.
-- Examples:
-- >>> sort_array({})
-- {}
-- >>> sort_array({5})
-- {5}
-- >>> sort_array({2, 4, 3, 0, 1, 5})
-- {0, 1, 2, 3, 4, 5}
-- >>> sort_array({2, 4, 3, 0, 1, 5, 6})
-- {6, 5, 4, 3, 2, 1, 0}
-- Sort a table of non‑negative integers without modifying the original table.
-- The table is sorted in ascending order if the sum of the first and last
-- elements is odd, otherwise it is sorted in descending order.
--
-- @param array table of non‑negative integers
-- @return a new table containing the sorted elements
local function sort_array(array)
    -- Create a shallow copy so the original table is untouched
    local sorted = {}
    for i = 1, #array do
        sorted[i] = array[i]
    end

    -- Empty table – nothing to sort
    if #sorted == 0 then
        return sorted
    end

    local first  = sorted[1]
    local last   = sorted[#sorted]
    local sum    = first + last

    -- Determine sort order based on parity of the sum
    if sum % 2 == 1 then
        -- Ascending order
        table.sort(sorted)
    else
        -- Descending order
        table.sort(sorted, function(a, b) return a > b end)
    end

    return sorted
end
lu = require('luaunit')

function test_humaneval()
local candidate = sort_array
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({5}), {5})
    lu.assertEquals(candidate({2, 4, 3, 0, 1, 5}), {0, 1, 2, 3, 4, 5})
    lu.assertEquals(candidate({2, 4, 3, 0, 1, 5, 6}), {6, 5, 4, 3, 2, 1, 0})
    lu.assertEquals(candidate({2, 1}), {1, 2})
    lu.assertEquals(candidate({15, 42, 87, 32, 11, 0}), {0, 11, 15, 32, 42, 87})
    lu.assertEquals(candidate({21, 14, 23, 11}), {23, 21, 14, 11})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a table of non-negative integers, return a colua of the given table after sorting,
-- you will sort the given table in ascending order if the sum( first index value, last index value) is odd,
-- or sort it in descending order if the sum( first index value, last index value) is even.
-- Note:
-- * don't change the given table.
-- Examples:
-- >>> sort_array({})
-- {}
-- >>> sort_array({5})
-- {5}
-- >>> sort_array({2, 4, 3, 0, 1, 5})
-- {0, 1, 2, 3, 4, 5}
-- >>> sort_array({2, 4, 3, 0, 1, 5, 6})
-- {6, 5, 4, 3, 2, 1, 0}
local function sort_array(array)
    local n = #array
    if n == 0 then
        return {}
    end

    local first = array[1]
    local last  = array[n]
    local sum   = first + last

    -- create a copy so the original array is not modified
    local sorted = {}
    for i = 1, n do
        sorted[i] = array[i]
    end

    if sum % 2 == 1 then
        -- odd sum → ascending order
        table.sort(sorted)
    else
        -- even sum → descending order
        table.sort(sorted, function(a, b) return a > b end)
    end

    return sorted
end
lu = require('luaunit')

function test_humaneval()
local candidate = sort_array
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({5}), {5})
    lu.assertEquals(candidate({2, 4, 3, 0, 1, 5}), {0, 1, 2, 3, 4, 5})
    lu.assertEquals(candidate({2, 4, 3, 0, 1, 5, 6}), {6, 5, 4, 3, 2, 1, 0})
    lu.assertEquals(candidate({2, 1}), {1, 2})
    lu.assertEquals(candidate({15, 42, 87, 32, 11, 0}), {0, 11, 15, 32, 42, 87})
    lu.assertEquals(candidate({21, 14, 23, 11}), {23, 21, 14, 11})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 89 (LUA) - HumanEval_89_encrypt
================================================================================

PROMPT:
----------------------------------------
-- Create a function encrypt that takes a string as an argument and
-- returns a string encrypted with the alphabet being rotated. 
-- The alphabet should be rotated in a manner such that the letters 
-- shift down by two multiplied to two places.
-- For example:
-- >>> encrypt('hi')
-- 'lm'
-- >>> encrypt('asdfghjkl')
-- 'ewhjklnop'
-- >>> encrypt('gf')
-- 'kj'
-- >>> encrypt('et')
-- 'ix'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = encrypt
    lu.assertEquals(candidate('hi'), 'lm')
    lu.assertEquals(candidate('asdfghjkl'), 'ewhjklnop')
    lu.assertEquals(candidate('gf'), 'kj')
    lu.assertEquals(candidate('et'), 'ix')
    lu.assertEquals(candidate('faewfawefaewg'), 'jeiajeaijeiak')
    lu.assertEquals(candidate('hellomyfriend'), 'lippsqcjvmirh')
    lu.assertEquals(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')
    lu.assertEquals(candidate('a'), 'e')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Create a function encrypt that takes a string as an argument and
-- returns a string encrypted with the alphabet being rotated. 
-- The alphabet should be rotated in a manner such that the letters 
-- shift down by two multiplied to two places.
-- For example:
-- >>> encrypt('hi')
-- 'lm'
-- >>> encrypt('asdfghjkl')
-- 'ewhjklnop'
-- >>> encrypt('gf')
-- 'kj'
-- >>> encrypt('et')
-- 'ix'
-- Encrypt a string using a Caesar cipher with a shift of +4
-- (i.e., rotate the alphabet down by 2 * 2 places).
local function encrypt(s)
  -- Helper to shift a single character
  local function shift_char(c)
    local byte = string.byte(c)
    -- Lowercase letters
    if byte >= string.byte('a') and byte <= string.byte('z') then
      return string.char(((byte - string.byte('a') + 4) % 26) + string.byte('a'))
    -- Uppercase letters
    elseif byte >= string.byte('A') and byte <= string.byte('Z') then
      return string.char(((byte - string.byte('A') + 4) % 26) + string.byte('A'))
    else
      -- Non‑alphabetic characters are unchanged
      return c
    end
  end

  -- Build the result string
  local result = {}
  for i = 1, #s do
    result[i] = shift_char(s:sub(i,i))
  end
  return table.concat(result)
end
lu = require('luaunit')

function test_humaneval()
local candidate = encrypt
    lu.assertEquals(candidate('hi'), 'lm')
    lu.assertEquals(candidate('asdfghjkl'), 'ewhjklnop')
    lu.assertEquals(candidate('gf'), 'kj')
    lu.assertEquals(candidate('et'), 'ix')
    lu.assertEquals(candidate('faewfawefaewg'), 'jeiajeaijeiak')
    lu.assertEquals(candidate('hellomyfriend'), 'lippsqcjvmirh')
    lu.assertEquals(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')
    lu.assertEquals(candidate('a'), 'e')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Create a function encrypt that takes a string as an argument and
-- returns a string encrypted with the alphabet being rotated. 
-- The alphabet should be rotated in a manner such that the letters 
-- shift down by two multiplied to two places.
-- For example:
-- >>> encrypt('hi')
-- 'lm'
-- >>> encrypt('asdfghjkl')
-- 'ewhjklnop'
-- >>> encrypt('gf')
-- 'kj'
-- >>> encrypt('et')
-- 'ix'
-- Encrypts a string by shifting each lowercase alphabetic character
-- four positions forward (wrapping around from 'z' to 'a').
-- Non‑alphabetic characters are left unchanged.
local function encrypt(s)
  local result = {}
  for i = 1, #s do
    local c = s:sub(i,i)
    local code = string.byte(c)
    if code >= string.byte('a') and code <= string.byte('z') then
      -- shift by +4 with wrap‑around
      local shifted = ((code - string.byte('a') + 4) % 26) + string.byte('a')
      result[i] = string.char(shifted)
    else
      -- leave non‑letters unchanged
      result[i] = c
    end
  end
  return table.concat(result)
end

-- Example usage:
-- print(encrypt('hi'))          --> 'lm'
-- print(encrypt('asdfghjkl'))   --> 'ewhjklnop'
-- print(encrypt('gf'))          --> 'kj'
-- print(encrypt('et'))          --> 'ix'
lu = require('luaunit')

function test_humaneval()
local candidate = encrypt
    lu.assertEquals(candidate('hi'), 'lm')
    lu.assertEquals(candidate('asdfghjkl'), 'ewhjklnop')
    lu.assertEquals(candidate('gf'), 'kj')
    lu.assertEquals(candidate('et'), 'ix')
    lu.assertEquals(candidate('faewfawefaewg'), 'jeiajeaijeiak')
    lu.assertEquals(candidate('hellomyfriend'), 'lippsqcjvmirh')
    lu.assertEquals(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')
    lu.assertEquals(candidate('a'), 'e')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Create a function encrypt that takes a string as an argument and
-- returns a string encrypted with the alphabet being rotated. 
-- The alphabet should be rotated in a manner such that the letters 
-- shift down by two multiplied to two places.
-- For example:
-- >>> encrypt('hi')
-- 'lm'
-- >>> encrypt('asdfghjkl')
-- 'ewhjklnop'
-- >>> encrypt('gf')
-- 'kj'
-- >>> encrypt('et')
-- 'ix'
local function encrypt(s)
  local res = {}
  for i = 1, #s do
    local c = s:sub(i, i)
    local code = string.byte(c)
    if code >= 97 and code <= 122 then  -- lower case
      local new = (code - 97 + 4) % 26 + 97
      res[i] = string.char(new)
    elseif code >= 65 and code <= 90 then  -- upper case
      local new = (code - 65 + 4) % 26 + 65
      res[i] = string.char(new)
    else
      res[i] = c  -- non‑alphabetic characters unchanged
    end
  end
  return table.concat(res)
end
lu = require('luaunit')

function test_humaneval()
local candidate = encrypt
    lu.assertEquals(candidate('hi'), 'lm')
    lu.assertEquals(candidate('asdfghjkl'), 'ewhjklnop')
    lu.assertEquals(candidate('gf'), 'kj')
    lu.assertEquals(candidate('et'), 'ix')
    lu.assertEquals(candidate('faewfawefaewg'), 'jeiajeaijeiak')
    lu.assertEquals(candidate('hellomyfriend'), 'lippsqcjvmirh')
    lu.assertEquals(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')
    lu.assertEquals(candidate('a'), 'e')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Create a function encrypt that takes a string as an argument and
-- returns a string encrypted with the alphabet being rotated. 
-- The alphabet should be rotated in a manner such that the letters 
-- shift down by two multiplied to two places.
-- For example:
-- >>> encrypt('hi')
-- 'lm'
-- >>> encrypt('asdfghjkl')
-- 'ewhjklnop'
-- >>> encrypt('gf')
-- 'kj'
-- >>> encrypt('et')
-- 'ix'
local function encrypt(s)
  local res = {}
  for i = 1, #s do
    local c = string.byte(s, i)
    if c >= 97 and c <= 122 then          -- lowercase
      res[i] = string.char(((c - 97 + 4) % 26) + 97)
    elseif c >= 65 and c <= 90 then       -- uppercase
      res[i] = string.char(((c - 65 + 4) % 26) + 65)
    else                                  -- non‑alphabetic
      res[i] = string.char(c)
    end
  end
  return table.concat(res)
end
lu = require('luaunit')

function test_humaneval()
local candidate = encrypt
    lu.assertEquals(candidate('hi'), 'lm')
    lu.assertEquals(candidate('asdfghjkl'), 'ewhjklnop')
    lu.assertEquals(candidate('gf'), 'kj')
    lu.assertEquals(candidate('et'), 'ix')
    lu.assertEquals(candidate('faewfawefaewg'), 'jeiajeaijeiak')
    lu.assertEquals(candidate('hellomyfriend'), 'lippsqcjvmirh')
    lu.assertEquals(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')
    lu.assertEquals(candidate('a'), 'e')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 90 (LUA) - HumanEval_90_next_smallest
================================================================================

PROMPT:
----------------------------------------
-- You are given a table of integers.
-- Write a function next_smallest() that returns the 2nd smallest element of the table.
-- Return nil if there is no such element.
-- >>> next_smallest({1, 2, 3, 4, 5})
-- 2
-- >>> next_smallest({5, 1, 4, 3, 2})
-- 2
-- >>> next_smallest({})
-- None
-- >>> next_smallest({1, 1})
-- None

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = next_smallest
    lu.assertEquals(candidate({1, 2, 3, 4, 5}), 2)
    lu.assertEquals(candidate({5, 1, 4, 3, 2}), 2)
    lu.assertEquals(candidate({}), None)
    lu.assertEquals(candidate({1, 1}), None)
    lu.assertEquals(candidate({1, 1, 1, 1, 0}), 1)
    lu.assertEquals(candidate({1, 1}), None)
    lu.assertEquals(candidate({-35, 34, 12, -45}), -35)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You are given a table of integers.
-- Write a function next_smallest() that returns the 2nd smallest element of the table.
-- Return nil if there is no such element.
-- >>> next_smallest({1, 2, 3, 4, 5})
-- 2
-- >>> next_smallest({5, 1, 4, 3, 2})
-- 2
-- >>> next_smallest({})
-- None
-- >>> next_smallest({1, 1})
-- None
-- Find the 2nd smallest distinct element in a table.
-- Returns nil if there is no such element.
local function next_smallest(lst)
    local min1, min2 = nil, nil

    for _, v in ipairs(lst) do
        if min1 == nil or v < min1 then
            if v ~= min1 then
                min2 = min1
                min1 = v
            end
        elseif v ~= min1 then
            if min2 == nil or v < min2 then
                min2 = v
            end
        end
    end

    return min2
end
lu = require('luaunit')

function test_humaneval()
local candidate = next_smallest
    lu.assertEquals(candidate({1, 2, 3, 4, 5}), 2)
    lu.assertEquals(candidate({5, 1, 4, 3, 2}), 2)
    lu.assertEquals(candidate({}), None)
    lu.assertEquals(candidate({1, 1}), None)
    lu.assertEquals(candidate({1, 1, 1, 1, 0}), 1)
    lu.assertEquals(candidate({1, 1}), None)
    lu.assertEquals(candidate({-35, 34, 12, -45}), -35)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You are given a table of integers.
-- Write a function next_smallest() that returns the 2nd smallest element of the table.
-- Return nil if there is no such element.
-- >>> next_smallest({1, 2, 3, 4, 5})
-- 2
-- >>> next_smallest({5, 1, 4, 3, 2})
-- 2
-- >>> next_smallest({})
-- None
-- >>> next_smallest({1, 1})
-- None
local function next_smallest(lst)
  -- Return nil if the list is empty or has fewer than 2 distinct values
  if #lst < 2 then
    return nil
  end

  local min1, min2 = nil, nil

  for _, v in ipairs(lst) do
    if min1 == nil or v < min1 then
      -- Found a new smallest value
      min2 = min1
      min1 = v
    elseif (min2 == nil or v < min2) and v ~= min1 then
      -- Found a new second smallest distinct value
      min2 = v
    end
  end

  return min2
end
lu = require('luaunit')

function test_humaneval()
local candidate = next_smallest
    lu.assertEquals(candidate({1, 2, 3, 4, 5}), 2)
    lu.assertEquals(candidate({5, 1, 4, 3, 2}), 2)
    lu.assertEquals(candidate({}), None)
    lu.assertEquals(candidate({1, 1}), None)
    lu.assertEquals(candidate({1, 1, 1, 1, 0}), 1)
    lu.assertEquals(candidate({1, 1}), None)
    lu.assertEquals(candidate({-35, 34, 12, -45}), -35)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You are given a table of integers.
-- Write a function next_smallest() that returns the 2nd smallest element of the table.
-- Return nil if there is no such element.
-- >>> next_smallest({1, 2, 3, 4, 5})
-- 2
-- >>> next_smallest({5, 1, 4, 3, 2})
-- 2
-- >>> next_smallest({})
-- None
-- >>> next_smallest({1, 1})
-- None
-- Returns the second smallest distinct value in `lst`.
-- If the list is empty or contains only one distinct value, returns nil.
local function next_smallest(lst)
    local min1, min2 = nil, nil

    for _, v in ipairs(lst) do
        -- Update the smallest value
        if min1 == nil or v < min1 then
            min2 = min1
            min1 = v
        -- Update the second smallest value (must be distinct from the smallest)
        elseif v ~= min1 and (min2 == nil or v < min2) then
            min2 = v
        end
    end

    return min2
end
lu = require('luaunit')

function test_humaneval()
local candidate = next_smallest
    lu.assertEquals(candidate({1, 2, 3, 4, 5}), 2)
    lu.assertEquals(candidate({5, 1, 4, 3, 2}), 2)
    lu.assertEquals(candidate({}), None)
    lu.assertEquals(candidate({1, 1}), None)
    lu.assertEquals(candidate({1, 1, 1, 1, 0}), 1)
    lu.assertEquals(candidate({1, 1}), None)
    lu.assertEquals(candidate({-35, 34, 12, -45}), -35)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You are given a table of integers.
-- Write a function next_smallest() that returns the 2nd smallest element of the table.
-- Return nil if there is no such element.
-- >>> next_smallest({1, 2, 3, 4, 5})
-- 2
-- >>> next_smallest({5, 1, 4, 3, 2})
-- 2
-- >>> next_smallest({})
-- None
-- >>> next_smallest({1, 1})
-- None
local function next_smallest(lst)
  -- Use two variables to keep track of the smallest and the second smallest distinct values
  local min1 = math.huge
  local min2 = math.huge

  for _, v in ipairs(lst) do
    if v < min1 then
      -- Found a new smallest value; shift the previous smallest to second smallest
      min2 = min1
      min1 = v
    elseif v ~= min1 and v < min2 then
      -- Found a new second smallest distinct value
      min2 = v
    end
  end

  -- If min2 was never updated, there is no second smallest element
  if min2 == math.huge then
    return nil
  else
    return min2
  end
end
lu = require('luaunit')

function test_humaneval()
local candidate = next_smallest
    lu.assertEquals(candidate({1, 2, 3, 4, 5}), 2)
    lu.assertEquals(candidate({5, 1, 4, 3, 2}), 2)
    lu.assertEquals(candidate({}), None)
    lu.assertEquals(candidate({1, 1}), None)
    lu.assertEquals(candidate({1, 1, 1, 1, 0}), 1)
    lu.assertEquals(candidate({1, 1}), None)
    lu.assertEquals(candidate({-35, 34, 12, -45}), -35)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154474
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 96 (LUA) - HumanEval_96_count_up_to
================================================================================

PROMPT:
----------------------------------------
-- Implement a function that takes an non-negative integer and returns a table of the first n
-- integers that are prime numbers and less than n.
-- for example:
-- >>> count_up_to(5)
-- {2, 3}
-- >>> count_up_to(11)
-- {2, 3, 5, 7}
-- >>> count_up_to(0)
-- {}
-- >>> count_up_to(20)
-- {2, 3, 5, 7, 11, 13, 17, 19}
-- >>> count_up_to(1)
-- {}
-- >>> count_up_to(18)
-- {2, 3, 5, 7, 11, 13, 17}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = count_up_to
    lu.assertEquals(candidate(5), {2, 3})
    lu.assertEquals(candidate(6), {2, 3, 5})
    lu.assertEquals(candidate(7), {2, 3, 5})
    lu.assertEquals(candidate(10), {2, 3, 5, 7})
    lu.assertEquals(candidate(0), {})
    lu.assertEquals(candidate(22), {2, 3, 5, 7, 11, 13, 17, 19})
    lu.assertEquals(candidate(1), {})
    lu.assertEquals(candidate(18), {2, 3, 5, 7, 11, 13, 17})
    lu.assertEquals(candidate(47), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43})
    lu.assertEquals(candidate(101), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Implement a function that takes an non-negative integer and returns a table of the first n
-- integers that are prime numbers and less than n.
-- for example:
-- >>> count_up_to(5)
-- {2, 3}
-- >>> count_up_to(11)
-- {2, 3, 5, 7}
-- >>> count_up_to(0)
-- {}
-- >>> count_up_to(20)
-- {2, 3, 5, 7, 11, 13, 17, 19}
-- >>> count_up_to(1)
-- {}
-- >>> count_up_to(18)
-- {2, 3, 5, 7, 11, 13, 17}
-- Returns a table containing all prime numbers less than n
local function count_up_to(n)
    local primes = {}

    -- Helper function to test primality
    local function is_prime(x)
        if x < 2 then return false end
        local limit = math.floor(math.sqrt(x))
        for i = 2, limit do
            if x % i == 0 then
                return false
            end
        end
        return true
    end

    for i = 2, n - 1 do
        if is_prime(i) then
            table.insert(primes, i)
        end
    end

    return primes
end
lu = require('luaunit')

function test_humaneval()
local candidate = count_up_to
    lu.assertEquals(candidate(5), {2, 3})
    lu.assertEquals(candidate(6), {2, 3, 5})
    lu.assertEquals(candidate(7), {2, 3, 5})
    lu.assertEquals(candidate(10), {2, 3, 5, 7})
    lu.assertEquals(candidate(0), {})
    lu.assertEquals(candidate(22), {2, 3, 5, 7, 11, 13, 17, 19})
    lu.assertEquals(candidate(1), {})
    lu.assertEquals(candidate(18), {2, 3, 5, 7, 11, 13, 17})
    lu.assertEquals(candidate(47), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43})
    lu.assertEquals(candidate(101), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Implement a function that takes an non-negative integer and returns a table of the first n
-- integers that are prime numbers and less than n.
-- for example:
-- >>> count_up_to(5)
-- {2, 3}
-- >>> count_up_to(11)
-- {2, 3, 5, 7}
-- >>> count_up_to(0)
-- {}
-- >>> count_up_to(20)
-- {2, 3, 5, 7, 11, 13, 17, 19}
-- >>> count_up_to(1)
-- {}
-- >>> count_up_to(18)
-- {2, 3, 5, 7, 11, 13, 17}
-- Returns a table containing all prime numbers less than n
local function count_up_to(n)
  local primes = {}

  -- Only numbers 2 and above can be prime
  for num = 2, n - 1 do
    local is_prime = true
    local limit = math.floor(math.sqrt(num))

    for div = 2, limit do
      if num % div == 0 then
        is_prime = false
        break
      end
    end

    if is_prime then
      table.insert(primes, num)
    end
  end

  return primes
end
lu = require('luaunit')

function test_humaneval()
local candidate = count_up_to
    lu.assertEquals(candidate(5), {2, 3})
    lu.assertEquals(candidate(6), {2, 3, 5})
    lu.assertEquals(candidate(7), {2, 3, 5})
    lu.assertEquals(candidate(10), {2, 3, 5, 7})
    lu.assertEquals(candidate(0), {})
    lu.assertEquals(candidate(22), {2, 3, 5, 7, 11, 13, 17, 19})
    lu.assertEquals(candidate(1), {})
    lu.assertEquals(candidate(18), {2, 3, 5, 7, 11, 13, 17})
    lu.assertEquals(candidate(47), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43})
    lu.assertEquals(candidate(101), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Implement a function that takes an non-negative integer and returns a table of the first n
-- integers that are prime numbers and less than n.
-- for example:
-- >>> count_up_to(5)
-- {2, 3}
-- >>> count_up_to(11)
-- {2, 3, 5, 7}
-- >>> count_up_to(0)
-- {}
-- >>> count_up_to(20)
-- {2, 3, 5, 7, 11, 13, 17, 19}
-- >>> count_up_to(1)
-- {}
-- >>> count_up_to(18)
-- {2, 3, 5, 7, 11, 13, 17}
-- Returns a table of all prime numbers < n
local function count_up_to(n)
    local primes = {}  -- result table

    -- Helper to test primality
    local function is_prime(x)
        if x < 2 then return false end
        local limit = math.floor(math.sqrt(x))
        for d = 2, limit do
            if x % d == 0 then
                return false
            end
        end
        return true
    end

    for num = 2, n - 1 do
        if is_prime(num) then
            table.insert(primes, num)
        end
    end

    return primes
end
lu = require('luaunit')

function test_humaneval()
local candidate = count_up_to
    lu.assertEquals(candidate(5), {2, 3})
    lu.assertEquals(candidate(6), {2, 3, 5})
    lu.assertEquals(candidate(7), {2, 3, 5})
    lu.assertEquals(candidate(10), {2, 3, 5, 7})
    lu.assertEquals(candidate(0), {})
    lu.assertEquals(candidate(22), {2, 3, 5, 7, 11, 13, 17, 19})
    lu.assertEquals(candidate(1), {})
    lu.assertEquals(candidate(18), {2, 3, 5, 7, 11, 13, 17})
    lu.assertEquals(candidate(47), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43})
    lu.assertEquals(candidate(101), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Implement a function that takes an non-negative integer and returns a table of the first n
-- integers that are prime numbers and less than n.
-- for example:
-- >>> count_up_to(5)
-- {2, 3}
-- >>> count_up_to(11)
-- {2, 3, 5, 7}
-- >>> count_up_to(0)
-- {}
-- >>> count_up_to(20)
-- {2, 3, 5, 7, 11, 13, 17, 19}
-- >>> count_up_to(1)
-- {}
-- >>> count_up_to(18)
-- {2, 3, 5, 7, 11, 13, 17}
-- Returns a table containing all prime numbers less than the given non‑negative integer `n`.
-- The primes are returned in ascending order.
local function count_up_to(n)
    -- Helper function to determine if a number is prime.
    local function is_prime(x)
        if x < 2 then return false end
        if x == 2 then return true end
        if x % 2 == 0 then return false end
        local limit = math.floor(math.sqrt(x))
        for i = 3, limit, 2 do
            if x % i == 0 then return false end
        end
        return true
    end

    local primes = {}
    for num = 2, n - 1 do
        if is_prime(num) then
            table.insert(primes, num)
        end
    end
    return primes
end
lu = require('luaunit')

function test_humaneval()
local candidate = count_up_to
    lu.assertEquals(candidate(5), {2, 3})
    lu.assertEquals(candidate(6), {2, 3, 5})
    lu.assertEquals(candidate(7), {2, 3, 5})
    lu.assertEquals(candidate(10), {2, 3, 5, 7})
    lu.assertEquals(candidate(0), {})
    lu.assertEquals(candidate(22), {2, 3, 5, 7, 11, 13, 17, 19})
    lu.assertEquals(candidate(1), {})
    lu.assertEquals(candidate(18), {2, 3, 5, 7, 11, 13, 17})
    lu.assertEquals(candidate(47), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43})
    lu.assertEquals(candidate(101), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 97 (LUA) - HumanEval_97_multiply
================================================================================

PROMPT:
----------------------------------------
-- Complete the function that takes two integers and returns 
-- the product of their unit digits.
-- Assume the input is always valid.
-- Examples:
-- >>> multiply(148, 412)
-- 16
-- >>> multiply(19, 28)
-- 72
-- >>> multiply(2020, 1851)
-- 0
-- >>> multiply(14, -15)
-- 20

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = multiply
    lu.assertEquals(candidate(148, 412), 16)
    lu.assertEquals(candidate(19, 28), 72)
    lu.assertEquals(candidate(2020, 1851), 0)
    lu.assertEquals(candidate(14, -15), 20)
    lu.assertEquals(candidate(76, 67), 42)
    lu.assertEquals(candidate(17, 27), 49)
    lu.assertEquals(candidate(0, 1), 0)
    lu.assertEquals(candidate(0, 0), 0)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Complete the function that takes two integers and returns 
-- the product of their unit digits.
-- Assume the input is always valid.
-- Examples:
-- >>> multiply(148, 412)
-- 16
-- >>> multiply(19, 28)
-- 72
-- >>> multiply(2020, 1851)
-- 0
-- >>> multiply(14, -15)
-- 20
local function multiply(a, b)
    -- Extract the unit digit of each number (ignoring sign)
    local unitA = math.abs(a) % 10
    local unitB = math.abs(b) % 10

    -- Return the product of the unit digits
    return unitA * unitB
end
lu = require('luaunit')

function test_humaneval()
local candidate = multiply
    lu.assertEquals(candidate(148, 412), 16)
    lu.assertEquals(candidate(19, 28), 72)
    lu.assertEquals(candidate(2020, 1851), 0)
    lu.assertEquals(candidate(14, -15), 20)
    lu.assertEquals(candidate(76, 67), 42)
    lu.assertEquals(candidate(17, 27), 49)
    lu.assertEquals(candidate(0, 1), 0)
    lu.assertEquals(candidate(0, 0), 0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Complete the function that takes two integers and returns 
-- the product of their unit digits.
-- Assume the input is always valid.
-- Examples:
-- >>> multiply(148, 412)
-- 16
-- >>> multiply(19, 28)
-- 72
-- >>> multiply(2020, 1851)
-- 0
-- >>> multiply(14, -15)
-- 20
-- Complete the function that takes two integers and returns 
-- the product of their unit digits.
-- Assume the input is always valid.
-- Examples:
-- >>> multiply(148, 412)
-- 16
-- >>> multiply(19, 28)
-- 72
-- >>> multiply(2020, 1851)
-- 0
-- >>> multiply(14, -15)
-- 20
local function multiply(a, b)
    -- Extract the unit digit of each number (ignoring sign)
    local unitA = math.abs(a) % 10
    local unitB = math.abs(b) % 10
    return unitA * unitB
end
lu = require('luaunit')

function test_humaneval()
local candidate = multiply
    lu.assertEquals(candidate(148, 412), 16)
    lu.assertEquals(candidate(19, 28), 72)
    lu.assertEquals(candidate(2020, 1851), 0)
    lu.assertEquals(candidate(14, -15), 20)
    lu.assertEquals(candidate(76, 67), 42)
    lu.assertEquals(candidate(17, 27), 49)
    lu.assertEquals(candidate(0, 1), 0)
    lu.assertEquals(candidate(0, 0), 0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Complete the function that takes two integers and returns 
-- the product of their unit digits.
-- Assume the input is always valid.
-- Examples:
-- >>> multiply(148, 412)
-- 16
-- >>> multiply(19, 28)
-- 72
-- >>> multiply(2020, 1851)
-- 0
-- >>> multiply(14, -15)
-- 20
-- Complete the function that takes two integers and returns 
-- the product of their unit digits.
-- Assume the input is always valid.
-- Examples:
-- >>> multiply(148, 412)
-- 16
-- >>> multiply(19, 28)
-- 72
-- >>> multiply(2020, 1851)
-- 0
-- >>> multiply(14, -15)
-- 20
local function multiply(a, b)
    -- The unit digit of a number is the remainder when divided by 10.
    -- Lua's modulo operator (%) returns a non‑negative remainder for positive divisors,
    -- so it works correctly for negative numbers as well.
    local unitA = a % 10
    local unitB = b % 10
    return unitA * unitB
end
lu = require('luaunit')

function test_humaneval()
local candidate = multiply
    lu.assertEquals(candidate(148, 412), 16)
    lu.assertEquals(candidate(19, 28), 72)
    lu.assertEquals(candidate(2020, 1851), 0)
    lu.assertEquals(candidate(14, -15), 20)
    lu.assertEquals(candidate(76, 67), 42)
    lu.assertEquals(candidate(17, 27), 49)
    lu.assertEquals(candidate(0, 1), 0)
    lu.assertEquals(candidate(0, 0), 0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Complete the function that takes two integers and returns 
-- the product of their unit digits.
-- Assume the input is always valid.
-- Examples:
-- >>> multiply(148, 412)
-- 16
-- >>> multiply(19, 28)
-- 72
-- >>> multiply(2020, 1851)
-- 0
-- >>> multiply(14, -15)
-- 20
-- Complete the function that takes two integers and returns 
-- the product of their unit digits.
-- Assume the input is always valid.
-- Examples:
-- >>> multiply(148, 412)
-- 16
-- >>> multiply(19, 28)
-- 72
-- >>> multiply(2020, 1851)
-- 0
-- >>> multiply(14, -15)
-- 20
local function multiply(a, b)
    -- Get the absolute value of each number and extract the unit digit
    local unitA = math.abs(a) % 10
    local unitB = math.abs(b) % 10
    -- Return the product of the two unit digits
    return unitA * unitB
end
lu = require('luaunit')

function test_humaneval()
local candidate = multiply
    lu.assertEquals(candidate(148, 412), 16)
    lu.assertEquals(candidate(19, 28), 72)
    lu.assertEquals(candidate(2020, 1851), 0)
    lu.assertEquals(candidate(14, -15), 20)
    lu.assertEquals(candidate(76, 67), 42)
    lu.assertEquals(candidate(17, 27), 49)
    lu.assertEquals(candidate(0, 1), 0)
    lu.assertEquals(candidate(0, 0), 0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 99 (LUA) - HumanEval_99_closest_integer
================================================================================

PROMPT:
----------------------------------------
-- Create a function that takes a value (string) representing a number
-- and returns the closest integer to it. If the number is equidistant
-- from two integers, round it away from zero.
-- Examples
-- >>> closest_integer('10')
-- 10
-- >>> closest_integer('15.3')
-- 15
-- Note:
-- Rounding away from zero means that if the given number is equidistant
-- from two integers, the one you should return is the one that is the
-- farthest from zero. For example closest_integer("14.5") should
-- return 15 and closest_integer("-14.5") should return -15.

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = closest_integer
    lu.assertEquals(candidate('10'), 10)
    lu.assertEquals(candidate('14.5'), 15)
    lu.assertEquals(candidate('-15.5'), -16)
    lu.assertEquals(candidate('15.3'), 15)
    lu.assertEquals(candidate('0'), 0)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Create a function that takes a value (string) representing a number
-- and returns the closest integer to it. If the number is equidistant
-- from two integers, round it away from zero.
-- Examples
-- >>> closest_integer('10')
-- 10
-- >>> closest_integer('15.3')
-- 15
-- Note:
-- Rounding away from zero means that if the given number is equidistant
-- from two integers, the one you should return is the one that is the
-- farthest from zero. For example closest_integer("14.5") should
-- return 15 and closest_integer("-14.5") should return -15.
-- Create a function that takes a value (string) representing a number
-- and returns the closest integer to it. If the number is equidistant
-- from two integers, round it away from zero.
-- Examples
-- >>> closest_integer('10')
-- 10
-- >>> closest_integer('15.3')
-- 15
-- Note:
-- Rounding away from zero means that if the given number is equidistant
-- from two integers, the one you should return is the
-- farthest from zero. For example closest_integer("14.5") should
-- return 15 and closest_integer("-14.5") should return -15.
local function closest_integer(value)
    -- Convert the string to a number
    local num = tonumber(value)
    if not num then
        error("invalid number string: " .. tostring(value))
    end

    -- Find the floor and ceil of the number
    local fl = math.floor(num)
    local ce = math.ceil(num)

    -- If the number is already an integer, return it
    if fl == ce then
        return fl
    end

    -- Compute distances to floor and ceil
    local d_fl = math.abs(num - fl)
    local d_ce = math.abs(ce - num)

    if d_fl < d_ce then
        return fl
    elseif d_ce < d_fl then
        return ce
    else
        -- Equidistant: choose the one further from zero
        if num >= 0 then
            return ce   -- round up for positive numbers
        else
            return fl   -- round down (more negative) for negative numbers
        end
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = closest_integer
    lu.assertEquals(candidate('10'), 10)
    lu.assertEquals(candidate('14.5'), 15)
    lu.assertEquals(candidate('-15.5'), -16)
    lu.assertEquals(candidate('15.3'), 15)
    lu.assertEquals(candidate('0'), 0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Create a function that takes a value (string) representing a number
-- and returns the closest integer to it. If the number is equidistant
-- from two integers, round it away from zero.
-- Examples
-- >>> closest_integer('10')
-- 10
-- >>> closest_integer('15.3')
-- 15
-- Note:
-- Rounding away from zero means that if the given number is equidistant
-- from two integers, the one you should return is the one that is the
-- farthest from zero. For example closest_integer("14.5") should
-- return 15 and closest_integer("-14.5") should return -15.
-- Create a function that takes a value (string) representing a number
-- and returns the closest integer to it. If the number is equidistant
-- from two integers, round it away from zero.
-- Examples
-- >>> closest_integer('10')
-- 10
-- >>> closest_integer('15.3')
-- 15
-- Note:
-- Rounding away from zero means that if the given number is equidistant
-- from two integers, the one you should return is the one that is the
-- farthest from zero. For example closest_integer("14.5") should
-- return 15 and closest_integer("-14.5") should return -15.

local function closest_integer(value)
    -- Convert the string to a number
    local n = tonumber(value)
    if n == nil then
        return nil  -- or error("Invalid number")
    end

    -- Compute floor and ceil
    local fl = math.floor(n)
    local ce = math.ceil(n)

    -- If already an integer, return it
    if fl == ce then
        return fl
    end

    -- Distances to the two nearest integers
    local distFl = math.abs(n - fl)
    local distCe = math.abs(ce - n)

    -- Choose the closer integer, or break ties by rounding away from zero
    if distFl < distCe then
        return fl
    elseif distCe < distFl then
        return ce
    else
        -- Tie: choose the one further from zero
        if n > 0 then
            return ce
        else
            return fl
        end
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = closest_integer
    lu.assertEquals(candidate('10'), 10)
    lu.assertEquals(candidate('14.5'), 15)
    lu.assertEquals(candidate('-15.5'), -16)
    lu.assertEquals(candidate('15.3'), 15)
    lu.assertEquals(candidate('0'), 0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Create a function that takes a value (string) representing a number
-- and returns the closest integer to it. If the number is equidistant
-- from two integers, round it away from zero.
-- Examples
-- >>> closest_integer('10')
-- 10
-- >>> closest_integer('15.3')
-- 15
-- Note:
-- Rounding away from zero means that if the given number is equidistant
-- from two integers, the one you should return is the one that is the
-- farthest from zero. For example closest_integer("14.5") should
-- return 15 and closest_integer("-14.5") should return -15.
-- Create a function that takes a value (string) representing a number
-- and returns the closest integer to it. If the number is equidistant
-- from two integers, round it away from zero.
-- Examples
-- >>> closest_integer('10')
-- 10
-- >>> closest_integer('15.3')
-- 15
-- Note:
-- Rounding away from zero means that if the given number is equidistant
-- from two integers, the one you should return is the one that is the
-- farthest from zero. For example closest_integer("14.5") should
-- return 15 and closest_integer("-14.5") should return -15.

local function closest_integer(value)
    -- Convert the string to a number
    local num = tonumber(value)
    if num == nil then
        error("invalid numeric string: " .. tostring(value))
    end

    -- Quick return for integers
    if num == math.floor(num) then
        return num
    end

    local floor_val = math.floor(num)
    local ceil_val  = math.ceil(num)

    local diff_floor = math.abs(num - floor_val)
    local diff_ceil  = math.abs(ceil_val - num)

    if diff_floor < diff_ceil then
        return floor_val
    elseif diff_ceil < diff_floor then
        return ceil_val
    else
        -- Equidistant: round away from zero
        if num > 0 then
            return ceil_val
        else
            return floor_val
        end
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = closest_integer
    lu.assertEquals(candidate('10'), 10)
    lu.assertEquals(candidate('14.5'), 15)
    lu.assertEquals(candidate('-15.5'), -16)
    lu.assertEquals(candidate('15.3'), 15)
    lu.assertEquals(candidate('0'), 0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Create a function that takes a value (string) representing a number
-- and returns the closest integer to it. If the number is equidistant
-- from two integers, round it away from zero.
-- Examples
-- >>> closest_integer('10')
-- 10
-- >>> closest_integer('15.3')
-- 15
-- Note:
-- Rounding away from zero means that if the given number is equidistant
-- from two integers, the one you should return is the one that is the
-- farthest from zero. For example closest_integer("14.5") should
-- return 15 and closest_integer("-14.5") should return -15.
local function closest_integer(value)
  local num = tonumber(value)
  if not num then
    error("Invalid number")
  end

  local fl = math.floor(num)
  local ce = math.ceil(num)

  -- If the number is already an integer, return it
  if fl == ce then
    return fl
  end

  local diffFl = num - fl   -- distance to floor
  local diffCe = ce - num   -- distance to ceil

  if diffFl < diffCe then
    return fl
  elseif diffCe < diffFl then
    return ce
  else
    -- Tie: round away from zero
    return num > 0 and ce or fl
  end
end
lu = require('luaunit')

function test_humaneval()
local candidate = closest_integer
    lu.assertEquals(candidate('10'), 10)
    lu.assertEquals(candidate('14.5'), 15)
    lu.assertEquals(candidate('-15.5'), -16)
    lu.assertEquals(candidate('15.3'), 15)
    lu.assertEquals(candidate('0'), 0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 100 (LUA) - HumanEval_100_make_a_pile
================================================================================

PROMPT:
----------------------------------------
-- Given a positive integer n, you have to make a pile of n levels of stones.
-- The first level has n stones.
-- The number of stones in the next level is:
--     - the next odd number if n is odd.
--     - the next even number if n is even.
-- Return the number of stones in each level in a table, where element at index
-- i represents the number of stones in the level (i+1).
-- Examples:
-- >>> make_a_pile(3)
-- {3, 5, 7}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = make_a_pile
    lu.assertEquals(candidate(3), {3, 5, 7})
    lu.assertEquals(candidate(4), {4, 6, 8, 10})
    lu.assertEquals(candidate(5), {5, 7, 9, 11, 13})
    lu.assertEquals(candidate(6), {6, 8, 10, 12, 14, 16})
    lu.assertEquals(candidate(8), {8, 10, 12, 14, 16, 18, 20, 22})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a positive integer n, you have to make a pile of n levels of stones.
-- The first level has n stones.
-- The number of stones in the next level is:
--     - the next odd number if n is odd.
--     - the next even number if n is even.
-- Return the number of stones in each level in a table, where element at index
-- i represents the number of stones in the level (i+1).
-- Examples:
-- >>> make_a_pile(3)
-- {3, 5, 7}
-- Given a positive integer n, you have to make a pile of n levels of stones.
-- The first level has n stones.
-- The number of stones in the next level is:
--     - the next odd number if n is odd.
--     - the next even number if n is even.
-- Return the number of stones in each level in a table, where element at index
-- i represents the number of stones in the level (i+1).
-- Examples:
-- >>> make_a_pile(3)
-- {3, 5, 7}

local function make_a_pile(n)
    -- Ensure n is a positive integer
    if n <= 0 or math.floor(n) ~= n then
        error("n must be a positive integer")
    end

    local pile = {}
    for i = 0, n - 1 do
        pile[i + 1] = n + 2 * i
    end
    return pile
end

-- Example usage:
-- local result = make_a_pile(3)
-- for i, v in ipairs(result) do print(i, v) end
lu = require('luaunit')

function test_humaneval()
local candidate = make_a_pile
    lu.assertEquals(candidate(3), {3, 5, 7})
    lu.assertEquals(candidate(4), {4, 6, 8, 10})
    lu.assertEquals(candidate(5), {5, 7, 9, 11, 13})
    lu.assertEquals(candidate(6), {6, 8, 10, 12, 14, 16})
    lu.assertEquals(candidate(8), {8, 10, 12, 14, 16, 18, 20, 22})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a positive integer n, you have to make a pile of n levels of stones.
-- The first level has n stones.
-- The number of stones in the next level is:
--     - the next odd number if n is odd.
--     - the next even number if n is even.
-- Return the number of stones in each level in a table, where element at index
-- i represents the number of stones in the level (i+1).
-- Examples:
-- >>> make_a_pile(3)
-- {3, 5, 7}
-- Return a table representing the pile of stones.
-- The first element is `n`, and each subsequent element is
-- the next odd (if `n` is odd) or next even (if `n` is even) number.
local function make_a_pile(n)
    local pile = {}
    for i = 1, n do
        -- Since odd numbers and even numbers both increase by 2,
        -- the increment is always 2.
        pile[i] = n + (i - 1) * 2
    end
    return pile
end
lu = require('luaunit')

function test_humaneval()
local candidate = make_a_pile
    lu.assertEquals(candidate(3), {3, 5, 7})
    lu.assertEquals(candidate(4), {4, 6, 8, 10})
    lu.assertEquals(candidate(5), {5, 7, 9, 11, 13})
    lu.assertEquals(candidate(6), {6, 8, 10, 12, 14, 16})
    lu.assertEquals(candidate(8), {8, 10, 12, 14, 16, 18, 20, 22})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a positive integer n, you have to make a pile of n levels of stones.
-- The first level has n stones.
-- The number of stones in the next level is:
--     - the next odd number if n is odd.
--     - the next even number if n is even.
-- Return the number of stones in each level in a table, where element at index
-- i represents the number of stones in the level (i+1).
-- Examples:
-- >>> make_a_pile(3)
-- {3, 5, 7}
local function make_a_pile(n)
  local pile = {}
  for i = 1, n do
    pile[i] = n + (i - 1) * 2
  end
  return pile
end
lu = require('luaunit')

function test_humaneval()
local candidate = make_a_pile
    lu.assertEquals(candidate(3), {3, 5, 7})
    lu.assertEquals(candidate(4), {4, 6, 8, 10})
    lu.assertEquals(candidate(5), {5, 7, 9, 11, 13})
    lu.assertEquals(candidate(6), {6, 8, 10, 12, 14, 16})
    lu.assertEquals(candidate(8), {8, 10, 12, 14, 16, 18, 20, 22})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a positive integer n, you have to make a pile of n levels of stones.
-- The first level has n stones.
-- The number of stones in the next level is:
--     - the next odd number if n is odd.
--     - the next even number if n is even.
-- Return the number of stones in each level in a table, where element at index
-- i represents the number of stones in the level (i+1).
-- Examples:
-- >>> make_a_pile(3)
-- {3, 5, 7}
local function make_a_pile(n)
    local pile = {}
    for i = 1, n do
        pile[i] = n + (i - 1) * 2
    end
    return pile
end
lu = require('luaunit')

function test_humaneval()
local candidate = make_a_pile
    lu.assertEquals(candidate(3), {3, 5, 7})
    lu.assertEquals(candidate(4), {4, 6, 8, 10})
    lu.assertEquals(candidate(5), {5, 7, 9, 11, 13})
    lu.assertEquals(candidate(6), {6, 8, 10, 12, 14, 16})
    lu.assertEquals(candidate(8), {8, 10, 12, 14, 16, 18, 20, 22})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154475
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------
