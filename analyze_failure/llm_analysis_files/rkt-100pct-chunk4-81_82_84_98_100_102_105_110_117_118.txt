As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 81 (RKT) - HumanEval_81_numerical_letter_grade
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; It is the last week of the semester and the teacher has to give the grades
;; to students. The teacher has been making her own algorithm for grading.
;; The only problem is, she has lost the code she used for grading.
;; She has given you a list of GPAs for some students and you have to write 
;; a function that can output a list of letter grades using the following table:
;;          GPA       |    Letter grade
;;           4.0                A+
;;         > 3.7                A 
;;         > 3.3                A- 
;;         > 3.0                B+
;;         > 2.7                B 
;;         > 2.3                B-
;;         > 2.0                C+
;;         > 1.7                C
;;         > 1.3                C-
;;         > 1.0                D+ 
;;         > 0.7                D 
;;         > 0.0                D-
;;           0.0                E
;; Example:
;; >>> (grade_equation (list 4.0 3 1.7 2 3.5))
;; (list "A+" "B" "C-" "C" "A-")

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate numerical_letter_grade))
    (check-within (candidate (list 4.0 3 1.7 2 3.5)) (list "A+" "B" "C-" "C" "A-") 0.001)
    (check-within (candidate (list 1.2)) (list "D+") 0.001)
    (check-within (candidate (list 0.5)) (list "D-") 0.001)
    (check-within (candidate (list 0.0)) (list "E") 0.001)
    (check-within (candidate (list 1.0 0.3 1.5 2.8 3.3)) (list "D" "D-" "C-" "B" "B+") 0.001)
    (check-within (candidate (list 0.0 0.7)) (list "E" "D-") 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; It is the last week of the semester and the teacher has to give the grades
;; to students. The teacher has been making her own algorithm for grading.
;; The only problem is, she has lost the code she used for grading.
;; She has given you a list of GPAs for some students and you have to write 
;; a function that can output a list of letter grades using the following table:
;;          GPA       |    Letter grade
;;           4.0                A+
;;         > 3.7                A 
;;         > 3.3                A- 
;;         > 3.0                B+
;;         > 2.7                B 
;;         > 2.3                B-
;;         > 2.0                C+
;;         > 1.7                C
;;         > 1.3                C-
;;         > 1.0                D+ 
;;         > 0.7                D 
;;         > 0.0                D-
;;           0.0                E
;; Example:
;; >>> (grade_equation (list 4.0 3 1.7 2 3.5))
;; (list "A+" "B" "C-" "C" "A-")

;; Convert a list of numeric GPAs into a list of letter grades
(define (numerical_letter_grade grades)
  ;; Helper that maps a single GPA to its letter grade
  (define (grade g)
    (cond
      [(equal? g 4.0)        "A+"]
      [(> g 3.7)             "A"]
      [(> g 3.3)             "A-"]
      [(> g 3.0)             "B+"]
      [(> g 2.7)             "B"]
      [(> g 2.3)             "B-"]
      [(> g 2.0)             "C+"]
      [(> g 1.7)             "C"]
      [(> g 1.3)             "C-"]
      [(> g 1.0)             "D+"]
      [(> g 0.7)             "D"]
      [(> g 0.0)             "D-"]
      [(equal? g 0.0)        "E"]
      [else                  "E"]))  ; fall‑back for unexpected values

  ;; Map the helper over the input list
  (map grade grades))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate numerical_letter_grade))
    (check-within (candidate (list 4.0 3 1.7 2 3.5)) (list "A+" "B" "C-" "C" "A-") 0.001)
    (check-within (candidate (list 1.2)) (list "D+") 0.001)
    (check-within (candidate (list 0.5)) (list "D-") 0.001)
    (check-within (candidate (list 0.0)) (list "E") 0.001)
    (check-within (candidate (list 1.0 0.3 1.5 2.8 3.3)) (list "D" "D-" "C-" "B" "B+") 0.001)
    (check-within (candidate (list 0.0 0.7)) (list "E" "D-") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183915
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; It is the last week of the semester and the teacher has to give the grades
;; to students. The teacher has been making her own algorithm for grading.
;; The only problem is, she has lost the code she used for grading.
;; She has given you a list of GPAs for some students and you have to write 
;; a function that can output a list of letter grades using the following table:
;;          GPA       |    Letter grade
;;           4.0                A+
;;         > 3.7                A 
;;         > 3.3                A- 
;;         > 3.0                B+
;;         > 2.7                B 
;;         > 2.3                B-
;;         > 2.0                C+
;;         > 1.7                C
;;         > 1.3                C-
;;         > 1.0                D+ 
;;         > 0.7                D 
;;         > 0.0                D-
;;           0.0                E
;; Example:
;; >>> (grade_equation (list 4.0 3 1.7 2 3.5))
;; (list "A+" "B" "C-" "C" "A-")
(define (numerical_letter_grade grades)
  (map (lambda (g)
         (cond
           [(= g 4.0) "A+"]
           [(> g 3.7) "A"]
           [(> g 3.3) "A-"]
           [(> g 3.0) "B+"]
           [(> g 2.7) "B"]
           [(> g 2.3) "B-"]
           [(> g 2.0) "C+"]
           [(> g 1.7) "C"]
           [(> g 1.3) "C-"]
           [(> g 1.0) "D+"]
           [(> g 0.7) "D"]
           [(> g 0.0) "D-"]
           [else "E"]))
       grades))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate numerical_letter_grade))
    (check-within (candidate (list 4.0 3 1.7 2 3.5)) (list "A+" "B" "C-" "C" "A-") 0.001)
    (check-within (candidate (list 1.2)) (list "D+") 0.001)
    (check-within (candidate (list 0.5)) (list "D-") 0.001)
    (check-within (candidate (list 0.0)) (list "E") 0.001)
    (check-within (candidate (list 1.0 0.3 1.5 2.8 3.3)) (list "D" "D-" "C-" "B" "B+") 0.001)
    (check-within (candidate (list 0.0 0.7)) (list "E" "D-") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183915
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; It is the last week of the semester and the teacher has to give the grades
;; to students. The teacher has been making her own algorithm for grading.
;; The only problem is, she has lost the code she used for grading.
;; She has given you a list of GPAs for some students and you have to write 
;; a function that can output a list of letter grades using the following table:
;;          GPA       |    Letter grade
;;           4.0                A+
;;         > 3.7                A 
;;         > 3.3                A- 
;;         > 3.0                B+
;;         > 2.7                B 
;;         > 2.3                B-
;;         > 2.0                C+
;;         > 1.7                C
;;         > 1.3                C-
;;         > 1.0                D+ 
;;         > 0.7                D 
;;         > 0.0                D-
;;           0.0                E
;; Example:
;; >>> (grade_equation (list 4.0 3 1.7 2 3.5))
;; (list "A+" "B" "C-" "C" "A-")

;; Convert a list of numeric GPAs into their corresponding letter grades.
(define (numerical_letter_grade grades)
  (map (lambda (g)
         (cond
           [(= g 4.0) "A+"]
           [(> g 3.7) "A"]
           [(> g 3.3) "A-"]
           [(> g 3.0) "B+"]
           [(> g 2.7) "B"]
           [(> g 2.3) "B-"]
           [(> g 2.0) "C+"]
           [(> g 1.7) "C"]
           [(> g 1.3) "C-"]
           [(> g 1.0) "D+"]
           [(> g 0.7) "D"]
           [(> g 0.0) "D-"]
           [else "E"]))
       grades))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate numerical_letter_grade))
    (check-within (candidate (list 4.0 3 1.7 2 3.5)) (list "A+" "B" "C-" "C" "A-") 0.001)
    (check-within (candidate (list 1.2)) (list "D+") 0.001)
    (check-within (candidate (list 0.5)) (list "D-") 0.001)
    (check-within (candidate (list 0.0)) (list "E") 0.001)
    (check-within (candidate (list 1.0 0.3 1.5 2.8 3.3)) (list "D" "D-" "C-" "B" "B+") 0.001)
    (check-within (candidate (list 0.0 0.7)) (list "E" "D-") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183915
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; It is the last week of the semester and the teacher has to give the grades
;; to students. The teacher has been making her own algorithm for grading.
;; The only problem is, she has lost the code she used for grading.
;; She has given you a list of GPAs for some students and you have to write 
;; a function that can output a list of letter grades using the following table:
;;          GPA       |    Letter grade
;;           4.0                A+
;;         > 3.7                A 
;;         > 3.3                A- 
;;         > 3.0                B+
;;         > 2.7                B 
;;         > 2.3                B-
;;         > 2.0                C+
;;         > 1.7                C
;;         > 1.3                C-
;;         > 1.0                D+ 
;;         > 0.7                D 
;;         > 0.0                D-
;;           0.0                E
;; Example:
;; >>> (grade_equation (list 4.0 3 1.7 2 3.5))
;; (list "A+" "B" "C-" "C" "A-")

;; Convert a list of numeric GPAs into a list of letter grades.
(define (numerical_letter_grade grades)
  ;; Helper function that maps a single GPA to its letter grade.
  (define (grade g)
    (cond
      [(= g 4.0)      "A+"]   ; exact match for the top grade
      [(> g 3.7)      "A"]    ; > 3.7
      [(> g 3.3)      "A-"]   ; > 3.3
      [(> g 3.0)      "B+"]   ; > 3.0
      [(> g 2.7)      "B"]    ; > 2.7
      [(> g 2.3)      "B-"]   ; > 2.3
      [(> g 2.0)      "C+"]   ; > 2.0
      [(> g 1.7)      "C"]    ; > 1.7
      [(> g 1.3)      "C-"]   ; > 1.3
      [(> g 1.0)      "D+"]   ; > 1.0
      [(> g 0.7)      "D"]    ; > 0.7
      [(> g 0.0)      "D-"]   ; > 0.0
      [else           "E"]))  ; 0.0 or below

  ;; Apply the helper to each element of the input list.
  (map grade grades))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate numerical_letter_grade))
    (check-within (candidate (list 4.0 3 1.7 2 3.5)) (list "A+" "B" "C-" "C" "A-") 0.001)
    (check-within (candidate (list 1.2)) (list "D+") 0.001)
    (check-within (candidate (list 0.5)) (list "D-") 0.001)
    (check-within (candidate (list 0.0)) (list "E") 0.001)
    (check-within (candidate (list 1.0 0.3 1.5 2.8 3.3)) (list "D" "D-" "C-" "B" "B+") 0.001)
    (check-within (candidate (list 0.0 0.7)) (list "E" "D-") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183915
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 82 (RKT) - HumanEval_82_prime_length
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-within (candidate "Hello") #t 0.001)
    (check-within (candidate "abcdcba") #t 0.001)
    (check-within (candidate "kittens") #t 0.001)
    (check-within (candidate "orange") #f 0.001)
    (check-within (candidate "wow") #t 0.001)
    (check-within (candidate "world") #t 0.001)
    (check-within (candidate "MadaM") #t 0.001)
    (check-within (candidate "Wow") #t 0.001)
    (check-within (candidate "") #f 0.001)
    (check-within (candidate "HI") #t 0.001)
    (check-within (candidate "go") #t 0.001)
    (check-within (candidate "gogo") #f 0.001)
    (check-within (candidate "aaaaaaaaaaaaaaa") #f 0.001)
    (check-within (candidate "Madam") #t 0.001)
    (check-within (candidate "M") #f 0.001)
    (check-within (candidate "0") #f 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length str)
  ;; Helper: test if an integer n (> 1) is prime
  (define (prime? n)
    (cond
      [(< n 2) #f]                 ; 0 and 1 are not prime
      [(= n 2) #t]                 ; 2 is prime
      [(even? n) #f]               ; even numbers > 2 are not prime
      [else
       (let loop ([i 3])
         (cond
           [(> (* i i) n) #t]       ; no divisor found up to sqrt(n)
           [(zero? (modulo n i)) #f] ; divisor found
           [else (loop (+ i 2))]))]))
  (prime? (string-length str)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-within (candidate "Hello") #t 0.001)
    (check-within (candidate "abcdcba") #t 0.001)
    (check-within (candidate "kittens") #t 0.001)
    (check-within (candidate "orange") #f 0.001)
    (check-within (candidate "wow") #t 0.001)
    (check-within (candidate "world") #t 0.001)
    (check-within (candidate "MadaM") #t 0.001)
    (check-within (candidate "Wow") #t 0.001)
    (check-within (candidate "") #f 0.001)
    (check-within (candidate "HI") #t 0.001)
    (check-within (candidate "go") #t 0.001)
    (check-within (candidate "gogo") #f 0.001)
    (check-within (candidate "aaaaaaaaaaaaaaa") #f 0.001)
    (check-within (candidate "Madam") #t 0.001)
    (check-within (candidate "M") #f 0.001)
    (check-within (candidate "0") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183916
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f

;; Helper function: test whether an integer n is prime
(define (prime? n)
  (cond
    [(< n 2) #f]                     ; 0 and 1 are not prime
    [(or (= n 2) (= n 3)) #t]        ; 2 and 3 are prime
    [(even? n) #f]                   ; even numbers > 2 are not prime
    [else
     (let loop ([i 3])
       (cond
         [(> (* i i) n) #t]          ; no divisor found up to sqrt(n)
         [(zero? (modulo n i)) #f]   ; divisor found
         [else (loop (+ i 2))]))]))   ; test next odd number

;; Main function: returns #t if the string length is prime, #f otherwise
(define (prime_length string)
  (prime? (string-length string)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-within (candidate "Hello") #t 0.001)
    (check-within (candidate "abcdcba") #t 0.001)
    (check-within (candidate "kittens") #t 0.001)
    (check-within (candidate "orange") #f 0.001)
    (check-within (candidate "wow") #t 0.001)
    (check-within (candidate "world") #t 0.001)
    (check-within (candidate "MadaM") #t 0.001)
    (check-within (candidate "Wow") #t 0.001)
    (check-within (candidate "") #f 0.001)
    (check-within (candidate "HI") #t 0.001)
    (check-within (candidate "go") #t 0.001)
    (check-within (candidate "gogo") #f 0.001)
    (check-within (candidate "aaaaaaaaaaaaaaa") #f 0.001)
    (check-within (candidate "Madam") #t 0.001)
    (check-within (candidate "M") #f 0.001)
    (check-within (candidate "0") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183916
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f

(define (prime_length string)
  ;; Helper: check if a positive integer n is prime
  (define (prime? n)
    (cond
      [(< n 2) #f]                 ; 0 and 1 are not prime
      [(= n 2) #t]                 ; 2 is prime
      [(even? n) #f]               ; even numbers > 2 are not prime
      [else
       (let loop ([i 3])
         (cond
           [(> (* i i) n) #t]       ; no divisor found
           [(zero? (modulo n i)) #f] ; divisor found
           [else (loop (+ i 2))]))])) ; test next odd number

  (prime? (string-length string)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-within (candidate "Hello") #t 0.001)
    (check-within (candidate "abcdcba") #t 0.001)
    (check-within (candidate "kittens") #t 0.001)
    (check-within (candidate "orange") #f 0.001)
    (check-within (candidate "wow") #t 0.001)
    (check-within (candidate "world") #t 0.001)
    (check-within (candidate "MadaM") #t 0.001)
    (check-within (candidate "Wow") #t 0.001)
    (check-within (candidate "") #f 0.001)
    (check-within (candidate "HI") #t 0.001)
    (check-within (candidate "go") #t 0.001)
    (check-within (candidate "gogo") #f 0.001)
    (check-within (candidate "aaaaaaaaaaaaaaa") #f 0.001)
    (check-within (candidate "Madam") #t 0.001)
    (check-within (candidate "M") #f 0.001)
    (check-within (candidate "0") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183916
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  ;; Helper: test if an integer n is prime
  (define (prime? n)
    (cond
      [(< n 2) #f]                     ; 0 and 1 are not prime
      [(= n 2) #t]                     ; 2 is prime
      [(even? n) #f]                   ; even numbers > 2 are not prime
      [else
       ;; Check odd divisors up to sqrt(n)
       (let loop ([i 3])
         (cond
           [(> (* i i) n) #t]           ; no divisor found
           [(zero? (modulo n i)) #f]    ; divisor found
           [else (loop (+ i 2))]))]))   ; try next odd number

  ;; Apply the test to the length of the string
  (prime? (string-length string)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-within (candidate "Hello") #t 0.001)
    (check-within (candidate "abcdcba") #t 0.001)
    (check-within (candidate "kittens") #t 0.001)
    (check-within (candidate "orange") #f 0.001)
    (check-within (candidate "wow") #t 0.001)
    (check-within (candidate "world") #t 0.001)
    (check-within (candidate "MadaM") #t 0.001)
    (check-within (candidate "Wow") #t 0.001)
    (check-within (candidate "") #f 0.001)
    (check-within (candidate "HI") #t 0.001)
    (check-within (candidate "go") #t 0.001)
    (check-within (candidate "gogo") #f 0.001)
    (check-within (candidate "aaaaaaaaaaaaaaa") #f 0.001)
    (check-within (candidate "Madam") #t 0.001)
    (check-within (candidate "M") #f 0.001)
    (check-within (candidate "0") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183916
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 84 (RKT) - HumanEval_84_solve
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;;     @N integer
;;          Constraints: 0 ≤ N ≤ 10000.
;; Output:
;;      a string of binary number

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-within (candidate 1000) "1" 0.001)
    (check-within (candidate 150) "110" 0.001)
    (check-within (candidate 147) "1100" 0.001)
    (check-within (candidate 333) "1001" 0.001)
    (check-within (candidate 963) "10010" 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;;     @N integer
;;          Constraints: 0 ≤ N ≤ 10000.
;; Output:
;;      a string of binary number

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;;     @N integer
;;          Constraints: 0 ≤ N ≤ 10000.
;; Output:
;;      a string of binary number
(define (solve N)
  ;; Helper to compute the sum of decimal digits of N
  (define (digit-sum n)
    (if (= n 0)
        0
        (+ (modulo n 10)
           (digit-sum (quotient n 10)))))
  (define sum (digit-sum N))
  ;; Convert the sum to a binary string
  (number->string sum 2))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-within (candidate 1000) "1" 0.001)
    (check-within (candidate 150) "110" 0.001)
    (check-within (candidate 147) "1100" 0.001)
    (check-within (candidate 333) "1001" 0.001)
    (check-within (candidate 963) "10010" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183917
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;;     @N integer
;;          Constraints: 0 ≤ N ≤ 10000.
;; Output:
;;      a string of binary number

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;;     @N integer
;;          Constraints: 0 ≤ N ≤ 10000.
;; Output:
;;      a string of binary number
(define (solve N)
  (define (sum-digits n)
    (if (= n 0)
        0
        (+ (modulo n 10)
           (sum-digits (quotient n 10)))))
  (number->string (sum-digits N) 2))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-within (candidate 1000) "1" 0.001)
    (check-within (candidate 150) "110" 0.001)
    (check-within (candidate 147) "1100" 0.001)
    (check-within (candidate 333) "1001" 0.001)
    (check-within (candidate 963) "10010" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183917
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;;     @N integer
;;          Constraints: 0 ≤ N ≤ 10000.
;; Output:
;;      a string of binary number

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;;     @N integer
;;          Constraints: 0 ≤ N ≤ 10000.
;; Output:
;;      a string of binary number
(define (solve N)
  ;; Sum the decimal digits of N
  (define digit-sum
    (foldl + 0
           (map (lambda (c)
                  (- (char->integer c) (char->integer #\0)))
                (string->list (number->string N)))))
  ;; Convert the sum to a binary string
  (number->string digit-sum 2))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-within (candidate 1000) "1" 0.001)
    (check-within (candidate 150) "110" 0.001)
    (check-within (candidate 147) "1100" 0.001)
    (check-within (candidate 333) "1001" 0.001)
    (check-within (candidate 963) "10010" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183917
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;;     @N integer
;;          Constraints: 0 ≤ N ≤ 10000.
;; Output:
;;      a string of binary number

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;;     @N integer
;;          Constraints: 0 ≤ N ≤ 10000.
;; Output:
;;      a string of binary number

(define (solve N)
  ;; Compute the sum of the decimal digits of N
  (define digit-sum
    (let loop ([n N] [acc 0])
      (if (= n 0)
          acc
          (loop (quotient n 10) (+ acc (remainder n 10))))))
  ;; Convert that sum to a binary string
  (number->string digit-sum 2))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-within (candidate 1000) "1" 0.001)
    (check-within (candidate 150) "110" 0.001)
    (check-within (candidate 147) "1100" 0.001)
    (check-within (candidate 333) "1001" 0.001)
    (check-within (candidate 963) "10010" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183917
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 98 (RKT) - HumanEval_98_count_upper
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-within (candidate "aBCdEf") 1 0.001)
    (check-within (candidate "abcdefg") 0 0.001)
    (check-within (candidate "dBBE") 0 0.001)
    (check-within (candidate "B") 0 0.001)
    (check-within (candidate "U") 1 0.001)
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "EEEE") 2 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0

;; Count the number of uppercase vowels at even indices in a string.
(define (count_upper s)
  (for/fold ([cnt 0]) ([i (in-range (string-length s))])
    (if (and (= (modulo i 2) 0)
             (member (string-ref s i) '(#\A #\E #\I #\O #\U)))
        (+ cnt 1)
        cnt)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-within (candidate "aBCdEf") 1 0.001)
    (check-within (candidate "abcdefg") 0 0.001)
    (check-within (candidate "dBBE") 0 0.001)
    (check-within (candidate "B") 0 0.001)
    (check-within (candidate "U") 1 0.001)
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "EEEE") 2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183944
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0
(define (count_upper s)
  (let loop ((i 0) (cnt 0))
    (if (>= i (string-length s))
        cnt
        (let ((c (string-ref s i)))
          (if (and (even? i)
                   (member c '(#\A #\E #\I #\O #\U)))
              (loop (+ i 1) (+ cnt 1))
              (loop (+ i 1) cnt))))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-within (candidate "aBCdEf") 1 0.001)
    (check-within (candidate "abcdefg") 0 0.001)
    (check-within (candidate "dBBE") 0 0.001)
    (check-within (candidate "B") 0 0.001)
    (check-within (candidate "U") 1 0.001)
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "EEEE") 2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183944
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0

;; Count the number of uppercase vowels in even indices of a string.
(define (count_upper s)
  (define (upper-vowel? c)
    (member c '(#\A #\E #\I #\O #\U)))
  (define len (string-length s))
  (define (loop i acc)
    (cond
      [(>= i len) acc]
      [(even? i)
       (if (upper-vowel? (string-ref s i))
           (loop (+ i 1) (+ acc 1))
           (loop (+ i 1) acc))]
      [else
       (loop (+ i 1) acc)]))
  (loop 0 0))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-within (candidate "aBCdEf") 1 0.001)
    (check-within (candidate "abcdefg") 0 0.001)
    (check-within (candidate "dBBE") 0 0.001)
    (check-within (candidate "B") 0 0.001)
    (check-within (candidate "U") 1 0.001)
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "EEEE") 2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183944
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0
(define (count_upper s)
  (define len (string-length s))
  (define vowels (list #\A #\E #\I #\O #\U))
  (define (even-index? i) (= (remainder i 2) 0))
  (let loop ((i 0) (cnt 0))
    (if (>= i len)
        cnt
        (let ((c (string-ref s i)))
          (loop (+ i 1)
                (if (and (even-index? i) (member c vowels))
                    (+ cnt 1)
                    cnt))))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-within (candidate "aBCdEf") 1 0.001)
    (check-within (candidate "abcdefg") 0 0.001)
    (check-within (candidate "dBBE") 0 0.001)
    (check-within (candidate "B") 0 0.001)
    (check-within (candidate "U") 1 0.001)
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "EEEE") 2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183944
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 100 (RKT) - HumanEval_100_make_a_pile
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;;     - the next odd number if n is odd.
;;     - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-within (candidate 3) (list 3 5 7) 0.001)
    (check-within (candidate 4) (list 4 6 8 10) 0.001)
    (check-within (candidate 5) (list 5 7 9 11 13) 0.001)
    (check-within (candidate 6) (list 6 8 10 12 14 16) 0.001)
    (check-within (candidate 8) (list 8 10 12 14 16 18 20 22) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;;     - the next odd number if n is odd.
;;     - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)

;; Return a list of n levels of stones.
;; The first level has n stones, and each subsequent level
;; increases by 2 (maintaining the same parity as the first).
(define (make_a_pile n)
  (build-list n (lambda (i) (+ n (* 2 i)))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-within (candidate 3) (list 3 5 7) 0.001)
    (check-within (candidate 4) (list 4 6 8 10) 0.001)
    (check-within (candidate 5) (list 5 7 9 11 13) 0.001)
    (check-within (candidate 6) (list 6 8 10 12 14 16) 0.001)
    (check-within (candidate 8) (list 8 10 12 14 16 18 20 22) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183946
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;;     - the next odd number if n is odd.
;;     - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;;     - the next odd number if n is odd.
;;     - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)

(define (make_a_pile n)
  ;; The sequence always increases by 2 each level, starting from n.
  (build-list n (lambda (i) (+ n (* 2 i)))))

;; Test examples
(printf "~a~n" (make_a_pile 3))   ; => (3 5 7)
(printf "~a~n" (make_a_pile 4))   ; => (4 6 8 10)
(printf "~a~n" (make_a_pile 1))   ; => (1)
(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-within (candidate 3) (list 3 5 7) 0.001)
    (check-within (candidate 4) (list 4 6 8 10) 0.001)
    (check-within (candidate 5) (list 5 7 9 11 13) 0.001)
    (check-within (candidate 6) (list 6 8 10 12 14 16) 0.001)
    (check-within (candidate 8) (list 8 10 12 14 16 18 20 22) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183946
STDOUT:
(3 5 7)
(4 6 8 10)
(1)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;;     - the next odd number if n is odd.
;;     - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;;     - the next odd number if n is odd.
;;     - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;;
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
;;
(define (make_a_pile n)
  ;; Build a list of length n where the i-th element (0‑based) is n + 2*i.
  (build-list n (lambda (i) (+ n (* 2 i)))))

;; Quick tests
(displayln (make_a_pile 3))  ; => (3 5 7)
(displayln (make_a_pile 4))  ; => (4 6 8 10)
(displayln (make_a_pile 1))  ; => (1)
(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-within (candidate 3) (list 3 5 7) 0.001)
    (check-within (candidate 4) (list 4 6 8 10) 0.001)
    (check-within (candidate 5) (list 5 7 9 11 13) 0.001)
    (check-within (candidate 6) (list 6 8 10 12 14 16) 0.001)
    (check-within (candidate 8) (list 8 10 12 14 16 18 20 22) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183946
STDOUT:
(3 5 7)
(4 6 8 10)
(1)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;;     - the next odd number if n is odd.
;;     - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;;     - the next odd number if n is odd.
;;     - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)

(define (make_a_pile n)
  ;; The pile is simply n, n+2, n+4, …, n+2*(n-1)
  (build-list n
              (lambda (i)
                (+ n (* 2 i)))))

;; Test examples
(displayln (make_a_pile 3))   ; → (3 5 7)
(displayln (make_a_pile 4))   ; → (4 6 8 10)
(displayln (make_a_pile 1))   ; → (1)
(displayln (make_a_pile 5))   ; → (5 7 9 11 13)
(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-within (candidate 3) (list 3 5 7) 0.001)
    (check-within (candidate 4) (list 4 6 8 10) 0.001)
    (check-within (candidate 5) (list 5 7 9 11 13) 0.001)
    (check-within (candidate 6) (list 6 8 10 12 14 16) 0.001)
    (check-within (candidate 8) (list 8 10 12 14 16 18 20 22) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183946
STDOUT:
(3 5 7)
(4 6 8 10)
(1)
(5 7 9 11 13)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 102 (RKT) - HumanEval_102_choose_num
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-within (candidate 12 15) 14 0.001)
    (check-within (candidate 13 12) -1 0.001)
    (check-within (candidate 33 12354) 12354 0.001)
    (check-within (candidate 5234 5233) -1 0.001)
    (check-within (candidate 6 29) 28 0.001)
    (check-within (candidate 27 10) -1 0.001)
    (check-within (candidate 7 7) -1 0.001)
    (check-within (candidate 546 546) 546 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive.
;; If there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(> x y) -1]                                   ; x is greater than y → no range
    [else
     (let* ([y-even (if (even? y) y (- y 1))])     ; largest even ≤ y
       (if (>= y-even x) y-even -1))]))            ; check if it lies in [x, y]
(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-within (candidate 12 15) 14 0.001)
    (check-within (candidate 13 12) -1 0.001)
    (check-within (candidate 33 12354) 12354 0.001)
    (check-within (candidate 5234 5233) -1 0.001)
    (check-within (candidate 6 29) 28 0.001)
    (check-within (candidate 27 10) -1 0.001)
    (check-within (candidate 7 7) -1 0.001)
    (check-within (candidate 546 546) 546 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183948
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive.
;; If there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (if (> x y)
      -1                                     ; x is greater than y → no valid range
      (let ((candidate (if (even? y) y (- y 1)))) ; largest even ≤ y
        (if (>= candidate x)
            candidate                          ; candidate lies within [x, y]
            -1))))                               ; otherwise no even number in range
(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-within (candidate 12 15) 14 0.001)
    (check-within (candidate 13 12) -1 0.001)
    (check-within (candidate 33 12354) 12354 0.001)
    (check-within (candidate 5234 5233) -1 0.001)
    (check-within (candidate 6 29) 28 0.001)
    (check-within (candidate 27 10) -1 0.001)
    (check-within (candidate 7 7) -1 0.001)
    (check-within (candidate 546 546) 546 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183948
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive.
;; If there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(> x y) -1]                               ; x greater than y → no valid range
    [else
     (let* ([max-even (if (even? y) y (- y 1))] ; largest even ≤ y
            [result (if (>= max-even x) max-even -1)])
       result)]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-within (candidate 12 15) 14 0.001)
    (check-within (candidate 13 12) -1 0.001)
    (check-within (candidate 33 12354) 12354 0.001)
    (check-within (candidate 5234 5233) -1 0.001)
    (check-within (candidate 6 29) 28 0.001)
    (check-within (candidate 27 10) -1 0.001)
    (check-within (candidate 7 7) -1 0.001)
    (check-within (candidate 546 546) 546 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183948
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive.
;; If there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(> x y) -1]                          ; x is greater than y → no valid range
    [else
     (let ([candidate (if (even? y) y (- y 1))]) ; largest even ≤ y
       (if (>= candidate x) candidate -1))]))     ; check if candidate ≥ x
(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-within (candidate 12 15) 14 0.001)
    (check-within (candidate 13 12) -1 0.001)
    (check-within (candidate 33 12354) 12354 0.001)
    (check-within (candidate 5234 5233) -1 0.001)
    (check-within (candidate 6 29) 28 0.001)
    (check-within (candidate 27 10) -1 0.001)
    (check-within (candidate 7 7) -1 0.001)
    (check-within (candidate 546 546) 546 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183948
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 105 (RKT) - HumanEval_105_by_length
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given a list of integers, sort the integers that are between 1 and 9 inclusive,
;; reverse the resulting list, and then replace each digit by its corresponding name from
;; "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
;; For example:
;; >>> (by_length (list 2 1 1 4 5 8 2 3))
;; (list "Eight" "Five" "Four" "Three" "Two" "Two" "One" "One")
;;   If the list is empty, return an empty list:
;; >>> (by_length (list ))
;; (list )
;;   If the list has any strange number ignore it:
;; >>> (by_length (list 1 -1 55))
;; (list "One")

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate by_length))
    (check-within (candidate (list 2 1 1 4 5 8 2 3)) (list "Eight" "Five" "Four" "Three" "Two" "Two" "One" "One") 0.001)
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 -1 55)) (list "One") 0.001)
    (check-within (candidate (list 1 -1 3 2)) (list "Three" "Two" "One") 0.001)
    (check-within (candidate (list 9 4 8)) (list "Nine" "Eight" "Four") 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given a list of integers, sort the integers that are between 1 and 9 inclusive,
;; reverse the resulting list, and then replace each digit by its corresponding name from
;; "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
;; For example:
;; >>> (by_length (list 2 1 1 4 5 8 2 3))
;; (list "Eight" "Five" "Four" "Three" "Two" "Two" "One" "One")
;;   If the list is empty, return an empty list:
;; >>> (by_length (list ))
;; (list )
;;   If the list has any strange number ignore it:
;; >>> (by_length (list 1 -1 55))
;; (list "One")

;; Given a list of integers, sort the integers that are between 1 and 9 inclusive,
;; reverse the resulting list, and then replace each digit by its corresponding
;; name from "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
;; Example:
;; (by_length (list 2 1 1 4 5 8 2 3))
;; => (list "Eight" "Five" "Four" "Three" "Two" "Two" "One" "One")

(define (by_length arr)
  ;; Step 1: keep only integers between 1 and 9 inclusive
  (define valid
    (filter (lambda (x)
              (and (integer? x)
                   (>= x 1)
                   (<= x 9)))
            arr))
  ;; Step 2: sort ascending
  (define sorted (sort valid <))
  ;; Step 3: reverse the sorted list
  (define rev (reverse sorted))
  ;; Step 4: mapping from digit to name
  (define names
    (list "One" "Two" "Three" "Four" "Five"
          "Six" "Seven" "Eight" "Nine"))
  ;; Step 5: replace each digit with its name
  (map (lambda (n) (list-ref names (- n 1))) rev))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate by_length))
    (check-within (candidate (list 2 1 1 4 5 8 2 3)) (list "Eight" "Five" "Four" "Three" "Two" "Two" "One" "One") 0.001)
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 -1 55)) (list "One") 0.001)
    (check-within (candidate (list 1 -1 3 2)) (list "Three" "Two" "One") 0.001)
    (check-within (candidate (list 9 4 8)) (list "Nine" "Eight" "Four") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183951
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given a list of integers, sort the integers that are between 1 and 9 inclusive,
;; reverse the resulting list, and then replace each digit by its corresponding name from
;; "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
;; For example:
;; >>> (by_length (list 2 1 1 4 5 8 2 3))
;; (list "Eight" "Five" "Four" "Three" "Two" "Two" "One" "One")
;;   If the list is empty, return an empty list:
;; >>> (by_length (list ))
;; (list )
;;   If the list has any strange number ignore it:
;; >>> (by_length (list 1 -1 55))
;; (list "One")

;; Given a list of integers, sort the integers that are between 1 and 9 inclusive,
;; reverse the resulting list, and then replace each digit by its corresponding name
;; from "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
;; For example:
;; >>> (by_length (list 2 1 1 4 5 8 2 3))
;; (list "Eight" "Five" "Four" "Three" "Two" "Two" "One" "One")
;;   If the list is empty, return an empty list:
;; >>> (by_length (list ))
;; (list )
;;   If the list has any strange number ignore it:
;; >>> (by_length (list 1 -1 55))
;; (list "One")
(define (by_length arr)
  ;; List of digit names indexed from 0 to 8
  (define digit-names
    (list "One" "Two" "Three" "Four" "Five"
          "Six" "Seven" "Eight" "Nine"))
  ;; Keep only integers 1‑9
  (define filtered
    (filter (lambda (x)
              (and (integer? x) (>= x 1) (<= x 9)))
            arr))
  ;; Sort ascending, then reverse to get descending
  (define sorted (sort filtered <))
  (define reversed (reverse sorted))
  ;; Map each digit to its name
  (map (lambda (x)
         (list-ref digit-names (sub1 x))) ; sub1 because list is 0‑based
       reversed))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate by_length))
    (check-within (candidate (list 2 1 1 4 5 8 2 3)) (list "Eight" "Five" "Four" "Three" "Two" "Two" "One" "One") 0.001)
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 -1 55)) (list "One") 0.001)
    (check-within (candidate (list 1 -1 3 2)) (list "Three" "Two" "One") 0.001)
    (check-within (candidate (list 9 4 8)) (list "Nine" "Eight" "Four") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183951
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given a list of integers, sort the integers that are between 1 and 9 inclusive,
;; reverse the resulting list, and then replace each digit by its corresponding name from
;; "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
;; For example:
;; >>> (by_length (list 2 1 1 4 5 8 2 3))
;; (list "Eight" "Five" "Four" "Three" "Two" "Two" "One" "One")
;;   If the list is empty, return an empty list:
;; >>> (by_length (list ))
;; (list )
;;   If the list has any strange number ignore it:
;; >>> (by_length (list 1 -1 55))
;; (list "One")

;; Given a list of integers, sort the integers that are between 1 and 9 inclusive,
;; reverse the resulting list, and then replace each digit by its corresponding name from
;; "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
(define (by_length arr)
  (define names (list "One" "Two" "Three" "Four" "Five" "Six" "Seven" "Eight" "Nine"))
  ;; Keep only integers in the range 1..9
  (define filtered (filter (lambda (x)
                             (and (integer? x) (>= x 1) (<= x 9)))
                           arr))
  ;; Sort ascending, then reverse to get descending
  (define sorted (sort filtered <))
  (define rev (reverse sorted))
  ;; Map each number to its name
  (map (lambda (n) (list-ref names (- n 1))) rev))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate by_length))
    (check-within (candidate (list 2 1 1 4 5 8 2 3)) (list "Eight" "Five" "Four" "Three" "Two" "Two" "One" "One") 0.001)
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 -1 55)) (list "One") 0.001)
    (check-within (candidate (list 1 -1 3 2)) (list "Three" "Two" "One") 0.001)
    (check-within (candidate (list 9 4 8)) (list "Nine" "Eight" "Four") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183951
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given a list of integers, sort the integers that are between 1 and 9 inclusive,
;; reverse the resulting list, and then replace each digit by its corresponding name from
;; "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
;; For example:
;; >>> (by_length (list 2 1 1 4 5 8 2 3))
;; (list "Eight" "Five" "Four" "Three" "Two" "Two" "One" "One")
;;   If the list is empty, return an empty list:
;; >>> (by_length (list ))
;; (list )
;;   If the list has any strange number ignore it:
;; >>> (by_length (list 1 -1 55))
;; (list "One")

;; Given a list of integers, sort the integers that are between 1 and 9 inclusive,
;; reverse the resulting list, and then replace each digit by its corresponding
;; name from "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
;; For example:
;; >>> (by_length (list 2 1 1 4 5 8 2 3))
;; (list "Eight" "Five" "Four" "Three" "Two" "Two" "One" "One")
;;   If the list is empty, return an empty list:
;; >>> (by_length (list ))
;; (list )
;;   If the list has any strange number ignore it:
;; >>> (by_length (list 1 -1 55))
;; (list "One")

(define (by_length arr)
  ;; List of names indexed from 0 to 8
  (define names
    (list "One" "Two" "Three" "Four" "Five" "Six" "Seven" "Eight" "Nine"))

  ;; Keep only integers in the range 1..9
  (define filtered
    (filter (lambda (x)
              (and (integer? x)
                   (>= x 1)
                   (<= x 9)))
            arr))

  ;; Sort ascending, reverse, then map to names
  (map (lambda (n)
         (list-ref names (- n 1)))
       (reverse (sort filtered <))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate by_length))
    (check-within (candidate (list 2 1 1 4 5 8 2 3)) (list "Eight" "Five" "Four" "Three" "Two" "Two" "One" "One") 0.001)
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 -1 55)) (list "One") 0.001)
    (check-within (candidate (list 1 -1 3 2)) (list "Three" "Two" "One") 0.001)
    (check-within (candidate (list 9 4 8)) (list "Nine" "Eight" "Four") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183951
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 110 (RKT) - HumanEval_110_exchange
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; In this problem, you will implement a function that takes two lists of numbers,
;; and determines whether it is possible to perform an exchange of elements
;; between them to make lst1 a list of only even numbers.
;; There is no limit on the number of exchanged elements between lst1 and lst2.
;; If it is possible to exchange elements between the lst1 and lst2 to make
;; all the elements of lst1 to be even, return "YES".
;; Otherwise, return "NO".
;; For example:
;; >>> (exchange (list 1 2 3 4) (list 1 2 3 4))
;; "YES"
;; >>> (exchange (list 1 2 3 4) (list 1 5 3 4))
;; "NO"
;; It is assumed that the input lists will be non-empty.

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate exchange))
    (check-within (candidate (list 1 2 3 4) (list 1 2 3 4)) "YES" 0.001)
    (check-within (candidate (list 1 2 3 4) (list 1 5 3 4)) "NO" 0.001)
    (check-within (candidate (list 1 2 3 4) (list 2 1 4 3)) "YES" 0.001)
    (check-within (candidate (list 5 7 3) (list 2 6 4)) "YES" 0.001)
    (check-within (candidate (list 5 7 3) (list 2 6 3)) "NO" 0.001)
    (check-within (candidate (list 3 2 6 1 8 9) (list 3 5 5 1 1 1)) "NO" 0.001)
    (check-within (candidate (list 100 200) (list 200 200)) "YES" 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; In this problem, you will implement a function that takes two lists of numbers,
;; and determines whether it is possible to perform an exchange of elements
;; between them to make lst1 a list of only even numbers.
;; There is no limit on the number of exchanged elements between lst1 and lst2.
;; If it is possible to exchange elements between the lst1 and lst2 to make
;; all the elements of lst1 to be even, return "YES".
;; Otherwise, return "NO".
;; For example:
;; >>> (exchange (list 1 2 3 4) (list 1 2 3 4))
;; "YES"
;; >>> (exchange (list 1 2 3 4) (list 1 5 3 4))
;; "NO"
;; It is assumed that the input lists will be non-empty.

;; Count how many even numbers there are in the two lists combined.
;; If that number is at least the length of lst1, we can rearrange
;; elements by swapping so that lst1 contains only evens.
(define (exchange lst1 lst2)
  (let* ([len1 (length lst1)]
         [total-evens (+ (length (filter even? lst1))
                         (length (filter even? lst2)))]
         )
    (if (>= total-evens len1)
        "YES"
        "NO")))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate exchange))
    (check-within (candidate (list 1 2 3 4) (list 1 2 3 4)) "YES" 0.001)
    (check-within (candidate (list 1 2 3 4) (list 1 5 3 4)) "NO" 0.001)
    (check-within (candidate (list 1 2 3 4) (list 2 1 4 3)) "YES" 0.001)
    (check-within (candidate (list 5 7 3) (list 2 6 4)) "YES" 0.001)
    (check-within (candidate (list 5 7 3) (list 2 6 3)) "NO" 0.001)
    (check-within (candidate (list 3 2 6 1 8 9) (list 3 5 5 1 1 1)) "NO" 0.001)
    (check-within (candidate (list 100 200) (list 200 200)) "YES" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183955
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; In this problem, you will implement a function that takes two lists of numbers,
;; and determines whether it is possible to perform an exchange of elements
;; between them to make lst1 a list of only even numbers.
;; There is no limit on the number of exchanged elements between lst1 and lst2.
;; If it is possible to exchange elements between the lst1 and lst2 to make
;; all the elements of lst1 to be even, return "YES".
;; Otherwise, return "NO".
;; For example:
;; >>> (exchange (list 1 2 3 4) (list 1 2 3 4))
;; "YES"
;; >>> (exchange (list 1 2 3 4) (list 1 5 3 4))
;; "NO"
;; It is assumed that the input lists will be non-empty.

;; Determine if we can make lst1 all even by exchanging elements with lst2.
(define (exchange lst1 lst2)
  (define len1 (length lst1))
  (define evens
    (filter even? (append lst1 lst2)))   ; all even numbers in both lists
  (if (>= (length evens) len1)
      "YES"
      "NO"))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate exchange))
    (check-within (candidate (list 1 2 3 4) (list 1 2 3 4)) "YES" 0.001)
    (check-within (candidate (list 1 2 3 4) (list 1 5 3 4)) "NO" 0.001)
    (check-within (candidate (list 1 2 3 4) (list 2 1 4 3)) "YES" 0.001)
    (check-within (candidate (list 5 7 3) (list 2 6 4)) "YES" 0.001)
    (check-within (candidate (list 5 7 3) (list 2 6 3)) "NO" 0.001)
    (check-within (candidate (list 3 2 6 1 8 9) (list 3 5 5 1 1 1)) "NO" 0.001)
    (check-within (candidate (list 100 200) (list 200 200)) "YES" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183955
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; In this problem, you will implement a function that takes two lists of numbers,
;; and determines whether it is possible to perform an exchange of elements
;; between them to make lst1 a list of only even numbers.
;; There is no limit on the number of exchanged elements between lst1 and lst2.
;; If it is possible to exchange elements between the lst1 and lst2 to make
;; all the elements of lst1 to be even, return "YES".
;; Otherwise, return "NO".
;; For example:
;; >>> (exchange (list 1 2 3 4) (list 1 2 3 4))
;; "YES"
;; >>> (exchange (list 1 2 3 4) (list 1 5 3 4))
;; "NO"
;; It is assumed that the input lists will be non-empty.

(require racket/list)

;; Return "YES" if lst1 can be made all even by exchanging elements with lst2,
;; otherwise return "NO".
(define (exchange lst1 lst2)
  (let* ((odd-count  (count odd?  lst1))
         (even-count (count even? lst2)))
    (if (<= odd-count even-count)
        "YES"
        "NO")))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate exchange))
    (check-within (candidate (list 1 2 3 4) (list 1 2 3 4)) "YES" 0.001)
    (check-within (candidate (list 1 2 3 4) (list 1 5 3 4)) "NO" 0.001)
    (check-within (candidate (list 1 2 3 4) (list 2 1 4 3)) "YES" 0.001)
    (check-within (candidate (list 5 7 3) (list 2 6 4)) "YES" 0.001)
    (check-within (candidate (list 5 7 3) (list 2 6 3)) "NO" 0.001)
    (check-within (candidate (list 3 2 6 1 8 9) (list 3 5 5 1 1 1)) "NO" 0.001)
    (check-within (candidate (list 100 200) (list 200 200)) "YES" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183955
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; In this problem, you will implement a function that takes two lists of numbers,
;; and determines whether it is possible to perform an exchange of elements
;; between them to make lst1 a list of only even numbers.
;; There is no limit on the number of exchanged elements between lst1 and lst2.
;; If it is possible to exchange elements between the lst1 and lst2 to make
;; all the elements of lst1 to be even, return "YES".
;; Otherwise, return "NO".
;; For example:
;; >>> (exchange (list 1 2 3 4) (list 1 2 3 4))
;; "YES"
;; >>> (exchange (list 1 2 3 4) (list 1 5 3 4))
;; "NO"
;; It is assumed that the input lists will be non-empty.

;; In this problem, you will implement a function that takes two lists of numbers,
;; and determines whether it is possible to perform an exchange of elements
;; between them to make lst1 a list of only even numbers.
;; There is no limit on the number of exchanged elements between lst1 and lst2.
;; If it is possible to exchange elements between the lst1 and lst2 to make
;; all the elements of lst1 to be even, return "YES".
;; Otherwise, return "NO".
;; For example:
;; >>> (exchange (list 1 2 3 4) (list 1 2 3 4))
;; "YES"
;; >>> (exchange (list 1 2 3 4) (list 1 5 3 4))
;; "NO"
;; It is assumed that the input lists will be non-empty.
(define (exchange lst1 lst2)
  (define len1 (length lst1))
  (define evens-total
    (+ (length (filter even? lst1))
       (length (filter even? lst2))))
  (if (>= evens-total len1)
      "YES"
      "NO"))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate exchange))
    (check-within (candidate (list 1 2 3 4) (list 1 2 3 4)) "YES" 0.001)
    (check-within (candidate (list 1 2 3 4) (list 1 5 3 4)) "NO" 0.001)
    (check-within (candidate (list 1 2 3 4) (list 2 1 4 3)) "YES" 0.001)
    (check-within (candidate (list 5 7 3) (list 2 6 4)) "YES" 0.001)
    (check-within (candidate (list 5 7 3) (list 2 6 3)) "NO" 0.001)
    (check-within (candidate (list 3 2 6 1 8 9) (list 3 5 5 1 1 1)) "NO" 0.001)
    (check-within (candidate (list 100 200) (list 200 200)) "YES" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183955
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 117 (RKT) - HumanEval_117_select_words
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given a string s and a natural number n, you have been tasked to implement 
;; a function that returns a list of all words from string s that contain exactly 
;; n consonants, in order these words appear in the string s.
;; If the string s is empty then the function should return an empty list.
;; Note: you may assume the input string contains only letters and spaces.
;; Examples:
;; >>> (select_words "Mary had a little lamb" 4)
;; (list "little")
;; >>> (select_words "Mary had a little lamb" 3)
;; (list "Mary" "lamb")
;; >>> (select_words "simple white space" 2)
;; (list )
;; >>> (select_words "Hello world" 4)
;; (list "world")
;; >>> (select_words "Uncle sam" 3)
;; (list "Uncle")

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate select_words))
    (check-within (candidate "Mary had a little lamb" 4) (list "little") 0.001)
    (check-within (candidate "Mary had a little lamb" 3) (list "Mary" "lamb") 0.001)
    (check-within (candidate "simple white space" 2) (list ) 0.001)
    (check-within (candidate "Hello world" 4) (list "world") 0.001)
    (check-within (candidate "Uncle sam" 3) (list "Uncle") 0.001)
    (check-within (candidate "" 4) (list ) 0.001)
    (check-within (candidate "a b c d e f" 1) (list "b" "c" "d" "f") 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given a string s and a natural number n, you have been tasked to implement 
;; a function that returns a list of all words from string s that contain exactly 
;; n consonants, in order these words appear in the string s.
;; If the string s is empty then the function should return an empty list.
;; Note: you may assume the input string contains only letters and spaces.
;; Examples:
;; >>> (select_words "Mary had a little lamb" 4)
;; (list "little")
;; >>> (select_words "Mary had a little lamb" 3)
;; (list "Mary" "lamb")
;; >>> (select_words "simple white space" 2)
;; (list )
;; >>> (select_words "Hello world" 4)
;; (list "world")
;; >>> (select_words "Uncle sam" 3)
;; (list "Uncle")

;; Given a string s and a natural number n, you have been tasked to implement 
;; a function that returns a list of all words from string s that contain exactly 
;; n consonants, in order these words appear in the string s.
;; If the string s is empty then the function should return an empty list.
;; Note: you may assume the input string contains only letters and spaces.
;; Examples:
;; >>> (select_words "Mary had a little lamb" 4)
;; (list "little")
;; >>> (select_words "Mary had a little lamb" 3)
;; (list "Mary" "lamb")
;; >>> (select_words "simple white space" 2)
;; (list )
;; >>> (select_words "Hello world" 4)
;; (list "world")
;; >>> (select_words "Uncle sam" 3)
;; (list "Uncle")

(define (select_words s n)
  ;; Helper to count consonants in a word
  (define (consonant-count word)
    (let loop ((chars (string->list word)) (cnt 0))
      (cond
        [(empty? chars) cnt]
        [else
         (let ([c (char-downcase (first chars))])
           (if (and (char-alphabetic? c)
                    (not (member c '(#\a #\e #\i #\o #\u))))
               (loop (rest chars) (+ cnt 1))
               (loop (rest chars) cnt)))])))
  (if (string=? s "")
      '()
      (let* ([words (string-split s)]
             [selected (filter (lambda (w) (= (consonant-count w) n)) words)])
        selected)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate select_words))
    (check-within (candidate "Mary had a little lamb" 4) (list "little") 0.001)
    (check-within (candidate "Mary had a little lamb" 3) (list "Mary" "lamb") 0.001)
    (check-within (candidate "simple white space" 2) (list ) 0.001)
    (check-within (candidate "Hello world" 4) (list "world") 0.001)
    (check-within (candidate "Uncle sam" 3) (list "Uncle") 0.001)
    (check-within (candidate "" 4) (list ) 0.001)
    (check-within (candidate "a b c d e f" 1) (list "b" "c" "d" "f") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183962
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given a string s and a natural number n, you have been tasked to implement 
;; a function that returns a list of all words from string s that contain exactly 
;; n consonants, in order these words appear in the string s.
;; If the string s is empty then the function should return an empty list.
;; Note: you may assume the input string contains only letters and spaces.
;; Examples:
;; >>> (select_words "Mary had a little lamb" 4)
;; (list "little")
;; >>> (select_words "Mary had a little lamb" 3)
;; (list "Mary" "lamb")
;; >>> (select_words "simple white space" 2)
;; (list )
;; >>> (select_words "Hello world" 4)
;; (list "world")
;; >>> (select_words "Uncle sam" 3)
;; (list "Uncle")

;; Count the number of consonants in a word.
(define (count-consonants word)
  (define vowels "aeiouAEIOU")
  (foldl (lambda (c acc)
           (if (and (char-alphabetic? c)
                    (not (member c (string->list vowels))))
               (+ acc 1)
               acc))
         0
         (string->list word)))

;; Return a list of words from s that contain exactly n consonants.
(define (select_words s n)
  (if (string=? s "")
      '()
      (filter (lambda (w) (= (count-consonants w) n))
              (string-split s))))

;; Example usage:
;; (select_words "Mary had a little lamb" 4) => (list "little")
;; (select_words "Mary had a little lamb" 3) => (list "Mary" "lamb")
;; (select_words "simple white space" 2)   => (list)
;; (select_words "Hello world" 4)          => (list "world")
;; (select_words "Uncle sam" 3)            => (list "Uncle")
(require rackunit)

(define (test-humaneval) 

  (let (( candidate select_words))
    (check-within (candidate "Mary had a little lamb" 4) (list "little") 0.001)
    (check-within (candidate "Mary had a little lamb" 3) (list "Mary" "lamb") 0.001)
    (check-within (candidate "simple white space" 2) (list ) 0.001)
    (check-within (candidate "Hello world" 4) (list "world") 0.001)
    (check-within (candidate "Uncle sam" 3) (list "Uncle") 0.001)
    (check-within (candidate "" 4) (list ) 0.001)
    (check-within (candidate "a b c d e f" 1) (list "b" "c" "d" "f") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183962
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given a string s and a natural number n, you have been tasked to implement 
;; a function that returns a list of all words from string s that contain exactly 
;; n consonants, in order these words appear in the string s.
;; If the string s is empty then the function should return an empty list.
;; Note: you may assume the input string contains only letters and spaces.
;; Examples:
;; >>> (select_words "Mary had a little lamb" 4)
;; (list "little")
;; >>> (select_words "Mary had a little lamb" 3)
;; (list "Mary" "lamb")
;; >>> (select_words "simple white space" 2)
;; (list )
;; >>> (select_words "Hello world" 4)
;; (list "world")
;; >>> (select_words "Uncle sam" 3)
;; (list "Uncle")

;; Return a list of all words from string `s` that contain exactly
;; `n` consonants, preserving the original order.
(define (select_words s n)
  ;; Split the string into words (splits on whitespace).
  (define words (string-split s))
  
  ;; Count the consonants in a single word.
  (define (consonant-count w)
    (define vowels '(#\a #\e #\i #\o #\u))
    (let loop ((i 0) (cnt 0))
      (if (>= i (string-length w))
          cnt
          (let ((c (string-ref w i)))
            (if (and (char-alphabetic? c)
                     (not (member (char-downcase c) vowels)))
                (loop (+ i 1) (+ cnt 1))
                (loop (+ i 1) cnt))))))
  
  ;; Filter words whose consonant count equals `n`.
  (filter (λ (w) (= (consonant-count w) n)) words))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate select_words))
    (check-within (candidate "Mary had a little lamb" 4) (list "little") 0.001)
    (check-within (candidate "Mary had a little lamb" 3) (list "Mary" "lamb") 0.001)
    (check-within (candidate "simple white space" 2) (list ) 0.001)
    (check-within (candidate "Hello world" 4) (list "world") 0.001)
    (check-within (candidate "Uncle sam" 3) (list "Uncle") 0.001)
    (check-within (candidate "" 4) (list ) 0.001)
    (check-within (candidate "a b c d e f" 1) (list "b" "c" "d" "f") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183962
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given a string s and a natural number n, you have been tasked to implement 
;; a function that returns a list of all words from string s that contain exactly 
;; n consonants, in order these words appear in the string s.
;; If the string s is empty then the function should return an empty list.
;; Note: you may assume the input string contains only letters and spaces.
;; Examples:
;; >>> (select_words "Mary had a little lamb" 4)
;; (list "little")
;; >>> (select_words "Mary had a little lamb" 3)
;; (list "Mary" "lamb")
;; >>> (select_words "simple white space" 2)
;; (list )
;; >>> (select_words "Hello world" 4)
;; (list "world")
;; >>> (select_words "Uncle sam" 3)
;; (list "Uncle")

;; Return the number of consonants in a word
(define (count-consonants word)
  (define (consonant? c)
    (and (char-alphabetic? c)
         (not (member (char-downcase c) (string->list "aeiou")))))
  (foldl (lambda (c acc) (if (consonant? c) (+ acc 1) acc))
         0
         (string->list word)))

;; Return a list of words from string s that contain exactly n consonants
(define (select_words s n)
  (if (string=? s "")
      '()
      (filter (lambda (w) (= (count-consonants w) n))
              (string-split s))))

;; Examples
(displayln (select_words "Mary had a little lamb" 4))   ; => (list "little")
(displayln (select_words "Mary had a little lamb" 3))   ; => (list "Mary" "lamb")
(displayln (select_words "simple white space" 2))      ; => (list)
(displayln (select_words "Hello world" 4))             ; => (list "world")
(displayln (select_words "Uncle sam" 3))               ; => (list "Uncle")
(require rackunit)

(define (test-humaneval) 

  (let (( candidate select_words))
    (check-within (candidate "Mary had a little lamb" 4) (list "little") 0.001)
    (check-within (candidate "Mary had a little lamb" 3) (list "Mary" "lamb") 0.001)
    (check-within (candidate "simple white space" 2) (list ) 0.001)
    (check-within (candidate "Hello world" 4) (list "world") 0.001)
    (check-within (candidate "Uncle sam" 3) (list "Uncle") 0.001)
    (check-within (candidate "" 4) (list ) 0.001)
    (check-within (candidate "a b c d e f" 1) (list "b" "c" "d" "f") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183962
STDOUT:
(little)
(Mary lamb)
()
(world)
(Uncle)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 118 (RKT) - HumanEval_118_get_closest_vowel
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_closest_vowel))
    (check-within (candidate "yogurt") "u" 0.001)
    (check-within (candidate "full") "u" 0.001)
    (check-within (candidate "easy") "" 0.001)
    (check-within (candidate "eAsy") "" 0.001)
    (check-within (candidate "ali") "" 0.001)
    (check-within (candidate "bad") "a" 0.001)
    (check-within (candidate "most") "o" 0.001)
    (check-within (candidate "ab") "" 0.001)
    (check-within (candidate "ba") "" 0.001)
    (check-within (candidate "quick") "" 0.001)
    (check-within (candidate "anime") "i" 0.001)
    (check-within (candidate "Asia") "" 0.001)
    (check-within (candidate "Above") "o" 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""

(define (is-vowel? c)
  (or (eq? c #\a) (eq? c #\e) (eq? c #\i) (eq? c #\o) (eq? c #\u)
      (eq? c #\A) (eq? c #\E) (eq? c #\I) (eq? c #\O) (eq? c #\U)))

(define (get_closest_vowel word)
  (define len (string-length word))
  ;; If the word is too short, no vowel can be between two consonants
  (if (< len 3)
      ""
      (let loop ([i (- len 2)])          ; start from the rightmost possible index
        (cond
          [(< i 1) ""]                   ; no more positions to check
          [else
           (define c (string-ref word i))
           (define left (string-ref word (sub1 i)))
           (define right (string-ref word (add1 i)))
           (if (and (is-vowel? c)
                    (not (is-vowel? left))
                    (not (is-vowel? right)))
               (string c)                ; found the closest vowel from the right
               (loop (sub1 i)))]))))

;; Test cases
(displayln (get_closest_vowel "yogurt")) ; => "u"
(displayln (get_closest_vowel "FULL"))   ; => "U"
(displayln (get_closest_vowel "quick"))  ; => ""
(displayln (get_closest_vowel "ab"))     ; => ""
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_closest_vowel))
    (check-within (candidate "yogurt") "u" 0.001)
    (check-within (candidate "full") "u" 0.001)
    (check-within (candidate "easy") "" 0.001)
    (check-within (candidate "eAsy") "" 0.001)
    (check-within (candidate "ali") "" 0.001)
    (check-within (candidate "bad") "a" 0.001)
    (check-within (candidate "most") "o" 0.001)
    (check-within (candidate "ab") "" 0.001)
    (check-within (candidate "ba") "" 0.001)
    (check-within (candidate "quick") "" 0.001)
    (check-within (candidate "anime") "i" 0.001)
    (check-within (candidate "Asia") "" 0.001)
    (check-within (candidate "Above") "o" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183963
STDOUT:
u
U
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""

;; Return the closest vowel that is surrounded by consonants,
;; scanning from the right side of the word.
;; Vowels at the very beginning or end are ignored.
;; If no such vowel exists, return the empty string.
(define (get_closest_vowel word)
  (define vowels "aeiouAEIOU")
  (define len (string-length word))

  ;; Helper: is this character a vowel?
  (define (char-vowel? ch)
    (string-contains? vowels (string ch)))

  ;; Helper: is this character a consonant? (i.e., a letter that is not a vowel)
  (define (char-consonant? ch)
    (and (char-alphabetic? ch)
         (not (char-vowel? ch))))

  ;; Scan from the rightmost possible vowel position
  (let loop ((i (- len 2)))          ; last index that could be a vowel
    (cond
      [(< i 1) ""]                   ; reached the beginning, nothing found
      [else
       (define ch (string-ref word i))
       (if (char-vowel? ch)
           (if (and (char-consonant? (string-ref word (- i 1)))
                    (char-consonant? (string-ref word (+ i 1))))
               (string ch)             ; found the closest vowel
               (loop (- i 1)))         ; continue searching left
           (loop (- i 1)))]))          ; not a vowel, keep searching
)
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_closest_vowel))
    (check-within (candidate "yogurt") "u" 0.001)
    (check-within (candidate "full") "u" 0.001)
    (check-within (candidate "easy") "" 0.001)
    (check-within (candidate "eAsy") "" 0.001)
    (check-within (candidate "ali") "" 0.001)
    (check-within (candidate "bad") "a" 0.001)
    (check-within (candidate "most") "o" 0.001)
    (check-within (candidate "ab") "" 0.001)
    (check-within (candidate "ba") "" 0.001)
    (check-within (candidate "quick") "" 0.001)
    (check-within (candidate "anime") "i" 0.001)
    (check-within (candidate "Asia") "" 0.001)
    (check-within (candidate "Above") "o" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183963
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""

(define (get_closest_vowel word)
  ;; Helper to test if a character is a vowel (case‑sensitive)
  (define (vowel? c)
    (member c '(#\a #\e #\i #\o #\u #\A #\E #\I #\O #\U)))
  
  (define len (string-length word))
  
  ;; If the word is too short to contain a vowel between two consonants, return ""
  (if (< len 3)
      ""
      ;; Scan from right to left, skipping the first and last positions
      (let loop ([i (- len 2)])  ; start at second‑to‑last index
        (cond
          [(< i 1) ""]
          [else
           (define c (string-ref word i))
           (if (and (vowel? c)
                    (not (vowel? (string-ref word (- i 1))))
                    (not (vowel? (string-ref word (+ i 1)))))
               ;; Return the vowel as a one‑character string
               (string c)
               (loop (- i 1)))]))))

;; Test cases
(displayln (get_closest_vowel "yogurt"))   ; => "u"
(displayln (get_closest_vowel "FULL"))     ; => "U"
(displayln (get_closest_vowel "quick"))    ; => ""
(displayln (get_closest_vowel "ab"))       ; => ""
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_closest_vowel))
    (check-within (candidate "yogurt") "u" 0.001)
    (check-within (candidate "full") "u" 0.001)
    (check-within (candidate "easy") "" 0.001)
    (check-within (candidate "eAsy") "" 0.001)
    (check-within (candidate "ali") "" 0.001)
    (check-within (candidate "bad") "a" 0.001)
    (check-within (candidate "most") "o" 0.001)
    (check-within (candidate "ab") "" 0.001)
    (check-within (candidate "ba") "" 0.001)
    (check-within (candidate "quick") "" 0.001)
    (check-within (candidate "anime") "i" 0.001)
    (check-within (candidate "Asia") "" 0.001)
    (check-within (candidate "Above") "o" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183963
STDOUT:
u
U
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""

(define (get_closest_vowel word)
  (define len (string-length word))
  ;; List of vowel characters (case‑sensitive)
  (define vowels '(#\a #\e #\i #\o #\u #\A #\E #\I #\O #\U))
  (define (is-vowel? c)
    (member c vowels))
  ;; Scan from right to left, skipping the first and last positions
  (let loop ((i (- len 2)))          ; start at second‑to‑last character
    (cond
      [(< i 1) ""]                   ; reached the beginning without a match
      [(and (is-vowel? (string-ref word i))
            (not (is-vowel? (string-ref word (- i 1))))
            (not (is-vowel? (string-ref word (+ i 1)))))
       (substring word i (+ i 1))]   ; found the closest vowel
      [else (loop (- i 1))])))       ; continue searching

;; Test cases
(displayln (get_closest_vowel "yogurt")) ; "u"
(displayln (get_closest_vowel "FULL"))   ; "U"
(displayln (get_closest_vowel "quick"))  ; ""
(displayln (get_closest_vowel "ab"))     ; ""
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_closest_vowel))
    (check-within (candidate "yogurt") "u" 0.001)
    (check-within (candidate "full") "u" 0.001)
    (check-within (candidate "easy") "" 0.001)
    (check-within (candidate "eAsy") "" 0.001)
    (check-within (candidate "ali") "" 0.001)
    (check-within (candidate "bad") "a" 0.001)
    (check-within (candidate "most") "o" 0.001)
    (check-within (candidate "ab") "" 0.001)
    (check-within (candidate "ba") "" 0.001)
    (check-within (candidate "quick") "" 0.001)
    (check-within (candidate "anime") "i" 0.001)
    (check-within (candidate "Asia") "" 0.001)
    (check-within (candidate "Above") "o" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183963
STDOUT:
u
U
STDERR: (empty)
--------------------
