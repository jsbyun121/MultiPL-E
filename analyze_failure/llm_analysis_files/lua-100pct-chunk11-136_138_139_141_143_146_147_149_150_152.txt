As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 136 (LUA) - HumanEval_136_largest_smallest_integers
================================================================================

PROMPT:
----------------------------------------
-- Create a function that returns a table (a, b), where 'a' is
-- the largest of negative integers, and 'b' is the smallest
-- of positive integers in a table.
-- If there is no negative or positive integers, return them as nil.
-- Examples:
-- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})
-- {None, 1}
-- >>> largest_smallest_integers({})
-- {None, None}
-- >>> largest_smallest_integers({0})
-- {None, None}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = largest_smallest_integers
    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7}), {None, 1})
    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7, 0}), {None, 1})
    lu.assertEquals(candidate({1, 3, 2, 4, 5, 6, -2}), {-2, 1})
    lu.assertEquals(candidate({4, 5, 3, 6, 2, 7, -7}), {-7, 2})
    lu.assertEquals(candidate({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2})
    lu.assertEquals(candidate({}), {None, None})
    lu.assertEquals(candidate({0}), {None, None})
    lu.assertEquals(candidate({-1, -3, -5, -6}), {-1, None})
    lu.assertEquals(candidate({-1, -3, -5, -6, 0}), {-1, None})
    lu.assertEquals(candidate({-6, -4, -4, -3, 1}), {-3, 1})
    lu.assertEquals(candidate({-6, -4, -4, -3, -100, 1}), {-3, 1})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Create a function that returns a table (a, b), where 'a' is
-- the largest of negative integers, and 'b' is the smallest
-- of positive integers in a table.
-- If there is no negative or positive integers, return them as nil.
-- Examples:
-- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})
-- {None, 1}
-- >>> largest_smallest_integers({})
-- {None, None}
-- >>> largest_smallest_integers({0})
-- {None, None}
-- Create a function that returns a table (a, b), where 'a' is
-- the largest of negative integers, and 'b' is the smallest
-- of positive integers in a table.
-- If there is no negative or positive integers, return them as nil.
-- Examples:
-- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})
-- {None, 1}
-- >>> largest_smallest_integers({})
-- {None, None}
-- >>> largest_smallest_integers({0})
-- {None, None}
local function largest_smallest_integers(lst)
    local largest_neg = nil
    local smallest_pos = nil

    for _, v in ipairs(lst) do
        if type(v) == "number" then
            if v < 0 then
                if largest_neg == nil or v > largest_neg then
                    largest_neg = v
                end
            elseif v > 0 then
                if smallest_pos == nil or v < smallest_pos then
                    smallest_pos = v
                end
            end
        end
    end

    return { largest_neg, smallest_pos }
end
lu = require('luaunit')

function test_humaneval()
local candidate = largest_smallest_integers
    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7}), {None, 1})
    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7, 0}), {None, 1})
    lu.assertEquals(candidate({1, 3, 2, 4, 5, 6, -2}), {-2, 1})
    lu.assertEquals(candidate({4, 5, 3, 6, 2, 7, -7}), {-7, 2})
    lu.assertEquals(candidate({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2})
    lu.assertEquals(candidate({}), {None, None})
    lu.assertEquals(candidate({0}), {None, None})
    lu.assertEquals(candidate({-1, -3, -5, -6}), {-1, None})
    lu.assertEquals(candidate({-1, -3, -5, -6, 0}), {-1, None})
    lu.assertEquals(candidate({-6, -4, -4, -3, 1}), {-3, 1})
    lu.assertEquals(candidate({-6, -4, -4, -3, -100, 1}), {-3, 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Create a function that returns a table (a, b), where 'a' is
-- the largest of negative integers, and 'b' is the smallest
-- of positive integers in a table.
-- If there is no negative or positive integers, return them as nil.
-- Examples:
-- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})
-- {None, 1}
-- >>> largest_smallest_integers({})
-- {None, None}
-- >>> largest_smallest_integers({0})
-- {None, None}
local function largest_smallest_integers(lst)
  local max_neg
  local min_pos

  for _, v in ipairs(lst) do
    if v < 0 then
      if not max_neg or v > max_neg then
        max_neg = v
      end
    elseif v > 0 then
      if not min_pos or v < min_pos then
        min_pos = v
      end
    end
  end

  return {max_neg, min_pos}
end
lu = require('luaunit')

function test_humaneval()
local candidate = largest_smallest_integers
    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7}), {None, 1})
    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7, 0}), {None, 1})
    lu.assertEquals(candidate({1, 3, 2, 4, 5, 6, -2}), {-2, 1})
    lu.assertEquals(candidate({4, 5, 3, 6, 2, 7, -7}), {-7, 2})
    lu.assertEquals(candidate({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2})
    lu.assertEquals(candidate({}), {None, None})
    lu.assertEquals(candidate({0}), {None, None})
    lu.assertEquals(candidate({-1, -3, -5, -6}), {-1, None})
    lu.assertEquals(candidate({-1, -3, -5, -6, 0}), {-1, None})
    lu.assertEquals(candidate({-6, -4, -4, -3, 1}), {-3, 1})
    lu.assertEquals(candidate({-6, -4, -4, -3, -100, 1}), {-3, 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Create a function that returns a table (a, b), where 'a' is
-- the largest of negative integers, and 'b' is the smallest
-- of positive integers in a table.
-- If there is no negative or positive integers, return them as nil.
-- Examples:
-- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})
-- {None, 1}
-- >>> largest_smallest_integers({})
-- {None, None}
-- >>> largest_smallest_integers({0})
-- {None, None}
local function largest_smallest_integers(lst)
    -- Variables to hold the results
    local largest_neg   -- largest (closest to zero) negative integer
    local smallest_pos  -- smallest (closest to zero) positive integer

    -- Iterate over the list
    for _, v in ipairs(lst) do
        -- Only consider numeric values
        if type(v) == "number" then
            if v < 0 then
                -- Update largest_neg if this is the first negative or larger than current
                if largest_neg == nil or v > largest_neg then
                    largest_neg = v
                end
            elseif v > 0 then
                -- Update smallest_pos if this is the first positive or smaller than current
                if smallest_pos == nil or v < smallest_pos then
                    smallest_pos = v
                end
            end
        end
    end

    -- Return the two values in a table (nil if not found)
    return {largest_neg, smallest_pos}
end
lu = require('luaunit')

function test_humaneval()
local candidate = largest_smallest_integers
    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7}), {None, 1})
    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7, 0}), {None, 1})
    lu.assertEquals(candidate({1, 3, 2, 4, 5, 6, -2}), {-2, 1})
    lu.assertEquals(candidate({4, 5, 3, 6, 2, 7, -7}), {-7, 2})
    lu.assertEquals(candidate({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2})
    lu.assertEquals(candidate({}), {None, None})
    lu.assertEquals(candidate({0}), {None, None})
    lu.assertEquals(candidate({-1, -3, -5, -6}), {-1, None})
    lu.assertEquals(candidate({-1, -3, -5, -6, 0}), {-1, None})
    lu.assertEquals(candidate({-6, -4, -4, -3, 1}), {-3, 1})
    lu.assertEquals(candidate({-6, -4, -4, -3, -100, 1}), {-3, 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Create a function that returns a table (a, b), where 'a' is
-- the largest of negative integers, and 'b' is the smallest
-- of positive integers in a table.
-- If there is no negative or positive integers, return them as nil.
-- Examples:
-- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})
-- {None, 1}
-- >>> largest_smallest_integers({})
-- {None, None}
-- >>> largest_smallest_integers({0})
-- {None, None}
-- Return a table {a, b} where
--   a – largest negative integer in lst (or nil if none)
--   b – smallest positive integer in lst (or nil if none)
local function largest_smallest_integers(lst)
    local a, b = nil, nil

    for _, v in ipairs(lst) do
        if v < 0 then
            if a == nil or v > a then
                a = v
            end
        elseif v > 0 then
            if b == nil or v < b then
                b = v
            end
        end
    end

    return {a, b}
end
lu = require('luaunit')

function test_humaneval()
local candidate = largest_smallest_integers
    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7}), {None, 1})
    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7, 0}), {None, 1})
    lu.assertEquals(candidate({1, 3, 2, 4, 5, 6, -2}), {-2, 1})
    lu.assertEquals(candidate({4, 5, 3, 6, 2, 7, -7}), {-7, 2})
    lu.assertEquals(candidate({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2})
    lu.assertEquals(candidate({}), {None, None})
    lu.assertEquals(candidate({0}), {None, None})
    lu.assertEquals(candidate({-1, -3, -5, -6}), {-1, None})
    lu.assertEquals(candidate({-1, -3, -5, -6, 0}), {-1, None})
    lu.assertEquals(candidate({-6, -4, -4, -3, 1}), {-3, 1})
    lu.assertEquals(candidate({-6, -4, -4, -3, -100, 1}), {-3, 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 138 (LUA) - HumanEval_138_is_equal_to_sum_even
================================================================================

PROMPT:
----------------------------------------
-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
-- Example
-- >>> is_equal_to_sum_even(4)
-- false
-- >>> is_equal_to_sum_even(6)
-- false
-- >>> is_equal_to_sum_even(8)
-- true

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = is_equal_to_sum_even
    lu.assertEquals(candidate(4), false)
    lu.assertEquals(candidate(6), false)
    lu.assertEquals(candidate(8), true)
    lu.assertEquals(candidate(10), true)
    lu.assertEquals(candidate(11), false)
    lu.assertEquals(candidate(12), true)
    lu.assertEquals(candidate(13), false)
    lu.assertEquals(candidate(16), true)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
-- Example
-- >>> is_equal_to_sum_even(4)
-- false
-- >>> is_equal_to_sum_even(6)
-- false
-- >>> is_equal_to_sum_even(8)
-- true
-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
-- Example
-- >>> is_equal_to_sum_even(4)
-- false
-- >>> is_equal_to_sum_even(6)
-- false
-- >>> is_equal_to_sum_even(8)
-- true
local function is_equal_to_sum_even(n)
    -- A sum of four positive even numbers is at least 8 (2+2+2+2)
    -- and must be even.
    return n >= 8 and n % 2 == 0
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_equal_to_sum_even
    lu.assertEquals(candidate(4), false)
    lu.assertEquals(candidate(6), false)
    lu.assertEquals(candidate(8), true)
    lu.assertEquals(candidate(10), true)
    lu.assertEquals(candidate(11), false)
    lu.assertEquals(candidate(12), true)
    lu.assertEquals(candidate(13), false)
    lu.assertEquals(candidate(16), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
-- Example
-- >>> is_equal_to_sum_even(4)
-- false
-- >>> is_equal_to_sum_even(6)
-- false
-- >>> is_equal_to_sum_even(8)
-- true
-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
-- Example
-- >>> is_equal_to_sum_even(4)
-- false
-- >>> is_equal_to_sum_even(6)
-- false
-- >>> is_equal_to_sum_even(8)
-- true
local function is_equal_to_sum_even(n)
    -- The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8.
    -- Any larger even number can be achieved by adding 2 to one of the terms.
    -- Therefore, n must be an even integer greater than or equal to 8.
    return n >= 8 and n % 2 == 0
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_equal_to_sum_even
    lu.assertEquals(candidate(4), false)
    lu.assertEquals(candidate(6), false)
    lu.assertEquals(candidate(8), true)
    lu.assertEquals(candidate(10), true)
    lu.assertEquals(candidate(11), false)
    lu.assertEquals(candidate(12), true)
    lu.assertEquals(candidate(13), false)
    lu.assertEquals(candidate(16), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
-- Example
-- >>> is_equal_to_sum_even(4)
-- false
-- >>> is_equal_to_sum_even(6)
-- false
-- >>> is_equal_to_sum_even(8)
-- true
-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
-- Example
-- >>> is_equal_to_sum_even(4)
-- false
-- >>> is_equal_to_sum_even(6)
-- false
-- >>> is_equal_to_sum_even(8)
-- true
local function is_equal_to_sum_even(n)
    -- A sum of four positive even numbers must be even and at least 8 (2+2+2+2).
    -- For any even n >= 8 we can construct such a sum: 2 + 2 + 2 + (n - 6).
    return n >= 8 and n % 2 == 0
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_equal_to_sum_even
    lu.assertEquals(candidate(4), false)
    lu.assertEquals(candidate(6), false)
    lu.assertEquals(candidate(8), true)
    lu.assertEquals(candidate(10), true)
    lu.assertEquals(candidate(11), false)
    lu.assertEquals(candidate(12), true)
    lu.assertEquals(candidate(13), false)
    lu.assertEquals(candidate(16), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
-- Example
-- >>> is_equal_to_sum_even(4)
-- false
-- >>> is_equal_to_sum_even(6)
-- false
-- >>> is_equal_to_sum_even(8)
-- true
-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
-- Example
-- >>> is_equal_to_sum_even(4)
-- false
-- >>> is_equal_to_sum_even(6)
-- false
-- >>> is_equal_to_sum_even(8)
-- true
local function is_equal_to_sum_even(n)
    -- The smallest sum of four positive even numbers is 2+2+2+2 = 8.
    -- Any even number >= 8 can be represented as 2+2+2+(n-6),
    -- where n-6 is also a positive even integer.
    return n >= 8 and n % 2 == 0
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_equal_to_sum_even
    lu.assertEquals(candidate(4), false)
    lu.assertEquals(candidate(6), false)
    lu.assertEquals(candidate(8), true)
    lu.assertEquals(candidate(10), true)
    lu.assertEquals(candidate(11), false)
    lu.assertEquals(candidate(12), true)
    lu.assertEquals(candidate(13), false)
    lu.assertEquals(candidate(16), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 139 (LUA) - HumanEval_139_special_factorial
================================================================================

PROMPT:
----------------------------------------
-- The Brazilian factorial is defined as:
-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
-- where n > 0
-- For example:
-- >>> special_factorial(4)
-- 288
-- The function will receive an integer as input and should return the special
-- factorial of this integer.

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = special_factorial
    lu.assertEquals(candidate(4), 288)
    lu.assertEquals(candidate(5), 34560)
    lu.assertEquals(candidate(7), 125411328000)
    lu.assertEquals(candidate(1), 1)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- The Brazilian factorial is defined as:
-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
-- where n > 0
-- For example:
-- >>> special_factorial(4)
-- 288
-- The function will receive an integer as input and should return the special
-- factorial of this integer.
local function special_factorial(n)
    local product = 1
    local fact = 1
    for i = 1, n do
        fact = fact * i
        product = product * fact
    end
    return product
end
lu = require('luaunit')

function test_humaneval()
local candidate = special_factorial
    lu.assertEquals(candidate(4), 288)
    lu.assertEquals(candidate(5), 34560)
    lu.assertEquals(candidate(7), 125411328000)
    lu.assertEquals(candidate(1), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- The Brazilian factorial is defined as:
-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
-- where n > 0
-- For example:
-- >>> special_factorial(4)
-- 288
-- The function will receive an integer as input and should return the special
-- factorial of this integer.
-- The Brazilian factorial is defined as:
-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
-- where n > 0
-- For example:
-- >>> special_factorial(4)
-- 288
-- The function will receive an integer as input and should return the special
-- factorial of this integer.

local function special_factorial(n)
    -- Validate input
    if n <= 0 then
        error("Input must be a positive integer")
    end

    local result = 1          -- Product of all factorials
    local current_fact = 1    -- Current factorial value (i!)

    for i = 1, n do
        current_fact = current_fact * i   -- Compute i!
        result = result * current_fact    -- Multiply into the product
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = special_factorial
    lu.assertEquals(candidate(4), 288)
    lu.assertEquals(candidate(5), 34560)
    lu.assertEquals(candidate(7), 125411328000)
    lu.assertEquals(candidate(1), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- The Brazilian factorial is defined as:
-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
-- where n > 0
-- For example:
-- >>> special_factorial(4)
-- 288
-- The function will receive an integer as input and should return the special
-- factorial of this integer.
-- The Brazilian factorial is defined as:
-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
-- where n > 0
-- For example:
-- >>> special_factorial(4)
-- 288
-- The function will receive an integer as input and should return the special
-- factorial of this integer.

local function special_factorial(n)
    -- Ensure n is a positive integer
    if n <= 0 then
        error("n must be a positive integer")
    end

    local result = 1      -- product of all factorials
    local factorial = 1   -- current factorial value

    for i = 1, n do
        factorial = factorial * i   -- compute i!
        result = result * factorial -- multiply into the product
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = special_factorial
    lu.assertEquals(candidate(4), 288)
    lu.assertEquals(candidate(5), 34560)
    lu.assertEquals(candidate(7), 125411328000)
    lu.assertEquals(candidate(1), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- The Brazilian factorial is defined as:
-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
-- where n > 0
-- For example:
-- >>> special_factorial(4)
-- 288
-- The function will receive an integer as input and should return the special
-- factorial of this integer.
local function special_factorial(n)
    -- Ensure n is a positive integer
    if n <= 0 then
        error("n must be a positive integer")
    end

    local result = 1      -- product of factorials
    local current_fact = 1  -- current factorial value

    for i = 1, n do
        current_fact = current_fact * i   -- compute i!
        result = result * current_fact    -- multiply into result
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = special_factorial
    lu.assertEquals(candidate(4), 288)
    lu.assertEquals(candidate(5), 34560)
    lu.assertEquals(candidate(7), 125411328000)
    lu.assertEquals(candidate(1), 1)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 141 (LUA) - HumanEval_141_file_name_check
================================================================================

PROMPT:
----------------------------------------
-- Create a function which takes a string representing a file's name, and returns
-- 'Yes' if the the file's name is valid, and returns 'No' otherwise.
-- A file's name is considered to be valid if and only if all the following conditions 
-- are met:
-- - There should not be more than three digits ('0'-'9') in the file's name.
-- - The file's name contains exactly one dot '.'
-- - The substring before the dot should not be empty, and it starts with a letter from 
-- the latin alphapet ('a'-'z' and 'A'-'Z').
-- - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
-- Examples:
-- >>> file_name_check('example.txt')
-- 'Yes'
-- >>> file_name_check('1example.dll')
-- 'No'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = file_name_check
    lu.assertEquals(candidate('example.txt'), 'Yes')
    lu.assertEquals(candidate('1example.dll'), 'No')
    lu.assertEquals(candidate('s1sdf3.asd'), 'No')
    lu.assertEquals(candidate('K.dll'), 'Yes')
    lu.assertEquals(candidate('MY16FILE3.exe'), 'Yes')
    lu.assertEquals(candidate('His12FILE94.exe'), 'No')
    lu.assertEquals(candidate('_Y.txt'), 'No')
    lu.assertEquals(candidate('?aREYA.exe'), 'No')
    lu.assertEquals(candidate('/this_is_valid.dll'), 'No')
    lu.assertEquals(candidate('this_is_valid.wow'), 'No')
    lu.assertEquals(candidate('this_is_valid.txt'), 'Yes')
    lu.assertEquals(candidate('this_is_valid.txtexe'), 'No')
    lu.assertEquals(candidate('#this2_i4s_5valid.ten'), 'No')
    lu.assertEquals(candidate('@this1_is6_valid.exe'), 'No')
    lu.assertEquals(candidate('this_is_12valid.6exe4.txt'), 'No')
    lu.assertEquals(candidate('all.exe.txt'), 'No')
    lu.assertEquals(candidate('I563_No.exe'), 'Yes')
    lu.assertEquals(candidate('Is3youfault.txt'), 'Yes')
    lu.assertEquals(candidate('no_one#knows.dll'), 'Yes')
    lu.assertEquals(candidate('1I563_Yes3.exe'), 'No')
    lu.assertEquals(candidate('I563_Yes3.txtt'), 'No')
    lu.assertEquals(candidate('final..txt'), 'No')
    lu.assertEquals(candidate('final132'), 'No')
    lu.assertEquals(candidate('_f4indsartal132.'), 'No')
    lu.assertEquals(candidate('.txt'), 'No')
    lu.assertEquals(candidate('s.'), 'No')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Create a function which takes a string representing a file's name, and returns
-- 'Yes' if the the file's name is valid, and returns 'No' otherwise.
-- A file's name is considered to be valid if and only if all the following conditions 
-- are met:
-- - There should not be more than three digits ('0'-'9') in the file's name.
-- - The file's name contains exactly one dot '.'
-- - The substring before the dot should not be empty, and it starts with a letter from 
-- the latin alphapet ('a'-'z' and 'A'-'Z').
-- - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
-- Examples:
-- >>> file_name_check('example.txt')
-- 'Yes'
-- >>> file_name_check('1example.dll')
-- 'No'
local function file_name_check(file_name)
    -- Count how many digits are in the whole file name
    local _, digit_count = file_name:gsub("%d", "")
    if digit_count > 3 then
        return 'No'
    end

    -- Count the number of dots – must be exactly one
    local dot_count = 0
    for _ in file_name:gmatch("%.") do
        dot_count = dot_count + 1
    end
    if dot_count ~= 1 then
        return 'No'
    end

    -- Split into the part before the dot and after the dot
    local before, after = file_name:match("^([^%.]+)%.([^%.]+)$")
    if not before or not after then
        return 'No'
    end

    -- The part before the dot must start with a letter
    if not before:match("^%a") then
        return 'No'
    end

    -- The part after the dot must be one of the allowed extensions
    if after ~= 'txt' and after ~= 'exe' and after ~= 'dll' then
        return 'No'
    end

    return 'Yes'
end
lu = require('luaunit')

function test_humaneval()
local candidate = file_name_check
    lu.assertEquals(candidate('example.txt'), 'Yes')
    lu.assertEquals(candidate('1example.dll'), 'No')
    lu.assertEquals(candidate('s1sdf3.asd'), 'No')
    lu.assertEquals(candidate('K.dll'), 'Yes')
    lu.assertEquals(candidate('MY16FILE3.exe'), 'Yes')
    lu.assertEquals(candidate('His12FILE94.exe'), 'No')
    lu.assertEquals(candidate('_Y.txt'), 'No')
    lu.assertEquals(candidate('?aREYA.exe'), 'No')
    lu.assertEquals(candidate('/this_is_valid.dll'), 'No')
    lu.assertEquals(candidate('this_is_valid.wow'), 'No')
    lu.assertEquals(candidate('this_is_valid.txt'), 'Yes')
    lu.assertEquals(candidate('this_is_valid.txtexe'), 'No')
    lu.assertEquals(candidate('#this2_i4s_5valid.ten'), 'No')
    lu.assertEquals(candidate('@this1_is6_valid.exe'), 'No')
    lu.assertEquals(candidate('this_is_12valid.6exe4.txt'), 'No')
    lu.assertEquals(candidate('all.exe.txt'), 'No')
    lu.assertEquals(candidate('I563_No.exe'), 'Yes')
    lu.assertEquals(candidate('Is3youfault.txt'), 'Yes')
    lu.assertEquals(candidate('no_one#knows.dll'), 'Yes')
    lu.assertEquals(candidate('1I563_Yes3.exe'), 'No')
    lu.assertEquals(candidate('I563_Yes3.txtt'), 'No')
    lu.assertEquals(candidate('final..txt'), 'No')
    lu.assertEquals(candidate('final132'), 'No')
    lu.assertEquals(candidate('_f4indsartal132.'), 'No')
    lu.assertEquals(candidate('.txt'), 'No')
    lu.assertEquals(candidate('s.'), 'No')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Create a function which takes a string representing a file's name, and returns
-- 'Yes' if the the file's name is valid, and returns 'No' otherwise.
-- A file's name is considered to be valid if and only if all the following conditions 
-- are met:
-- - There should not be more than three digits ('0'-'9') in the file's name.
-- - The file's name contains exactly one dot '.'
-- - The substring before the dot should not be empty, and it starts with a letter from 
-- the latin alphapet ('a'-'z' and 'A'-'Z').
-- - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
-- Examples:
-- >>> file_name_check('example.txt')
-- 'Yes'
-- >>> file_name_check('1example.dll')
-- 'No'
local function file_name_check(file_name)
    -- 1. Count digits
    local digit_count = 0
    for _ in file_name:gmatch("%d") do
        digit_count = digit_count + 1
    end
    if digit_count > 3 then
        return 'No'
    end

    -- 2. Count dots
    local dot_count = 0
    for _ in file_name:gmatch("%.") do
        dot_count = dot_count + 1
    end
    if dot_count ~= 1 then
        return 'No'
    end

    -- 3. Split into prefix and suffix
    local dot_pos = string.find(file_name, "%.")
    local prefix = string.sub(file_name, 1, dot_pos - 1)
    local suffix = string.sub(file_name, dot_pos + 1)

    -- 4. Validate prefix
    if #prefix == 0 then
        return 'No'
    end
    if not prefix:match("^[A-Za-z]") then
        return 'No'
    end

    -- 5. Validate suffix
    local allowed = { txt = true, exe = true, dll = true }
    if not allowed[suffix] then
        return 'No'
    end

    return 'Yes'
end
lu = require('luaunit')

function test_humaneval()
local candidate = file_name_check
    lu.assertEquals(candidate('example.txt'), 'Yes')
    lu.assertEquals(candidate('1example.dll'), 'No')
    lu.assertEquals(candidate('s1sdf3.asd'), 'No')
    lu.assertEquals(candidate('K.dll'), 'Yes')
    lu.assertEquals(candidate('MY16FILE3.exe'), 'Yes')
    lu.assertEquals(candidate('His12FILE94.exe'), 'No')
    lu.assertEquals(candidate('_Y.txt'), 'No')
    lu.assertEquals(candidate('?aREYA.exe'), 'No')
    lu.assertEquals(candidate('/this_is_valid.dll'), 'No')
    lu.assertEquals(candidate('this_is_valid.wow'), 'No')
    lu.assertEquals(candidate('this_is_valid.txt'), 'Yes')
    lu.assertEquals(candidate('this_is_valid.txtexe'), 'No')
    lu.assertEquals(candidate('#this2_i4s_5valid.ten'), 'No')
    lu.assertEquals(candidate('@this1_is6_valid.exe'), 'No')
    lu.assertEquals(candidate('this_is_12valid.6exe4.txt'), 'No')
    lu.assertEquals(candidate('all.exe.txt'), 'No')
    lu.assertEquals(candidate('I563_No.exe'), 'Yes')
    lu.assertEquals(candidate('Is3youfault.txt'), 'Yes')
    lu.assertEquals(candidate('no_one#knows.dll'), 'Yes')
    lu.assertEquals(candidate('1I563_Yes3.exe'), 'No')
    lu.assertEquals(candidate('I563_Yes3.txtt'), 'No')
    lu.assertEquals(candidate('final..txt'), 'No')
    lu.assertEquals(candidate('final132'), 'No')
    lu.assertEquals(candidate('_f4indsartal132.'), 'No')
    lu.assertEquals(candidate('.txt'), 'No')
    lu.assertEquals(candidate('s.'), 'No')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Create a function which takes a string representing a file's name, and returns
-- 'Yes' if the the file's name is valid, and returns 'No' otherwise.
-- A file's name is considered to be valid if and only if all the following conditions 
-- are met:
-- - There should not be more than three digits ('0'-'9') in the file's name.
-- - The file's name contains exactly one dot '.'
-- - The substring before the dot should not be empty, and it starts with a letter from 
-- the latin alphapet ('a'-'z' and 'A'-'Z').
-- - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
-- Examples:
-- >>> file_name_check('example.txt')
-- 'Yes'
-- >>> file_name_check('1example.dll')
-- 'No'
local function file_name_check(file_name)
    -- Count digits – must be at most 3
    local digit_count = 0
    for _ in file_name:gmatch("%d") do
        digit_count = digit_count + 1
        if digit_count > 3 then
            return 'No'
        end
    end

    -- Validate the overall structure:
    --  * exactly one dot
    --  * part before dot starts with a letter and contains no other dot
    --  * part after dot is one of the allowed extensions
    local pre, ext = file_name:match("^([A-Za-z][^.]*)%.([a-z]+)$")
    if not pre or not ext then
        return 'No'
    end

    if not (ext == 'txt' or ext == 'exe' or ext == 'dll') then
        return 'No'
    end

    return 'Yes'
end
lu = require('luaunit')

function test_humaneval()
local candidate = file_name_check
    lu.assertEquals(candidate('example.txt'), 'Yes')
    lu.assertEquals(candidate('1example.dll'), 'No')
    lu.assertEquals(candidate('s1sdf3.asd'), 'No')
    lu.assertEquals(candidate('K.dll'), 'Yes')
    lu.assertEquals(candidate('MY16FILE3.exe'), 'Yes')
    lu.assertEquals(candidate('His12FILE94.exe'), 'No')
    lu.assertEquals(candidate('_Y.txt'), 'No')
    lu.assertEquals(candidate('?aREYA.exe'), 'No')
    lu.assertEquals(candidate('/this_is_valid.dll'), 'No')
    lu.assertEquals(candidate('this_is_valid.wow'), 'No')
    lu.assertEquals(candidate('this_is_valid.txt'), 'Yes')
    lu.assertEquals(candidate('this_is_valid.txtexe'), 'No')
    lu.assertEquals(candidate('#this2_i4s_5valid.ten'), 'No')
    lu.assertEquals(candidate('@this1_is6_valid.exe'), 'No')
    lu.assertEquals(candidate('this_is_12valid.6exe4.txt'), 'No')
    lu.assertEquals(candidate('all.exe.txt'), 'No')
    lu.assertEquals(candidate('I563_No.exe'), 'Yes')
    lu.assertEquals(candidate('Is3youfault.txt'), 'Yes')
    lu.assertEquals(candidate('no_one#knows.dll'), 'Yes')
    lu.assertEquals(candidate('1I563_Yes3.exe'), 'No')
    lu.assertEquals(candidate('I563_Yes3.txtt'), 'No')
    lu.assertEquals(candidate('final..txt'), 'No')
    lu.assertEquals(candidate('final132'), 'No')
    lu.assertEquals(candidate('_f4indsartal132.'), 'No')
    lu.assertEquals(candidate('.txt'), 'No')
    lu.assertEquals(candidate('s.'), 'No')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Create a function which takes a string representing a file's name, and returns
-- 'Yes' if the the file's name is valid, and returns 'No' otherwise.
-- A file's name is considered to be valid if and only if all the following conditions 
-- are met:
-- - There should not be more than three digits ('0'-'9') in the file's name.
-- - The file's name contains exactly one dot '.'
-- - The substring before the dot should not be empty, and it starts with a letter from 
-- the latin alphapet ('a'-'z' and 'A'-'Z').
-- - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
-- Examples:
-- >>> file_name_check('example.txt')
-- 'Yes'
-- >>> file_name_check('1example.dll')
-- 'No'
-- Function to check whether a file name is valid according to the given rules
local function file_name_check(file_name)
    -- Ensure the input is a string
    if type(file_name) ~= "string" then
        return "No"
    end

    -- 1. Exactly one dot
    local dot_count = 0
    for _ in string.gmatch(file_name, "%.") do
        dot_count = dot_count + 1
    end
    if dot_count ~= 1 then
        return "No"
    end

    -- 2. Split into name and extension
    local name, ext = file_name:match("^(.-)%.([^%.]+)$")
    if not name or not ext then
        return "No"
    end

    -- 3. Name part must not be empty and must start with a latin letter
    if name == "" then
        return "No"
    end
    if not name:match("^[A-Za-z]") then
        return "No"
    end

    -- 4. Extension must be one of the allowed ones
    local allowed_ext = { txt = true, exe = true, dll = true }
    if not allowed_ext[ext] then
        return "No"
    end

    -- 5. Count digits in the entire file name (name + extension)
    local digit_count = 0
    for _ in string.gmatch(file_name, "%d") do
        digit_count = digit_count + 1
    end
    if digit_count > 3 then
        return "No"
    end

    -- All checks passed
    return "Yes"
end

-- Example usage
print(file_name_check('example.txt'))  -- 'Yes'
print(file_name_check('1example.dll')) -- 'No'
lu = require('luaunit')

function test_humaneval()
local candidate = file_name_check
    lu.assertEquals(candidate('example.txt'), 'Yes')
    lu.assertEquals(candidate('1example.dll'), 'No')
    lu.assertEquals(candidate('s1sdf3.asd'), 'No')
    lu.assertEquals(candidate('K.dll'), 'Yes')
    lu.assertEquals(candidate('MY16FILE3.exe'), 'Yes')
    lu.assertEquals(candidate('His12FILE94.exe'), 'No')
    lu.assertEquals(candidate('_Y.txt'), 'No')
    lu.assertEquals(candidate('?aREYA.exe'), 'No')
    lu.assertEquals(candidate('/this_is_valid.dll'), 'No')
    lu.assertEquals(candidate('this_is_valid.wow'), 'No')
    lu.assertEquals(candidate('this_is_valid.txt'), 'Yes')
    lu.assertEquals(candidate('this_is_valid.txtexe'), 'No')
    lu.assertEquals(candidate('#this2_i4s_5valid.ten'), 'No')
    lu.assertEquals(candidate('@this1_is6_valid.exe'), 'No')
    lu.assertEquals(candidate('this_is_12valid.6exe4.txt'), 'No')
    lu.assertEquals(candidate('all.exe.txt'), 'No')
    lu.assertEquals(candidate('I563_No.exe'), 'Yes')
    lu.assertEquals(candidate('Is3youfault.txt'), 'Yes')
    lu.assertEquals(candidate('no_one#knows.dll'), 'Yes')
    lu.assertEquals(candidate('1I563_Yes3.exe'), 'No')
    lu.assertEquals(candidate('I563_Yes3.txtt'), 'No')
    lu.assertEquals(candidate('final..txt'), 'No')
    lu.assertEquals(candidate('final132'), 'No')
    lu.assertEquals(candidate('_f4indsartal132.'), 'No')
    lu.assertEquals(candidate('.txt'), 'No')
    lu.assertEquals(candidate('s.'), 'No')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
Yes
No
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 143 (LUA) - HumanEval_143_words_in_sentence
================================================================================

PROMPT:
----------------------------------------
-- You are given a string representing a sentence,
-- the sentence contains some words separated by a space,
-- and you have to return a string that contains the words from the original sentence,
-- whose lengths are prime numbers,
-- the order of the words in the new string should be the same as the original one.
-- Example 1:
-- >>> words_in_sentence('This is a test')
-- 'is'
-- Example 2:
-- >>> words_in_sentence('lets go for swimming')
-- 'go for'
-- Constraints:
--     * 1 <= len(sentence) <= 100
--     * sentence contains only letters

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = words_in_sentence
    lu.assertEquals(candidate('This is a test'), 'is')
    lu.assertEquals(candidate('lets go for swimming'), 'go for')
    lu.assertEquals(candidate('there is no place available here'), 'there is no place')
    lu.assertEquals(candidate('Hi I am Hussein'), 'Hi am Hussein')
    lu.assertEquals(candidate('go for it'), 'go for it')
    lu.assertEquals(candidate('here'), '')
    lu.assertEquals(candidate('here is'), 'is')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You are given a string representing a sentence,
-- the sentence contains some words separated by a space,
-- and you have to return a string that contains the words from the original sentence,
-- whose lengths are prime numbers,
-- the order of the words in the new string should be the same as the original one.
-- Example 1:
-- >>> words_in_sentence('This is a test')
-- 'is'
-- Example 2:
-- >>> words_in_sentence('lets go for swimming')
-- 'go for'
-- Constraints:
--     * 1 <= len(sentence) <= 100
--     * sentence contains only letters
local function words_in_sentence(sentence)
  -- Helper function to check if a number is prime
  local function is_prime(n)
    if n < 2 then return false end
    local limit = math.floor(math.sqrt(n))
    for i = 2, limit do
      if n % i == 0 then return false end
    end
    return true
  end

  local result = {}
  -- Iterate over each word in the sentence
  for word in sentence:gmatch("%S+") do
    if is_prime(#word) then
      table.insert(result, word)
    end
  end

  -- Join the qualifying words with a single space
  return table.concat(result, " ")
end
lu = require('luaunit')

function test_humaneval()
local candidate = words_in_sentence
    lu.assertEquals(candidate('This is a test'), 'is')
    lu.assertEquals(candidate('lets go for swimming'), 'go for')
    lu.assertEquals(candidate('there is no place available here'), 'there is no place')
    lu.assertEquals(candidate('Hi I am Hussein'), 'Hi am Hussein')
    lu.assertEquals(candidate('go for it'), 'go for it')
    lu.assertEquals(candidate('here'), '')
    lu.assertEquals(candidate('here is'), 'is')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You are given a string representing a sentence,
-- the sentence contains some words separated by a space,
-- and you have to return a string that contains the words from the original sentence,
-- whose lengths are prime numbers,
-- the order of the words in the new string should be the same as the original one.
-- Example 1:
-- >>> words_in_sentence('This is a test')
-- 'is'
-- Example 2:
-- >>> words_in_sentence('lets go for swimming')
-- 'go for'
-- Constraints:
--     * 1 <= len(sentence) <= 100
--     * sentence contains only letters
-- Returns a string containing only the words from `sentence`
-- whose lengths are prime numbers, preserving the original order.
local function words_in_sentence(sentence)
    -- Helper: check if a number is prime
    local function is_prime(n)
        if n < 2 then return false end
        if n == 2 then return true end
        if n % 2 == 0 then return false end
        local sqrt_n = math.floor(math.sqrt(n))
        for i = 3, sqrt_n, 2 do
            if n % i == 0 then
                return false
            end
        end
        return true
    end

    local result = {}
    for word in string.gmatch(sentence, "%S+") do
        if is_prime(#word) then
            table.insert(result, word)
        end
    end

    return table.concat(result, " ")
end
lu = require('luaunit')

function test_humaneval()
local candidate = words_in_sentence
    lu.assertEquals(candidate('This is a test'), 'is')
    lu.assertEquals(candidate('lets go for swimming'), 'go for')
    lu.assertEquals(candidate('there is no place available here'), 'there is no place')
    lu.assertEquals(candidate('Hi I am Hussein'), 'Hi am Hussein')
    lu.assertEquals(candidate('go for it'), 'go for it')
    lu.assertEquals(candidate('here'), '')
    lu.assertEquals(candidate('here is'), 'is')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You are given a string representing a sentence,
-- the sentence contains some words separated by a space,
-- and you have to return a string that contains the words from the original sentence,
-- whose lengths are prime numbers,
-- the order of the words in the new string should be the same as the original one.
-- Example 1:
-- >>> words_in_sentence('This is a test')
-- 'is'
-- Example 2:
-- >>> words_in_sentence('lets go for swimming')
-- 'go for'
-- Constraints:
--     * 1 <= len(sentence) <= 100
--     * sentence contains only letters
-- Returns a string containing only the words from `sentence`
-- whose lengths are prime numbers, preserving the original order.
local function words_in_sentence(sentence)
  -- Helper to check if a number is prime.
  local function is_prime(n)
    if n <= 1 then return false end
    if n == 2 then return true end
    if n % 2 == 0 then return false end
    local i = 3
    while i * i <= n do
      if n % i == 0 then return false end
      i = i + 2
    end
    return true
  end

  local selected = {}
  for word in sentence:gmatch("%S+") do
    if is_prime(#word) then
      table.insert(selected, word)
    end
  end
  return table.concat(selected, " ")
end
lu = require('luaunit')

function test_humaneval()
local candidate = words_in_sentence
    lu.assertEquals(candidate('This is a test'), 'is')
    lu.assertEquals(candidate('lets go for swimming'), 'go for')
    lu.assertEquals(candidate('there is no place available here'), 'there is no place')
    lu.assertEquals(candidate('Hi I am Hussein'), 'Hi am Hussein')
    lu.assertEquals(candidate('go for it'), 'go for it')
    lu.assertEquals(candidate('here'), '')
    lu.assertEquals(candidate('here is'), 'is')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You are given a string representing a sentence,
-- the sentence contains some words separated by a space,
-- and you have to return a string that contains the words from the original sentence,
-- whose lengths are prime numbers,
-- the order of the words in the new string should be the same as the original one.
-- Example 1:
-- >>> words_in_sentence('This is a test')
-- 'is'
-- Example 2:
-- >>> words_in_sentence('lets go for swimming')
-- 'go for'
-- Constraints:
--     * 1 <= len(sentence) <= 100
--     * sentence contains only letters
local function words_in_sentence(sentence)
    -- Helper to test primality of a number
    local function is_prime(n)
        if n < 2 then return false end
        if n == 2 then return true end
        if n % 2 == 0 then return false end
        local limit = math.floor(math.sqrt(n))
        for i = 3, limit, 2 do
            if n % i == 0 then return false end
        end
        return true
    end

    local chosen = {}
    -- Iterate over each word separated by whitespace
    for word in sentence:gmatch("%S+") do
        if is_prime(#word) then
            table.insert(chosen, word)
        end
    end

    return table.concat(chosen, " ")
end
lu = require('luaunit')

function test_humaneval()
local candidate = words_in_sentence
    lu.assertEquals(candidate('This is a test'), 'is')
    lu.assertEquals(candidate('lets go for swimming'), 'go for')
    lu.assertEquals(candidate('there is no place available here'), 'there is no place')
    lu.assertEquals(candidate('Hi I am Hussein'), 'Hi am Hussein')
    lu.assertEquals(candidate('go for it'), 'go for it')
    lu.assertEquals(candidate('here'), '')
    lu.assertEquals(candidate('here is'), 'is')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154480
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 146 (LUA) - HumanEval_146_specialFilter
================================================================================

PROMPT:
----------------------------------------
-- Write a function that takes a table of numbers as input and returns 
-- the number of elements in the table that are greater than 10 and both 
-- first and last digits of a number are odd (1, 3, 5, 7, 9).
-- For example:
-- >>> specialFilter({15, -73, 14, -15})
-- 1
-- >>> specialFilter({33, -2, -3, 45, 21, 109})
-- 2

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = specialFilter
    lu.assertEquals(candidate({5, -2, 1, -5}), 0)
    lu.assertEquals(candidate({15, -73, 14, -15}), 1)
    lu.assertEquals(candidate({33, -2, -3, 45, 21, 109}), 2)
    lu.assertEquals(candidate({43, -12, 93, 125, 121, 109}), 4)
    lu.assertEquals(candidate({71, -2, -33, 75, 21, 19}), 3)
    lu.assertEquals(candidate({1}), 0)
    lu.assertEquals(candidate({}), 0)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Write a function that takes a table of numbers as input and returns 
-- the number of elements in the table that are greater than 10 and both 
-- first and last digits of a number are odd (1, 3, 5, 7, 9).
-- For example:
-- >>> specialFilter({15, -73, 14, -15})
-- 1
-- >>> specialFilter({33, -2, -3, 45, 21, 109})
-- 2
-- Count numbers >10 whose first and last digits are odd
local function specialFilter(nums)
  local count = 0
  for _, n in ipairs(nums) do
    if n > 10 then
      local s = tostring(n)          -- convert number to string
      local first = tonumber(s:sub(1, 1))
      local last  = tonumber(s:sub(-1))
      if first % 2 == 1 and last % 2 == 1 then
        count = count + 1
      end
    end
  end
  return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = specialFilter
    lu.assertEquals(candidate({5, -2, 1, -5}), 0)
    lu.assertEquals(candidate({15, -73, 14, -15}), 1)
    lu.assertEquals(candidate({33, -2, -3, 45, 21, 109}), 2)
    lu.assertEquals(candidate({43, -12, 93, 125, 121, 109}), 4)
    lu.assertEquals(candidate({71, -2, -33, 75, 21, 19}), 3)
    lu.assertEquals(candidate({1}), 0)
    lu.assertEquals(candidate({}), 0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Write a function that takes a table of numbers as input and returns 
-- the number of elements in the table that are greater than 10 and both 
-- first and last digits of a number are odd (1, 3, 5, 7, 9).
-- For example:
-- >>> specialFilter({15, -73, 14, -15})
-- 1
-- >>> specialFilter({33, -2, -3, 45, 21, 109})
-- 2
-- Returns the number of elements in the table that are greater than 10
-- and whose first and last digits are odd (1, 3, 5, 7, 9).
local function specialFilter(nums)
    local count = 0
    for _, n in ipairs(nums) do
        if n > 10 then
            -- Work with the absolute value to ignore a leading '-'
            local s = tostring(math.abs(n))
            local first = tonumber(s:sub(1, 1))
            local last  = tonumber(s:sub(-1))
            if first % 2 == 1 and last % 2 == 1 then
                count = count + 1
            end
        end
    end
    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = specialFilter
    lu.assertEquals(candidate({5, -2, 1, -5}), 0)
    lu.assertEquals(candidate({15, -73, 14, -15}), 1)
    lu.assertEquals(candidate({33, -2, -3, 45, 21, 109}), 2)
    lu.assertEquals(candidate({43, -12, 93, 125, 121, 109}), 4)
    lu.assertEquals(candidate({71, -2, -33, 75, 21, 19}), 3)
    lu.assertEquals(candidate({1}), 0)
    lu.assertEquals(candidate({}), 0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Write a function that takes a table of numbers as input and returns 
-- the number of elements in the table that are greater than 10 and both 
-- first and last digits of a number are odd (1, 3, 5, 7, 9).
-- For example:
-- >>> specialFilter({15, -73, 14, -15})
-- 1
-- >>> specialFilter({33, -2, -3, 45, 21, 109})
-- 2
-- Returns the number of elements in `nums` that are greater than 10 and
-- whose first and last digits are odd (1, 3, 5, 7, 9).
local function specialFilter(nums)
  local count = 0

  for _, n in ipairs(nums) do
    if n > 10 then
      local absVal = math.abs(n)

      -- Last digit
      local last = absVal % 10

      -- First digit
      local first = absVal
      while first >= 10 do
        first = math.floor(first / 10)
      end

      -- Check if both digits are odd
      if (first % 2 == 1) and (last % 2 == 1) then
        count = count + 1
      end
    end
  end

  return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = specialFilter
    lu.assertEquals(candidate({5, -2, 1, -5}), 0)
    lu.assertEquals(candidate({15, -73, 14, -15}), 1)
    lu.assertEquals(candidate({33, -2, -3, 45, 21, 109}), 2)
    lu.assertEquals(candidate({43, -12, 93, 125, 121, 109}), 4)
    lu.assertEquals(candidate({71, -2, -33, 75, 21, 19}), 3)
    lu.assertEquals(candidate({1}), 0)
    lu.assertEquals(candidate({}), 0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Write a function that takes a table of numbers as input and returns 
-- the number of elements in the table that are greater than 10 and both 
-- first and last digits of a number are odd (1, 3, 5, 7, 9).
-- For example:
-- >>> specialFilter({15, -73, 14, -15})
-- 1
-- >>> specialFilter({33, -2, -3, 45, 21, 109})
-- 2
local function specialFilter(nums)
    local count = 0
    for _, n in ipairs(nums) do
        if n > 10 then
            -- Convert the number to a string (use abs to ignore any sign)
            local s = tostring(math.abs(n))
            local first = tonumber(s:sub(1, 1))
            local last  = tonumber(s:sub(-1))
            if first % 2 == 1 and last % 2 == 1 then
                count = count + 1
            end
        end
    end
    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = specialFilter
    lu.assertEquals(candidate({5, -2, 1, -5}), 0)
    lu.assertEquals(candidate({15, -73, 14, -15}), 1)
    lu.assertEquals(candidate({33, -2, -3, 45, 21, 109}), 2)
    lu.assertEquals(candidate({43, -12, 93, 125, 121, 109}), 4)
    lu.assertEquals(candidate({71, -2, -33, 75, 21, 19}), 3)
    lu.assertEquals(candidate({1}), 0)
    lu.assertEquals(candidate({}), 0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 147 (LUA) - HumanEval_147_get_max_triples
================================================================================

PROMPT:
----------------------------------------
-- You are given a positive integer n. You have to create an integer table a of length n.
-- For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
-- Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
--     and a[i] + a[j] + a[k] is a multiple of 3.
--     Example :
--     >>> get_max_triples(5)
--     1
-- Explanation: 
-- a = [1, 3, 7, 13, 21]
-- The only valid triple is (1, 7, 13).

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = get_max_triples
    lu.assertEquals(candidate(5), 1)
    lu.assertEquals(candidate(6), 4)
    lu.assertEquals(candidate(10), 36)
    lu.assertEquals(candidate(100), 53361)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You are given a positive integer n. You have to create an integer table a of length n.
-- For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
-- Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
--     and a[i] + a[j] + a[k] is a multiple of 3.
--     Example :
--     >>> get_max_triples(5)
--     1
-- Explanation: 
-- a = [1, 3, 7, 13, 21]
-- The only valid triple is (1, 7, 13).
-- Calculates the number of triples (a[i], a[j], a[k]) with i < j < k
-- such that a[i] + a[j] + a[k] is divisible by 3, where a[i] = i^2 - i + 1.
local function get_max_triples(n)
    -- Count of indices i (1 ≤ i ≤ n) where a[i] ≡ 0 (mod 3).
    -- These are exactly the indices i ≡ 2 (mod 3).
    local count0 = math.floor((n + 1) / 3)   -- numbers 2,5,8,...
    -- All remaining indices have a[i] ≡ 1 (mod 3).
    local count1 = n - count0

    -- Helper to compute n choose 3 safely.
    local function comb3(x)
        if x < 3 then return 0 end
        return (x * (x - 1) * (x - 2)) // 6
    end

    -- Only triples with all residues 0 or all residues 1 are valid.
    return comb3(count0) + comb3(count1)
end
lu = require('luaunit')

function test_humaneval()
local candidate = get_max_triples
    lu.assertEquals(candidate(5), 1)
    lu.assertEquals(candidate(6), 4)
    lu.assertEquals(candidate(10), 36)
    lu.assertEquals(candidate(100), 53361)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You are given a positive integer n. You have to create an integer table a of length n.
-- For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
-- Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
--     and a[i] + a[j] + a[k] is a multiple of 3.
--     Example :
--     >>> get_max_triples(5)
--     1
-- Explanation: 
-- a = [1, 3, 7, 13, 21]
-- The only valid triple is (1, 7, 13).
-- Calculates the number of triples (a[i], a[j], a[k]) where
-- i < j < k and a[i] + a[j] + a[k] is a multiple of 3.
--
-- a[i] = i*i - i + 1
-- The key observation is that a[i] mod 3 depends only on i mod 3:
--   if i % 3 == 2  → a[i] ≡ 0 (mod 3)
--   otherwise      → a[i] ≡ 1 (mod 3)
-- Therefore a triple sums to a multiple of 3 iff all three indices
-- belong to the same residue class (all 0‑mod‑3 or all 1‑mod‑3).
--
-- The number of indices with i % 3 == 2 is floor((n + 1) / 3).
-- The rest are indices with i % 3 == 0 or 1.
--
-- The answer is C(cnt0, 3) + C(cnt1, 3) where cnt0 is the number of
-- indices with residue 0 and cnt1 = n - cnt0.

local function get_max_triples(n)
    -- Count indices with i % 3 == 2 (these give residue 0)
    local cnt0 = math.floor((n + 1) / 3)
    -- Remaining indices give residue 1
    local cnt1 = n - cnt0

    local function comb3(k)
        if k < 3 then
            return 0
        end
        -- C(k,3) = k*(k-1)*(k-2)/6  (always integer)
        return k * (k - 1) * (k - 2) / 6
    end

    return comb3(cnt0) + comb3(cnt1)
end
lu = require('luaunit')

function test_humaneval()
local candidate = get_max_triples
    lu.assertEquals(candidate(5), 1)
    lu.assertEquals(candidate(6), 4)
    lu.assertEquals(candidate(10), 36)
    lu.assertEquals(candidate(100), 53361)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You are given a positive integer n. You have to create an integer table a of length n.
-- For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
-- Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
--     and a[i] + a[j] + a[k] is a multiple of 3.
--     Example :
--     >>> get_max_triples(5)
--     1
-- Explanation: 
-- a = [1, 3, 7, 13, 21]
-- The only valid triple is (1, 7, 13).
-- Computes the number of triples (a[i], a[j], a[k]) with i < j < k
-- such that a[i] + a[j] + a[k] is a multiple of 3.
-- Here a[i] = i*i - i + 1.
local function get_max_triples(n)
  -- Count how many indices have i mod 3 == 2 (these give a[i] % 3 == 0)
  local c0 = math.floor((n + 1) / 3)  -- indices 2,5,8,...
  -- Remaining indices give a[i] % 3 == 1
  local c1 = n - c0

  -- Helper to compute binomial coefficient C(k,3)
  local function comb3(k)
    if k < 3 then return 0 end
    return (k * (k - 1) * (k - 2)) // 6
  end

  return comb3(c0) + comb3(c1)
end

-- Example usage:
-- print(get_max_triples(5))  --> 1
lu = require('luaunit')

function test_humaneval()
local candidate = get_max_triples
    lu.assertEquals(candidate(5), 1)
    lu.assertEquals(candidate(6), 4)
    lu.assertEquals(candidate(10), 36)
    lu.assertEquals(candidate(100), 53361)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You are given a positive integer n. You have to create an integer table a of length n.
-- For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
-- Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
--     and a[i] + a[j] + a[k] is a multiple of 3.
--     Example :
--     >>> get_max_triples(5)
--     1
-- Explanation: 
-- a = [1, 3, 7, 13, 21]
-- The only valid triple is (1, 7, 13).
-- Returns the number of triples (a[i], a[j], a[k]) with i < j < k
-- such that a[i] + a[j] + a[k] is a multiple of 3.
local function get_max_triples(n)
    -- Count how many indices have residue 2 modulo 3 (i.e. a[i] % 3 == 0)
    local cnt0 = math.floor((n + 1) / 3)   -- indices i where i % 3 == 2
    local cnt1 = n - cnt0                  -- the rest (i % 3 == 0 or 1)

    -- Helper to compute nC3 safely (returns 0 if n < 3)
    local function comb3(x)
        if x < 3 then return 0 end
        return (x * (x - 1) * (x - 2)) // 6
    end

    return comb3(cnt0) + comb3(cnt1)
end

-- Example usage:
print(get_max_triples(5))  -- Output: 1
lu = require('luaunit')

function test_humaneval()
local candidate = get_max_triples
    lu.assertEquals(candidate(5), 1)
    lu.assertEquals(candidate(6), 4)
    lu.assertEquals(candidate(10), 36)
    lu.assertEquals(candidate(100), 53361)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
1
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 149 (LUA) - HumanEval_149_sorted_list_sum
================================================================================

PROMPT:
----------------------------------------
-- Write a function that accepts a table of strings as a parameter,
-- deletes the strings that have odd lengths from it,
-- and returns the resulted table with a sorted order,
-- The table is always a table of strings and never a table of numbers,
-- and it may contain duplicates.
-- The order of the table should be ascending by length of each word, and you
-- should return the table sorted by that rule.
-- If two words have the same length, sort the table alphabetically.
-- The function should return a table of strings in sorted order.
-- You may assume that all words will have the same length.
-- For example:
-- >>> list_sort({'aa', 'a', 'aaa'})
-- {'aa'}
-- >>> list_sort({'ab', 'a', 'aaa', 'cd'})
-- {'ab', 'cd'}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = sorted_list_sum
    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})
    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})
    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})
    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})
    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})
    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})
    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Write a function that accepts a table of strings as a parameter,
-- deletes the strings that have odd lengths from it,
-- and returns the resulted table with a sorted order,
-- The table is always a table of strings and never a table of numbers,
-- and it may contain duplicates.
-- The order of the table should be ascending by length of each word, and you
-- should return the table sorted by that rule.
-- If two words have the same length, sort the table alphabetically.
-- The function should return a table of strings in sorted order.
-- You may assume that all words will have the same length.
-- For example:
-- >>> list_sort({'aa', 'a', 'aaa'})
-- {'aa'}
-- >>> list_sort({'ab', 'a', 'aaa', 'cd'})
-- {'ab', 'cd'}
-- Function that removes strings of odd length and returns the remaining
-- strings sorted first by length (ascending) and then alphabetically.
local function sorted_list_sum(lst)
    -- Filter out odd‑length strings
    local filtered = {}
    for _, str in ipairs(lst) do
        if #str % 2 == 0 then
            table.insert(filtered, str)
        end
    end

    -- Sort by length, then alphabetically
    table.sort(filtered, function(a, b)
        if #a ~= #b then
            return #a < #b
        else
            return a < b
        end
    end)

    return filtered
end
lu = require('luaunit')

function test_humaneval()
local candidate = sorted_list_sum
    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})
    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})
    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})
    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})
    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})
    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})
    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Write a function that accepts a table of strings as a parameter,
-- deletes the strings that have odd lengths from it,
-- and returns the resulted table with a sorted order,
-- The table is always a table of strings and never a table of numbers,
-- and it may contain duplicates.
-- The order of the table should be ascending by length of each word, and you
-- should return the table sorted by that rule.
-- If two words have the same length, sort the table alphabetically.
-- The function should return a table of strings in sorted order.
-- You may assume that all words will have the same length.
-- For example:
-- >>> list_sort({'aa', 'a', 'aaa'})
-- {'aa'}
-- >>> list_sort({'ab', 'a', 'aaa', 'cd'})
-- {'ab', 'cd'}
-- Delete odd‑length strings, then sort by length (ascending) and alphabetically
local function sorted_list_sum(lst)
  -- 1️⃣  Build a new table containing only even‑length strings
  local even = {}
  for _, word in ipairs(lst) do
    if (#word % 2) == 0 then
      table.insert(even, word)
    end
  end

  -- 2️⃣  Sort the resulting table
  table.sort(even, function(a, b)
    local la, lb = #a, #b
    if la ~= lb then
      return la < lb          -- ascending by length
    else
      return a < b            -- alphabetical if same length
    end
  end)

  return even
end
lu = require('luaunit')

function test_humaneval()
local candidate = sorted_list_sum
    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})
    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})
    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})
    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})
    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})
    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})
    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Write a function that accepts a table of strings as a parameter,
-- deletes the strings that have odd lengths from it,
-- and returns the resulted table with a sorted order,
-- The table is always a table of strings and never a table of numbers,
-- and it may contain duplicates.
-- The order of the table should be ascending by length of each word, and you
-- should return the table sorted by that rule.
-- If two words have the same length, sort the table alphabetically.
-- The function should return a table of strings in sorted order.
-- You may assume that all words will have the same length.
-- For example:
-- >>> list_sort({'aa', 'a', 'aaa'})
-- {'aa'}
-- >>> list_sort({'ab', 'a', 'aaa', 'cd'})
-- {'ab', 'cd'}
-- Accepts a table of strings, removes strings of odd length,
-- and returns a new table sorted first by length (ascending)
-- and then alphabetically for equal lengths.
local function sorted_list_sum(lst)
    -- Step 1: filter out odd‑length strings
    local filtered = {}
    for _, word in ipairs(lst) do
        if #word % 2 == 0 then
            table.insert(filtered, word)
        end
    end

    -- Step 2: sort by length, then alphabetically
    table.sort(filtered, function(a, b)
        local la, lb = #a, #b
        if la ~= lb then
            return la < lb
        else
            return a < b
        end
    end)

    return filtered
end
lu = require('luaunit')

function test_humaneval()
local candidate = sorted_list_sum
    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})
    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})
    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})
    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})
    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})
    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})
    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Write a function that accepts a table of strings as a parameter,
-- deletes the strings that have odd lengths from it,
-- and returns the resulted table with a sorted order,
-- The table is always a table of strings and never a table of numbers,
-- and it may contain duplicates.
-- The order of the table should be ascending by length of each word, and you
-- should return the table sorted by that rule.
-- If two words have the same length, sort the table alphabetically.
-- The function should return a table of strings in sorted order.
-- You may assume that all words will have the same length.
-- For example:
-- >>> list_sort({'aa', 'a', 'aaa'})
-- {'aa'}
-- >>> list_sort({'ab', 'a', 'aaa', 'cd'})
-- {'ab', 'cd'}
-- Function: sorted_list_sum
--   Accepts a table of strings `lst`.
--   Removes any string whose length is odd.
--   Returns a new table containing the remaining strings sorted
--   first by ascending length, then alphabetically for equal lengths.
--   Duplicates are preserved.
local function sorted_list_sum(lst)
    -- Collect only even‑length strings
    local even = {}
    for _, str in ipairs(lst) do
        if #str % 2 == 0 then
            table.insert(even, str)
        end
    end

    -- Sort by length, then alphabetically
    table.sort(even, function(a, b)
        if #a ~= #b then
            return #a < #b
        else
            return a < b
        end
    end)

    return even
end
lu = require('luaunit')

function test_humaneval()
local candidate = sorted_list_sum
    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})
    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})
    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})
    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})
    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})
    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})
    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 150 (LUA) - HumanEval_150_x_or_y
================================================================================

PROMPT:
----------------------------------------
-- A simple program which should return the value of x if n is 
-- a prime number and should return the value of y otherwise.
-- Examples:
-- >>> x_or_y(7, 34, 12)
-- 34
-- >>> x_or_y(15, 8, 5)
-- 5

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = x_or_y
    lu.assertEquals(candidate(7, 34, 12), 34)
    lu.assertEquals(candidate(15, 8, 5), 5)
    lu.assertEquals(candidate(3, 33, 5212), 33)
    lu.assertEquals(candidate(1259, 3, 52), 3)
    lu.assertEquals(candidate(7919, -1, 12), -1)
    lu.assertEquals(candidate(3609, 1245, 583), 583)
    lu.assertEquals(candidate(91, 56, 129), 129)
    lu.assertEquals(candidate(6, 34, 1234), 1234)
    lu.assertEquals(candidate(1, 2, 0), 0)
    lu.assertEquals(candidate(2, 2, 0), 2)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- A simple program which should return the value of x if n is 
-- a prime number and should return the value of y otherwise.
-- Examples:
-- >>> x_or_y(7, 34, 12)
-- 34
-- >>> x_or_y(15, 8, 5)
-- 5
-- Returns x if n is prime, otherwise returns y
local function x_or_y(n, x, y)
  -- Negative numbers, 0 and 1 are not prime
  if n < 2 then
    return y
  end

  -- Check divisibility from 2 up to sqrt(n)
  local limit = math.floor(math.sqrt(n))
  for i = 2, limit do
    if n % i == 0 then
      return y  -- n is composite
    end
  end

  return x  -- n is prime
end
lu = require('luaunit')

function test_humaneval()
local candidate = x_or_y
    lu.assertEquals(candidate(7, 34, 12), 34)
    lu.assertEquals(candidate(15, 8, 5), 5)
    lu.assertEquals(candidate(3, 33, 5212), 33)
    lu.assertEquals(candidate(1259, 3, 52), 3)
    lu.assertEquals(candidate(7919, -1, 12), -1)
    lu.assertEquals(candidate(3609, 1245, 583), 583)
    lu.assertEquals(candidate(91, 56, 129), 129)
    lu.assertEquals(candidate(6, 34, 1234), 1234)
    lu.assertEquals(candidate(1, 2, 0), 0)
    lu.assertEquals(candidate(2, 2, 0), 2)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- A simple program which should return the value of x if n is 
-- a prime number and should return the value of y otherwise.
-- Examples:
-- >>> x_or_y(7, 34, 12)
-- 34
-- >>> x_or_y(15, 8, 5)
-- 5
-- A simple program which should return the value of x if n is 
-- a prime number and should return the value of y otherwise.
-- Examples:
-- >>> x_or_y(7, 34, 12)
-- 34
-- >>> x_or_y(15, 8, 5)
-- 5
local function x_or_y(n, x, y)
  -- Helper function to determine primality
  local function is_prime(num)
    if num <= 1 then return false end
    if num <= 3 then return true end
    if num % 2 == 0 or num % 3 == 0 then return false end

    local i = 5
    local limit = math.floor(math.sqrt(num))
    while i <= limit do
      if num % i == 0 or num % (i + 2) == 0 then
        return false
      end
      i = i + 6
    end
    return true
  end

  if is_prime(n) then
    return x
  else
    return y
  end
end

-- Example usage
print(x_or_y(7, 34, 12))   -- outputs 34
print(x_or_y(15, 8, 5))    -- outputs 5
lu = require('luaunit')

function test_humaneval()
local candidate = x_or_y
    lu.assertEquals(candidate(7, 34, 12), 34)
    lu.assertEquals(candidate(15, 8, 5), 5)
    lu.assertEquals(candidate(3, 33, 5212), 33)
    lu.assertEquals(candidate(1259, 3, 52), 3)
    lu.assertEquals(candidate(7919, -1, 12), -1)
    lu.assertEquals(candidate(3609, 1245, 583), 583)
    lu.assertEquals(candidate(91, 56, 129), 129)
    lu.assertEquals(candidate(6, 34, 1234), 1234)
    lu.assertEquals(candidate(1, 2, 0), 0)
    lu.assertEquals(candidate(2, 2, 0), 2)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
34
5
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- A simple program which should return the value of x if n is 
-- a prime number and should return the value of y otherwise.
-- Examples:
-- >>> x_or_y(7, 34, 12)
-- 34
-- >>> x_or_y(15, 8, 5)
-- 5
-- A simple program which should return the value of x if n is 
-- a prime number and should return the value of y otherwise.
-- Examples:
-- >>> x_or_y(7, 34, 12)
-- 34
-- >>> x_or_y(15, 8, 5)
-- 5

local function x_or_y(n, x, y)
    -- Helper to determine if a number is prime
    local function is_prime(num)
        if num < 2 then
            return false
        end
        -- Check divisibility up to the square root of num
        local limit = math.floor(math.sqrt(num))
        for i = 2, limit do
            if num % i == 0 then
                return false
            end
        end
        return true
    end

    if is_prime(n) then
        return x
    else
        return y
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = x_or_y
    lu.assertEquals(candidate(7, 34, 12), 34)
    lu.assertEquals(candidate(15, 8, 5), 5)
    lu.assertEquals(candidate(3, 33, 5212), 33)
    lu.assertEquals(candidate(1259, 3, 52), 3)
    lu.assertEquals(candidate(7919, -1, 12), -1)
    lu.assertEquals(candidate(3609, 1245, 583), 583)
    lu.assertEquals(candidate(91, 56, 129), 129)
    lu.assertEquals(candidate(6, 34, 1234), 1234)
    lu.assertEquals(candidate(1, 2, 0), 0)
    lu.assertEquals(candidate(2, 2, 0), 2)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- A simple program which should return the value of x if n is 
-- a prime number and should return the value of y otherwise.
-- Examples:
-- >>> x_or_y(7, 34, 12)
-- 34
-- >>> x_or_y(15, 8, 5)
-- 5
local function x_or_y(n, x, y)
  -- Helper function to test primality
  local function is_prime(num)
    if num <= 1 then return false end
    if num == 2 then return true end
    if num % 2 == 0 then return false end

    local limit = math.floor(math.sqrt(num))
    for i = 3, limit, 2 do
      if num % i == 0 then
        return false
      end
    end
    return true
  end

  if is_prime(n) then
    return x
  else
    return y
  end
end
lu = require('luaunit')

function test_humaneval()
local candidate = x_or_y
    lu.assertEquals(candidate(7, 34, 12), 34)
    lu.assertEquals(candidate(15, 8, 5), 5)
    lu.assertEquals(candidate(3, 33, 5212), 33)
    lu.assertEquals(candidate(1259, 3, 52), 3)
    lu.assertEquals(candidate(7919, -1, 12), -1)
    lu.assertEquals(candidate(3609, 1245, 583), 583)
    lu.assertEquals(candidate(91, 56, 129), 129)
    lu.assertEquals(candidate(6, 34, 1234), 1234)
    lu.assertEquals(candidate(1, 2, 0), 0)
    lu.assertEquals(candidate(2, 2, 0), 2)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 152 (LUA) - HumanEval_152_compare
================================================================================

PROMPT:
----------------------------------------
-- I think we all remember that feeling when the result of some long-awaited
-- event is finally known. The feelings and thoughts you have at that moment are
-- definitely worth noting down and comparing.
-- Your task is to determine if a person correctly guessed the results of a number of matches.
-- You are given two tables of scores and guesses of equal length, where each index shows a match. 
-- Return a table of the same length denoting how far off each guess was. If they have guessed correctly,
-- the value is 0, and if not, the value is the absolute difference between the guess and the score.
-- example:
-- >>> compare({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2})
-- {0, 0, 0, 0, 3, 3}
-- >>> compare({0, 5, 0, 0, 0, 4}, {4, 1, 1, 0, 0, -2})
-- {4, 4, 1, 0, 0, 6}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = compare
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2}), {0, 0, 0, 0, 3, 3})
    lu.assertEquals(candidate({0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}), {0, 0, 0, 0, 0, 0})
    lu.assertEquals(candidate({1, 2, 3}, {-1, -2, -3}), {2, 4, 6})
    lu.assertEquals(candidate({1, 2, 3, 5}, {-1, 2, 3, 4}), {2, 0, 0, 1})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- I think we all remember that feeling when the result of some long-awaited
-- event is finally known. The feelings and thoughts you have at that moment are
-- definitely worth noting down and comparing.
-- Your task is to determine if a person correctly guessed the results of a number of matches.
-- You are given two tables of scores and guesses of equal length, where each index shows a match. 
-- Return a table of the same length denoting how far off each guess was. If they have guessed correctly,
-- the value is 0, and if not, the value is the absolute difference between the guess and the score.
-- example:
-- >>> compare({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2})
-- {0, 0, 0, 0, 3, 3}
-- >>> compare({0, 5, 0, 0, 0, 4}, {4, 1, 1, 0, 0, -2})
-- {4, 4, 1, 0, 0, 6}
-- |compare| takes two tables of equal length, `game` (the actual scores)
-- and `guess` (the guessed scores), and returns a new table where each
-- element is the absolute difference between the corresponding elements
-- of the two input tables.  If a guess matches the score exactly the
-- result is 0.
--
-- Example:
--   compare({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2})  --> {0, 0, 0, 0, 3, 3}
--   compare({0, 5, 0, 0, 0, 4}, {4, 1, 1, 0, 0, -2})  --> {4, 4, 1, 0, 0, 6}
--
-- The function assumes that both input tables have the same length.
local function compare(game, guess)
    local result = {}
    for i = 1, #game do
        local diff = game[i] - guess[i]
        if diff < 0 then diff = -diff end  -- math.abs is available in Lua 5.2+, but we keep it explicit for compatibility
        result[i] = diff
    end
    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = compare
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2}), {0, 0, 0, 0, 3, 3})
    lu.assertEquals(candidate({0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}), {0, 0, 0, 0, 0, 0})
    lu.assertEquals(candidate({1, 2, 3}, {-1, -2, -3}), {2, 4, 6})
    lu.assertEquals(candidate({1, 2, 3, 5}, {-1, 2, 3, 4}), {2, 0, 0, 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- I think we all remember that feeling when the result of some long-awaited
-- event is finally known. The feelings and thoughts you have at that moment are
-- definitely worth noting down and comparing.
-- Your task is to determine if a person correctly guessed the results of a number of matches.
-- You are given two tables of scores and guesses of equal length, where each index shows a match. 
-- Return a table of the same length denoting how far off each guess was. If they have guessed correctly,
-- the value is 0, and if not, the value is the absolute difference between the guess and the score.
-- example:
-- >>> compare({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2})
-- {0, 0, 0, 0, 3, 3}
-- >>> compare({0, 5, 0, 0, 0, 4}, {4, 1, 1, 0, 0, -2})
-- {4, 4, 1, 0, 0, 6}
local function compare(game, guess)
    local result = {}
    for i = 1, #game do
        local diff = math.abs(game[i] - guess[i])
        result[i] = diff
    end
    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = compare
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2}), {0, 0, 0, 0, 3, 3})
    lu.assertEquals(candidate({0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}), {0, 0, 0, 0, 0, 0})
    lu.assertEquals(candidate({1, 2, 3}, {-1, -2, -3}), {2, 4, 6})
    lu.assertEquals(candidate({1, 2, 3, 5}, {-1, 2, 3, 4}), {2, 0, 0, 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- I think we all remember that feeling when the result of some long-awaited
-- event is finally known. The feelings and thoughts you have at that moment are
-- definitely worth noting down and comparing.
-- Your task is to determine if a person correctly guessed the results of a number of matches.
-- You are given two tables of scores and guesses of equal length, where each index shows a match. 
-- Return a table of the same length denoting how far off each guess was. If they have guessed correctly,
-- the value is 0, and if not, the value is the absolute difference between the guess and the score.
-- example:
-- >>> compare({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2})
-- {0, 0, 0, 0, 3, 3}
-- >>> compare({0, 5, 0, 0, 0, 4}, {4, 1, 1, 0, 0, -2})
-- {4, 4, 1, 0, 0, 6}
-- Returns a table where each element is the absolute difference between the
-- corresponding elements of `game` and `guess`.  If the values are equal,
-- the result is 0.
local function compare(game, guess)
    local result = {}
    -- Ensure both tables have the same length; if not, process up to the
    -- shorter length to avoid errors.
    local len = math.min(#game, #guess)

    for i = 1, len do
        local diff = game[i] - guess[i]
        if diff < 0 then diff = -diff end   -- math.abs is available in Lua 5.3+, but we can avoid it
        result[i] = diff
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = compare
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2}), {0, 0, 0, 0, 3, 3})
    lu.assertEquals(candidate({0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}), {0, 0, 0, 0, 0, 0})
    lu.assertEquals(candidate({1, 2, 3}, {-1, -2, -3}), {2, 4, 6})
    lu.assertEquals(candidate({1, 2, 3, 5}, {-1, 2, 3, 4}), {2, 0, 0, 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- I think we all remember that feeling when the result of some long-awaited
-- event is finally known. The feelings and thoughts you have at that moment are
-- definitely worth noting down and comparing.
-- Your task is to determine if a person correctly guessed the results of a number of matches.
-- You are given two tables of scores and guesses of equal length, where each index shows a match. 
-- Return a table of the same length denoting how far off each guess was. If they have guessed correctly,
-- the value is 0, and if not, the value is the absolute difference between the guess and the score.
-- example:
-- >>> compare({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2})
-- {0, 0, 0, 0, 3, 3}
-- >>> compare({0, 5, 0, 0, 0, 4}, {4, 1, 1, 0, 0, -2})
-- {4, 4, 1, 0, 0, 6}
local function compare(game, guess)
  local result = {}
  for i, score in ipairs(game) do
    local g = guess[i]
    if score == g then
      result[i] = 0
    else
      local diff = score - g
      if diff < 0 then diff = -diff end
      result[i] = diff
    end
  end
  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = compare
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2}), {0, 0, 0, 0, 3, 3})
    lu.assertEquals(candidate({0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}), {0, 0, 0, 0, 0, 0})
    lu.assertEquals(candidate({1, 2, 3}, {-1, -2, -3}), {2, 4, 6})
    lu.assertEquals(candidate({1, 2, 3, 5}, {-1, 2, 3, 4}), {2, 0, 0, 1})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154481
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------
