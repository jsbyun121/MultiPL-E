As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 90 (JL) - HumanEval_90_next_smallest
================================================================================

PROMPT:
----------------------------------------
"""You are given a vector of integers.
Write a function next_smallest() that returns the 2nd smallest element of the vector.
Return nothing if there is no such element.
>>> next_smallest([1, 2, 3, 4, 5])
2
>>> next_smallest([5, 1, 4, 3, 2])
2
>>> next_smallest([])
nothing
>>> next_smallest([1, 1])
nothing"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = next_smallest;
	@test(candidate([1, 2, 3, 4, 5]) == 2)
	@test(candidate([5, 1, 4, 3, 2]) == 2)
	@test(candidate(Vector{Int64}([])) == nothing)
	@test(candidate([1, 1]) == nothing)
	@test(candidate([1, 1, 1, 1, 0]) == 1)
	@test(candidate([1, 1]) == nothing)
	@test(candidate([-35, 34, 12, -45]) == -35)
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""You are given a vector of integers.
Write a function next_smallest() that returns the 2nd smallest element of the vector.
Return nothing if there is no such element.
>>> next_smallest([1, 2, 3, 4, 5])
2
>>> next_smallest([5, 1, 4, 3, 2])
2
>>> next_smallest([])
nothing
>>> next_smallest([1, 1])
nothing"""
function next_smallest(lst::Vector{Int64})::Union{Int64, Nothing}
    # Return nothing if the vector is empty or has no distinct second smallest value
    if isempty(lst)
        return nothing
    end

    # Keep only unique values and sort them
    uniq_vals = sort(unique(lst))

    # If there are fewer than two distinct values, there is no second smallest
    if length(uniq_vals) < 2
        return nothing
    end

    # Return the second smallest distinct element
    return uniq_vals[2]
end
using Test

@testset begin

candidate = next_smallest;
	@test(candidate([1, 2, 3, 4, 5]) == 2)
	@test(candidate([5, 1, 4, 3, 2]) == 2)
	@test(candidate(Vector{Int64}([])) == nothing)
	@test(candidate([1, 1]) == nothing)
	@test(candidate([1, 1, 1, 1, 0]) == 1)
	@test(candidate([1, 1]) == nothing)
	@test(candidate([-35, 34, 12, -45]) == -35)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154678
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    7      7  0.1s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""You are given a vector of integers.
Write a function next_smallest() that returns the 2nd smallest element of the vector.
Return nothing if there is no such element.
>>> next_smallest([1, 2, 3, 4, 5])
2
>>> next_smallest([5, 1, 4, 3, 2])
2
>>> next_smallest([])
nothing
>>> next_smallest([1, 1])
nothing"""
function next_smallest(lst::Vector{Int64})::Union{Int64, Nothing}
    # If the list is empty there is no second smallest element
    if isempty(lst)
        return nothing
    end

    # Find the distinct values and sort them
    uniq_vals = sort(unique(lst))

    # If there is only one distinct value, we cannot have a second smallest
    if length(uniq_vals) < 2
        return nothing
    else
        # The second element in the sorted unique list is the 2nd smallest
        return uniq_vals[2]
    end
end
using Test

@testset begin

candidate = next_smallest;
	@test(candidate([1, 2, 3, 4, 5]) == 2)
	@test(candidate([5, 1, 4, 3, 2]) == 2)
	@test(candidate(Vector{Int64}([])) == nothing)
	@test(candidate([1, 1]) == nothing)
	@test(candidate([1, 1, 1, 1, 0]) == 1)
	@test(candidate([1, 1]) == nothing)
	@test(candidate([-35, 34, 12, -45]) == -35)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154678
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    7      7  0.1s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""You are given a vector of integers.
Write a function next_smallest() that returns the 2nd smallest element of the vector.
Return nothing if there is no such element.
>>> next_smallest([1, 2, 3, 4, 5])
2
>>> next_smallest([5, 1, 4, 3, 2])
2
>>> next_smallest([])
nothing
>>> next_smallest([1, 1])
nothing"""
function next_smallest(lst::Vector{Int64})::Union{Int64, Nothing}
    # Obtain the distinct values and sort them in ascending order
    uniq_sorted = sort(unique(lst))
    
    # If we have at least two distinct elements, return the second one
    if length(uniq_sorted) ≥ 2
        return uniq_sorted[2]
    else
        return nothing
    end
end
using Test

@testset begin

candidate = next_smallest;
	@test(candidate([1, 2, 3, 4, 5]) == 2)
	@test(candidate([5, 1, 4, 3, 2]) == 2)
	@test(candidate(Vector{Int64}([])) == nothing)
	@test(candidate([1, 1]) == nothing)
	@test(candidate([1, 1, 1, 1, 0]) == 1)
	@test(candidate([1, 1]) == nothing)
	@test(candidate([-35, 34, 12, -45]) == -35)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154678
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    7      7  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""You are given a vector of integers.
Write a function next_smallest() that returns the 2nd smallest element of the vector.
Return nothing if there is no such element.
>>> next_smallest([1, 2, 3, 4, 5])
2
>>> next_smallest([5, 1, 4, 3, 2])
2
>>> next_smallest([])
nothing
>>> next_smallest([1, 1])
nothing"""
function next_smallest(lst::Vector{Int64})::Union{Int64, Nothing}
    first = nothing
    second = nothing
    for x in lst
        if first === nothing || x < first
            second = first
            first = x
        elseif x != first && (second === nothing || x < second)
            second = x
        end
    end
    return second
end
using Test

@testset begin

candidate = next_smallest;
	@test(candidate([1, 2, 3, 4, 5]) == 2)
	@test(candidate([5, 1, 4, 3, 2]) == 2)
	@test(candidate(Vector{Int64}([])) == nothing)
	@test(candidate([1, 1]) == nothing)
	@test(candidate([1, 1, 1, 1, 0]) == 1)
	@test(candidate([1, 1]) == nothing)
	@test(candidate([-35, 34, 12, -45]) == -35)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154678
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    7      7  0.1s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 96 (JL) - HumanEval_96_count_up_to
================================================================================

PROMPT:
----------------------------------------
"""Implement a function that takes an non-negative integer and returns a vector of the first n
integers that are prime numbers and less than n.
for example:
>>> count_up_to(5)
[2, 3]
>>> count_up_to(11)
[2, 3, 5, 7]
>>> count_up_to(0)
[]
>>> count_up_to(20)
[2, 3, 5, 7, 11, 13, 17, 19]
>>> count_up_to(1)
[]
>>> count_up_to(18)
[2, 3, 5, 7, 11, 13, 17]"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = count_up_to;
	@test(candidate(5) == [2, 3])
	@test(candidate(6) == [2, 3, 5])
	@test(candidate(7) == [2, 3, 5])
	@test(candidate(10) == [2, 3, 5, 7])
	@test(candidate(0) == Vector{Int64}([]))
	@test(candidate(22) == [2, 3, 5, 7, 11, 13, 17, 19])
	@test(candidate(1) == Vector{Int64}([]))
	@test(candidate(18) == [2, 3, 5, 7, 11, 13, 17])
	@test(candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])
	@test(candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""Implement a function that takes an non-negative integer and returns a vector of the first n
integers that are prime numbers and less than n.
for example:
>>> count_up_to(5)
[2, 3]
>>> count_up_to(11)
[2, 3, 5, 7]
>>> count_up_to(0)
[]
>>> count_up_to(20)
[2, 3, 5, 7, 11, 13, 17, 19]
>>> count_up_to(1)
[]
>>> count_up_to(18)
[2, 3, 5, 7, 11, 13, 17]"""
function count_up_to(n::Int64)::Vector{Int64}
    # Return an empty vector if n is less than or equal to 2
    if n <= 2
        return Int64[]
    end

    primes = Int64[]
    for num in 2:(n - 1)
        is_prime = true
        # Only need to check divisors up to sqrt(num)
        limit = floor(Int, sqrt(num))
        for d in 2:limit
            if num % d == 0
                is_prime = false
                break
            end
        end
        if is_prime
            push!(primes, num)
        end
    end
    return primes
end
using Test

@testset begin

candidate = count_up_to;
	@test(candidate(5) == [2, 3])
	@test(candidate(6) == [2, 3, 5])
	@test(candidate(7) == [2, 3, 5])
	@test(candidate(10) == [2, 3, 5, 7])
	@test(candidate(0) == Vector{Int64}([]))
	@test(candidate(22) == [2, 3, 5, 7, 11, 13, 17, 19])
	@test(candidate(1) == Vector{Int64}([]))
	@test(candidate(18) == [2, 3, 5, 7, 11, 13, 17])
	@test(candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])
	@test(candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154705
STDOUT:
Test Summary: | Pass  Total  Time
test set      |   10     10  0.2s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""Implement a function that takes an non-negative integer and returns a vector of the first n
integers that are prime numbers and less than n.
for example:
>>> count_up_to(5)
[2, 3]
>>> count_up_to(11)
[2, 3, 5, 7]
>>> count_up_to(0)
[]
>>> count_up_to(20)
[2, 3, 5, 7, 11, 13, 17, 19]
>>> count_up_to(1)
[]
>>> count_up_to(18)
[2, 3, 5, 7, 11, 13, 17]"""
function count_up_to(n::Int64)::Vector{Int64}
    # Return all prime numbers strictly less than n
    if n <= 2
        return Int64[]
    end

    # Boolean array where index i corresponds to integer i
    is_prime = trues(n)          # indices 1 … n-1
    is_prime[1] = false          # 1 is not prime

    limit = floor(Int, sqrt(n - 1))
    for i in 2:limit
        if is_prime[i]
            # Mark multiples of i starting from i*i
            for j in i * i : i : n - 1
                is_prime[j] = false
            end
        end
    end

    primes = Int64[]
    for i in 2:n-1
        if is_prime[i]
            push!(primes, i)
        end
    end
    return primes
end
using Test

@testset begin

candidate = count_up_to;
	@test(candidate(5) == [2, 3])
	@test(candidate(6) == [2, 3, 5])
	@test(candidate(7) == [2, 3, 5])
	@test(candidate(10) == [2, 3, 5, 7])
	@test(candidate(0) == Vector{Int64}([]))
	@test(candidate(22) == [2, 3, 5, 7, 11, 13, 17, 19])
	@test(candidate(1) == Vector{Int64}([]))
	@test(candidate(18) == [2, 3, 5, 7, 11, 13, 17])
	@test(candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])
	@test(candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154705
STDOUT:
Test Summary: | Pass  Total  Time
test set      |   10     10  0.2s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""Implement a function that takes an non-negative integer and returns a vector of the first n
integers that are prime numbers and less than n.
for example:
>>> count_up_to(5)
[2, 3]
>>> count_up_to(11)
[2, 3, 5, 7]
>>> count_up_to(0)
[]
>>> count_up_to(20)
[2, 3, 5, 7, 11, 13, 17, 19]
>>> count_up_to(1)
[]
>>> count_up_to(18)
[2, 3, 5, 7, 11, 13, 17]"""
# Returns all prime numbers strictly less than `n`
function count_up_to(n::Int64)::Vector{Int64}
    # For n <= 2 there are no primes less than n
    if n <= 2
        return Int64[]
    end

    primes = Int64[]
    for i in 2:n-1
        is_prime = true
        limit = floor(Int, sqrt(i))
        for j in 2:limit
            if i % j == 0
                is_prime = false
                break
            end
        end
        if is_prime
            push!(primes, i)
        end
    end
    return primes
end
using Test

@testset begin

candidate = count_up_to;
	@test(candidate(5) == [2, 3])
	@test(candidate(6) == [2, 3, 5])
	@test(candidate(7) == [2, 3, 5])
	@test(candidate(10) == [2, 3, 5, 7])
	@test(candidate(0) == Vector{Int64}([]))
	@test(candidate(22) == [2, 3, 5, 7, 11, 13, 17, 19])
	@test(candidate(1) == Vector{Int64}([]))
	@test(candidate(18) == [2, 3, 5, 7, 11, 13, 17])
	@test(candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])
	@test(candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154705
STDOUT:
Test Summary: | Pass  Total  Time
test set      |   10     10  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""Implement a function that takes an non-negative integer and returns a vector of the first n
integers that are prime numbers and less than n.
for example:
>>> count_up_to(5)
[2, 3]
>>> count_up_to(11)
[2, 3, 5, 7]
>>> count_up_to(0)
[]
>>> count_up_to(20)
[2, 3, 5, 7, 11, 13, 17, 19]
>>> count_up_to(1)
[]
>>> count_up_to(18)
[2, 3, 5, 7, 11, 13, 17]"""
# count_up_to.jl
#
# Returns a vector containing all prime numbers that are strictly less than `n`.
# The function is written in pure Julia and uses a simple trial‑division
# algorithm (checking divisibility up to the square root of each candidate).
# The result is a `Vector{Int64}` as required by the signature.

function count_up_to(n::Int64)::Vector{Int64}
    # Handle the trivial cases first
    if n <= 2
        return Int64[]
    end

    primes = Int64[]
    for candidate in 2:n-1
        # Assume candidate is prime until a divisor is found
        is_prime = true
        limit = floor(Int, sqrt(candidate))
        for d in 2:limit
            if candidate % d == 0
                is_prime = false
                break
            end
        end
        if is_prime
            push!(primes, candidate)
        end
    end
    return primes
end
using Test

@testset begin

candidate = count_up_to;
	@test(candidate(5) == [2, 3])
	@test(candidate(6) == [2, 3, 5])
	@test(candidate(7) == [2, 3, 5])
	@test(candidate(10) == [2, 3, 5, 7])
	@test(candidate(0) == Vector{Int64}([]))
	@test(candidate(22) == [2, 3, 5, 7, 11, 13, 17, 19])
	@test(candidate(1) == Vector{Int64}([]))
	@test(candidate(18) == [2, 3, 5, 7, 11, 13, 17])
	@test(candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])
	@test(candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154705
STDOUT:
Test Summary: | Pass  Total  Time
test set      |   10     10  0.2s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 97 (JL) - HumanEval_97_multiply
================================================================================

PROMPT:
----------------------------------------
"""Complete the function that takes two integers and returns 
the product of their unit digits.
Assume the input is always valid.
Examples:
>>> multiply(148, 412)
16
>>> multiply(19, 28)
72
>>> multiply(2020, 1851)
0
>>> multiply(14, -15)
20"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = multiply;
	@test(candidate(148, 412) == 16)
	@test(candidate(19, 28) == 72)
	@test(candidate(2020, 1851) == 0)
	@test(candidate(14, -15) == 20)
	@test(candidate(76, 67) == 42)
	@test(candidate(17, 27) == 49)
	@test(candidate(0, 1) == 0)
	@test(candidate(0, 0) == 0)
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""Complete the function that takes two integers and returns 
the product of their unit digits.
Assume the input is always valid.
Examples:
>>> multiply(148, 412)
16
>>> multiply(19, 28)
72
>>> multiply(2020, 1851)
0
>>> multiply(14, -15)
20"""
function multiply(a::Int64, b::Int64)::Int64
    # Extract the unit (ones) digit of each number, ignoring sign
    digit_a = abs(a) % 10
    digit_b = abs(b) % 10
    # Return the product of these two digits
    return digit_a * digit_b
end
using Test

@testset begin

candidate = multiply;
	@test(candidate(148, 412) == 16)
	@test(candidate(19, 28) == 72)
	@test(candidate(2020, 1851) == 0)
	@test(candidate(14, -15) == 20)
	@test(candidate(76, 67) == 42)
	@test(candidate(17, 27) == 49)
	@test(candidate(0, 1) == 0)
	@test(candidate(0, 0) == 0)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154706
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.1s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""Complete the function that takes two integers and returns 
the product of their unit digits.
Assume the input is always valid.
Examples:
>>> multiply(148, 412)
16
>>> multiply(19, 28)
72
>>> multiply(2020, 1851)
0
>>> multiply(14, -15)
20"""
function multiply(a::Int64, b::Int64)::Int64
    # Extract the unit digits of both numbers (ignoring sign)
    da = abs(a) % 10
    db = abs(b) % 10
    # Return their product
    return da * db
end
using Test

@testset begin

candidate = multiply;
	@test(candidate(148, 412) == 16)
	@test(candidate(19, 28) == 72)
	@test(candidate(2020, 1851) == 0)
	@test(candidate(14, -15) == 20)
	@test(candidate(76, 67) == 42)
	@test(candidate(17, 27) == 49)
	@test(candidate(0, 1) == 0)
	@test(candidate(0, 0) == 0)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154706
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.1s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""Complete the function that takes two integers and returns 
the product of their unit digits.
Assume the input is always valid.
Examples:
>>> multiply(148, 412)
16
>>> multiply(19, 28)
72
>>> multiply(2020, 1851)
0
>>> multiply(14, -15)
20"""
function multiply(a::Int64, b::Int64)::Int64
    # Extract the unit digits (absolute value to ignore sign) and multiply them
    return (abs(a) % 10) * (abs(b) % 10)
end
using Test

@testset begin

candidate = multiply;
	@test(candidate(148, 412) == 16)
	@test(candidate(19, 28) == 72)
	@test(candidate(2020, 1851) == 0)
	@test(candidate(14, -15) == 20)
	@test(candidate(76, 67) == 42)
	@test(candidate(17, 27) == 49)
	@test(candidate(0, 1) == 0)
	@test(candidate(0, 0) == 0)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154706
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""Complete the function that takes two integers and returns 
the product of their unit digits.
Assume the input is always valid.
Examples:
>>> multiply(148, 412)
16
>>> multiply(19, 28)
72
>>> multiply(2020, 1851)
0
>>> multiply(14, -15)
20"""
function multiply(a::Int64, b::Int64)::Int64
    # Extract the unit digits (ignoring the sign)
    unit_a = abs(a) % 10
    unit_b = abs(b) % 10
    # Return their product
    return unit_a * unit_b
end
using Test

@testset begin

candidate = multiply;
	@test(candidate(148, 412) == 16)
	@test(candidate(19, 28) == 72)
	@test(candidate(2020, 1851) == 0)
	@test(candidate(14, -15) == 20)
	@test(candidate(76, 67) == 42)
	@test(candidate(17, 27) == 49)
	@test(candidate(0, 1) == 0)
	@test(candidate(0, 0) == 0)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154706
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.1s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 100 (JL) - HumanEval_100_make_a_pile
================================================================================

PROMPT:
----------------------------------------
"""Given a positive integer n, you have to make a pile of n levels of stones.
The first level has n stones.
The number of stones in the next level is:
    - the next odd number if n is odd.
    - the next even number if n is even.
Return the number of stones in each level in a vector, where element at index
i represents the number of stones in the level (i+1).
Examples:
>>> make_a_pile(3)
[3, 5, 7]"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = make_a_pile;
	@test(candidate(3) == [3, 5, 7])
	@test(candidate(4) == [4, 6, 8, 10])
	@test(candidate(5) == [5, 7, 9, 11, 13])
	@test(candidate(6) == [6, 8, 10, 12, 14, 16])
	@test(candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22])
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""Given a positive integer n, you have to make a pile of n levels of stones.
The first level has n stones.
The number of stones in the next level is:
    - the next odd number if n is odd.
    - the next even number if n is even.
Return the number of stones in each level in a vector, where element at index
i represents the number of stones in the level (i+1).
Examples:
>>> make_a_pile(3)
[3, 5, 7]"""
function make_a_pile(n::Int64)::Vector{Int64}
    # Create a vector of the required length
    pile = Vector{Int64}(undef, n)
    pile[1] = n                         # first level

    # Each subsequent level is the next odd (if n is odd) or even (if n is even) number.
    # Since we always add 2, the parity stays the same.
    for i in 2:n
        pile[i] = pile[i-1] + 2
    end

    return pile
end
using Test

@testset begin

candidate = make_a_pile;
	@test(candidate(3) == [3, 5, 7])
	@test(candidate(4) == [4, 6, 8, 10])
	@test(candidate(5) == [5, 7, 9, 11, 13])
	@test(candidate(6) == [6, 8, 10, 12, 14, 16])
	@test(candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154717
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    5      5  0.1s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""Given a positive integer n, you have to make a pile of n levels of stones.
The first level has n stones.
The number of stones in the next level is:
    - the next odd number if n is odd.
    - the next even number if n is even.
Return the number of stones in each level in a vector, where element at index
i represents the number of stones in the level (i+1).
Examples:
>>> make_a_pile(3)
[3, 5, 7]"""
function make_a_pile(n::Int64)::Vector{Int64}
    # Create a vector of length n where each element increases by 2
    return [n + 2*i for i in 0:n-1]
end
using Test

@testset begin

candidate = make_a_pile;
	@test(candidate(3) == [3, 5, 7])
	@test(candidate(4) == [4, 6, 8, 10])
	@test(candidate(5) == [5, 7, 9, 11, 13])
	@test(candidate(6) == [6, 8, 10, 12, 14, 16])
	@test(candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154717
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    5      5  0.1s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""Given a positive integer n, you have to make a pile of n levels of stones.
The first level has n stones.
The number of stones in the next level is:
    - the next odd number if n is odd.
    - the next even number if n is even.
Return the number of stones in each level in a vector, where element at index
i represents the number of stones in the level (i+1).
Examples:
>>> make_a_pile(3)
[3, 5, 7]"""
function make_a_pile(n::Int64)::Vector{Int64}
    @assert n > 0 "n must be a positive integer"
    # The sequence starts at n and each subsequent level increases by 2
    return [n + 2 * (i - 1) for i in 1:n]
end
using Test

@testset begin

candidate = make_a_pile;
	@test(candidate(3) == [3, 5, 7])
	@test(candidate(4) == [4, 6, 8, 10])
	@test(candidate(5) == [5, 7, 9, 11, 13])
	@test(candidate(6) == [6, 8, 10, 12, 14, 16])
	@test(candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154717
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    5      5  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""Given a positive integer n, you have to make a pile of n levels of stones.
The first level has n stones.
The number of stones in the next level is:
    - the next odd number if n is odd.
    - the next even number if n is even.
Return the number of stones in each level in a vector, where element at index
i represents the number of stones in the level (i+1).
Examples:
>>> make_a_pile(3)
[3, 5, 7]"""
function make_a_pile(n::Int64)::Vector{Int64}
    # Allocate a vector of the required size
    pile = Vector{Int64}(undef, n)

    # Each subsequent level increases by 2 (next odd or next even)
    for i in 1:n
        pile[i] = n + 2 * (i - 1)
    end

    return pile
end
using Test

@testset begin

candidate = make_a_pile;
	@test(candidate(3) == [3, 5, 7])
	@test(candidate(4) == [4, 6, 8, 10])
	@test(candidate(5) == [5, 7, 9, 11, 13])
	@test(candidate(6) == [6, 8, 10, 12, 14, 16])
	@test(candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154717
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    5      5  0.1s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 102 (JL) - HumanEval_102_choose_num
================================================================================

PROMPT:
----------------------------------------
"""This function takes two positive numbers x and y and returns the
biggest even integer number that is in the range [x, y] inclusive. If 
there's no such number, then the function should return -1.
For example:
>>> choose_num(12, 15)
14
>>> choose_num(13, 12)
-1"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = choose_num;
	@test(candidate(12, 15) == 14)
	@test(candidate(13, 12) == -1)
	@test(candidate(33, 12354) == 12354)
	@test(candidate(5234, 5233) == -1)
	@test(candidate(6, 29) == 28)
	@test(candidate(27, 10) == -1)
	@test(candidate(7, 7) == -1)
	@test(candidate(546, 546) == 546)
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""This function takes two positive numbers x and y and returns the
biggest even integer number that is in the range [x, y] inclusive. If 
there's no such number, then the function should return -1.
For example:
>>> choose_num(12, 15)
14
>>> choose_num(13, 12)
-1"""
function choose_num(x::Int64, y::Int64)::Int64
    # If the lower bound is greater than the upper bound, no range exists.
    if x > y
        return -1
    end

    # The largest even number not exceeding y is either y itself
    # (if y is even) or y-1 (if y is odd).
    candidate = y - (y % 2)

    # If that candidate lies within the range, return it.
    # Otherwise, no even integer exists in [x, y].
    if candidate >= x
        return candidate
    else
        return -1
    end
end
using Test

@testset begin

candidate = choose_num;
	@test(candidate(12, 15) == 14)
	@test(candidate(13, 12) == -1)
	@test(candidate(33, 12354) == 12354)
	@test(candidate(5234, 5233) == -1)
	@test(candidate(6, 29) == 28)
	@test(candidate(27, 10) == -1)
	@test(candidate(7, 7) == -1)
	@test(candidate(546, 546) == 546)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154722
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.1s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""This function takes two positive numbers x and y and returns the
biggest even integer number that is in the range [x, y] inclusive. If 
there's no such number, then the function should return -1.
For example:
>>> choose_num(12, 15)
14
>>> choose_num(13, 12)
-1"""
# Returns the largest even integer in the inclusive range [x, y].
# If no such integer exists (or x > y), returns -1.
function choose_num(x::Int64, y::Int64)::Int64
    # Ensure the range is valid
    if x > y
        return -1
    end

    # Compute the largest even number <= y
    max_even = y - (y % 2)   # y if even, y-1 if odd

    # Check if that even number is within the range
    return max_even >= x ? max_even : -1
end
using Test

@testset begin

candidate = choose_num;
	@test(candidate(12, 15) == 14)
	@test(candidate(13, 12) == -1)
	@test(candidate(33, 12354) == 12354)
	@test(candidate(5234, 5233) == -1)
	@test(candidate(6, 29) == 28)
	@test(candidate(27, 10) == -1)
	@test(candidate(7, 7) == -1)
	@test(candidate(546, 546) == 546)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154722
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.1s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""This function takes two positive numbers x and y and returns the
biggest even integer number that is in the range [x, y] inclusive. If 
there's no such number, then the function should return -1.
For example:
>>> choose_num(12, 15)
14
>>> choose_num(13, 12)
-1"""
function choose_num(x::Int64, y::Int64)::Int64
    # If the interval is invalid, immediately return -1
    if x > y
        return -1
    end

    # Find the largest even number not exceeding `y`
    max_even = y - mod(y, 2)

    # Check if this even number lies within the interval [x, y]
    return max_even >= x ? max_even : -1
end
using Test

@testset begin

candidate = choose_num;
	@test(candidate(12, 15) == 14)
	@test(candidate(13, 12) == -1)
	@test(candidate(33, 12354) == 12354)
	@test(candidate(5234, 5233) == -1)
	@test(candidate(6, 29) == 28)
	@test(candidate(27, 10) == -1)
	@test(candidate(7, 7) == -1)
	@test(candidate(546, 546) == 546)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154722
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""This function takes two positive numbers x and y and returns the
biggest even integer number that is in the range [x, y] inclusive. If 
there's no such number, then the function should return -1.
For example:
>>> choose_num(12, 15)
14
>>> choose_num(13, 12)
-1"""
function choose_num(x::Int64, y::Int64)::Int64
    # If the range is invalid, return -1
    if x > y
        return -1
    end

    # Find the largest even number that is ≤ y
    largest_even = iseven(y) ? y : y - 1

    # Return it if it lies within [x, y], otherwise return -1
    return largest_even >= x ? largest_even : -1
end
using Test

@testset begin

candidate = choose_num;
	@test(candidate(12, 15) == 14)
	@test(candidate(13, 12) == -1)
	@test(candidate(33, 12354) == 12354)
	@test(candidate(5234, 5233) == -1)
	@test(candidate(6, 29) == 28)
	@test(candidate(27, 10) == -1)
	@test(candidate(7, 7) == -1)
	@test(candidate(546, 546) == 546)
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154722
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.1s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 104 (JL) - HumanEval_104_unique_digits
================================================================================

PROMPT:
----------------------------------------
"""Given a vector of positive integers x. return a sorted vector of all 
elements that hasn't any even digit.
Note: Returned vector should be sorted in increasing order.
For example:
>>> unique_digits([15, 33, 1422, 1])
[1, 15, 33]
>>> unique_digits([152, 323, 1422, 10])
[]"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = unique_digits;
	@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])
	@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))
	@test(candidate([12345, 2033, 111, 151]) == [111, 151])
	@test(candidate([135, 103, 31]) == [31, 135])
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""Given a vector of positive integers x. return a sorted vector of all 
elements that hasn't any even digit.
Note: Returned vector should be sorted in increasing order.
For example:
>>> unique_digits([15, 33, 1422, 1])
[1, 15, 33]
>>> unique_digits([152, 323, 1422, 10])
[]"""
function unique_digits(x::Vector{Int64})::Vector{Int64}
    # Keep only numbers whose every decimal digit is odd (1,3,5,7,9)
    filtered = filter(n -> all(isodd, digits(n)), x)
    # Return the sorted result
    return sort(filtered)
end
using Test

@testset begin

candidate = unique_digits;
	@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])
	@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))
	@test(candidate([12345, 2033, 111, 151]) == [111, 151])
	@test(candidate([135, 103, 31]) == [31, 135])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154727
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    4      4  0.2s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""Given a vector of positive integers x. return a sorted vector of all 
elements that hasn't any even digit.
Note: Returned vector should be sorted in increasing order.
For example:
>>> unique_digits([15, 33, 1422, 1])
[1, 15, 33]
>>> unique_digits([152, 323, 1422, 10])
[]"""
# Returns a sorted vector of all elements from `x` that contain **no even digits**.
# A digit is considered even if it is 0, 2, 4, 6, or 8.
#
# Example:
#   unique_digits([15, 33, 1422, 1])  # → [1, 15, 33]
#   unique_digits([152, 323, 1422, 10])  # → []
#
function unique_digits(x::Vector{Int64})::Vector{Int64}
    # Helper: check if a single integer has only odd digits
    function all_odd_digits(n::Int64)::Bool
        # Handle the special case n == 0 (though input is positive, just in case)
        if n == 0
            return false
        end
        while n > 0
            d = n % 10
            if d % 2 == 0          # even digit found
                return false
            end
            n ÷= 10
        end
        return true
    end

    # Filter numbers that satisfy the condition
    filtered = filter(all_odd_digits, x)

    # Return sorted result
    return sort(filtered)
end
using Test

@testset begin

candidate = unique_digits;
	@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])
	@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))
	@test(candidate([12345, 2033, 111, 151]) == [111, 151])
	@test(candidate([135, 103, 31]) == [31, 135])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154727
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    4      4  0.2s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""Given a vector of positive integers x. return a sorted vector of all 
elements that hasn't any even digit.
Note: Returned vector should be sorted in increasing order.
For example:
>>> unique_digits([15, 33, 1422, 1])
[1, 15, 33]
>>> unique_digits([152, 323, 1422, 10])
[]"""
function unique_digits(x::Vector{Int64})::Vector{Int64}
    res = Int64[]
    for n in x
        # digits(n) returns the decimal digits of n (in reverse order)
        if all(isodd, digits(n))
            push!(res, n)
        end
    end
    sort!(res)          # sort the result in increasing order
    return res
end
using Test

@testset begin

candidate = unique_digits;
	@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])
	@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))
	@test(candidate([12345, 2033, 111, 151]) == [111, 151])
	@test(candidate([135, 103, 31]) == [31, 135])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154727
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    4      4  0.2s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""Given a vector of positive integers x. return a sorted vector of all 
elements that hasn't any even digit.
Note: Returned vector should be sorted in increasing order.
For example:
>>> unique_digits([15, 33, 1422, 1])
[1, 15, 33]
>>> unique_digits([152, 323, 1422, 10])
[]"""
function unique_digits(x::Vector{Int64})::Vector{Int64}
    # Keep only numbers whose every digit is odd
    filtered = filter(n -> all(d -> d % 2 == 1, digits(n)), x)
    # Return the sorted result
    return sort(filtered)
end
using Test

@testset begin

candidate = unique_digits;
	@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])
	@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))
	@test(candidate([12345, 2033, 111, 151]) == [111, 151])
	@test(candidate([135, 103, 31]) == [31, 135])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154727
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    4      4  0.2s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 106 (JL) - HumanEval_106_f
================================================================================

PROMPT:
----------------------------------------
""" Implement the function f that takes n as a parameter,
and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even
or the sum of numbers from 1 to i otherwise.
i starts from 1.
the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
Example:
>>> f(5)
[1, 2, 6, 24, 15]"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = f;
	@test(candidate(5) == [1, 2, 6, 24, 15])
	@test(candidate(7) == [1, 2, 6, 24, 15, 720, 28])
	@test(candidate(1) == [1])
	@test(candidate(3) == [1, 2, 6])
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
""" Implement the function f that takes n as a parameter,
and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even
or the sum of numbers from 1 to i otherwise.
i starts from 1.
the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
Example:
>>> f(5)
[1, 2, 6, 24, 15]"""
function f(n::Int64)::Vector{Int64}
    result = Vector{Int64}(undef, n)
    for i in 1:n
        if iseven(i)
            # compute factorial iteratively to avoid recursion overhead
            fact = 1
            for k in 1:i
                fact *= k
            end
            result[i] = fact
        else
            # sum from 1 to i
            result[i] = i * (i + 1) ÷ 2
        end
    end
    return result
end
using Test

@testset begin

candidate = f;
	@test(candidate(5) == [1, 2, 6, 24, 15])
	@test(candidate(7) == [1, 2, 6, 24, 15, 720, 28])
	@test(candidate(1) == [1])
	@test(candidate(3) == [1, 2, 6])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154733
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    4      4  0.1s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
""" Implement the function f that takes n as a parameter,
and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even
or the sum of numbers from 1 to i otherwise.
i starts from 1.
the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
Example:
>>> f(5)
[1, 2, 6, 24, 15]"""
function f(n::Int64)::Vector{Int64}
    # Allocate the result vector once for efficiency
    result = Vector{Int64}(undef, n)

    for i in 1:n
        if iseven(i)
            # Even index → factorial of i
            result[i] = factorial(i)      # Base factorial returns Int64 for small i
        else
            # Odd index → sum of numbers from 1 to i
            result[i] = i * (i + 1) ÷ 2   # Arithmetic series formula
        end
    end

    return result
end
using Test

@testset begin

candidate = f;
	@test(candidate(5) == [1, 2, 6, 24, 15])
	@test(candidate(7) == [1, 2, 6, 24, 15, 720, 28])
	@test(candidate(1) == [1])
	@test(candidate(3) == [1, 2, 6])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154733
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    4      4  0.1s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
""" Implement the function f that takes n as a parameter,
and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even
or the sum of numbers from 1 to i otherwise.
i starts from 1.
the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
Example:
>>> f(5)
[1, 2, 6, 24, 15]"""
function f(n::Int64)::Vector{Int64}
    # Return an empty vector if n is zero or negative
    if n <= 0
        return Int64[]
    end

    result = Vector{Int64}(undef, n)

    for i in 1:n
        if iseven(i)
            # factorial of i
            result[i] = factorial(i)
        else
            # sum of numbers from 1 to i
            result[i] = i * (i + 1) ÷ 2
        end
    end

    return result
end
using Test

@testset begin

candidate = f;
	@test(candidate(5) == [1, 2, 6, 24, 15])
	@test(candidate(7) == [1, 2, 6, 24, 15, 720, 28])
	@test(candidate(1) == [1])
	@test(candidate(3) == [1, 2, 6])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154733
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    4      4  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
""" Implement the function f that takes n as a parameter,
and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even
or the sum of numbers from 1 to i otherwise.
i starts from 1.
the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
Example:
>>> f(5)
[1, 2, 6, 24, 15]"""
function f(n::Int64)::Vector{Int64}
    # Preallocate the result vector
    result = Vector{Int64}(undef, n)

    for i in 1:n
        if iseven(i)
            # Even index – factorial of i
            result[i] = factorial(i)
        else
            # Odd index – sum from 1 to i
            result[i] = i * (i + 1) ÷ 2
        end
    end

    return result
end
using Test

@testset begin

candidate = f;
	@test(candidate(5) == [1, 2, 6, 24, 15])
	@test(candidate(7) == [1, 2, 6, 24, 15, 720, 28])
	@test(candidate(1) == [1])
	@test(candidate(3) == [1, 2, 6])
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154733
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    4      4  0.1s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 110 (JL) - HumanEval_110_exchange
================================================================================

PROMPT:
----------------------------------------
"""In this problem, you will implement a function that takes two vectors of numbers,
and determines whether it is possible to perform an exchange of elements
between them to make lst1 a vector of only even numbers.
There is no limit on the number of exchanged elements between lst1 and lst2.
If it is possible to exchange elements between the lst1 and lst2 to make
all the elements of lst1 to be even, return "YES".
Otherwise, return "NO".
For example:
>>> exchange([1, 2, 3, 4], [1, 2, 3, 4])
"YES"
>>> exchange([1, 2, 3, 4], [1, 5, 3, 4])
"NO"
It is assumed that the input vectors will be non-empty."""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = exchange;
	@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == "YES")
	@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == "NO")
	@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == "YES")
	@test(candidate([5, 7, 3], [2, 6, 4]) == "YES")
	@test(candidate([5, 7, 3], [2, 6, 3]) == "NO")
	@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == "NO")
	@test(candidate([100, 200], [200, 200]) == "YES")
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""In this problem, you will implement a function that takes two vectors of numbers,
and determines whether it is possible to perform an exchange of elements
between them to make lst1 a vector of only even numbers.
There is no limit on the number of exchanged elements between lst1 and lst2.
If it is possible to exchange elements between the lst1 and lst2 to make
all the elements of lst1 to be even, return "YES".
Otherwise, return "NO".
For example:
>>> exchange([1, 2, 3, 4], [1, 2, 3, 4])
"YES"
>>> exchange([1, 2, 3, 4], [1, 5, 3, 4])
"NO"
It is assumed that the input vectors will be non-empty."""
function exchange(lst1::Vector{Int64}, lst2::Vector{Int64})::String
    # Count how many odd numbers are in lst1
    odd_cnt = count(isodd, lst1)
    # Count how many even numbers are in lst2
    even_cnt = count(iseven, lst2)

    # We can replace each odd in lst1 with an even from lst2
    return odd_cnt <= even_cnt ? "YES" : "NO"
end
using Test

@testset begin

candidate = exchange;
	@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == "YES")
	@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == "NO")
	@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == "YES")
	@test(candidate([5, 7, 3], [2, 6, 4]) == "YES")
	@test(candidate([5, 7, 3], [2, 6, 3]) == "NO")
	@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == "NO")
	@test(candidate([100, 200], [200, 200]) == "YES")
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154747
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    7      7  0.1s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""In this problem, you will implement a function that takes two vectors of numbers,
and determines whether it is possible to perform an exchange of elements
between them to make lst1 a vector of only even numbers.
There is no limit on the number of exchanged elements between lst1 and lst2.
If it is possible to exchange elements between the lst1 and lst2 to make
all the elements of lst1 to be even, return "YES".
Otherwise, return "NO".
For example:
>>> exchange([1, 2, 3, 4], [1, 2, 3, 4])
"YES"
>>> exchange([1, 2, 3, 4], [1, 5, 3, 4])
"NO"
It is assumed that the input vectors will be non-empty."""
function exchange(lst1::Vector{Int64}, lst2::Vector{Int64})::String
    # Count even numbers in both lists
    total_even = count(x -> x % 2 == 0, lst1) + count(x -> x % 2 == 0, lst2)
    # We need at least `length(lst1)` evens to fill lst1 entirely with even numbers
    return total_even >= length(lst1) ? "YES" : "NO"
end
using Test

@testset begin

candidate = exchange;
	@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == "YES")
	@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == "NO")
	@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == "YES")
	@test(candidate([5, 7, 3], [2, 6, 4]) == "YES")
	@test(candidate([5, 7, 3], [2, 6, 3]) == "NO")
	@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == "NO")
	@test(candidate([100, 200], [200, 200]) == "YES")
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154747
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    7      7  0.1s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""In this problem, you will implement a function that takes two vectors of numbers,
and determines whether it is possible to perform an exchange of elements
between them to make lst1 a vector of only even numbers.
There is no limit on the number of exchanged elements between lst1 and lst2.
If it is possible to exchange elements between the lst1 and lst2 to make
all the elements of lst1 to be even, return "YES".
Otherwise, return "NO".
For example:
>>> exchange([1, 2, 3, 4], [1, 2, 3, 4])
"YES"
>>> exchange([1, 2, 3, 4], [1, 5, 3, 4])
"NO"
It is assumed that the input vectors will be non-empty."""
function exchange(lst1::Vector{Int64}, lst2::Vector{Int64})::String
    # Count how many odd numbers are in lst1
    odds_in_lst1 = count(x -> isodd(x), lst1)

    # Count how many even numbers are in lst2
    evens_in_lst2 = count(x -> iseven(x), lst2)

    # We can replace every odd element in lst1 with an even element from lst2
    return evens_in_lst2 >= odds_in_lst1 ? "YES" : "NO"
end
using Test

@testset begin

candidate = exchange;
	@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == "YES")
	@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == "NO")
	@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == "YES")
	@test(candidate([5, 7, 3], [2, 6, 4]) == "YES")
	@test(candidate([5, 7, 3], [2, 6, 3]) == "NO")
	@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == "NO")
	@test(candidate([100, 200], [200, 200]) == "YES")
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154747
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    7      7  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""In this problem, you will implement a function that takes two vectors of numbers,
and determines whether it is possible to perform an exchange of elements
between them to make lst1 a vector of only even numbers.
There is no limit on the number of exchanged elements between lst1 and lst2.
If it is possible to exchange elements between the lst1 and lst2 to make
all the elements of lst1 to be even, return "YES".
Otherwise, return "NO".
For example:
>>> exchange([1, 2, 3, 4], [1, 2, 3, 4])
"YES"
>>> exchange([1, 2, 3, 4], [1, 5, 3, 4])
"NO"
It is assumed that the input vectors will be non-empty."""
# ------------------------------------------------------------
# Determines whether lst1 can be made all even by exchanging
# elements with lst2.  Returns "YES" or "NO".
# ------------------------------------------------------------
function exchange(lst1::Vector{Int64}, lst2::Vector{Int64})::String
    # Count evens in both lists
    evens1 = count(iseven, lst1)
    evens2 = count(iseven, lst2)

    # Total evens must cover all positions of lst1
    if evens1 + evens2 >= length(lst1)
        return "YES"
    else
        return "NO"
    end
end
using Test

@testset begin

candidate = exchange;
	@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == "YES")
	@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == "NO")
	@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == "YES")
	@test(candidate([5, 7, 3], [2, 6, 4]) == "YES")
	@test(candidate([5, 7, 3], [2, 6, 3]) == "NO")
	@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == "NO")
	@test(candidate([100, 200], [200, 200]) == "YES")
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154747
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    7      7  0.1s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 111 (JL) - HumanEval_111_histogram
================================================================================

PROMPT:
----------------------------------------
"""Given a string representing a space separated lowercase letters, return a dictionary
of the letter with the most repetition and containing the corresponding count.
If several letters have the same occurrence, return all of them.
Example:
>>> histogram("a b c")
Dict("a" => 1, "b" => 1, "c" => 1)
>>> histogram("a b b a")
Dict("a" => 2, "b" => 2)
>>> histogram("a b c a b")
Dict("a" => 2, "b" => 2)
>>> histogram("b b b b a")
Dict("b" => 4)
>>> histogram("")
Dict()"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = histogram;
	@test(candidate("a b b a") == Dict("a" => 2, "b" => 2))
	@test(candidate("a b c a b") == Dict("a" => 2, "b" => 2))
	@test(candidate("a b c d g") == Dict("a" => 1, "b" => 1, "c" => 1, "d" => 1, "g" => 1))
	@test(candidate("r t g") == Dict("r" => 1, "t" => 1, "g" => 1))
	@test(candidate("b b b b a") == Dict("b" => 4))
	@test(candidate("r t g") == Dict("r" => 1, "t" => 1, "g" => 1))
	@test(candidate("") == Dict())
	@test(candidate("a") == Dict("a" => 1))
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""Given a string representing a space separated lowercase letters, return a dictionary
of the letter with the most repetition and containing the corresponding count.
If several letters have the same occurrence, return all of them.
Example:
>>> histogram("a b c")
Dict("a" => 1, "b" => 1, "c" => 1)
>>> histogram("a b b a")
Dict("a" => 2, "b" => 2)
>>> histogram("a b c a b")
Dict("a" => 2, "b" => 2)
>>> histogram("b b b b a")
Dict("b" => 4)
>>> histogram("")
Dict()"""
function histogram(test::String)::Dict{String, Int64}
    # Split the string on whitespace to get the individual letters
    letters = split(test)

    # If the input is empty, return an empty dictionary
    if isempty(letters)
        return Dict{String, Int64}()
    end

    # Count occurrences of each letter
    freq = Dict{String, Int64}()
    for l in letters
        freq[l] = get(freq, l, 0) + 1
    end

    # Determine the maximum count
    maxcnt = maximum(values(freq))

    # Build the result dictionary containing only the most frequent letters
    result = Dict{String, Int64}()
    for (k, v) in freq
        if v == maxcnt
            result[k] = v
        end
    end

    return result
end
using Test

@testset begin

candidate = histogram;
	@test(candidate("a b b a") == Dict("a" => 2, "b" => 2))
	@test(candidate("a b c a b") == Dict("a" => 2, "b" => 2))
	@test(candidate("a b c d g") == Dict("a" => 1, "b" => 1, "c" => 1, "d" => 1, "g" => 1))
	@test(candidate("r t g") == Dict("r" => 1, "t" => 1, "g" => 1))
	@test(candidate("b b b b a") == Dict("b" => 4))
	@test(candidate("r t g") == Dict("r" => 1, "t" => 1, "g" => 1))
	@test(candidate("") == Dict())
	@test(candidate("a") == Dict("a" => 1))
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154748
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.4s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""Given a string representing a space separated lowercase letters, return a dictionary
of the letter with the most repetition and containing the corresponding count.
If several letters have the same occurrence, return all of them.
Example:
>>> histogram("a b c")
Dict("a" => 1, "b" => 1, "c" => 1)
>>> histogram("a b b a")
Dict("a" => 2, "b" => 2)
>>> histogram("a b c a b")
Dict("a" => 2, "b" => 2)
>>> histogram("b b b b a")
Dict("b" => 4)
>>> histogram("")
Dict()"""
function histogram(test::String)::Dict{String, Int64}
    # Split the input on whitespace; handles multiple spaces and leading/trailing spaces
    letters = split(test)
    
    # If there are no letters, return an empty dictionary
    if isempty(letters)
        return Dict{String, Int64}()
    end
    
    # Count the occurrences of each letter
    freq = Dict{String, Int64}()
    for l in letters
        freq[l] = get(freq, l, 0) + 1
    end
    
    # Find the maximum count
    maxcount = maximum(values(freq))
    
    # Build the result dictionary containing only the letters with the maximum count
    result = Dict{String, Int64}()
    for (k, v) in freq
        if v == maxcount
            result[k] = v
        end
    end
    
    return result
end
using Test

@testset begin

candidate = histogram;
	@test(candidate("a b b a") == Dict("a" => 2, "b" => 2))
	@test(candidate("a b c a b") == Dict("a" => 2, "b" => 2))
	@test(candidate("a b c d g") == Dict("a" => 1, "b" => 1, "c" => 1, "d" => 1, "g" => 1))
	@test(candidate("r t g") == Dict("r" => 1, "t" => 1, "g" => 1))
	@test(candidate("b b b b a") == Dict("b" => 4))
	@test(candidate("r t g") == Dict("r" => 1, "t" => 1, "g" => 1))
	@test(candidate("") == Dict())
	@test(candidate("a") == Dict("a" => 1))
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154748
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.4s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""Given a string representing a space separated lowercase letters, return a dictionary
of the letter with the most repetition and containing the corresponding count.
If several letters have the same occurrence, return all of them.
Example:
>>> histogram("a b c")
Dict("a" => 1, "b" => 1, "c" => 1)
>>> histogram("a b b a")
Dict("a" => 2, "b" => 2)
>>> histogram("a b c a b")
Dict("a" => 2, "b" => 2)
>>> histogram("b b b b a")
Dict("b" => 4)
>>> histogram("")
Dict()"""
# Histogram of most frequent letters in a space‑separated string
# Returns a dictionary mapping each letter that has the highest count
# to that count.  If the input string is empty or contains only spaces,
# an empty dictionary is returned.

function histogram(test::String)::Dict{String, Int64}
    # Split the string on whitespace – this automatically discards
    # any leading/trailing/multiple spaces.
    words = split(test)

    # If there are no words, return an empty dictionary.
    if isempty(words)
        return Dict{String, Int64}()
    end

    # Count occurrences of each word.
    counts = Dict{String, Int64}()
    for w in words
        counts[w] = get(counts, w, 0) + 1
    end

    # Find the maximum count.
    maxcount = maximum(values(counts))

    # Build the result dictionary containing only the words
    # that have the maximum count.
    result = Dict{String, Int64}()
    for (k, v) in counts
        if v == maxcount
            result[k] = v
        end
    end

    return result
end
using Test

@testset begin

candidate = histogram;
	@test(candidate("a b b a") == Dict("a" => 2, "b" => 2))
	@test(candidate("a b c a b") == Dict("a" => 2, "b" => 2))
	@test(candidate("a b c d g") == Dict("a" => 1, "b" => 1, "c" => 1, "d" => 1, "g" => 1))
	@test(candidate("r t g") == Dict("r" => 1, "t" => 1, "g" => 1))
	@test(candidate("b b b b a") == Dict("b" => 4))
	@test(candidate("r t g") == Dict("r" => 1, "t" => 1, "g" => 1))
	@test(candidate("") == Dict())
	@test(candidate("a") == Dict("a" => 1))
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154748
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.4s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""Given a string representing a space separated lowercase letters, return a dictionary
of the letter with the most repetition and containing the corresponding count.
If several letters have the same occurrence, return all of them.
Example:
>>> histogram("a b c")
Dict("a" => 1, "b" => 1, "c" => 1)
>>> histogram("a b b a")
Dict("a" => 2, "b" => 2)
>>> histogram("a b c a b")
Dict("a" => 2, "b" => 2)
>>> histogram("b b b b a")
Dict("b" => 4)
>>> histogram("")
Dict()"""
function histogram(test::String)::Dict{String, Int64}
    # Return an empty dictionary for an empty input
    if isempty(test)
        return Dict{String, Int64}()
    end

    # Split the input string on whitespace to get the letters
    letters = split(test)

    # Count the occurrences of each letter
    freq = Dict{String, Int64}()
    for l in letters
        freq[l] = get(freq, l, 0) + 1
    end

    # Find the maximum count
    max_count = maximum(values(freq))

    # Build the result dictionary containing only the most frequent letters
    result = Dict{String, Int64}()
    for (k, v) in freq
        if v == max_count
            result[k] = v
        end
    end

    return result
end
using Test

@testset begin

candidate = histogram;
	@test(candidate("a b b a") == Dict("a" => 2, "b" => 2))
	@test(candidate("a b c a b") == Dict("a" => 2, "b" => 2))
	@test(candidate("a b c d g") == Dict("a" => 1, "b" => 1, "c" => 1, "d" => 1, "g" => 1))
	@test(candidate("r t g") == Dict("r" => 1, "t" => 1, "g" => 1))
	@test(candidate("b b b b a") == Dict("b" => 4))
	@test(candidate("r t g") == Dict("r" => 1, "t" => 1, "g" => 1))
	@test(candidate("") == Dict())
	@test(candidate("a") == Dict("a" => 1))
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154748
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    8      8  0.4s
STDERR: (empty)
--------------------

================================================================================
PROBLEM 112 (JL) - HumanEval_112_reverse_delete
================================================================================

PROMPT:
----------------------------------------
"""Task
We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
then check if the result string is palindrome.
A string is called palindrome if it reads the same backward as forward.
You should return a tuple containing the result string and true/false for the check.
Example
>>> reverse_delete("abcde", "ae")
("bcd", false)
>>> reverse_delete("abcdef", "b")
("acdef", false)
>>> reverse_delete("abcdedcba", "ab")
("cdedc", true)"""

----------------------------------------

TEST CASES:
----------------------------------------
using Test

@testset begin

candidate = reverse_delete;
	@test(candidate("abcde", "ae") == ("bcd", false))
	@test(candidate("abcdef", "b") == ("acdef", false))
	@test(candidate("abcdedcba", "ab") == ("cdedc", true))
	@test(candidate("dwik", "w") == ("dik", false))
	@test(candidate("a", "a") == ("", true))
	@test(candidate("abcdedcba", "") == ("abcdedcba", true))
	@test(candidate("abcdedcba", "v") == ("abcdedcba", true))
	@test(candidate("vabba", "v") == ("abba", true))
	@test(candidate("mamma", "mia") == ("", true))
end

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
"""Task
We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
then check if the result string is palindrome.
A string is called palindrome if it reads the same backward as forward.
You should return a tuple containing the result string and true/false for the check.
Example
>>> reverse_delete("abcde", "ae")
("bcd", false)
>>> reverse_delete("abcdef", "b")
("acdef", false)
>>> reverse_delete("abcdedcba", "ab")
("cdedc", true)"""
function reverse_delete(s::String, c::String)::Tuple{String, Bool}
    # Build a set of characters to delete for O(1) look‑ups
    delete_set = Set(c)

    # Remove all characters from `s` that appear in `c`
    result = filter(ch -> !(ch in delete_set), s)

    # Check whether the resulting string is a palindrome
    is_palindrome = result == String(reverse(result))

    return (result, is_palindrome)
end
using Test

@testset begin

candidate = reverse_delete;
	@test(candidate("abcde", "ae") == ("bcd", false))
	@test(candidate("abcdef", "b") == ("acdef", false))
	@test(candidate("abcdedcba", "ab") == ("cdedc", true))
	@test(candidate("dwik", "w") == ("dik", false))
	@test(candidate("a", "a") == ("", true))
	@test(candidate("abcdedcba", "") == ("abcdedcba", true))
	@test(candidate("abcdedcba", "v") == ("abcdedcba", true))
	@test(candidate("vabba", "v") == ("abba", true))
	@test(candidate("mamma", "mia") == ("", true))
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154749
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    9      9  0.1s
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
"""Task
We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
then check if the result string is palindrome.
A string is called palindrome if it reads the same backward as forward.
You should return a tuple containing the result string and true/false for the check.
Example
>>> reverse_delete("abcde", "ae")
("bcd", false)
>>> reverse_delete("abcdef", "b")
("acdef", false)
>>> reverse_delete("abcdedcba", "ab")
("cdedc", true)"""
function reverse_delete(s::String, c::String)::Tuple{String, Bool}
    # Build a set of characters that need to be removed
    chars_to_remove = Set(c)

    # Filter out all characters that are in the removal set
    result = filter(ch -> !(ch in chars_to_remove), s)

    # Check whether the resulting string is a palindrome
    is_palindrome = result == reverse(result)

    # Return the tuple (resulting string, palindrome flag)
    return (result, is_palindrome)
end
using Test

@testset begin

candidate = reverse_delete;
	@test(candidate("abcde", "ae") == ("bcd", false))
	@test(candidate("abcdef", "b") == ("acdef", false))
	@test(candidate("abcdedcba", "ab") == ("cdedc", true))
	@test(candidate("dwik", "w") == ("dik", false))
	@test(candidate("a", "a") == ("", true))
	@test(candidate("abcdedcba", "") == ("abcdedcba", true))
	@test(candidate("abcdedcba", "v") == ("abcdedcba", true))
	@test(candidate("vabba", "v") == ("abba", true))
	@test(candidate("mamma", "mia") == ("", true))
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154749
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    9      9  0.1s
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
"""Task
We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
then check if the result string is palindrome.
A string is called palindrome if it reads the same backward as forward.
You should return a tuple containing the result string and true/false for the check.
Example
>>> reverse_delete("abcde", "ae")
("bcd", false)
>>> reverse_delete("abcdef", "b")
("acdef", false)
>>> reverse_delete("abcdedcba", "ab")
("cdedc", true)"""
function reverse_delete(s::String, c::String)::Tuple{String, Bool}
    # Characters that should be removed
    delset = Set(c)

    # Build the resulting string by filtering out unwanted characters
    result = join(filter(ch -> !(ch in delset), s))

    # Check if the resulting string is a palindrome
    is_palindrome = result == reverse(result)

    return (result, is_palindrome)
end
using Test

@testset begin

candidate = reverse_delete;
	@test(candidate("abcde", "ae") == ("bcd", false))
	@test(candidate("abcdef", "b") == ("acdef", false))
	@test(candidate("abcdedcba", "ab") == ("cdedc", true))
	@test(candidate("dwik", "w") == ("dik", false))
	@test(candidate("a", "a") == ("", true))
	@test(candidate("abcdedcba", "") == ("abcdedcba", true))
	@test(candidate("abcdedcba", "v") == ("abcdedcba", true))
	@test(candidate("vabba", "v") == ("abba", true))
	@test(candidate("mamma", "mia") == ("", true))
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154749
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    9      9  0.1s
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
"""Task
We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
then check if the result string is palindrome.
A string is called palindrome if it reads the same backward as forward.
You should return a tuple containing the result string and true/false for the check.
Example
>>> reverse_delete("abcde", "ae")
("bcd", false)
>>> reverse_delete("abcdef", "b")
("acdef", false)
>>> reverse_delete("abcdedcba", "ab")
("cdedc", true)"""
function reverse_delete(s::String, c::String)::Tuple{String, Bool}
    # Build the string after deleting every character that appears in `c`
    kept = join([ch for ch in s if !(ch in c)])
    # Check if the resulting string is a palindrome
    is_pal = kept == reverse(kept)
    return (kept, is_pal)
end
using Test

@testset begin

candidate = reverse_delete;
	@test(candidate("abcde", "ae") == ("bcd", false))
	@test(candidate("abcdef", "b") == ("acdef", false))
	@test(candidate("abcdedcba", "ab") == ("cdedc", true))
	@test(candidate("dwik", "w") == ("dik", false))
	@test(candidate("a", "a") == ("", true))
	@test(candidate("abcdedcba", "") == ("abcdedcba", true))
	@test(candidate("abcdedcba", "v") == ("abcdedcba", true))
	@test(candidate("vabba", "v") == ("abba", true))
	@test(candidate("mamma", "mia") == ("", true))
end


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154749
STDOUT:
Test Summary: | Pass  Total  Time
test set      |    9      9  0.2s
STDERR: (empty)
--------------------
