As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 81 (ML) - HumanEval_81_numerical_letter_grade
================================================================================

PROMPT:
----------------------------------------
(**It is the last week of the semester and the teacher has to give the grades
 * to students. The teacher has been making her own algorithm for grading.
 * The only problem is, she has lost the code she used for grading.
 * She has given you a list of GPAs for some students and you have to write 
 * a function that can output a list of letter grades using the following table:
 * GPA       |    Letter grade
 * 4.0                A+
 * > 3.7                A 
 * > 3.3                A- 
 * > 3.0                B+
 * > 2.7                B 
 * > 2.3                B-
 * > 2.0                C+
 * > 1.7                C
 * > 1.3                C-
 * > 1.0                D+ 
 * > 0.7                D 
 * > 0.0                D-
 * 0.0                E
 * Example:
 * >>> grade_equation [4.0; 3; 1.7; 2; 3.5]
 * ["A+"; "B"; "C-"; "C"; "A-"]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = numerical_letter_grade in
  (assert ((candidate [4.0; 3.0; 1.7; 2.0; 3.5]) = ["A+"; "B"; "C-"; "C"; "A-"]));
  (assert ((candidate [1.2]) = ["D+"]));
  (assert ((candidate [0.5]) = ["D-"]));
  (assert ((candidate [0.0]) = ["E"]));
  (assert ((candidate [1.0; 0.3; 1.5; 2.8; 3.3]) = ["D"; "D-"; "C-"; "B"; "B+"]));
  (assert ((candidate [0.0; 0.7]) = ["E"; "D-"]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**It is the last week of the semester and the teacher has to give the grades
 * to students. The teacher has been making her own algorithm for grading.
 * The only problem is, she has lost the code she used for grading.
 * She has given you a list of GPAs for some students and you have to write 
 * a function that can output a list of letter grades using the following table:
 * GPA       |    Letter grade
 * 4.0                A+
 * > 3.7                A 
 * > 3.3                A- 
 * > 3.0                B+
 * > 2.7                B 
 * > 2.3                B-
 * > 2.0                C+
 * > 1.7                C
 * > 1.3                C-
 * > 1.0                D+ 
 * > 0.7                D 
 * > 0.0                D-
 * 0.0                E
 * Example:
 * >>> grade_equation [4.0; 3; 1.7; 2; 3.5]
 * ["A+"; "B"; "C-"; "C"; "A-"]
*)
(* Convert a list of GPAs to the corresponding letter grades. *)
let numerical_letter_grade (grades : float list) : string list =
  let grade_of_gpa g =
    if g = 4.0 then "A+"
    else if g > 3.7 then "A"
    else if g > 3.3 then "A-"
    else if g > 3.0 then "B+"
    else if g > 2.7 then "B"
    else if g > 2.3 then "B-"
    else if g > 2.0 then "C+"
    else if g > 1.7 then "C"
    else if g > 1.3 then "C-"
    else if g > 1.0 then "D+"
    else if g > 0.7 then "D"
    else if g > 0.0 then "D-"
    else "E"
  in
  List.map grade_of_gpa grades

let assertions =
 let candidate = numerical_letter_grade in
  (assert ((candidate [4.0; 3.0; 1.7; 2.0; 3.5]) = ["A+"; "B"; "C-"; "C"; "A-"]));
  (assert ((candidate [1.2]) = ["D+"]));
  (assert ((candidate [0.5]) = ["D-"]));
  (assert ((candidate [0.0]) = ["E"]));
  (assert ((candidate [1.0; 0.3; 1.5; 2.8; 3.3]) = ["D"; "D-"; "C-"; "B"; "B+"]));
  (assert ((candidate [0.0; 0.7]) = ["E"; "D-"]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**It is the last week of the semester and the teacher has to give the grades
 * to students. The teacher has been making her own algorithm for grading.
 * The only problem is, she has lost the code she used for grading.
 * She has given you a list of GPAs for some students and you have to write 
 * a function that can output a list of letter grades using the following table:
 * GPA       |    Letter grade
 * 4.0                A+
 * > 3.7                A 
 * > 3.3                A- 
 * > 3.0                B+
 * > 2.7                B 
 * > 2.3                B-
 * > 2.0                C+
 * > 1.7                C
 * > 1.3                C-
 * > 1.0                D+ 
 * > 0.7                D 
 * > 0.0                D-
 * 0.0                E
 * Example:
 * >>> grade_equation [4.0; 3; 1.7; 2; 3.5]
 * ["A+"; "B"; "C-"; "C"; "A-"]
*)
let numerical_letter_grade (grades : float list) : string list =
  let grade_of_gpa g =
    if g = 4.0 then "A+"
    else if g > 3.7 then "A"
    else if g > 3.3 then "A-"
    else if g > 3.0 then "B+"
    else if g > 2.7 then "B"
    else if g > 2.3 then "B-"
    else if g > 2.0 then "C+"
    else if g > 1.7 then "C"
    else if g > 1.3 then "C-"
    else if g > 1.0 then "D+"
    else if g > 0.7 then "D"
    else if g > 0.0 then "D-"
    else "E"
  in
  List.map grade_of_gpa grades

let assertions =
 let candidate = numerical_letter_grade in
  (assert ((candidate [4.0; 3.0; 1.7; 2.0; 3.5]) = ["A+"; "B"; "C-"; "C"; "A-"]));
  (assert ((candidate [1.2]) = ["D+"]));
  (assert ((candidate [0.5]) = ["D-"]));
  (assert ((candidate [0.0]) = ["E"]));
  (assert ((candidate [1.0; 0.3; 1.5; 2.8; 3.3]) = ["D"; "D-"; "C-"; "B"; "B+"]));
  (assert ((candidate [0.0; 0.7]) = ["E"; "D-"]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**It is the last week of the semester and the teacher has to give the grades
 * to students. The teacher has been making her own algorithm for grading.
 * The only problem is, she has lost the code she used for grading.
 * She has given you a list of GPAs for some students and you have to write 
 * a function that can output a list of letter grades using the following table:
 * GPA       |    Letter grade
 * 4.0                A+
 * > 3.7                A 
 * > 3.3                A- 
 * > 3.0                B+
 * > 2.7                B 
 * > 2.3                B-
 * > 2.0                C+
 * > 1.7                C
 * > 1.3                C-
 * > 1.0                D+ 
 * > 0.7                D 
 * > 0.0                D-
 * 0.0                E
 * Example:
 * >>> grade_equation [4.0; 3; 1.7; 2; 3.5]
 * ["A+"; "B"; "C-"; "C"; "A-"]
*)
let numerical_letter_grade (grades : float list) : string list =
  (* Helper function that maps a single GPA to its letter grade *)
  let letter_of_gpa g =
    if g >= 4.0 then "A+"
    else if g > 3.7 then "A"
    else if g > 3.3 then "A-"
    else if g > 3.0 then "B+"
    else if g > 2.7 then "B"
    else if g > 2.3 then "B-"
    else if g > 2.0 then "C+"
    else if g > 1.7 then "C"
    else if g > 1.3 then "C-"
    else if g > 1.0 then "D+"
    else if g > 0.7 then "D"
    else if g > 0.0 then "D-"
    else "E"
  in
  (* Map the helper over the input list *)
  List.map letter_of_gpa grades

let assertions =
 let candidate = numerical_letter_grade in
  (assert ((candidate [4.0; 3.0; 1.7; 2.0; 3.5]) = ["A+"; "B"; "C-"; "C"; "A-"]));
  (assert ((candidate [1.2]) = ["D+"]));
  (assert ((candidate [0.5]) = ["D-"]));
  (assert ((candidate [0.0]) = ["E"]));
  (assert ((candidate [1.0; 0.3; 1.5; 2.8; 3.3]) = ["D"; "D-"; "C-"; "B"; "B+"]));
  (assert ((candidate [0.0; 0.7]) = ["E"; "D-"]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**It is the last week of the semester and the teacher has to give the grades
 * to students. The teacher has been making her own algorithm for grading.
 * The only problem is, she has lost the code she used for grading.
 * She has given you a list of GPAs for some students and you have to write 
 * a function that can output a list of letter grades using the following table:
 * GPA       |    Letter grade
 * 4.0                A+
 * > 3.7                A 
 * > 3.3                A- 
 * > 3.0                B+
 * > 2.7                B 
 * > 2.3                B-
 * > 2.0                C+
 * > 1.7                C
 * > 1.3                C-
 * > 1.0                D+ 
 * > 0.7                D 
 * > 0.0                D-
 * 0.0                E
 * Example:
 * >>> grade_equation [4.0; 3; 1.7; 2; 3.5]
 * ["A+"; "B"; "C-"; "C"; "A-"]
*)
let numerical_letter_grade (grades : float list) : string list =
  let grade_of g =
    if g = 4.0 then "A+"
    else if g > 3.7 then "A"
    else if g > 3.3 then "A-"
    else if g > 3.0 then "B+"
    else if g > 2.7 then "B"
    else if g > 2.3 then "B-"
    else if g > 2.0 then "C+"
    else if g > 1.7 then "C"
    else if g > 1.3 then "C-"
    else if g > 1.0 then "D+"
    else if g > 0.7 then "D"
    else if g > 0.0 then "D-"
    else "E"
  in
  List.map grade_of grades

let assertions =
 let candidate = numerical_letter_grade in
  (assert ((candidate [4.0; 3.0; 1.7; 2.0; 3.5]) = ["A+"; "B"; "C-"; "C"; "A-"]));
  (assert ((candidate [1.2]) = ["D+"]));
  (assert ((candidate [0.5]) = ["D-"]));
  (assert ((candidate [0.0]) = ["E"]));
  (assert ((candidate [1.0; 0.3; 1.5; 2.8; 3.3]) = ["D"; "D-"; "C-"; "B"; "B+"]));
  (assert ((candidate [0.0; 0.7]) = ["E"; "D-"]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 82 (ML) - HumanEval_82_prime_length
================================================================================

PROMPT:
----------------------------------------
(**Write a function that takes a string and returns true if the string
 * length is a prime number or false otherwise
 * Examples
 * >>> prime_length "Hello"
 * true
 * >>> prime_length "abcdcba"
 * true
 * >>> prime_length "kittens"
 * true
 * >>> prime_length "orange"
 * false
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = prime_length in
  (assert ((candidate "Hello") = true));
  (assert ((candidate "abcdcba") = true));
  (assert ((candidate "kittens") = true));
  (assert ((candidate "orange") = false));
  (assert ((candidate "wow") = true));
  (assert ((candidate "world") = true));
  (assert ((candidate "MadaM") = true));
  (assert ((candidate "Wow") = true));
  (assert ((candidate "") = false));
  (assert ((candidate "HI") = true));
  (assert ((candidate "go") = true));
  (assert ((candidate "gogo") = false));
  (assert ((candidate "aaaaaaaaaaaaaaa") = false));
  (assert ((candidate "Madam") = true));
  (assert ((candidate "M") = false));
  (assert ((candidate "0") = false));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Write a function that takes a string and returns true if the string
 * length is a prime number or false otherwise
 * Examples
 * >>> prime_length "Hello"
 * true
 * >>> prime_length "abcdcba"
 * true
 * >>> prime_length "kittens"
 * true
 * >>> prime_length "orange"
 * false
*)
(* prime_length : string -> bool
   Returns true if the length of the string is a prime number, false otherwise. *)
let prime_length (s : string) : bool =
  let n = String.length s in
  if n <= 1 then false
  else
    let rec is_prime i =
      if i * i > n then true
      else if n mod i = 0 then false
      else is_prime (i + 1)
    in
    is_prime 2

let assertions =
 let candidate = prime_length in
  (assert ((candidate "Hello") = true));
  (assert ((candidate "abcdcba") = true));
  (assert ((candidate "kittens") = true));
  (assert ((candidate "orange") = false));
  (assert ((candidate "wow") = true));
  (assert ((candidate "world") = true));
  (assert ((candidate "MadaM") = true));
  (assert ((candidate "Wow") = true));
  (assert ((candidate "") = false));
  (assert ((candidate "HI") = true));
  (assert ((candidate "go") = true));
  (assert ((candidate "gogo") = false));
  (assert ((candidate "aaaaaaaaaaaaaaa") = false));
  (assert ((candidate "Madam") = true));
  (assert ((candidate "M") = false));
  (assert ((candidate "0") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Write a function that takes a string and returns true if the string
 * length is a prime number or false otherwise
 * Examples
 * >>> prime_length "Hello"
 * true
 * >>> prime_length "abcdcba"
 * true
 * >>> prime_length "kittens"
 * true
 * >>> prime_length "orange"
 * false
*)
(* Returns true if the length of the given string is a prime number,
   otherwise returns false. *)
let prime_length (s : string) : bool =
  let len = String.length s in
  let rec is_prime n =
    if n <= 1 then false
    else if n <= 3 then true
    else if n mod 2 = 0 || n mod 3 = 0 then false
    else
      let rec check i =
        if i * i > n then true
        else if n mod i = 0 || n mod (i + 2) = 0 then false
        else check (i + 6)
      in
      check 5
  in
  is_prime len

let assertions =
 let candidate = prime_length in
  (assert ((candidate "Hello") = true));
  (assert ((candidate "abcdcba") = true));
  (assert ((candidate "kittens") = true));
  (assert ((candidate "orange") = false));
  (assert ((candidate "wow") = true));
  (assert ((candidate "world") = true));
  (assert ((candidate "MadaM") = true));
  (assert ((candidate "Wow") = true));
  (assert ((candidate "") = false));
  (assert ((candidate "HI") = true));
  (assert ((candidate "go") = true));
  (assert ((candidate "gogo") = false));
  (assert ((candidate "aaaaaaaaaaaaaaa") = false));
  (assert ((candidate "Madam") = true));
  (assert ((candidate "M") = false));
  (assert ((candidate "0") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Write a function that takes a string and returns true if the string
 * length is a prime number or false otherwise
 * Examples
 * >>> prime_length "Hello"
 * true
 * >>> prime_length "abcdcba"
 * true
 * >>> prime_length "kittens"
 * true
 * >>> prime_length "orange"
 * false
*)
(* Check if an integer is prime *)
let is_prime n =
  if n <= 1 then false
  else
    let limit = int_of_float (sqrt (float_of_int n)) in
    let rec loop d =
      if d > limit then true
      else if n mod d = 0 then false
      else loop (d + 1)
    in
    loop 2

(* Return true if the string length is prime, false otherwise *)
let prime_length (s : string) : bool =
  is_prime (String.length s)

let assertions =
 let candidate = prime_length in
  (assert ((candidate "Hello") = true));
  (assert ((candidate "abcdcba") = true));
  (assert ((candidate "kittens") = true));
  (assert ((candidate "orange") = false));
  (assert ((candidate "wow") = true));
  (assert ((candidate "world") = true));
  (assert ((candidate "MadaM") = true));
  (assert ((candidate "Wow") = true));
  (assert ((candidate "") = false));
  (assert ((candidate "HI") = true));
  (assert ((candidate "go") = true));
  (assert ((candidate "gogo") = false));
  (assert ((candidate "aaaaaaaaaaaaaaa") = false));
  (assert ((candidate "Madam") = true));
  (assert ((candidate "M") = false));
  (assert ((candidate "0") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Write a function that takes a string and returns true if the string
 * length is a prime number or false otherwise
 * Examples
 * >>> prime_length "Hello"
 * true
 * >>> prime_length "abcdcba"
 * true
 * >>> prime_length "kittens"
 * true
 * >>> prime_length "orange"
 * false
*)
let prime_length (s : string) : bool =
  let is_prime n =
    if n <= 1 then false
    else
      let rec aux i =
        if i * i > n then true
        else if n mod i = 0 then false
        else aux (i + 1)
      in
      aux 2
  in
  is_prime (String.length s)

let assertions =
 let candidate = prime_length in
  (assert ((candidate "Hello") = true));
  (assert ((candidate "abcdcba") = true));
  (assert ((candidate "kittens") = true));
  (assert ((candidate "orange") = false));
  (assert ((candidate "wow") = true));
  (assert ((candidate "world") = true));
  (assert ((candidate "MadaM") = true));
  (assert ((candidate "Wow") = true));
  (assert ((candidate "") = false));
  (assert ((candidate "HI") = true));
  (assert ((candidate "go") = true));
  (assert ((candidate "gogo") = false));
  (assert ((candidate "aaaaaaaaaaaaaaa") = false));
  (assert ((candidate "Madam") = true));
  (assert ((candidate "M") = false));
  (assert ((candidate "0") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 83 (ML) - HumanEval_83_starts_one_ends
================================================================================

PROMPT:
----------------------------------------
(**Given a positive integer n, return the count of the numbers of n-digit
 * positive integers that start or end with 1.
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = starts_one_ends in
  (assert ((candidate 1) = 1));
  (assert ((candidate 2) = 18));
  (assert ((candidate 3) = 180));
  (assert ((candidate 4) = 1800));
  (assert ((candidate 5) = 18000));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given a positive integer n, return the count of the numbers of n-digit
 * positive integers that start or end with 1.
*)
(* Count of n‑digit positive integers that start or end with 1 *)
let starts_one_ends (n : int) : int =
  (* Helper: integer power *)
  let rec int_pow base exp =
    if exp = 0 then 1
    else base * int_pow base (exp - 1)
  in
  match n with
  | 1 -> 1                           (* only the number 1 itself *)
  | _ ->
      let pow10 = int_pow 10 (n - 2) in
      18 * pow10                      (* 10^(n‑1) + 9·10^(n‑2) – 10^(n‑2) *)

let assertions =
 let candidate = starts_one_ends in
  (assert ((candidate 1) = 1));
  (assert ((candidate 2) = 18));
  (assert ((candidate 3) = 180));
  (assert ((candidate 4) = 1800));
  (assert ((candidate 5) = 18000));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given a positive integer n, return the count of the numbers of n-digit
 * positive integers that start or end with 1.
*)
(* Count the n‑digit positive integers that start or end with 1. *)
let starts_one_ends (n : int) : int =
  (* Helper: compute 10^k using integer arithmetic. *)
  let pow10 k =
    let rec aux i acc =
      if i = 0 then acc else aux (i - 1) (acc * 10)
    in
    aux k 1
  in
  if n <= 0 then 0
  else
    let start = pow10 (n - 1) in
    let end_ =
      if n = 1 then 1 else 9 * pow10 (n - 2)
    in
    let both =
      if n = 1 then 1 else pow10 (n - 2)
    in
    start + end_ - both

let assertions =
 let candidate = starts_one_ends in
  (assert ((candidate 1) = 1));
  (assert ((candidate 2) = 18));
  (assert ((candidate 3) = 180));
  (assert ((candidate 4) = 1800));
  (assert ((candidate 5) = 18000));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given a positive integer n, return the count of the numbers of n-digit
 * positive integers that start or end with 1.
*)
let starts_one_ends (n : int) : int =
  (* Helper: compute 10^k as an int *)
  let pow10 k =
    let rec aux acc k =
      if k = 0 then acc else aux (acc * 10) (k - 1)
    in
    aux 1 k
  in
  if n <= 0 then 0                 (* not expected, but safe guard *)
  else if n = 1 then 1             (* only the single digit number 1 *)
  else
    (* For n > 1: 18 * 10^(n-2) *)
    18 * pow10 (n - 2)

let assertions =
 let candidate = starts_one_ends in
  (assert ((candidate 1) = 1));
  (assert ((candidate 2) = 18));
  (assert ((candidate 3) = 180));
  (assert ((candidate 4) = 1800));
  (assert ((candidate 5) = 18000));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given a positive integer n, return the count of the numbers of n-digit
 * positive integers that start or end with 1.
*)
(* Count of n‑digit positive integers that start or end with 1 *)
let starts_one_ends (n : int) : int =
  (* Helper to compute 10^(k) for a non‑negative integer k *)
  let rec pow10 k =
    if k = 0 then 1
    else 10 * pow10 (k - 1)
  in
  match n with
  | 1 -> 1                                 (* only the number 1 *)
  | _ -> 18 * pow10 (n - 2)                (* 18 × 10^(n‑2) for n ≥ 2 *)

let assertions =
 let candidate = starts_one_ends in
  (assert ((candidate 1) = 1));
  (assert ((candidate 2) = 18));
  (assert ((candidate 3) = 180));
  (assert ((candidate 4) = 1800));
  (assert ((candidate 5) = 18000));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 86 (ML) - HumanEval_86_anti_shuffle
================================================================================

PROMPT:
----------------------------------------
(**Write a function that takes a string and returns an ordered version of it.
 * Ordered version of string, is a string where all words (separated by space)
 * are replaced by a new word where all the characters arranged in
 * ascending order based on ascii value.
 * Note: You should keep the order of words and blank spaces in the sentence.
 * For example:
 * >>> anti_shuffle "Hi"
 * "Hi"
 * >>> anti_shuffle "hello"
 * "ehllo"
 * >>> anti_shuffle "Hello World!!!"
 * "Hello !!!Wdlor"
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = anti_shuffle in
  (assert ((candidate "Hi") = "Hi"));
  (assert ((candidate "hello") = "ehllo"));
  (assert ((candidate "number") = "bemnru"));
  (assert ((candidate "abcd") = "abcd"));
  (assert ((candidate "Hello World!!!") = "Hello !!!Wdlor"));
  (assert ((candidate "") = ""));
  (assert ((candidate "Hi. My name is Mister Robot. How are you?") = ".Hi My aemn is Meirst .Rboot How aer ?ouy"));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Write a function that takes a string and returns an ordered version of it.
 * Ordered version of string, is a string where all words (separated by space)
 * are replaced by a new word where all the characters arranged in
 * ascending order based on ascii value.
 * Note: You should keep the order of words and blank spaces in the sentence.
 * For example:
 * >>> anti_shuffle "Hi"
 * "Hi"
 * >>> anti_shuffle "hello"
 * "ehllo"
 * >>> anti_shuffle "Hello World!!!"
 * "Hello !!!Wdlor"
*)
(*  anti_shuffle : string -> string
    Reorders the characters of each word in ascending ASCII order while
    preserving the original word order and the spaces between them. *)
let anti_shuffle (s : string) : string =
  let len = String.length s in
  let out_buf = Buffer.create len in
  let word_buf = Buffer.create 16 in

  (* Helper: sort the characters in the current word buffer and add to out_buf *)
  let flush_word () =
    let word = Buffer.contents word_buf in
    if word <> "" then begin
      let sorted =
        word
        |> String.to_seq
        |> List.of_seq
        |> List.sort Char.compare
        |> List.to_seq
        |> String.of_seq
      in
      Buffer.add_string out_buf sorted;
      Buffer.clear word_buf
    end
  in

  for i = 0 to len - 1 do
    let c = s.[i] in
    if c = ' ' then begin
      flush_word ();           (* finish the current word *)
      Buffer.add_char out_buf c (* keep the space *)
    end else
      Buffer.add_char word_buf c
  done;

  (* flush the last word, if any *)
  flush_word ();

  Buffer.contents out_buf

let assertions =
 let candidate = anti_shuffle in
  (assert ((candidate "Hi") = "Hi"));
  (assert ((candidate "hello") = "ehllo"));
  (assert ((candidate "number") = "bemnru"));
  (assert ((candidate "abcd") = "abcd"));
  (assert ((candidate "Hello World!!!") = "Hello !!!Wdlor"));
  (assert ((candidate "") = ""));
  (assert ((candidate "Hi. My name is Mister Robot. How are you?") = ".Hi My aemn is Meirst .Rboot How aer ?ouy"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Write a function that takes a string and returns an ordered version of it.
 * Ordered version of string, is a string where all words (separated by space)
 * are replaced by a new word where all the characters arranged in
 * ascending order based on ascii value.
 * Note: You should keep the order of words and blank spaces in the sentence.
 * For example:
 * >>> anti_shuffle "Hi"
 * "Hi"
 * >>> anti_shuffle "hello"
 * "ehllo"
 * >>> anti_shuffle "Hello World!!!"
 * "Hello !!!Wdlor"
*)
let anti_shuffle (s : string) : string =
  let len = String.length s in
  let buf  = Buffer.create len in        (* output buffer *)
  let word = Buffer.create 16 in         (* temporary buffer for a word *)

  (* Process each character of the input string *)
  for i = 0 to len - 1 do
    let c = s.[i] in
    if c = ' ' then begin
      (* Flush the current word (if any) *)
      if Buffer.length word > 0 then begin
        let w = Buffer.contents word in
        let sorted =
          w
          |> String.to_seq
          |> List.of_seq
          |> List.sort Char.compare
        in
        Buffer.add_string buf
          (String.concat "" (List.map (String.make 1) sorted));
        Buffer.clear word
      end;
      (* Preserve the space *)
      Buffer.add_char buf c
    end else
      Buffer.add_char word c
  done;

  (* Flush the last word, if any *)
  if Buffer.length word > 0 then begin
    let w = Buffer.contents word in
    let sorted =
      w
      |> String.to_seq
      |> List.of_seq
      |> List.sort Char.compare
    in
    Buffer.add_string buf
      (String.concat "" (List.map (String.make 1) sorted))
  end;

  Buffer.contents buf

let assertions =
 let candidate = anti_shuffle in
  (assert ((candidate "Hi") = "Hi"));
  (assert ((candidate "hello") = "ehllo"));
  (assert ((candidate "number") = "bemnru"));
  (assert ((candidate "abcd") = "abcd"));
  (assert ((candidate "Hello World!!!") = "Hello !!!Wdlor"));
  (assert ((candidate "") = ""));
  (assert ((candidate "Hi. My name is Mister Robot. How are you?") = ".Hi My aemn is Meirst .Rboot How aer ?ouy"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Write a function that takes a string and returns an ordered version of it.
 * Ordered version of string, is a string where all words (separated by space)
 * are replaced by a new word where all the characters arranged in
 * ascending order based on ascii value.
 * Note: You should keep the order of words and blank spaces in the sentence.
 * For example:
 * >>> anti_shuffle "Hi"
 * "Hi"
 * >>> anti_shuffle "hello"
 * "ehllo"
 * >>> anti_shuffle "Hello World!!!"
 * "Hello !!!Wdlor"
*)
(* Sort the characters of a single word in ascending ASCII order *)
let sort_word (w : string) : string =
  w
  |> String.to_seq          (* convert string to a sequence of chars *)
  |> List.of_seq            (* sequence → list of chars *)
  |> List.sort compare      (* sort the list by ASCII value *)
  |> List.to_seq            (* list → sequence again *)
  |> String.of_seq          (* sequence → string *)

(* Main function *)
let anti_shuffle (s : string) : string =
  (* Split the string by spaces – consecutive spaces produce empty strings,
     which keeps the original spacing when we re‑join. *)
  let parts = String.split_on_char ' ' s in
  (* Sort each part independently. *)
  let sorted_parts = List.map sort_word parts in
  (* Re‑assemble the string with single spaces between the parts. *)
  String.concat " " sorted_parts

let assertions =
 let candidate = anti_shuffle in
  (assert ((candidate "Hi") = "Hi"));
  (assert ((candidate "hello") = "ehllo"));
  (assert ((candidate "number") = "bemnru"));
  (assert ((candidate "abcd") = "abcd"));
  (assert ((candidate "Hello World!!!") = "Hello !!!Wdlor"));
  (assert ((candidate "") = ""));
  (assert ((candidate "Hi. My name is Mister Robot. How are you?") = ".Hi My aemn is Meirst .Rboot How aer ?ouy"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Write a function that takes a string and returns an ordered version of it.
 * Ordered version of string, is a string where all words (separated by space)
 * are replaced by a new word where all the characters arranged in
 * ascending order based on ascii value.
 * Note: You should keep the order of words and blank spaces in the sentence.
 * For example:
 * >>> anti_shuffle "Hi"
 * "Hi"
 * >>> anti_shuffle "hello"
 * "ehllo"
 * >>> anti_shuffle "Hello World!!!"
 * "Hello !!!Wdlor"
*)
let anti_shuffle (s : string) : string =
  let len = String.length s in
  let out   = Buffer.create len in
  let word  = Buffer.create 16 in

  (* Flush the current word buffer, sort it, and append to the output. *)
  let flush_word () =
    if Buffer.length word > 0 then begin
      let chars  = Buffer.contents word |> String.to_seq |> List.of_seq in
      let sorted = List.sort Char.compare chars in
      Buffer.add_string out (String.of_seq (List.to_seq sorted));
      Buffer.clear word
    end
  in

  for i = 0 to len - 1 do
    let c = s.[i] in
    if c = ' ' then begin
      flush_word ();
      Buffer.add_char out c
    end else
      Buffer.add_char word c
  done;

  (* Flush any remaining word after the loop. *)
  flush_word ();

  Buffer.contents out

let assertions =
 let candidate = anti_shuffle in
  (assert ((candidate "Hi") = "Hi"));
  (assert ((candidate "hello") = "ehllo"));
  (assert ((candidate "number") = "bemnru"));
  (assert ((candidate "abcd") = "abcd"));
  (assert ((candidate "Hello World!!!") = "Hello !!!Wdlor"));
  (assert ((candidate "") = ""));
  (assert ((candidate "Hi. My name is Mister Robot. How are you?") = ".Hi My aemn is Meirst .Rboot How aer ?ouy"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 87 (ML) - HumanEval_87_get_row
================================================================================

PROMPT:
----------------------------------------
(**You are given a 2 dimensional data, as a nested lists,
 * which is similar to matrix, however, unlike matrices,
 * each row may contain a different number of columns.
 * Given lst, and integer x, find integers x in the list,
 * and return list of tuples, [(x1, y1), (x2, y2) ...] such that
 * each tuple is a coordinate - (row, columns), starting with 0.
 * Sort coordinates initially by rows in ascending order.
 * Also, sort coordinates of the row by columns in descending order.
 * Examples:
 * >>> get_row [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1
 * [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)]
 * >>> get_row [] 1
 * []
 * >>> get_row [[]; [1]; [1; 2; 3]] 3
 * [(2, 2)]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = get_row in
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1) = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)]));
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2) = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)]));
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1) = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)]));
  (assert ((candidate [] 1) = []));
  (assert ((candidate [[1]] 2) = []));
  (assert ((candidate [[]; [1]; [1; 2; 3]] 3) = [(2, 2)]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**You are given a 2 dimensional data, as a nested lists,
 * which is similar to matrix, however, unlike matrices,
 * each row may contain a different number of columns.
 * Given lst, and integer x, find integers x in the list,
 * and return list of tuples, [(x1, y1), (x2, y2) ...] such that
 * each tuple is a coordinate - (row, columns), starting with 0.
 * Sort coordinates initially by rows in ascending order.
 * Also, sort coordinates of the row by columns in descending order.
 * Examples:
 * >>> get_row [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1
 * [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)]
 * >>> get_row [] 1
 * []
 * >>> get_row [[]; [1]; [1; 2; 3]] 3
 * [(2, 2)]
*)
(* Find all coordinates of a value `x` in a ragged 2‑D list.
   The result is a list of (row, column) pairs sorted by
   row in ascending order, and for each row the columns are
   sorted in descending order. *)
let get_row (lst : int list list) (x : int) : (int * int) list =
  let rec aux rows row_idx acc =
    match rows with
    | [] -> List.rev acc
    | row :: rest ->
        (* Collect column indices where the element equals `x`. *)
        let idxs =
          row
          |> List.mapi (fun idx v -> if v = x then Some idx else None)
          |> List.filter_map (fun o -> o)
          (* Sort the indices in descending order. *)
          |> List.sort (fun a b -> compare b a)
        in
        (* Prepend the found coordinates to the accumulator. *)
        let acc' = List.fold_left (fun a idx -> (row_idx, idx) :: a) acc idxs in
        aux rest (row_idx + 1) acc'
  in
  aux lst 0 []

let assertions =
 let candidate = get_row in
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1) = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)]));
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2) = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)]));
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1) = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)]));
  (assert ((candidate [] 1) = []));
  (assert ((candidate [[1]] 2) = []));
  (assert ((candidate [[]; [1]; [1; 2; 3]] 3) = [(2, 2)]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**You are given a 2 dimensional data, as a nested lists,
 * which is similar to matrix, however, unlike matrices,
 * each row may contain a different number of columns.
 * Given lst, and integer x, find integers x in the list,
 * and return list of tuples, [(x1, y1), (x2, y2) ...] such that
 * each tuple is a coordinate - (row, columns), starting with 0.
 * Sort coordinates initially by rows in ascending order.
 * Also, sort coordinates of the row by columns in descending order.
 * Examples:
 * >>> get_row [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1
 * [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)]
 * >>> get_row [] 1
 * []
 * >>> get_row [[]; [1]; [1; 2; 3]] 3
 * [(2, 2)]
*)
(* Return all coordinates (row, col) where the value equals `x`.
   Rows are processed in ascending order and, for each row, the
   column indices are sorted in descending order. *)
let get_row (lst : int list list) (x : int) : (int * int) list =
  (* Helper to find all column indices in a row where the element equals x *)
  let indices_of_x row =
    let rec aux i acc = function
      | [] -> acc
      | h :: t ->
          let acc' = if h = x then i :: acc else acc in
          aux (i + 1) acc' t
    in
    aux 0 [] row
  in
  (* Process each row with its index *)
  let rec aux row_idx acc = function
    | [] -> List.rev acc
    | row :: rest ->
        let cols = indices_of_x row in
        (* Sort columns in descending order *)
        let sorted_cols = List.sort (fun a b -> compare b a) cols in
        let tuples = List.map (fun c -> (row_idx, c)) sorted_cols in
        aux (row_idx + 1) (List.rev_append tuples acc) rest
  in
  aux 0 [] lst

let assertions =
 let candidate = get_row in
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1) = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)]));
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2) = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)]));
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1) = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)]));
  (assert ((candidate [] 1) = []));
  (assert ((candidate [[1]] 2) = []));
  (assert ((candidate [[]; [1]; [1; 2; 3]] 3) = [(2, 2)]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**You are given a 2 dimensional data, as a nested lists,
 * which is similar to matrix, however, unlike matrices,
 * each row may contain a different number of columns.
 * Given lst, and integer x, find integers x in the list,
 * and return list of tuples, [(x1, y1), (x2, y2) ...] such that
 * each tuple is a coordinate - (row, columns), starting with 0.
 * Sort coordinates initially by rows in ascending order.
 * Also, sort coordinates of the row by columns in descending order.
 * Examples:
 * >>> get_row [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1
 * [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)]
 * >>> get_row [] 1
 * []
 * >>> get_row [[]; [1]; [1; 2; 3]] 3
 * [(2, 2)]
*)
(* Find all coordinates of the integer `x` in a ragged 2‑D list.  
   The result is a list of (row, column) tuples sorted first by
   row in ascending order and, within each row, by column in
   descending order. *)
let get_row (lst : int list list) (x : int) : (int * int) list =
  (* Helper that processes each row, keeping track of the current row index. *)
  let rec aux rows idx acc =
    match rows with
    | [] -> acc
    | row :: rest ->
        (* Find all column indices where the value equals `x`. *)
        let cols =
          row
          |> List.mapi (fun j v -> if v = x then Some j else None)
          |> List.filter_map (fun o -> o)
          (* Sort columns in descending order. *)
          |> List.sort (fun a b -> compare b a)
        in
        (* Append the coordinates for this row to the accumulator. *)
        let acc' = acc @ (List.map (fun j -> (idx, j)) cols) in
        aux rest (idx + 1) acc'
  in
  aux lst 0 []

let assertions =
 let candidate = get_row in
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1) = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)]));
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2) = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)]));
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1) = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)]));
  (assert ((candidate [] 1) = []));
  (assert ((candidate [[1]] 2) = []));
  (assert ((candidate [[]; [1]; [1; 2; 3]] 3) = [(2, 2)]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**You are given a 2 dimensional data, as a nested lists,
 * which is similar to matrix, however, unlike matrices,
 * each row may contain a different number of columns.
 * Given lst, and integer x, find integers x in the list,
 * and return list of tuples, [(x1, y1), (x2, y2) ...] such that
 * each tuple is a coordinate - (row, columns), starting with 0.
 * Sort coordinates initially by rows in ascending order.
 * Also, sort coordinates of the row by columns in descending order.
 * Examples:
 * >>> get_row [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1
 * [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)]
 * >>> get_row [] 1
 * []
 * >>> get_row [[]; [1]; [1; 2; 3]] 3
 * [(2, 2)]
*)
(* Find all occurrences of the integer `x` in a jagged 2‑D list and
   return their coordinates as a list of (row, column) tuples.
   Rows are sorted in ascending order, and for the same row the
   columns are sorted in descending order. *)
let get_row (lst : int list list) (x : int) : (int * int) list =
  (* Helper that walks through the rows, keeping the current row index. *)
  let rec aux rows row_idx acc =
    match rows with
    | [] -> acc
    | row :: rest ->
        (* Find all column indices in `row` where the value equals `x`. *)
        let rec find_indices row col_idx acc_inner =
          match row with
          | [] -> acc_inner
          | h :: tl ->
              let acc_inner' =
                if h = x then (row_idx, col_idx) :: acc_inner else acc_inner
              in
              find_indices tl (col_idx + 1) acc_inner'
        in
        let acc' = find_indices row 0 acc in
        aux rest (row_idx + 1) acc'
  in
  (* Collect all coordinates, then sort them as required. *)
  let coords = aux lst 0 [] in
  List.sort
    (fun (r1, c1) (r2, c2) ->
       if r1 <> r2 then compare r1 r2 else compare c2 c1)
    coords

let assertions =
 let candidate = get_row in
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1) = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)]));
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2) = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)]));
  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1) = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)]));
  (assert ((candidate [] 1) = []));
  (assert ((candidate [[1]] 2) = []));
  (assert ((candidate [[]; [1]; [1; 2; 3]] 3) = [(2, 2)]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183720
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 88 (ML) - HumanEval_88_sort_array
================================================================================

PROMPT:
----------------------------------------
(**Given a list of non-negative integers, return a coml of the given list after sorting,
 * you will sort the given list in ascending order if the sum( first index value, last index value) is odd,
 * or sort it in descending order if the sum( first index value, last index value) is even.
 * Note:
 * * don't change the given list.
 * Examples:
 * >>> sort_array []
 * []
 * >>> sort_array [5]
 * [5]
 * >>> sort_array [2; 4; 3; 0; 1; 5]
 * [0; 1; 2; 3; 4; 5]
 * >>> sort_array [2; 4; 3; 0; 1; 5; 6]
 * [6; 5; 4; 3; 2; 1; 0]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = sort_array in
  (assert ((candidate []) = []));
  (assert ((candidate [5]) = [5]));
  (assert ((candidate [2; 4; 3; 0; 1; 5]) = [0; 1; 2; 3; 4; 5]));
  (assert ((candidate [2; 4; 3; 0; 1; 5; 6]) = [6; 5; 4; 3; 2; 1; 0]));
  (assert ((candidate [2; 1]) = [1; 2]));
  (assert ((candidate [15; 42; 87; 32; 11; 0]) = [0; 11; 15; 32; 42; 87]));
  (assert ((candidate [21; 14; 23; 11]) = [23; 21; 14; 11]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given a list of non-negative integers, return a coml of the given list after sorting,
 * you will sort the given list in ascending order if the sum( first index value, last index value) is odd,
 * or sort it in descending order if the sum( first index value, last index value) is even.
 * Note:
 * * don't change the given list.
 * Examples:
 * >>> sort_array []
 * []
 * >>> sort_array [5]
 * [5]
 * >>> sort_array [2; 4; 3; 0; 1; 5]
 * [0; 1; 2; 3; 4; 5]
 * >>> sort_array [2; 4; 3; 0; 1; 5; 6]
 * [6; 5; 4; 3; 2; 1; 0]
*)
let sort_array (array : int list) : int list =
  match array with
  | [] | [_] -> array
  | _ ->
    let first = List.hd array in
    let last  = List.rev array |> List.hd in
    let sum   = first + last in
    if sum mod 2 = 1 then
      List.sort compare array          (* ascending if sum is odd *)
    else
      List.sort (fun a b -> compare b a) array  (* descending if sum is even *)

let assertions =
 let candidate = sort_array in
  (assert ((candidate []) = []));
  (assert ((candidate [5]) = [5]));
  (assert ((candidate [2; 4; 3; 0; 1; 5]) = [0; 1; 2; 3; 4; 5]));
  (assert ((candidate [2; 4; 3; 0; 1; 5; 6]) = [6; 5; 4; 3; 2; 1; 0]));
  (assert ((candidate [2; 1]) = [1; 2]));
  (assert ((candidate [15; 42; 87; 32; 11; 0]) = [0; 11; 15; 32; 42; 87]));
  (assert ((candidate [21; 14; 23; 11]) = [23; 21; 14; 11]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183721
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given a list of non-negative integers, return a coml of the given list after sorting,
 * you will sort the given list in ascending order if the sum( first index value, last index value) is odd,
 * or sort it in descending order if the sum( first index value, last index value) is even.
 * Note:
 * * don't change the given list.
 * Examples:
 * >>> sort_array []
 * []
 * >>> sort_array [5]
 * [5]
 * >>> sort_array [2; 4; 3; 0; 1; 5]
 * [0; 1; 2; 3; 4; 5]
 * >>> sort_array [2; 4; 3; 0; 1; 5; 6]
 * [6; 5; 4; 3; 2; 1; 0]
*)
(* Sort a list of non‑negative integers according to the sum of the first and
   last elements.  The function does **not** modify the original list. *)
let sort_array (array : int list) : int list =
  match array with
  | [] | [_] -> array          (* empty or single element lists stay the same *)
  | _ ->
      let first = List.hd array in
      let last  = List.nth array (List.length array - 1) in
      let sorted = List.sort compare array in
      if (first + last) mod 2 = 1 then
        sorted          (* ascending if the sum is odd *)
      else
        List.rev sorted (* descending if the sum is even *)

let assertions =
 let candidate = sort_array in
  (assert ((candidate []) = []));
  (assert ((candidate [5]) = [5]));
  (assert ((candidate [2; 4; 3; 0; 1; 5]) = [0; 1; 2; 3; 4; 5]));
  (assert ((candidate [2; 4; 3; 0; 1; 5; 6]) = [6; 5; 4; 3; 2; 1; 0]));
  (assert ((candidate [2; 1]) = [1; 2]));
  (assert ((candidate [15; 42; 87; 32; 11; 0]) = [0; 11; 15; 32; 42; 87]));
  (assert ((candidate [21; 14; 23; 11]) = [23; 21; 14; 11]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183721
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given a list of non-negative integers, return a coml of the given list after sorting,
 * you will sort the given list in ascending order if the sum( first index value, last index value) is odd,
 * or sort it in descending order if the sum( first index value, last index value) is even.
 * Note:
 * * don't change the given list.
 * Examples:
 * >>> sort_array []
 * []
 * >>> sort_array [5]
 * [5]
 * >>> sort_array [2; 4; 3; 0; 1; 5]
 * [0; 1; 2; 3; 4; 5]
 * >>> sort_array [2; 4; 3; 0; 1; 5; 6]
 * [6; 5; 4; 3; 2; 1; 0]
*)
let sort_array (array : int list) : int list =
  match array with
  | [] | [_] -> array
  | _ ->
      let first = List.hd array in
      let last  = List.rev array |> List.hd in
      let sum   = first + last in
      if sum mod 2 = 1 then
        List.sort compare array          (* ascending if odd *)
      else
        List.sort (fun a b -> compare b a) array  (* descending if even *)

let assertions =
 let candidate = sort_array in
  (assert ((candidate []) = []));
  (assert ((candidate [5]) = [5]));
  (assert ((candidate [2; 4; 3; 0; 1; 5]) = [0; 1; 2; 3; 4; 5]));
  (assert ((candidate [2; 4; 3; 0; 1; 5; 6]) = [6; 5; 4; 3; 2; 1; 0]));
  (assert ((candidate [2; 1]) = [1; 2]));
  (assert ((candidate [15; 42; 87; 32; 11; 0]) = [0; 11; 15; 32; 42; 87]));
  (assert ((candidate [21; 14; 23; 11]) = [23; 21; 14; 11]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183721
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given a list of non-negative integers, return a coml of the given list after sorting,
 * you will sort the given list in ascending order if the sum( first index value, last index value) is odd,
 * or sort it in descending order if the sum( first index value, last index value) is even.
 * Note:
 * * don't change the given list.
 * Examples:
 * >>> sort_array []
 * []
 * >>> sort_array [5]
 * [5]
 * >>> sort_array [2; 4; 3; 0; 1; 5]
 * [0; 1; 2; 3; 4; 5]
 * >>> sort_array [2; 4; 3; 0; 1; 5; 6]
 * [6; 5; 4; 3; 2; 1; 0]
*)
let sort_array (array : int list) : int list =
  match array with
  | [] | [_] -> array
  | _ ->
    let first = List.hd array in
    let last  = List.hd (List.rev array) in
    let sum   = first + last in
    if sum mod 2 = 0
    then List.sort (fun a b -> compare b a) array   (* descending *)
    else List.sort compare array                   (* ascending *)

let assertions =
 let candidate = sort_array in
  (assert ((candidate []) = []));
  (assert ((candidate [5]) = [5]));
  (assert ((candidate [2; 4; 3; 0; 1; 5]) = [0; 1; 2; 3; 4; 5]));
  (assert ((candidate [2; 4; 3; 0; 1; 5; 6]) = [6; 5; 4; 3; 2; 1; 0]));
  (assert ((candidate [2; 1]) = [1; 2]));
  (assert ((candidate [15; 42; 87; 32; 11; 0]) = [0; 11; 15; 32; 42; 87]));
  (assert ((candidate [21; 14; 23; 11]) = [23; 21; 14; 11]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183721
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 89 (ML) - HumanEval_89_encrypt
================================================================================

PROMPT:
----------------------------------------
(**Create a function encrypt that takes a string as an argument and
 * returns a string encrypted with the alphabet being rotated. 
 * The alphabet should be rotated in a manner such that the letters 
 * shift down by two multiplied to two places.
 * For example:
 * >>> encrypt "hi"
 * "lm"
 * >>> encrypt "asdfghjkl"
 * "ewhjklnop"
 * >>> encrypt "gf"
 * "kj"
 * >>> encrypt "et"
 * "ix"
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = encrypt in
  (assert ((candidate "hi") = "lm"));
  (assert ((candidate "asdfghjkl") = "ewhjklnop"));
  (assert ((candidate "gf") = "kj"));
  (assert ((candidate "et") = "ix"));
  (assert ((candidate "faewfawefaewg") = "jeiajeaijeiak"));
  (assert ((candidate "hellomyfriend") = "lippsqcjvmirh"));
  (assert ((candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") = "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"));
  (assert ((candidate "a") = "e"));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Create a function encrypt that takes a string as an argument and
 * returns a string encrypted with the alphabet being rotated. 
 * The alphabet should be rotated in a manner such that the letters 
 * shift down by two multiplied to two places.
 * For example:
 * >>> encrypt "hi"
 * "lm"
 * >>> encrypt "asdfghjkl"
 * "ewhjklnop"
 * >>> encrypt "gf"
 * "kj"
 * >>> encrypt "et"
 * "ix"
*)
(* Encrypt a string by shifting each lowercase letter forward by 4
   positions in the alphabet, wrapping around from 'z' to 'a'. *)
let encrypt (s : string) : string =
  String.map (fun c ->
    if 'a' <= c && c <= 'z' then
      let offset = (Char.code c - Char.code 'a' + 4) mod 26 in
      Char.chr (Char.code 'a' + offset)
    else
      c
  ) s

let assertions =
 let candidate = encrypt in
  (assert ((candidate "hi") = "lm"));
  (assert ((candidate "asdfghjkl") = "ewhjklnop"));
  (assert ((candidate "gf") = "kj"));
  (assert ((candidate "et") = "ix"));
  (assert ((candidate "faewfawefaewg") = "jeiajeaijeiak"));
  (assert ((candidate "hellomyfriend") = "lippsqcjvmirh"));
  (assert ((candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") = "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"));
  (assert ((candidate "a") = "e"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183721
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Create a function encrypt that takes a string as an argument and
 * returns a string encrypted with the alphabet being rotated. 
 * The alphabet should be rotated in a manner such that the letters 
 * shift down by two multiplied to two places.
 * For example:
 * >>> encrypt "hi"
 * "lm"
 * >>> encrypt "asdfghjkl"
 * "ewhjklnop"
 * >>> encrypt "gf"
 * "kj"
 * >>> encrypt "et"
 * "ix"
*)
let encrypt (s : string) : string =
  let shift_char c =
    if 'a' <= c && c <= 'z' then
      let base = Char.code 'a' in
      let offset = (Char.code c - base + 4) mod 26 in
      Char.chr (base + offset)
    else if 'A' <= c && c <= 'Z' then
      let base = Char.code 'A' in
      let offset = (Char.code c - base + 4) mod 26 in
      Char.chr (base + offset)
    else c
  in
  String.map shift_char s

let assertions =
 let candidate = encrypt in
  (assert ((candidate "hi") = "lm"));
  (assert ((candidate "asdfghjkl") = "ewhjklnop"));
  (assert ((candidate "gf") = "kj"));
  (assert ((candidate "et") = "ix"));
  (assert ((candidate "faewfawefaewg") = "jeiajeaijeiak"));
  (assert ((candidate "hellomyfriend") = "lippsqcjvmirh"));
  (assert ((candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") = "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"));
  (assert ((candidate "a") = "e"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183721
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Create a function encrypt that takes a string as an argument and
 * returns a string encrypted with the alphabet being rotated. 
 * The alphabet should be rotated in a manner such that the letters 
 * shift down by two multiplied to two places.
 * For example:
 * >>> encrypt "hi"
 * "lm"
 * >>> encrypt "asdfghjkl"
 * "ewhjklnop"
 * >>> encrypt "gf"
 * "kj"
 * >>> encrypt "et"
 * "ix"
*)
let encrypt (s : string) : string =
  String.map (fun c ->
    if c >= 'a' && c <= 'z' then
      let base = int_of_char 'a' in
      let offset = (int_of_char c - base + 4) mod 26 in
      char_of_int (base + offset)
    else if c >= 'A' && c <= 'Z' then
      let base = int_of_char 'A' in
      let offset = (int_of_char c - base + 4) mod 26 in
      char_of_int (base + offset)
    else
      c
  ) s

let assertions =
 let candidate = encrypt in
  (assert ((candidate "hi") = "lm"));
  (assert ((candidate "asdfghjkl") = "ewhjklnop"));
  (assert ((candidate "gf") = "kj"));
  (assert ((candidate "et") = "ix"));
  (assert ((candidate "faewfawefaewg") = "jeiajeaijeiak"));
  (assert ((candidate "hellomyfriend") = "lippsqcjvmirh"));
  (assert ((candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") = "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"));
  (assert ((candidate "a") = "e"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183721
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Create a function encrypt that takes a string as an argument and
 * returns a string encrypted with the alphabet being rotated. 
 * The alphabet should be rotated in a manner such that the letters 
 * shift down by two multiplied to two places.
 * For example:
 * >>> encrypt "hi"
 * "lm"
 * >>> encrypt "asdfghjkl"
 * "ewhjklnop"
 * >>> encrypt "gf"
 * "kj"
 * >>> encrypt "et"
 * "ix"
*)
(** Encrypt a string by shifting each lowercase letter forward by 4
    positions in the alphabet (a Caesar cipher with key 4).  *)
let encrypt (s : string) : string =
  let shift_char c =
    if 'a' <= c && c <= 'z' then
      let base = Char.code 'a' in
      let offset = Char.code c - base in
      Char.chr ((offset + 4) mod 26 + base)
    else c
  in
  String.map shift_char s

let assertions =
 let candidate = encrypt in
  (assert ((candidate "hi") = "lm"));
  (assert ((candidate "asdfghjkl") = "ewhjklnop"));
  (assert ((candidate "gf") = "kj"));
  (assert ((candidate "et") = "ix"));
  (assert ((candidate "faewfawefaewg") = "jeiajeaijeiak"));
  (assert ((candidate "hellomyfriend") = "lippsqcjvmirh"));
  (assert ((candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") = "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"));
  (assert ((candidate "a") = "e"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183721
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 96 (ML) - HumanEval_96_count_up_to
================================================================================

PROMPT:
----------------------------------------
(**Implement a function that takes an non-negative integer and returns a list of the first n
 * integers that are prime numbers and less than n.
 * for example:
 * >>> count_up_to 5
 * [2; 3]
 * >>> count_up_to 11
 * [2; 3; 5; 7]
 * >>> count_up_to 0
 * []
 * >>> count_up_to 20
 * [2; 3; 5; 7; 11; 13; 17; 19]
 * >>> count_up_to 1
 * []
 * >>> count_up_to 18
 * [2; 3; 5; 7; 11; 13; 17]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = count_up_to in
  (assert ((candidate 5) = [2; 3]));
  (assert ((candidate 6) = [2; 3; 5]));
  (assert ((candidate 7) = [2; 3; 5]));
  (assert ((candidate 10) = [2; 3; 5; 7]));
  (assert ((candidate 0) = []));
  (assert ((candidate 22) = [2; 3; 5; 7; 11; 13; 17; 19]));
  (assert ((candidate 1) = []));
  (assert ((candidate 18) = [2; 3; 5; 7; 11; 13; 17]));
  (assert ((candidate 47) = [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43]));
  (assert ((candidate 101) = [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71; 73; 79; 83; 89; 97]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Implement a function that takes an non-negative integer and returns a list of the first n
 * integers that are prime numbers and less than n.
 * for example:
 * >>> count_up_to 5
 * [2; 3]
 * >>> count_up_to 11
 * [2; 3; 5; 7]
 * >>> count_up_to 0
 * []
 * >>> count_up_to 20
 * [2; 3; 5; 7; 11; 13; 17; 19]
 * >>> count_up_to 1
 * []
 * >>> count_up_to 18
 * [2; 3; 5; 7; 11; 13; 17]
*)
let count_up_to (n : int) : int list =
  (* Helper to test primality of a number m *)
  let rec is_prime m =
    if m <= 1 then false
    else if m = 2 then true
    else
      let rec check d =
        if d * d > m then true
        else if m mod d = 0 then false
        else check (d + 1)
      in
      check 2
  in
  (* Build the list of primes less than n *)
  let rec aux i acc =
    if i >= n then List.rev acc
    else if is_prime i then aux (i + 1) (i :: acc)
    else aux (i + 1) acc
  in
  aux 2 []

let assertions =
 let candidate = count_up_to in
  (assert ((candidate 5) = [2; 3]));
  (assert ((candidate 6) = [2; 3; 5]));
  (assert ((candidate 7) = [2; 3; 5]));
  (assert ((candidate 10) = [2; 3; 5; 7]));
  (assert ((candidate 0) = []));
  (assert ((candidate 22) = [2; 3; 5; 7; 11; 13; 17; 19]));
  (assert ((candidate 1) = []));
  (assert ((candidate 18) = [2; 3; 5; 7; 11; 13; 17]));
  (assert ((candidate 47) = [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43]));
  (assert ((candidate 101) = [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71; 73; 79; 83; 89; 97]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183722
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Implement a function that takes an non-negative integer and returns a list of the first n
 * integers that are prime numbers and less than n.
 * for example:
 * >>> count_up_to 5
 * [2; 3]
 * >>> count_up_to 11
 * [2; 3; 5; 7]
 * >>> count_up_to 0
 * []
 * >>> count_up_to 20
 * [2; 3; 5; 7; 11; 13; 17; 19]
 * >>> count_up_to 1
 * []
 * >>> count_up_to 18
 * [2; 3; 5; 7; 11; 13; 17]
*)
(* Count all prime numbers strictly less than n *)
let count_up_to (n : int) : int list =
  (* Simple primality test *)
  let is_prime m =
    if m < 2 then false
    else
      let rec check d =
        if d * d > m then true
        else if m mod d = 0 then false
        else check (d + 1)
      in
      check 2
  in
  (* Build the list in reverse order for efficiency *)
  let rec aux i acc =
    if i >= n then List.rev acc
    else if is_prime i then aux (i + 1) (i :: acc)
    else aux (i + 1) acc
  in
  aux 2 []

let assertions =
 let candidate = count_up_to in
  (assert ((candidate 5) = [2; 3]));
  (assert ((candidate 6) = [2; 3; 5]));
  (assert ((candidate 7) = [2; 3; 5]));
  (assert ((candidate 10) = [2; 3; 5; 7]));
  (assert ((candidate 0) = []));
  (assert ((candidate 22) = [2; 3; 5; 7; 11; 13; 17; 19]));
  (assert ((candidate 1) = []));
  (assert ((candidate 18) = [2; 3; 5; 7; 11; 13; 17]));
  (assert ((candidate 47) = [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43]));
  (assert ((candidate 101) = [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71; 73; 79; 83; 89; 97]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183722
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Implement a function that takes an non-negative integer and returns a list of the first n
 * integers that are prime numbers and less than n.
 * for example:
 * >>> count_up_to 5
 * [2; 3]
 * >>> count_up_to 11
 * [2; 3; 5; 7]
 * >>> count_up_to 0
 * []
 * >>> count_up_to 20
 * [2; 3; 5; 7; 11; 13; 17; 19]
 * >>> count_up_to 1
 * []
 * >>> count_up_to 18
 * [2; 3; 5; 7; 11; 13; 17]
*)
(* Return all prime numbers strictly less than n *)
let count_up_to (n : int) : int list =
  (* Helper to test primality *)
  let is_prime x =
    if x <= 1 then false
    else if x = 2 then true
    else if x mod 2 = 0 then false
    else
      let rec check d =
        if d * d > x then true
        else if x mod d = 0 then false
        else check (d + 2)
      in
      check 3
  in

  (* Build the list by iterating from 2 up to n-1 *)
  let rec aux current acc =
    if current >= n then List.rev acc
    else if is_prime current then aux (current + 1) (current :: acc)
    else aux (current + 1) acc
  in
  aux 2 []

let assertions =
 let candidate = count_up_to in
  (assert ((candidate 5) = [2; 3]));
  (assert ((candidate 6) = [2; 3; 5]));
  (assert ((candidate 7) = [2; 3; 5]));
  (assert ((candidate 10) = [2; 3; 5; 7]));
  (assert ((candidate 0) = []));
  (assert ((candidate 22) = [2; 3; 5; 7; 11; 13; 17; 19]));
  (assert ((candidate 1) = []));
  (assert ((candidate 18) = [2; 3; 5; 7; 11; 13; 17]));
  (assert ((candidate 47) = [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43]));
  (assert ((candidate 101) = [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71; 73; 79; 83; 89; 97]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183722
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Implement a function that takes an non-negative integer and returns a list of the first n
 * integers that are prime numbers and less than n.
 * for example:
 * >>> count_up_to 5
 * [2; 3]
 * >>> count_up_to 11
 * [2; 3; 5; 7]
 * >>> count_up_to 0
 * []
 * >>> count_up_to 20
 * [2; 3; 5; 7; 11; 13; 17; 19]
 * >>> count_up_to 1
 * []
 * >>> count_up_to 18
 * [2; 3; 5; 7; 11; 13; 17]
*)
(* Return all prime numbers strictly less than n. *)
let count_up_to (n : int) : int list =
  (* Test whether a number is prime. *)
  let is_prime x =
    if x < 2 then false
    else
      let rec check d =
        d * d > x || (x mod d <> 0 && check (d + 1))
      in
      check 2
  in
  (* Build the list of primes by iterating from 2 up to n-1. *)
  let rec aux i acc =
    if i >= n then List.rev acc
    else if is_prime i then aux (i + 1) (i :: acc)
    else aux (i + 1) acc
  in
  aux 2 []

let assertions =
 let candidate = count_up_to in
  (assert ((candidate 5) = [2; 3]));
  (assert ((candidate 6) = [2; 3; 5]));
  (assert ((candidate 7) = [2; 3; 5]));
  (assert ((candidate 10) = [2; 3; 5; 7]));
  (assert ((candidate 0) = []));
  (assert ((candidate 22) = [2; 3; 5; 7; 11; 13; 17; 19]));
  (assert ((candidate 1) = []));
  (assert ((candidate 18) = [2; 3; 5; 7; 11; 13; 17]));
  (assert ((candidate 47) = [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43]));
  (assert ((candidate 101) = [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71; 73; 79; 83; 89; 97]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183722
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 98 (ML) - HumanEval_98_count_upper
================================================================================

PROMPT:
----------------------------------------
(**Given a string s, count the number of uppercase vowels in even indices.
 * For example:
 * >>> count_upper "aBCdEf"
 * 1
 * >>> count_upper "abcdefg"
 * 0
 * >>> count_upper "dBBE"
 * 0
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = count_upper in
  (assert ((candidate "aBCdEf") = 1));
  (assert ((candidate "abcdefg") = 0));
  (assert ((candidate "dBBE") = 0));
  (assert ((candidate "B") = 0));
  (assert ((candidate "U") = 1));
  (assert ((candidate "") = 0));
  (assert ((candidate "EEEE") = 2));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given a string s, count the number of uppercase vowels in even indices.
 * For example:
 * >>> count_upper "aBCdEf"
 * 1
 * >>> count_upper "abcdefg"
 * 0
 * >>> count_upper "dBBE"
 * 0
*)
(* Count the number of uppercase vowels that appear at even indices. *)
let count_upper (s : string) : int =
  let len = String.length s in
  let rec aux i acc =
    if i >= len then acc
    else
      let c = s.[i] in
      let acc' =
        if (i mod 2 = 0) &&
           (c = 'A' || c = 'E' || c = 'I' || c = 'O' || c = 'U')
        then acc + 1
        else acc
      in
      aux (i + 1) acc'
  in
  aux 0 0

let assertions =
 let candidate = count_upper in
  (assert ((candidate "aBCdEf") = 1));
  (assert ((candidate "abcdefg") = 0));
  (assert ((candidate "dBBE") = 0));
  (assert ((candidate "B") = 0));
  (assert ((candidate "U") = 1));
  (assert ((candidate "") = 0));
  (assert ((candidate "EEEE") = 2));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183722
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given a string s, count the number of uppercase vowels in even indices.
 * For example:
 * >>> count_upper "aBCdEf"
 * 1
 * >>> count_upper "abcdefg"
 * 0
 * >>> count_upper "dBBE"
 * 0
*)
let count_upper (s : string) : int =
  let len = String.length s in
  let count = ref 0 in
  for i = 0 to len - 1 do
    if i mod 2 = 0 then
      match s.[i] with
      | 'A' | 'E' | 'I' | 'O' | 'U' -> incr count
      | _ -> ()
  done;
  !count

let assertions =
 let candidate = count_upper in
  (assert ((candidate "aBCdEf") = 1));
  (assert ((candidate "abcdefg") = 0));
  (assert ((candidate "dBBE") = 0));
  (assert ((candidate "B") = 0));
  (assert ((candidate "U") = 1));
  (assert ((candidate "") = 0));
  (assert ((candidate "EEEE") = 2));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183722
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given a string s, count the number of uppercase vowels in even indices.
 * For example:
 * >>> count_upper "aBCdEf"
 * 1
 * >>> count_upper "abcdefg"
 * 0
 * >>> count_upper "dBBE"
 * 0
*)
let count_upper (s : string) : int =
  let len = String.length s in
  let rec aux i acc =
    if i >= len then acc
    else
      let c = s.[i] in
      let acc' =
        if i mod 2 = 0 &&
           (c = 'A' || c = 'E' || c = 'I' || c = 'O' || c = 'U')
        then acc + 1
        else acc
      in
      aux (i + 1) acc'
  in
  aux 0 0

let assertions =
 let candidate = count_upper in
  (assert ((candidate "aBCdEf") = 1));
  (assert ((candidate "abcdefg") = 0));
  (assert ((candidate "dBBE") = 0));
  (assert ((candidate "B") = 0));
  (assert ((candidate "U") = 1));
  (assert ((candidate "") = 0));
  (assert ((candidate "EEEE") = 2));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183722
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given a string s, count the number of uppercase vowels in even indices.
 * For example:
 * >>> count_upper "aBCdEf"
 * 1
 * >>> count_upper "abcdefg"
 * 0
 * >>> count_upper "dBBE"
 * 0
*)
let count_upper (s : string) : int =
  let len = String.length s in
  let count = ref 0 in
  for i = 0 to len - 1 do
    if i mod 2 = 0 then
      match s.[i] with
      | 'A' | 'E' | 'I' | 'O' | 'U' -> incr count
      | _ -> ()
  done;
  !count

let assertions =
 let candidate = count_upper in
  (assert ((candidate "aBCdEf") = 1));
  (assert ((candidate "abcdefg") = 0));
  (assert ((candidate "dBBE") = 0));
  (assert ((candidate "B") = 0));
  (assert ((candidate "U") = 1));
  (assert ((candidate "") = 0));
  (assert ((candidate "EEEE") = 2));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183722
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 100 (ML) - HumanEval_100_make_a_pile
================================================================================

PROMPT:
----------------------------------------
(**Given a positive integer n, you have to make a pile of n levels of stones.
 * The first level has n stones.
 * The number of stones in the next level is:
 * - the next odd number if n is odd.
 * - the next even number if n is even.
 * Return the number of stones in each level in a list, where element at index
 * i represents the number of stones in the level (i+1).
 * Examples:
 * >>> make_a_pile 3
 * [3; 5; 7]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = make_a_pile in
  (assert ((candidate 3) = [3; 5; 7]));
  (assert ((candidate 4) = [4; 6; 8; 10]));
  (assert ((candidate 5) = [5; 7; 9; 11; 13]));
  (assert ((candidate 6) = [6; 8; 10; 12; 14; 16]));
  (assert ((candidate 8) = [8; 10; 12; 14; 16; 18; 20; 22]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given a positive integer n, you have to make a pile of n levels of stones.
 * The first level has n stones.
 * The number of stones in the next level is:
 * - the next odd number if n is odd.
 * - the next even number if n is even.
 * Return the number of stones in each level in a list, where element at index
 * i represents the number of stones in the level (i+1).
 * Examples:
 * >>> make_a_pile 3
 * [3; 5; 7]
*)
let make_a_pile (n : int) : int list =
  (* Generate `n` numbers starting from `n`, each two more than the previous *)
  List.init n (fun k -> n + 2 * k)

let assertions =
 let candidate = make_a_pile in
  (assert ((candidate 3) = [3; 5; 7]));
  (assert ((candidate 4) = [4; 6; 8; 10]));
  (assert ((candidate 5) = [5; 7; 9; 11; 13]));
  (assert ((candidate 6) = [6; 8; 10; 12; 14; 16]));
  (assert ((candidate 8) = [8; 10; 12; 14; 16; 18; 20; 22]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183722
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given a positive integer n, you have to make a pile of n levels of stones.
 * The first level has n stones.
 * The number of stones in the next level is:
 * - the next odd number if n is odd.
 * - the next even number if n is even.
 * Return the number of stones in each level in a list, where element at index
 * i represents the number of stones in the level (i+1).
 * Examples:
 * >>> make_a_pile 3
 * [3; 5; 7]
*)
(* Given a positive integer n, you have to make a pile of n levels of stones.
 * The first level has n stones.
 * The number of stones in the next level is:
 * - the next odd number if n is odd.
 * - the next even number if n is even.
 * Return the number of stones in each level in a list, where element at index
 * i represents the number of stones in the level (i+1).
 * Examples:
 * >>> make_a_pile 3
 * [3; 5; 7]
 *)
let make_a_pile (n : int) : int list =
  List.init n (fun i -> n + 2 * i)

let assertions =
 let candidate = make_a_pile in
  (assert ((candidate 3) = [3; 5; 7]));
  (assert ((candidate 4) = [4; 6; 8; 10]));
  (assert ((candidate 5) = [5; 7; 9; 11; 13]));
  (assert ((candidate 6) = [6; 8; 10; 12; 14; 16]));
  (assert ((candidate 8) = [8; 10; 12; 14; 16; 18; 20; 22]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183722
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given a positive integer n, you have to make a pile of n levels of stones.
 * The first level has n stones.
 * The number of stones in the next level is:
 * - the next odd number if n is odd.
 * - the next even number if n is even.
 * Return the number of stones in each level in a list, where element at index
 * i represents the number of stones in the level (i+1).
 * Examples:
 * >>> make_a_pile 3
 * [3; 5; 7]
*)
(* Generates a pile of stones with `n` levels.  
   The first level contains `n` stones.  
   Each subsequent level contains the next odd number if the current level
   count is odd, or the next even number if the current level count is even.  
   Since the parity never changes, each level increases by 2. *)
let make_a_pile (n : int) : int list =
  let rec aux current remaining =
    if remaining = 0 then []
    else current :: aux (current + 2) (remaining - 1)
  in
  aux n n

let assertions =
 let candidate = make_a_pile in
  (assert ((candidate 3) = [3; 5; 7]));
  (assert ((candidate 4) = [4; 6; 8; 10]));
  (assert ((candidate 5) = [5; 7; 9; 11; 13]));
  (assert ((candidate 6) = [6; 8; 10; 12; 14; 16]));
  (assert ((candidate 8) = [8; 10; 12; 14; 16; 18; 20; 22]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183722
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given a positive integer n, you have to make a pile of n levels of stones.
 * The first level has n stones.
 * The number of stones in the next level is:
 * - the next odd number if n is odd.
 * - the next even number if n is even.
 * Return the number of stones in each level in a list, where element at index
 * i represents the number of stones in the level (i+1).
 * Examples:
 * >>> make_a_pile 3
 * [3; 5; 7]
*)
(* Return a list of `n` levels of stones.
   The first level contains `n` stones, and each subsequent level
   contains the next odd (if `n` is odd) or even (if `n` is even)
   number, i.e. we add 2 at each step. *)
let make_a_pile (n : int) : int list =
  (* Build the list in one pass: level i (0‑based) has n + 2*i stones. *)
  List.init n (fun i -> n + 2 * i)

let assertions =
 let candidate = make_a_pile in
  (assert ((candidate 3) = [3; 5; 7]));
  (assert ((candidate 4) = [4; 6; 8; 10]));
  (assert ((candidate 5) = [5; 7; 9; 11; 13]));
  (assert ((candidate 6) = [6; 8; 10; 12; 14; 16]));
  (assert ((candidate 8) = [8; 10; 12; 14; 16; 18; 20; 22]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183722
STDOUT: (empty)
STDERR: (empty)
--------------------
