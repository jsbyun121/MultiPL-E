As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 152 (RKT) - HumanEval_152_compare
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; I think we all remember that feeling when the result of some long-awaited
;; event is finally known. The feelings and thoughts you have at that moment are
;; definitely worth noting down and comparing.
;; Your task is to determine if a person correctly guessed the results of a number of matches.
;; You are given two lists of scores and guesses of equal length, where each index shows a match. 
;; Return a list of the same length denoting how far off each guess was. If they have guessed correctly,
;; the value is 0, and if not, the value is the absolute difference between the guess and the score.
;; example:
;; >>> (compare (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2))
;; (list 0 0 0 0 3 3)
;; >>> (compare (list 0 5 0 0 0 4) (list 4 1 1 0 0 -2))
;; (list 4 4 1 0 0 6)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate compare))
    (check-within (candidate (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2)) (list 0 0 0 0 3 3) 0.001)
    (check-within (candidate (list 0 0 0 0 0 0) (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0) 0.001)
    (check-within (candidate (list 1 2 3) (list -1 -2 -3)) (list 2 4 6) 0.001)
    (check-within (candidate (list 1 2 3 5) (list -1 2 3 4)) (list 2 0 0 1) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; I think we all remember that feeling when the result of some long-awaited
;; event is finally known. The feelings and thoughts you have at that moment are
;; definitely worth noting down and comparing.
;; Your task is to determine if a person correctly guessed the results of a number of matches.
;; You are given two lists of scores and guesses of equal length, where each index shows a match. 
;; Return a list of the same length denoting how far off each guess was. If they have guessed correctly,
;; the value is 0, and if not, the value is the absolute difference between the guess and the score.
;; example:
;; >>> (compare (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2))
;; (list 0 0 0 0 3 3)
;; >>> (compare (list 0 5 0 0 0 4) (list 4 1 1 0 0 -2))
;; (list 4 4 1 0 0 6)

;; Compare a list of game scores with a list of guesses.
;; Returns a list of the same length where each element is
;; the absolute difference between the corresponding score
;; and guess. A difference of 0 indicates a correct guess.
(define (compare game guess)
  (map (lambda (score guess) (abs (- score guess)))
       game
       guess))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate compare))
    (check-within (candidate (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2)) (list 0 0 0 0 3 3) 0.001)
    (check-within (candidate (list 0 0 0 0 0 0) (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0) 0.001)
    (check-within (candidate (list 1 2 3) (list -1 -2 -3)) (list 2 4 6) 0.001)
    (check-within (candidate (list 1 2 3 5) (list -1 2 3 4)) (list 2 0 0 1) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828007
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; I think we all remember that feeling when the result of some long-awaited
;; event is finally known. The feelings and thoughts you have at that moment are
;; definitely worth noting down and comparing.
;; Your task is to determine if a person correctly guessed the results of a number of matches.
;; You are given two lists of scores and guesses of equal length, where each index shows a match. 
;; Return a list of the same length denoting how far off each guess was. If they have guessed correctly,
;; the value is 0, and if not, the value is the absolute difference between the guess and the score.
;; example:
;; >>> (compare (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2))
;; (list 0 0 0 0 3 3)
;; >>> (compare (list 0 5 0 0 0 4) (list 4 1 1 0 0 -2))
;; (list 4 4 1 0 0 6)

;; Return a list of absolute differences between the corresponding elements
;; of the two lists `game` and `guess`.  If the guess is correct the
;; difference is 0.
(define (compare game guess)
  (map (lambda (g gr) (abs (- g gr))) game guess))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate compare))
    (check-within (candidate (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2)) (list 0 0 0 0 3 3) 0.001)
    (check-within (candidate (list 0 0 0 0 0 0) (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0) 0.001)
    (check-within (candidate (list 1 2 3) (list -1 -2 -3)) (list 2 4 6) 0.001)
    (check-within (candidate (list 1 2 3 5) (list -1 2 3 4)) (list 2 0 0 1) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828007
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; I think we all remember that feeling when the result of some long-awaited
;; event is finally known. The feelings and thoughts you have at that moment are
;; definitely worth noting down and comparing.
;; Your task is to determine if a person correctly guessed the results of a number of matches.
;; You are given two lists of scores and guesses of equal length, where each index shows a match. 
;; Return a list of the same length denoting how far off each guess was. If they have guessed correctly,
;; the value is 0, and if not, the value is the absolute difference between the guess and the score.
;; example:
;; >>> (compare (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2))
;; (list 0 0 0 0 3 3)
;; >>> (compare (list 0 5 0 0 0 4) (list 4 1 1 0 0 -2))
;; (list 4 4 1 0 0 6)

;; Return a list of the absolute differences between corresponding elements
;; of the two input lists.  If a guess matches the score exactly, the
;; difference is 0.
(define (compare game guess)
  (map (lambda (s g) (abs (- s g))) game guess))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate compare))
    (check-within (candidate (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2)) (list 0 0 0 0 3 3) 0.001)
    (check-within (candidate (list 0 0 0 0 0 0) (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0) 0.001)
    (check-within (candidate (list 1 2 3) (list -1 -2 -3)) (list 2 4 6) 0.001)
    (check-within (candidate (list 1 2 3 5) (list -1 2 3 4)) (list 2 0 0 1) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828007
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; I think we all remember that feeling when the result of some long-awaited
;; event is finally known. The feelings and thoughts you have at that moment are
;; definitely worth noting down and comparing.
;; Your task is to determine if a person correctly guessed the results of a number of matches.
;; You are given two lists of scores and guesses of equal length, where each index shows a match. 
;; Return a list of the same length denoting how far off each guess was. If they have guessed correctly,
;; the value is 0, and if not, the value is the absolute difference between the guess and the score.
;; example:
;; >>> (compare (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2))
;; (list 0 0 0 0 3 3)
;; >>> (compare (list 0 5 0 0 0 4) (list 4 1 1 0 0 -2))
;; (list 4 4 1 0 0 6)

;; Return a list of the absolute differences between corresponding elements
;; of the two input lists.  If a pair of elements are equal, the difference
;; is 0 (since |x - x| = 0).
(define (compare game guess)
  (map (lambda (x y) (abs (- x y))) game guess))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate compare))
    (check-within (candidate (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2)) (list 0 0 0 0 3 3) 0.001)
    (check-within (candidate (list 0 0 0 0 0 0) (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0) 0.001)
    (check-within (candidate (list 1 2 3) (list -1 -2 -3)) (list 2 4 6) 0.001)
    (check-within (candidate (list 1 2 3 5) (list -1 2 3 4)) (list 2 0 0 1) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828007
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 154 (RKT) - HumanEval_154_cycpattern_check
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-within (candidate "xyzw" "xyw") #f 0.001)
    (check-within (candidate "yello" "ell") #t 0.001)
    (check-within (candidate "whattup" "ptut") #f 0.001)
    (check-within (candidate "efef" "fee") #t 0.001)
    (check-within (candidate "abab" "aabb") #f 0.001)
    (check-within (candidate "winemtt" "tinem") #t 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t

(require racket/string)

;; You are given 2 words. You need to return #t if the second word or any of its rotations
;; is a substring in the first word
;;
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t

(define (cycpattern_check a b)
  ;; Return #t if any rotation of b is a substring of a
  (define len (string-length b))
  ;; If b is longer than a, no rotation can be a substring
  (if (> len (string-length a))
      #f
      (let loop ([i 0])
        (cond
          [(>= i len) #f]  ; no rotation found
          [else
           (define rotation
             (string-append (substring b i len)
                            (substring b 0 i)))
           (if (string-contains? a rotation)
               #t
               (loop (add1 i)))]))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-within (candidate "xyzw" "xyw") #f 0.001)
    (check-within (candidate "yello" "ell") #t 0.001)
    (check-within (candidate "whattup" "ptut") #f 0.001)
    (check-within (candidate "efef" "fee") #t 0.001)
    (check-within (candidate "abab" "aabb") #f 0.001)
    (check-within (candidate "winemtt" "tinem") #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828009
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t

(define (cycpattern_check a b)
  ;; Helper: generate all rotations of b
  (define (rotations s)
    (let* ((len (string-length s))
           (double (string-append s s)))
      (for/list ([i (in-range len)])
        (substring double i (+ i len)))))

  ;; Check each rotation against a
  (ormap (λ (rot) (string-contains? a rot))
         (rotations b)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-within (candidate "xyzw" "xyw") #f 0.001)
    (check-within (candidate "yello" "ell") #t 0.001)
    (check-within (candidate "whattup" "ptut") #f 0.001)
    (check-within (candidate "efef" "fee") #t 0.001)
    (check-within (candidate "abab" "aabb") #f 0.001)
    (check-within (candidate "winemtt" "tinem") #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828009
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t

;; You are given 2 words. You need to return #t if the second word or any of its rotations
;; is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  ;; Helper to produce the i‑th rotation of b
  (define (rotation i)
    (string-append (substring b i (string-length b))
                   (substring b 0 i)))

  ;; Recursive search over all rotations
  (define (search i)
    (cond
      [(>= i (string-length b)) #f]                     ; no match found
      [(string-contains? a (rotation i)) #t]            ; match found
      [else (search (+ i 1))]))                        ; try next rotation

  (search 0))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-within (candidate "xyzw" "xyw") #f 0.001)
    (check-within (candidate "yello" "ell") #t 0.001)
    (check-within (candidate "whattup" "ptut") #f 0.001)
    (check-within (candidate "efef" "fee") #t 0.001)
    (check-within (candidate "abab" "aabb") #f 0.001)
    (check-within (candidate "winemtt" "tinem") #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828009
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t

(define (cycpattern_check a b)
  (define len (string-length b))
  (define (rot i)
    (string-append (substring b i) (substring b 0 i)))
  (let loop ([i 0])
    (cond
      [(>= i len) #f]
      [(string-contains? a (rot i)) #t]
      [else (loop (+ i 1))])))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-within (candidate "xyzw" "xyw") #f 0.001)
    (check-within (candidate "yello" "ell") #t 0.001)
    (check-within (candidate "whattup" "ptut") #f 0.001)
    (check-within (candidate "efef" "fee") #t 0.001)
    (check-within (candidate "abab" "aabb") #f 0.001)
    (check-within (candidate "winemtt" "tinem") #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828009
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 157 (RKT) - HumanEval_157_right_angle_triangle
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given the lengths of the three sides of a triangle. Return #t if the three
;; sides form a right-angled triangle, #f otherwise.
;; A right-angled triangle is a triangle in which one angle is right angle or 
;; 90 degree.
;; Example:
;; >>> (right_angle_triangle 3 4 5)
;; #t
;; >>> (right_angle_triangle 1 2 3)
;; #f

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate right_angle_triangle))
    (check-within (candidate 3 4 5) #t 0.001)
    (check-within (candidate 1 2 3) #f 0.001)
    (check-within (candidate 10 6 8) #t 0.001)
    (check-within (candidate 2 2 2) #f 0.001)
    (check-within (candidate 7 24 25) #t 0.001)
    (check-within (candidate 10 5 7) #f 0.001)
    (check-within (candidate 5 12 13) #t 0.001)
    (check-within (candidate 15 8 17) #t 0.001)
    (check-within (candidate 48 55 73) #t 0.001)
    (check-within (candidate 1 1 1) #f 0.001)
    (check-within (candidate 2 2 10) #f 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given the lengths of the three sides of a triangle. Return #t if the three
;; sides form a right-angled triangle, #f otherwise.
;; A right-angled triangle is a triangle in which one angle is right angle or 
;; 90 degree.
;; Example:
;; >>> (right_angle_triangle 3 4 5)
;; #t
;; >>> (right_angle_triangle 1 2 3)
;; #f

;; Given the lengths of the three sides of a triangle. Return #t if the three
;; sides form a right-angled triangle, #f otherwise.
;; A right-angled triangle is a triangle in which one angle is right angle or 
;; 90 degree.
;; Example:
;; >>> (right_angle_triangle 3 4 5)
;; #t
;; >>> (right_angle_triangle 1 2 3)
;; #f
(define (right_angle_triangle a b c)
  (let* ((sides (sort (list a b c) <))            ; sort sides ascending
         (x (first sides))
         (y (second sides))
         (z (third sides)))
    (and (> x 0) (> y 0) (> z 0)                    ; all sides positive
         (= (+ (* x x) (* y y)) (* z z)))))         ; Pythagorean check
(require rackunit)

(define (test-humaneval) 

  (let (( candidate right_angle_triangle))
    (check-within (candidate 3 4 5) #t 0.001)
    (check-within (candidate 1 2 3) #f 0.001)
    (check-within (candidate 10 6 8) #t 0.001)
    (check-within (candidate 2 2 2) #f 0.001)
    (check-within (candidate 7 24 25) #t 0.001)
    (check-within (candidate 10 5 7) #f 0.001)
    (check-within (candidate 5 12 13) #t 0.001)
    (check-within (candidate 15 8 17) #t 0.001)
    (check-within (candidate 48 55 73) #t 0.001)
    (check-within (candidate 1 1 1) #f 0.001)
    (check-within (candidate 2 2 10) #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828011
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given the lengths of the three sides of a triangle. Return #t if the three
;; sides form a right-angled triangle, #f otherwise.
;; A right-angled triangle is a triangle in which one angle is right angle or 
;; 90 degree.
;; Example:
;; >>> (right_angle_triangle 3 4 5)
;; #t
;; >>> (right_angle_triangle 1 2 3)
;; #f

;; Given the lengths of the three sides of a triangle. Return #t if the three
;; sides form a right-angled triangle, #f otherwise.
;; A right-angled triangle is a triangle in which one angle is right angle or 
;; 90 degree.
;; Example:
;; >>> (right_angle_triangle 3 4 5)
;; #t
;; >>> (right_angle_triangle 1 2 3)
;; #f
(define (right_angle_triangle a b c)
  (define (square x) (* x x))
  (or (= (+ (square a) (square b)) (square c))
      (= (+ (square a) (square c)) (square b))
      (= (+ (square b) (square c)) (square a))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate right_angle_triangle))
    (check-within (candidate 3 4 5) #t 0.001)
    (check-within (candidate 1 2 3) #f 0.001)
    (check-within (candidate 10 6 8) #t 0.001)
    (check-within (candidate 2 2 2) #f 0.001)
    (check-within (candidate 7 24 25) #t 0.001)
    (check-within (candidate 10 5 7) #f 0.001)
    (check-within (candidate 5 12 13) #t 0.001)
    (check-within (candidate 15 8 17) #t 0.001)
    (check-within (candidate 48 55 73) #t 0.001)
    (check-within (candidate 1 1 1) #f 0.001)
    (check-within (candidate 2 2 10) #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828011
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given the lengths of the three sides of a triangle. Return #t if the three
;; sides form a right-angled triangle, #f otherwise.
;; A right-angled triangle is a triangle in which one angle is right angle or 
;; 90 degree.
;; Example:
;; >>> (right_angle_triangle 3 4 5)
;; #t
;; >>> (right_angle_triangle 1 2 3)
;; #f

;; Given the lengths of the three sides of a triangle.
;; Return #t if the three sides form a right‑angled triangle,
;; #f otherwise.
;;
;; A right‑angled triangle is a triangle in which one angle is a right
;; angle (90 degrees).
;;
;; Example:
;; >>> (right_angle_triangle 3 4 5)
;; #t
;; >>> (right_angle_triangle 1 2 3)
;; #f
(define (right_angle_triangle a b c)
  (and
   ;; All sides must be positive
   (positive? a) (positive? b) (positive? c)

   ;; Triangle inequality
   (> (+ a b) c)
   (> (+ a c) b)
   (> (+ b c) a)

   ;; Pythagorean condition (any side can be the hypotenuse)
   (or
    (= (+ (* a a) (* b b)) (* c c))
    (= (+ (* a a) (* c c)) (* b b))
    (= (+ (* b b) (* c c)) (* a a)))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate right_angle_triangle))
    (check-within (candidate 3 4 5) #t 0.001)
    (check-within (candidate 1 2 3) #f 0.001)
    (check-within (candidate 10 6 8) #t 0.001)
    (check-within (candidate 2 2 2) #f 0.001)
    (check-within (candidate 7 24 25) #t 0.001)
    (check-within (candidate 10 5 7) #f 0.001)
    (check-within (candidate 5 12 13) #t 0.001)
    (check-within (candidate 15 8 17) #t 0.001)
    (check-within (candidate 48 55 73) #t 0.001)
    (check-within (candidate 1 1 1) #f 0.001)
    (check-within (candidate 2 2 10) #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828011
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given the lengths of the three sides of a triangle. Return #t if the three
;; sides form a right-angled triangle, #f otherwise.
;; A right-angled triangle is a triangle in which one angle is right angle or 
;; 90 degree.
;; Example:
;; >>> (right_angle_triangle 3 4 5)
;; #t
;; >>> (right_angle_triangle 1 2 3)
;; #f

;; Given the lengths of the three sides of a triangle. Return #t if the three
;; sides form a right-angled triangle, #f otherwise.
;; A right-angled triangle is a triangle in which one angle is right angle or 
;; 90 degree.
;; Example:
;; >>> (right_angle_triangle 3 4 5)
;; #t
;; >>> (right_angle_triangle 1 2 3)
;; #f
(define (right_angle_triangle a b c)
  ;; Sort the sides so that the largest side is last.
  (let* ((sides (sort (list a b c) <))
         (x (list-ref sides 0))   ; smallest side
         (y (list-ref sides 1))   ; middle side
         (z (list-ref sides 2)))  ; largest side
    ;; Check the Pythagorean theorem.
    (= (+ (* x x) (* y y)) (* z z))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate right_angle_triangle))
    (check-within (candidate 3 4 5) #t 0.001)
    (check-within (candidate 1 2 3) #f 0.001)
    (check-within (candidate 10 6 8) #t 0.001)
    (check-within (candidate 2 2 2) #f 0.001)
    (check-within (candidate 7 24 25) #t 0.001)
    (check-within (candidate 10 5 7) #f 0.001)
    (check-within (candidate 5 12 13) #t 0.001)
    (check-within (candidate 15 8 17) #t 0.001)
    (check-within (candidate 48 55 73) #t 0.001)
    (check-within (candidate 1 1 1) #f 0.001)
    (check-within (candidate 2 2 10) #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828011
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 159 (RKT) - HumanEval_159_eat
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; You're a hungry rabbit, and you already have eaten a certain number of carrots,
;; but now you need to eat more carrots to complete the day's meals.
;; you should return a list of [ total number of eaten carrots after your meals,
;;                                 the number of carrots left after your meals ]
;; if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
;; Example:
;; >>> (eat 5 6 10)
;; (list 11 4)
;; >>> (eat 4 8 9)
;; (list 12 1)
;; >>> (eat 1 10 10)
;; (list 11 0)
;; >>> (eat 2 11 5)
;; (list 7 0)
;; Variables:
;; @number : integer
;;     the number of carrots that you have eaten.
;; @need : integer
;;     the number of carrots that you need to eat.
;; @remaining : integer
;;     the number of remaining carrots thet exist in stock
;; Constrain:
;; * 0 <= number <= 1000
;; * 0 <= need <= 1000
;; * 0 <= remaining <= 1000
;; Have fun :)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate eat))
    (check-within (candidate 5 6 10) (list 11 4) 0.001)
    (check-within (candidate 4 8 9) (list 12 1) 0.001)
    (check-within (candidate 1 10 10) (list 11 0) 0.001)
    (check-within (candidate 2 11 5) (list 7 0) 0.001)
    (check-within (candidate 4 5 7) (list 9 2) 0.001)
    (check-within (candidate 4 5 1) (list 5 0) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; You're a hungry rabbit, and you already have eaten a certain number of carrots,
;; but now you need to eat more carrots to complete the day's meals.
;; you should return a list of [ total number of eaten carrots after your meals,
;;                                 the number of carrots left after your meals ]
;; if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
;; Example:
;; >>> (eat 5 6 10)
;; (list 11 4)
;; >>> (eat 4 8 9)
;; (list 12 1)
;; >>> (eat 1 10 10)
;; (list 11 0)
;; >>> (eat 2 11 5)
;; (list 7 0)
;; Variables:
;; @number : integer
;;     the number of carrots that you have eaten.
;; @need : integer
;;     the number of carrots that you need to eat.
;; @remaining : integer
;;     the number of remaining carrots thet exist in stock
;; Constrain:
;; * 0 <= number <= 1000
;; * 0 <= need <= 1000
;; * 0 <= remaining <= 1000
;; Have fun :)

(define (eat number need remaining)
  ;; Determine how many carrots we can actually eat this round.
  (let* ((eaten (min need remaining))
         ;; Total carrots eaten after this meal.
         (total (+ number eaten))
         ;; Carrots left in stock after eating.
         (left (- remaining eaten)))
    (list total left)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate eat))
    (check-within (candidate 5 6 10) (list 11 4) 0.001)
    (check-within (candidate 4 8 9) (list 12 1) 0.001)
    (check-within (candidate 1 10 10) (list 11 0) 0.001)
    (check-within (candidate 2 11 5) (list 7 0) 0.001)
    (check-within (candidate 4 5 7) (list 9 2) 0.001)
    (check-within (candidate 4 5 1) (list 5 0) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828013
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; You're a hungry rabbit, and you already have eaten a certain number of carrots,
;; but now you need to eat more carrots to complete the day's meals.
;; you should return a list of [ total number of eaten carrots after your meals,
;;                                 the number of carrots left after your meals ]
;; if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
;; Example:
;; >>> (eat 5 6 10)
;; (list 11 4)
;; >>> (eat 4 8 9)
;; (list 12 1)
;; >>> (eat 1 10 10)
;; (list 11 0)
;; >>> (eat 2 11 5)
;; (list 7 0)
;; Variables:
;; @number : integer
;;     the number of carrots that you have eaten.
;; @need : integer
;;     the number of carrots that you need to eat.
;; @remaining : integer
;;     the number of remaining carrots thet exist in stock
;; Constrain:
;; * 0 <= number <= 1000
;; * 0 <= need <= 1000
;; * 0 <= remaining <= 1000
;; Have fun :)

;; You're a hungry rabbit, and you already have eaten a certain number of carrots,
;; but now you need to eat more carrots to complete the day's meals.
;; you should return a list of [ total number of eaten carrots after your meals,
;;                                 the number of carrots left after your meals ]
;; if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
;; Example:
;; >>> (eat 5 6 10)
;; (list 11 4)
;; >>> (eat 4 8 9)
;; (list 12 1)
;; >>> (eat 1 10 10)
;; (list 11 0)
;; >>> (eat 2 11 5)
;; (list 7 0)
;; Variables:
;; @number : integer
;;     the number of carrots that you have eaten.
;; @need : integer
;;     the number of carrots that you need to eat.
;; @remaining : integer
;;     the number of remaining carrots thet exist in stock
;; Constrain:
;; * 0 <= number <= 1000
;; * 0 <= need <= 1000
;; * 0 <= remaining <= 1000
;; Have fun :)

(define (eat number need remaining)
  (let* ((eaten (min need remaining))
         (total (+ number eaten))
         (left (- remaining eaten)))
    (list total left)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate eat))
    (check-within (candidate 5 6 10) (list 11 4) 0.001)
    (check-within (candidate 4 8 9) (list 12 1) 0.001)
    (check-within (candidate 1 10 10) (list 11 0) 0.001)
    (check-within (candidate 2 11 5) (list 7 0) 0.001)
    (check-within (candidate 4 5 7) (list 9 2) 0.001)
    (check-within (candidate 4 5 1) (list 5 0) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828013
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; You're a hungry rabbit, and you already have eaten a certain number of carrots,
;; but now you need to eat more carrots to complete the day's meals.
;; you should return a list of [ total number of eaten carrots after your meals,
;;                                 the number of carrots left after your meals ]
;; if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
;; Example:
;; >>> (eat 5 6 10)
;; (list 11 4)
;; >>> (eat 4 8 9)
;; (list 12 1)
;; >>> (eat 1 10 10)
;; (list 11 0)
;; >>> (eat 2 11 5)
;; (list 7 0)
;; Variables:
;; @number : integer
;;     the number of carrots that you have eaten.
;; @need : integer
;;     the number of carrots that you need to eat.
;; @remaining : integer
;;     the number of remaining carrots thet exist in stock
;; Constrain:
;; * 0 <= number <= 1000
;; * 0 <= need <= 1000
;; * 0 <= remaining <= 1000
;; Have fun :)

(define (eat number need remaining)
  ;; Determine how many carrots we can actually eat
  (define eaten (min need remaining))
  ;; Total carrots eaten after the meal
  (define total (+ number eaten))
  ;; Carrots left after eating
  (define left (- remaining eaten))
  (list total left))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate eat))
    (check-within (candidate 5 6 10) (list 11 4) 0.001)
    (check-within (candidate 4 8 9) (list 12 1) 0.001)
    (check-within (candidate 1 10 10) (list 11 0) 0.001)
    (check-within (candidate 2 11 5) (list 7 0) 0.001)
    (check-within (candidate 4 5 7) (list 9 2) 0.001)
    (check-within (candidate 4 5 1) (list 5 0) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828013
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; You're a hungry rabbit, and you already have eaten a certain number of carrots,
;; but now you need to eat more carrots to complete the day's meals.
;; you should return a list of [ total number of eaten carrots after your meals,
;;                                 the number of carrots left after your meals ]
;; if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
;; Example:
;; >>> (eat 5 6 10)
;; (list 11 4)
;; >>> (eat 4 8 9)
;; (list 12 1)
;; >>> (eat 1 10 10)
;; (list 11 0)
;; >>> (eat 2 11 5)
;; (list 7 0)
;; Variables:
;; @number : integer
;;     the number of carrots that you have eaten.
;; @need : integer
;;     the number of carrots that you need to eat.
;; @remaining : integer
;;     the number of remaining carrots thet exist in stock
;; Constrain:
;; * 0 <= number <= 1000
;; * 0 <= need <= 1000
;; * 0 <= remaining <= 1000
;; Have fun :)

;; You're a hungry rabbit, and you already have eaten a certain number of carrots,
;; but now you need to eat more carrots to complete the day's meals.
;; You should return a list of [ total number of eaten carrots after your meals,
;;                               the number of carrots left after your meals ]
;; If there are not enough remaining carrots, you will eat all remaining carrots,
;; but will still be hungry.
;;
;; Example:
;; >>> (eat 5 6 10)
;; (list 11 4)
;; >>> (eat 4 8 9)
;; (list 12 1)
;; >>> (eat 1 10 10)
;; (list 11 0)
;; >>> (eat 2 11 5)
;; (list 7 0)
;;
;; Variables:
;; @number   : integer, the number of carrots that you have eaten.
;; @need     : integer, the number of carrots that you need to eat.
;; @remaining: integer, the number of remaining carrots that exist in stock.
;;
;; Constraints:
;; * 0 <= number <= 1000
;; * 0 <= need <= 1000
;; * 0 <= remaining <= 1000

(define (eat number need remaining)
  (let* ((to-eat (min need remaining))   ; carrots that can actually be eaten
         (total   (+ number to-eat))      ; total eaten after meals
         (left    (- remaining to-eat)))   ; carrots left after meals
    (list total left)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate eat))
    (check-within (candidate 5 6 10) (list 11 4) 0.001)
    (check-within (candidate 4 8 9) (list 12 1) 0.001)
    (check-within (candidate 1 10 10) (list 11 0) 0.001)
    (check-within (candidate 2 11 5) (list 7 0) 0.001)
    (check-within (candidate 4 5 7) (list 9 2) 0.001)
    (check-within (candidate 4 5 1) (list 5 0) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828013
STDOUT: (empty)
STDERR: (empty)
--------------------
