As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 120 (RKT) - HumanEval_120_maximum
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
;; Example 1:
;; >>> (maximum (list -3 -4 5) 3)
;; (list -4 -3 5)
;; Example 2:
;; >>> (maximum (list 4 -4 4) 2)
;; (list 4 4)
;; Example 3:
;; >>> (maximum (list -3 2 1 2 -1 -2 1) 1)
;; (list 2)
;; Note:
;;     1. The length of the list will be in the range of [1, 1000].
;;     2. The elements in the list will be in the range of [-1000, 1000].
;;     3. 0 <= k <= len(arr)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate maximum))
    (check-within (candidate (list -3 -4 5) 3) (list -4 -3 5) 0.001)
    (check-within (candidate (list 4 -4 4) 2) (list 4 4) 0.001)
    (check-within (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2) 0.001)
    (check-within (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123) 0.001)
    (check-within (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20) 0.001)
    (check-within (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15) 0.001)
    (check-within (candidate (list -1 0 2 5 3 -10) 2) (list 3 5) 0.001)
    (check-within (candidate (list 1 0 5 -7) 1) (list 5) 0.001)
    (check-within (candidate (list 4 -4) 2) (list -4 4) 0.001)
    (check-within (candidate (list -10 10) 2) (list -10 10) 0.001)
    (check-within (candidate (list 1 2 3 -23 243 -400 0) 0) (list ) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
;; Example 1:
;; >>> (maximum (list -3 -4 5) 3)
;; (list -4 -3 5)
;; Example 2:
;; >>> (maximum (list 4 -4 4) 2)
;; (list 4 4)
;; Example 3:
;; >>> (maximum (list -3 2 1 2 -1 -2 1) 1)
;; (list 2)
;; Note:
;;     1. The length of the list will be in the range of [1, 1000].
;;     2. The elements in the list will be in the range of [-1000, 1000].
;;     3. 0 <= k <= len(arr)

;; Return a sorted list of length k containing the maximum k numbers from arr.
;; The result is sorted in ascending order.
(define (maximum arr k)
  ;; Sort the input list in ascending order.
  (define sorted (sort arr <))
  ;; Take the last k elements (the largest k values).
  (take-right sorted k))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate maximum))
    (check-within (candidate (list -3 -4 5) 3) (list -4 -3 5) 0.001)
    (check-within (candidate (list 4 -4 4) 2) (list 4 4) 0.001)
    (check-within (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2) 0.001)
    (check-within (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123) 0.001)
    (check-within (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20) 0.001)
    (check-within (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15) 0.001)
    (check-within (candidate (list -1 0 2 5 3 -10) 2) (list 3 5) 0.001)
    (check-within (candidate (list 1 0 5 -7) 1) (list 5) 0.001)
    (check-within (candidate (list 4 -4) 2) (list -4 4) 0.001)
    (check-within (candidate (list -10 10) 2) (list -10 10) 0.001)
    (check-within (candidate (list 1 2 3 -23 243 -400 0) 0) (list ) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183964
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
;; Example 1:
;; >>> (maximum (list -3 -4 5) 3)
;; (list -4 -3 5)
;; Example 2:
;; >>> (maximum (list 4 -4 4) 2)
;; (list 4 4)
;; Example 3:
;; >>> (maximum (list -3 2 1 2 -1 -2 1) 1)
;; (list 2)
;; Note:
;;     1. The length of the list will be in the range of [1, 1000].
;;     2. The elements in the list will be in the range of [-1000, 1000].
;;     3. 0 <= k <= len(arr)

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
;; Example 1:
;; >>> (maximum (list -3 -4 5) 3)
;; (list -4 -3 5)
;; Example 2:
;; >>> (maximum (list 4 -4 4) 2)
;; (list 4 4)
;; Example 3:
;; >>> (maximum (list -3 2 1 2 -1 -2 1) 1)
;; (list 2)
;; Note:
;;     1. The length of the list will be in the range of [1, 1000].
;;     2. The elements in the list will be in the range of [-1000, 1000].
;;     3. 0 <= k <= len(arr)

(define (maximum arr k)
  ;; Sort the list in ascending order and take the last k elements.
  (take-right (sort arr <) k))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate maximum))
    (check-within (candidate (list -3 -4 5) 3) (list -4 -3 5) 0.001)
    (check-within (candidate (list 4 -4 4) 2) (list 4 4) 0.001)
    (check-within (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2) 0.001)
    (check-within (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123) 0.001)
    (check-within (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20) 0.001)
    (check-within (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15) 0.001)
    (check-within (candidate (list -1 0 2 5 3 -10) 2) (list 3 5) 0.001)
    (check-within (candidate (list 1 0 5 -7) 1) (list 5) 0.001)
    (check-within (candidate (list 4 -4) 2) (list -4 4) 0.001)
    (check-within (candidate (list -10 10) 2) (list -10 10) 0.001)
    (check-within (candidate (list 1 2 3 -23 243 -400 0) 0) (list ) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183964
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
;; Example 1:
;; >>> (maximum (list -3 -4 5) 3)
;; (list -4 -3 5)
;; Example 2:
;; >>> (maximum (list 4 -4 4) 2)
;; (list 4 4)
;; Example 3:
;; >>> (maximum (list -3 2 1 2 -1 -2 1) 1)
;; (list 2)
;; Note:
;;     1. The length of the list will be in the range of [1, 1000].
;;     2. The elements in the list will be in the range of [-1000, 1000].
;;     3. 0 <= k <= len(arr)

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
(define (maximum arr k)
  ;; First sort the entire list in ascending order.
  (let ([sorted (sort arr <)])
    ;; Drop the first (len - k) elements to keep only the largest k.
    (drop sorted (- (length sorted) k))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate maximum))
    (check-within (candidate (list -3 -4 5) 3) (list -4 -3 5) 0.001)
    (check-within (candidate (list 4 -4 4) 2) (list 4 4) 0.001)
    (check-within (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2) 0.001)
    (check-within (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123) 0.001)
    (check-within (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20) 0.001)
    (check-within (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15) 0.001)
    (check-within (candidate (list -1 0 2 5 3 -10) 2) (list 3 5) 0.001)
    (check-within (candidate (list 1 0 5 -7) 1) (list 5) 0.001)
    (check-within (candidate (list 4 -4) 2) (list -4 4) 0.001)
    (check-within (candidate (list -10 10) 2) (list -10 10) 0.001)
    (check-within (candidate (list 1 2 3 -23 243 -400 0) 0) (list ) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183964
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
;; Example 1:
;; >>> (maximum (list -3 -4 5) 3)
;; (list -4 -3 5)
;; Example 2:
;; >>> (maximum (list 4 -4 4) 2)
;; (list 4 4)
;; Example 3:
;; >>> (maximum (list -3 2 1 2 -1 -2 1) 1)
;; (list 2)
;; Note:
;;     1. The length of the list will be in the range of [1, 1000].
;;     2. The elements in the list will be in the range of [-1000, 1000].
;;     3. 0 <= k <= len(arr)

(require racket/list)

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
(define (maximum arr k)
  (if (= k 0)
      '()
      (sort (take (sort arr >) k) <)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate maximum))
    (check-within (candidate (list -3 -4 5) 3) (list -4 -3 5) 0.001)
    (check-within (candidate (list 4 -4 4) 2) (list 4 4) 0.001)
    (check-within (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2) 0.001)
    (check-within (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123) 0.001)
    (check-within (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20) 0.001)
    (check-within (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15) 0.001)
    (check-within (candidate (list -1 0 2 5 3 -10) 2) (list 3 5) 0.001)
    (check-within (candidate (list 1 0 5 -7) 1) (list 5) 0.001)
    (check-within (candidate (list 4 -4) 2) (list -4 4) 0.001)
    (check-within (candidate (list -10 10) 2) (list -10 10) 0.001)
    (check-within (candidate (list 1 2 3 -23 243 -400 0) 0) (list ) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183964
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 122 (RKT) - HumanEval_122_add_elements
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given a non-empty list of integers arr and an integer k, return
;; the sum of the elements with at most two digits from the first k elements of arr.
;; Example:
;; >>> (add_elements (list 111 21 3 4000 5 6 7 8 9) 4)
;; 24
;; Constraints:
;;     1. 1 <= len(arr) <= 100
;;     2. 1 <= k <= len(arr)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add_elements))
    (check-within (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4 0.001)
    (check-within (candidate (list 111 121 3 4000 5 6) 2) 0 0.001)
    (check-within (candidate (list 11 21 3 90 5 6 7 8 9) 4) 125 0.001)
    (check-within (candidate (list 111 21 3 4000 5 6 7 8 9) 4) 24 0.001)
    (check-within (candidate (list 1) 1) 1 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given a non-empty list of integers arr and an integer k, return
;; the sum of the elements with at most two digits from the first k elements of arr.
;; Example:
;; >>> (add_elements (list 111 21 3 4000 5 6 7 8 9) 4)
;; 24
;; Constraints:
;;     1. 1 <= len(arr) <= 100
;;     2. 1 <= k <= len(arr)

;; Return the sum of the elements with at most two digits from the first k elements of arr.
;; We count digits of the absolute value of each number.
(define (add_elements arr k)
  ;; Take the first k elements
  (define first-k (take arr k))
  ;; Predicate: at most two digits
  (define two-digit? (lambda (x)
                       (<= (string-length (number->string (abs x))) 2)))
  ;; Sum the filtered elements
  (apply + (filter two-digit? first-k)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add_elements))
    (check-within (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4 0.001)
    (check-within (candidate (list 111 121 3 4000 5 6) 2) 0 0.001)
    (check-within (candidate (list 11 21 3 90 5 6 7 8 9) 4) 125 0.001)
    (check-within (candidate (list 111 21 3 4000 5 6 7 8 9) 4) 24 0.001)
    (check-within (candidate (list 1) 1) 1 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183966
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given a non-empty list of integers arr and an integer k, return
;; the sum of the elements with at most two digits from the first k elements of arr.
;; Example:
;; >>> (add_elements (list 111 21 3 4000 5 6 7 8 9) 4)
;; 24
;; Constraints:
;;     1. 1 <= len(arr) <= 100
;;     2. 1 <= k <= len(arr)

(require racket/list)

;; Given a non-empty list of integers arr and an integer k, return
;; the sum of the elements with at most two digits from the first k elements of arr.
;; Example:
;; >>> (add_elements (list 111 21 3 4000 5 6 7 8 9) 4)
;; 24
;; Constraints:
;;     1. 1 <= len(arr) <= 100
;;     2. 1 <= k <= len(arr)
(define (add_elements arr k)
  (define firstk (take arr k))
  (define (at-most-two-digits? n)
    (< (abs n) 100))
  (foldl + 0 (filter at-most-two-digits? firstk)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add_elements))
    (check-within (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4 0.001)
    (check-within (candidate (list 111 121 3 4000 5 6) 2) 0 0.001)
    (check-within (candidate (list 11 21 3 90 5 6 7 8 9) 4) 125 0.001)
    (check-within (candidate (list 111 21 3 4000 5 6 7 8 9) 4) 24 0.001)
    (check-within (candidate (list 1) 1) 1 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183966
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given a non-empty list of integers arr and an integer k, return
;; the sum of the elements with at most two digits from the first k elements of arr.
;; Example:
;; >>> (add_elements (list 111 21 3 4000 5 6 7 8 9) 4)
;; 24
;; Constraints:
;;     1. 1 <= len(arr) <= 100
;;     2. 1 <= k <= len(arr)

;; Given a non-empty list of integers arr and an integer k, return
;; the sum of the elements with at most two digits from the first k elements of arr.
;; Example:
;; >>> (add_elements (list 111 21 3 4000 5 6 7 8 9) 4)
;; 24
;; Constraints:
;;     1. 1 <= len(arr) <= 100
;;     2. 1 <= k <= len(arr)

(define (add_elements arr k)
  ;; Helper that returns #t if the integer has at most two digits
  (define (at-most-two-digits? n)
    (<= (string-length (number->string (abs n))) 2))

  ;; Recursive helper that walks through the list,
  ;; stopping after k elements, accumulating the sum.
  (define (loop lst remaining acc)
    (cond
      [(zero? remaining) acc]               ; processed k elements
      [(null? lst) acc]                    ; should not happen (k <= len(arr))
      [else
       (let ((x (car lst)))
         (loop (cdr lst)
               (sub1 remaining)
               (if (at-most-two-digits? x)
                   (+ acc x)
                   acc)))]))

  (loop arr k 0))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add_elements))
    (check-within (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4 0.001)
    (check-within (candidate (list 111 121 3 4000 5 6) 2) 0 0.001)
    (check-within (candidate (list 11 21 3 90 5 6 7 8 9) 4) 125 0.001)
    (check-within (candidate (list 111 21 3 4000 5 6 7 8 9) 4) 24 0.001)
    (check-within (candidate (list 1) 1) 1 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183966
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given a non-empty list of integers arr and an integer k, return
;; the sum of the elements with at most two digits from the first k elements of arr.
;; Example:
;; >>> (add_elements (list 111 21 3 4000 5 6 7 8 9) 4)
;; 24
;; Constraints:
;;     1. 1 <= len(arr) <= 100
;;     2. 1 <= k <= len(arr)

;; Given a non‑empty list of integers arr and an integer k, return
;; the sum of the elements with at most two digits from the first k elements of arr.
;; Example:
;; >>> (add_elements (list 111 21 3 4000 5 6 7 8 9) 4)
;; 24
;; Constraints:
;;     1. 1 <= len(arr) <= 100
;;     2. 1 <= k <= len(arr)

(define (add_elements arr k)
  ;; Take the first k elements
  (define firstk (take arr k))
  ;; Keep only those with at most two decimal digits (abs value <= 99)
  (define filtered (filter (lambda (n) (<= (abs n) 99)) firstk))
  ;; Sum the filtered list
  (foldl + 0 filtered))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add_elements))
    (check-within (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4 0.001)
    (check-within (candidate (list 111 121 3 4000 5 6) 2) 0 0.001)
    (check-within (candidate (list 11 21 3 90 5 6 7 8 9) 4) 125 0.001)
    (check-within (candidate (list 111 21 3 4000 5 6 7 8 9) 4) 24 0.001)
    (check-within (candidate (list 1) 1) 1 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183966
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 131 (RKT) - HumanEval_131_digits
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given a positive integer n, return the product of the odd digits.
;; Return 0 if all digits are even.
;; For example:
;; >>> (digits 1)
;; 1
;; >>> (digits 4)
;; 0
;; >>> (digits 235)
;; 15

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate digits))
    (check-within (candidate 5) 5 0.001)
    (check-within (candidate 54) 5 0.001)
    (check-within (candidate 120) 1 0.001)
    (check-within (candidate 5014) 5 0.001)
    (check-within (candidate 98765) 315 0.001)
    (check-within (candidate 5576543) 2625 0.001)
    (check-within (candidate 2468) 0 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer n, return the product of the odd digits.
;; Return 0 if all digits are even.
;; For example:
;; >>> (digits 1)
;; 1
;; >>> (digits 4)
;; 0
;; >>> (digits 235)
;; 15

;; Given a positive integer n, return the product of the odd digits.
;; Return 0 if all digits are even.
;; For example:
;; >>> (digits 1)
;; 1
;; >>> (digits 4)
;; 0
;; >>> (digits 235)
;; 15
(define (digits n)
  ;; Helper that walks through the digits of n.
  ;; acc   – product of odd digits seen so far
  ;; any?  – flag indicating if any odd digit has been encountered
  (define (helper n acc any?)
    (if (= n 0)
        (if any? acc 0)          ; if no odd digits → 0
        (let* ((d (modulo n 10))
               (new-acc (if (odd? d) (* acc d) acc))
               (new-any (or any? (odd? d))))
          (helper (quotient n 10) new-acc new-any))))
  (helper n 1 #f))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate digits))
    (check-within (candidate 5) 5 0.001)
    (check-within (candidate 54) 5 0.001)
    (check-within (candidate 120) 1 0.001)
    (check-within (candidate 5014) 5 0.001)
    (check-within (candidate 98765) 315 0.001)
    (check-within (candidate 5576543) 2625 0.001)
    (check-within (candidate 2468) 0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183975
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer n, return the product of the odd digits.
;; Return 0 if all digits are even.
;; For example:
;; >>> (digits 1)
;; 1
;; >>> (digits 4)
;; 0
;; >>> (digits 235)
;; 15

;; Given a positive integer n, return the product of the odd digits.
;; Return 0 if all digits are even.
;; For example:
;; >>> (digits 1)
;; 1
;; >>> (digits 4)
;; 0
;; >>> (digits 235)
;; 15
(define (digits n)
  (define (helper n prod found)
    (if (< n 10)
        ;; Base case: single digit left
        (if (odd? n)
            (* prod n)          ; multiply by the last odd digit
            (if found prod 0))  ; if no odd digits seen, return 0
        ;; Recursive case: process the last digit and recurse on the rest
        (let* ([last (modulo n 10)]
               [rest (quotient n 10)]
               [new-prod (if (odd? last) (* prod last) prod)]
               [new-found (or found (odd? last))])
          (helper rest new-prod new-found))))
  (helper n 1 #f))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate digits))
    (check-within (candidate 5) 5 0.001)
    (check-within (candidate 54) 5 0.001)
    (check-within (candidate 120) 1 0.001)
    (check-within (candidate 5014) 5 0.001)
    (check-within (candidate 98765) 315 0.001)
    (check-within (candidate 5576543) 2625 0.001)
    (check-within (candidate 2468) 0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183975
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer n, return the product of the odd digits.
;; Return 0 if all digits are even.
;; For example:
;; >>> (digits 1)
;; 1
;; >>> (digits 4)
;; 0
;; >>> (digits 235)
;; 15

;; Given a positive integer n, return the product of the odd digits.
;; Return 0 if all digits are even.
;; For example:
;; >>> (digits 1)
;; 1
;; >>> (digits 4)
;; 0
;; >>> (digits 235)
;; 15
(define (digits n)
  ;; Helper that walks through the digits of n.
  ;; `prod` holds the running product of odd digits.
  ;; `found?` signals whether at least one odd digit has been seen.
  (define (iter n prod found?)
    (if (= n 0)
        (if found? prod 0)            ; no digits left
        (let* ((digit (modulo n 10))
               (rest  (quotient n 10)))
          (if (odd? digit)
              (iter rest (* prod digit) #t) ; multiply and mark found
              (iter rest prod found?)))))
  (iter n 1 #f))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate digits))
    (check-within (candidate 5) 5 0.001)
    (check-within (candidate 54) 5 0.001)
    (check-within (candidate 120) 1 0.001)
    (check-within (candidate 5014) 5 0.001)
    (check-within (candidate 98765) 315 0.001)
    (check-within (candidate 5576543) 2625 0.001)
    (check-within (candidate 2468) 0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183975
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer n, return the product of the odd digits.
;; Return 0 if all digits are even.
;; For example:
;; >>> (digits 1)
;; 1
;; >>> (digits 4)
;; 0
;; >>> (digits 235)
;; 15

;; Given a positive integer n, return the product of the odd digits.
;; Return 0 if all digits are even.
;; For example:
;; >>> (digits 1)
;; 1
;; >>> (digits 4)
;; 0
;; >>> (digits 235)
;; 15

(define (digits n)
  ;; Helper: convert n into a list of its decimal digits.
  (define (digits->list num acc)
    (if (= num 0)
        acc
        (digits->list (quotient num 10) (cons (modulo num 10) acc))))
  
  (let* ([dlist (digits->list n '())]          ; list of digits
         [odds  (filter odd? dlist)])          ; keep only odd digits
    (if (null? odds)
        0                                      ; all digits even
        (foldl * 1 odds))))                    ; product of odd digits
(require rackunit)

(define (test-humaneval) 

  (let (( candidate digits))
    (check-within (candidate 5) 5 0.001)
    (check-within (candidate 54) 5 0.001)
    (check-within (candidate 120) 1 0.001)
    (check-within (candidate 5014) 5 0.001)
    (check-within (candidate 98765) 315 0.001)
    (check-within (candidate 5576543) 2625 0.001)
    (check-within (candidate 2468) 0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183975
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 133 (RKT) - HumanEval_133_sum_squares
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; You are given a list of numbers.
;; You need to return the sum of squared numbers in the given list,
;; round each element in the list to the upper int(Ceiling) first.
;; Examples:
;; >>> (lst (list 1.0 2.0 3.0))
;; 14
;; >>> (lst (list 1.0 4.0 9.0))
;; 98
;; >>> (lst (list 1.0 3.0 5.0 7.0))
;; 84
;; >>> (lst (list 1.4 4.2 0.0))
;; 29
;; >>> (lst (list -2.4 1.0 1.0))
;; 6

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_squares))
    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)
    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)
    (check-within (candidate (list 1.0 3.0 5.0 7.0)) 84 0.001)
    (check-within (candidate (list 1.4 4.2 0.0)) 29 0.001)
    (check-within (candidate (list -2.4 1.0 1.0)) 6 0.001)
    (check-within (candidate (list 100.0 1.0 15.0 2.0)) 10230 0.001)
    (check-within (candidate (list 10000.0 10000.0)) 200000000 0.001)
    (check-within (candidate (list -1.4 4.6 6.3)) 75 0.001)
    (check-within (candidate (list -1.4 17.9 18.9 19.9)) 1086 0.001)
    (check-within (candidate (list 0.0)) 0 0.001)
    (check-within (candidate (list -1.0)) 1 0.001)
    (check-within (candidate (list -1.0 1.0 0.0)) 2 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; You are given a list of numbers.
;; You need to return the sum of squared numbers in the given list,
;; round each element in the list to the upper int(Ceiling) first.
;; Examples:
;; >>> (lst (list 1.0 2.0 3.0))
;; 14
;; >>> (lst (list 1.0 4.0 9.0))
;; 98
;; >>> (lst (list 1.0 3.0 5.0 7.0))
;; 84
;; >>> (lst (list 1.4 4.2 0.0))
;; 29
;; >>> (lst (list -2.4 1.0 1.0))
;; 6

;; You are given a list of numbers.
;; You need to return the sum of squared numbers in the given list,
;; round each element in the list to the upper int(Ceiling) first.
;; Examples:
;; >>> (lst (list 1.0 2.0 3.0))
;; 14
;; >>> (lst (list 1.0 4.0 9.0))
;; 98
;; >>> (lst (list 1.0 3.0 5.0 7.0))
;; 84
;; >>> (lst (list 1.4 4.2 0.0))
;; 29
;; >>> (lst (list -2.4 1.0 1.0))
;; 6

(define (sum_squares lst)
  (apply +
         (map (lambda (x)
                (expt (ceiling x) 2))
              lst)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_squares))
    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)
    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)
    (check-within (candidate (list 1.0 3.0 5.0 7.0)) 84 0.001)
    (check-within (candidate (list 1.4 4.2 0.0)) 29 0.001)
    (check-within (candidate (list -2.4 1.0 1.0)) 6 0.001)
    (check-within (candidate (list 100.0 1.0 15.0 2.0)) 10230 0.001)
    (check-within (candidate (list 10000.0 10000.0)) 200000000 0.001)
    (check-within (candidate (list -1.4 4.6 6.3)) 75 0.001)
    (check-within (candidate (list -1.4 17.9 18.9 19.9)) 1086 0.001)
    (check-within (candidate (list 0.0)) 0 0.001)
    (check-within (candidate (list -1.0)) 1 0.001)
    (check-within (candidate (list -1.0 1.0 0.0)) 2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183976
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; You are given a list of numbers.
;; You need to return the sum of squared numbers in the given list,
;; round each element in the list to the upper int(Ceiling) first.
;; Examples:
;; >>> (lst (list 1.0 2.0 3.0))
;; 14
;; >>> (lst (list 1.0 4.0 9.0))
;; 98
;; >>> (lst (list 1.0 3.0 5.0 7.0))
;; 84
;; >>> (lst (list 1.4 4.2 0.0))
;; 29
;; >>> (lst (list -2.4 1.0 1.0))
;; 6

(define (sum_squares lst)
  (apply + (map (λ (x) (expt (ceiling x) 2)) lst)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_squares))
    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)
    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)
    (check-within (candidate (list 1.0 3.0 5.0 7.0)) 84 0.001)
    (check-within (candidate (list 1.4 4.2 0.0)) 29 0.001)
    (check-within (candidate (list -2.4 1.0 1.0)) 6 0.001)
    (check-within (candidate (list 100.0 1.0 15.0 2.0)) 10230 0.001)
    (check-within (candidate (list 10000.0 10000.0)) 200000000 0.001)
    (check-within (candidate (list -1.4 4.6 6.3)) 75 0.001)
    (check-within (candidate (list -1.4 17.9 18.9 19.9)) 1086 0.001)
    (check-within (candidate (list 0.0)) 0 0.001)
    (check-within (candidate (list -1.0)) 1 0.001)
    (check-within (candidate (list -1.0 1.0 0.0)) 2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183976
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; You are given a list of numbers.
;; You need to return the sum of squared numbers in the given list,
;; round each element in the list to the upper int(Ceiling) first.
;; Examples:
;; >>> (lst (list 1.0 2.0 3.0))
;; 14
;; >>> (lst (list 1.0 4.0 9.0))
;; 98
;; >>> (lst (list 1.0 3.0 5.0 7.0))
;; 84
;; >>> (lst (list 1.4 4.2 0.0))
;; 29
;; >>> (lst (list -2.4 1.0 1.0))
;; 6

;; You are given a list of numbers.
;; You need to return the sum of squared numbers in the given list,
;; round each element in the list to the upper int(Ceiling) first.
;; Examples:
;; >>> (lst (list 1.0 2.0 3.0))
;; 14
;; >>> (lst (list 1.0 4.0 9.0))
;; 98
;; >>> (lst (list 1.0 3.0 5.0 7.0))
;; 84
;; >>> (lst (list 1.4 4.2 0.0))
;; 29
;; >>> (lst (list -2.4 1.0 1.0))
;; 6

(define (sum_squares lst)
  (apply + (map (lambda (x)
                  (* (ceiling x) (ceiling x)))
                lst)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_squares))
    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)
    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)
    (check-within (candidate (list 1.0 3.0 5.0 7.0)) 84 0.001)
    (check-within (candidate (list 1.4 4.2 0.0)) 29 0.001)
    (check-within (candidate (list -2.4 1.0 1.0)) 6 0.001)
    (check-within (candidate (list 100.0 1.0 15.0 2.0)) 10230 0.001)
    (check-within (candidate (list 10000.0 10000.0)) 200000000 0.001)
    (check-within (candidate (list -1.4 4.6 6.3)) 75 0.001)
    (check-within (candidate (list -1.4 17.9 18.9 19.9)) 1086 0.001)
    (check-within (candidate (list 0.0)) 0 0.001)
    (check-within (candidate (list -1.0)) 1 0.001)
    (check-within (candidate (list -1.0 1.0 0.0)) 2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183976
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; You are given a list of numbers.
;; You need to return the sum of squared numbers in the given list,
;; round each element in the list to the upper int(Ceiling) first.
;; Examples:
;; >>> (lst (list 1.0 2.0 3.0))
;; 14
;; >>> (lst (list 1.0 4.0 9.0))
;; 98
;; >>> (lst (list 1.0 3.0 5.0 7.0))
;; 84
;; >>> (lst (list 1.4 4.2 0.0))
;; 29
;; >>> (lst (list -2.4 1.0 1.0))
;; 6

;; You are given a list of numbers.
;; You need to return the sum of squared numbers in the given list,
;; round each element in the list to the upper int(Ceiling) first.
;; Examples:
;; >>> (lst (list 1.0 2.0 3.0))
;; 14
;; >>> (lst (list 1.0 4.0 9.0))
;; 98
;; >>> (lst (list 1.0 3.0 5.0 7.0))
;; 84
;; >>> (lst (list 1.4 4.2 0.0))
;; 29
;; >>> (lst (list -2.4 1.0 1.0))
;; 6

(define (sum_squares lst)
  ;; Map each element to its ceiling, square it, and sum all results.
  (apply + (map (lambda (x)
                  (expt (ceiling x) 2))
                lst)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_squares))
    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)
    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)
    (check-within (candidate (list 1.0 3.0 5.0 7.0)) 84 0.001)
    (check-within (candidate (list 1.4 4.2 0.0)) 29 0.001)
    (check-within (candidate (list -2.4 1.0 1.0)) 6 0.001)
    (check-within (candidate (list 100.0 1.0 15.0 2.0)) 10230 0.001)
    (check-within (candidate (list 10000.0 10000.0)) 200000000 0.001)
    (check-within (candidate (list -1.4 4.6 6.3)) 75 0.001)
    (check-within (candidate (list -1.4 17.9 18.9 19.9)) 1086 0.001)
    (check-within (candidate (list 0.0)) 0 0.001)
    (check-within (candidate (list -1.0)) 1 0.001)
    (check-within (candidate (list -1.0 1.0 0.0)) 2 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183976
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 135 (RKT) - HumanEval_135_can_arrange
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-within (candidate (list 1 2 4 3 5)) 3 0.001)
    (check-within (candidate (list 1 2 4 5)) -1 0.001)
    (check-within (candidate (list 1 4 2 5 6 7 8 9 10)) 2 0.001)
    (check-within (candidate (list 4 8 5 7 3)) 4 0.001)
    (check-within (candidate (list )) -1 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1

;; Return the largest index i such that arr[i] < arr[i-1].
;; If no such index exists, return -1.
(define (can_arrange arr)
  (cond
    [(null? arr) -1]                     ; empty list → no such element
    [else
     (let loop ([prev (car arr)]          ; previous element
                [rest (cdr arr)]          ; remaining list
                [idx  1]                  ; current index (0‑based)
                [max-idx -1])             ; best index found so far
       (if (null? rest)
           max-idx
           (let* ([curr (car rest)])
             (loop curr
                   (cdr rest)
                   (add1 idx)
                   (if (< curr prev)
                       (max max-idx idx)
                       max-idx)))))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-within (candidate (list 1 2 4 3 5)) 3 0.001)
    (check-within (candidate (list 1 2 4 5)) -1 0.001)
    (check-within (candidate (list 1 4 2 5 6 7 8 9 10)) 2 0.001)
    (check-within (candidate (list 4 8 5 7 3)) 4 0.001)
    (check-within (candidate (list )) -1 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183978
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it.
;; If no such element exists then return -1. The given list will not contain
;; duplicate values.
;;
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1

(define (can_arrange arr)
  ;; Handle empty or single‑element lists – no comparison can be made.
  (if (or (null? arr) (null? (cdr arr)))
      -1
      (let loop ((lst (cdr arr))          ; remaining elements
                 (prev (car arr))         ; previous element
                 (idx 1)                  ; current index
                 (best -1))               ; best index found so far
        (if (null? lst)
            best
            (let ((curr (car lst)))
              (if (< curr prev)
                  (loop (cdr lst) curr (+ idx 1) idx)   ; update best
                  (loop (cdr lst) curr (+ idx 1) best)))))))

;; Test cases
(displayln (can_arrange (list 1 2 4 3 5))) ; => 3
(displayln (can_arrange (list 1 2 3)))     ; => -1
(displayln (can_arrange (list 5 4 3 2 1))) ; => 1 (since 4<5, 3<4, 2<3, 1<2; largest index is 4)
(displayln (can_arrange (list 1)))         ; => -1
(displayln (can_arrange '()))              ; => -1
(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-within (candidate (list 1 2 4 3 5)) 3 0.001)
    (check-within (candidate (list 1 2 4 5)) -1 0.001)
    (check-within (candidate (list 1 4 2 5 6 7 8 9 10)) 2 0.001)
    (check-within (candidate (list 4 8 5 7 3)) 4 0.001)
    (check-within (candidate (list )) -1 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183978
STDOUT:
3
-1
4
-1
-1
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it.
;; If no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (define n (length arr))
  (let loop ([i (- n 1)])
    (cond
      [(< i 1) -1]                               ; reached start, no violation
      [(< (list-ref arr i) (list-ref arr (- i 1))) i] ; found a drop
      [else (loop (- i 1))])))                   ; continue searching
(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-within (candidate (list 1 2 4 3 5)) 3 0.001)
    (check-within (candidate (list 1 2 4 5)) -1 0.001)
    (check-within (candidate (list 1 4 2 5 6 7 8 9 10)) 2 0.001)
    (check-within (candidate (list 4 8 5 7 3)) 4 0.001)
    (check-within (candidate (list )) -1 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183978
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it.
;; If no such element exists then return -1. The given list will not contain
;; duplicate values.
;;
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1

(define (can_arrange arr)
  ;; Start searching from the last index and move backwards.
  (let loop ((i (sub1 (length arr))))
    (cond
      ;; If we reach the first element (index 0) or an empty list,
      ;; there is no preceding element to compare with.
      [(< i 1) -1]
      ;; Check if the current element is strictly less than its predecessor.
      [(< (list-ref arr i) (list-ref arr (sub1 i))) i]
      ;; Continue searching with the previous index.
      [else (loop (sub1 i))])))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-within (candidate (list 1 2 4 3 5)) 3 0.001)
    (check-within (candidate (list 1 2 4 5)) -1 0.001)
    (check-within (candidate (list 1 4 2 5 6 7 8 9 10)) 2 0.001)
    (check-within (candidate (list 4 8 5 7 3)) 4 0.001)
    (check-within (candidate (list )) -1 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183978
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 136 (RKT) - HumanEval_136_largest_smallest_integers
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-within (candidate (list 2 4 1 3 5 7)) (list #f 1) 0.001)
    (check-within (candidate (list 2 4 1 3 5 7 0)) (list #f 1) 0.001)
    (check-within (candidate (list 1 3 2 4 5 6 -2)) (list -2 1) 0.001)
    (check-within (candidate (list 4 5 3 6 2 7 -7)) (list -7 2) 0.001)
    (check-within (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2) 0.001)
    (check-within (candidate (list )) (list #f #f) 0.001)
    (check-within (candidate (list 0)) (list #f #f) 0.001)
    (check-within (candidate (list -1 -3 -5 -6)) (list -1 #f) 0.001)
    (check-within (candidate (list -1 -3 -5 -6 0)) (list -1 #f) 0.001)
    (check-within (candidate (list -6 -4 -4 -3 1)) (list -3 1) 0.001)
    (check-within (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)

(define (largest_smallest_integers lst)
  ;; Separate the negatives and positives
  (define negatives
    (filter (lambda (x) (and (integer? x) (< x 0))) lst))
  (define positives
    (filter (lambda (x) (and (integer? x) (> x 0))) lst))

  ;; Find largest negative (or #f if none)
  (define largest-neg
    (if (empty? negatives)
        #f
        (apply max negatives)))

  ;; Find smallest positive (or #f if none)
  (define smallest-pos
    (if (empty? positives)
        #f
        (apply min positives)))

  ;; Return the result as a list
  (list largest-neg smallest-pos))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-within (candidate (list 2 4 1 3 5 7)) (list #f 1) 0.001)
    (check-within (candidate (list 2 4 1 3 5 7 0)) (list #f 1) 0.001)
    (check-within (candidate (list 1 3 2 4 5 6 -2)) (list -2 1) 0.001)
    (check-within (candidate (list 4 5 3 6 2 7 -7)) (list -7 2) 0.001)
    (check-within (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2) 0.001)
    (check-within (candidate (list )) (list #f #f) 0.001)
    (check-within (candidate (list 0)) (list #f #f) 0.001)
    (check-within (candidate (list -1 -3 -5 -6)) (list -1 #f) 0.001)
    (check-within (candidate (list -1 -3 -5 -6 0)) (list -1 #f) 0.001)
    (check-within (candidate (list -6 -4 -4 -3 1)) (list -3 1) 0.001)
    (check-within (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183979
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)

(define (largest_smallest_integers lst)
  (let* ([negatives (filter negative? lst)]
         [positives (filter positive? lst)]
         [neg-max    (if (null? negatives) #f (apply max negatives))]
         [pos-min    (if (null? positives) #f (apply min positives))])
    (list neg-max pos-min)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-within (candidate (list 2 4 1 3 5 7)) (list #f 1) 0.001)
    (check-within (candidate (list 2 4 1 3 5 7 0)) (list #f 1) 0.001)
    (check-within (candidate (list 1 3 2 4 5 6 -2)) (list -2 1) 0.001)
    (check-within (candidate (list 4 5 3 6 2 7 -7)) (list -7 2) 0.001)
    (check-within (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2) 0.001)
    (check-within (candidate (list )) (list #f #f) 0.001)
    (check-within (candidate (list 0)) (list #f #f) 0.001)
    (check-within (candidate (list -1 -3 -5 -6)) (list -1 #f) 0.001)
    (check-within (candidate (list -1 -3 -5 -6 0)) (list -1 #f) 0.001)
    (check-within (candidate (list -6 -4 -4 -3 1)) (list -3 1) 0.001)
    (check-within (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183979
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)

(define (largest_smallest_integers lst)
  (define max-neg #f)   ; largest negative integer seen so far
  (define min-pos #f)   ; smallest positive integer seen so far

  (for ([x lst])
    (cond
      [(and (integer? x) (< x 0))
       (when (or (not max-neg) (> x max-neg))
         (set! max-neg x))]
      [(and (integer? x) (> x 0))
       (when (or (not min-pos) (< x min-pos))
         (set! min-pos x))]))

  (list max-neg min-pos))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-within (candidate (list 2 4 1 3 5 7)) (list #f 1) 0.001)
    (check-within (candidate (list 2 4 1 3 5 7 0)) (list #f 1) 0.001)
    (check-within (candidate (list 1 3 2 4 5 6 -2)) (list -2 1) 0.001)
    (check-within (candidate (list 4 5 3 6 2 7 -7)) (list -7 2) 0.001)
    (check-within (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2) 0.001)
    (check-within (candidate (list )) (list #f #f) 0.001)
    (check-within (candidate (list 0)) (list #f #f) 0.001)
    (check-within (candidate (list -1 -3 -5 -6)) (list -1 #f) 0.001)
    (check-within (candidate (list -1 -3 -5 -6 0)) (list -1 #f) 0.001)
    (check-within (candidate (list -6 -4 -4 -3 1)) (list -3 1) 0.001)
    (check-within (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183979
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)

(define (largest_smallest_integers lst)
  (let loop ([rest lst] [max-neg #f] [min-pos #f])
    (if (null? rest)
        (list max-neg min-pos)
        (let* ([x (car rest)]
               [new-max-neg
                (cond
                  [(and (integer? x) (< x 0))
                   (if (or (false? max-neg) (> x max-neg)) x max-neg)]
                  [else max-neg])]
               [new-min-pos
                (cond
                  [(and (integer? x) (> x 0))
                   (if (or (false? min-pos) (< x min-pos)) x min-pos)]
                  [else min-pos])])
          (loop (cdr rest) new-max-neg new-min-pos)))))

;; Test cases
(displayln (largest_smallest_integers (list 2 4 1 3 5 7))) ; (list #f 1)
(displayln (largest_smallest_integers (list)))            ; (list #f #f)
(displayln (largest_smallest_integers (list 0)))          ; (list #f #f)
(displayln (largest_smallest_integers (list -5 -1 -3 2 4 0))) ; (list -1 2)
(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-within (candidate (list 2 4 1 3 5 7)) (list #f 1) 0.001)
    (check-within (candidate (list 2 4 1 3 5 7 0)) (list #f 1) 0.001)
    (check-within (candidate (list 1 3 2 4 5 6 -2)) (list -2 1) 0.001)
    (check-within (candidate (list 4 5 3 6 2 7 -7)) (list -7 2) 0.001)
    (check-within (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2) 0.001)
    (check-within (candidate (list )) (list #f #f) 0.001)
    (check-within (candidate (list 0)) (list #f #f) 0.001)
    (check-within (candidate (list -1 -3 -5 -6)) (list -1 #f) 0.001)
    (check-within (candidate (list -1 -3 -5 -6 0)) (list -1 #f) 0.001)
    (check-within (candidate (list -6 -4 -4 -3 1)) (list -3 1) 0.001)
    (check-within (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183979
STDOUT:
(#f 1)
(#f #f)
(#f #f)
(-1 2)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 138 (RKT) - HumanEval_138_is_equal_to_sum_even
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-within (candidate 4) #f 0.001)
    (check-within (candidate 6) #f 0.001)
    (check-within (candidate 8) #t 0.001)
    (check-within (candidate 10) #t 0.001)
    (check-within (candidate 11) #f 0.001)
    (check-within (candidate 12) #t 0.001)
    (check-within (candidate 13) #f 0.001)
    (check-within (candidate 16) #t 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (and (even? n) (>= n 8)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-within (candidate 4) #f 0.001)
    (check-within (candidate 6) #f 0.001)
    (check-within (candidate 8) #t 0.001)
    (check-within (candidate 10) #t 0.001)
    (check-within (candidate 11) #f 0.001)
    (check-within (candidate 12) #t 0.001)
    (check-within (candidate 13) #f 0.001)
    (check-within (candidate 16) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183981
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  ;; A sum of 4 positive even numbers is always even and at least 8 (2+2+2+2).
  ;; Therefore, the condition is simply that n is even and n ≥ 8.
  (and (even? n) (>= n 8)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-within (candidate 4) #f 0.001)
    (check-within (candidate 6) #f 0.001)
    (check-within (candidate 8) #t 0.001)
    (check-within (candidate 10) #t 0.001)
    (check-within (candidate 11) #f 0.001)
    (check-within (candidate 12) #t 0.001)
    (check-within (candidate 13) #f 0.001)
    (check-within (candidate 16) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183981
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t

;; Evaluate whether the given number n can be written as the sum of exactly
;; 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  ;; A sum of four positive even numbers must be even and at least 8
  (and (even? n) (>= n 8)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-within (candidate 4) #f 0.001)
    (check-within (candidate 6) #f 0.001)
    (check-within (candidate 8) #t 0.001)
    (check-within (candidate 10) #t 0.001)
    (check-within (candidate 11) #f 0.001)
    (check-within (candidate 12) #t 0.001)
    (check-within (candidate 13) #f 0.001)
    (check-within (candidate 16) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183981
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (and (integer? n)          ; n must be an integer
       (even? n)             ; n must be even
       (>= n 8)))            ; the smallest sum of 4 positive evens is 8
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-within (candidate 4) #f 0.001)
    (check-within (candidate 6) #f 0.001)
    (check-within (candidate 8) #t 0.001)
    (check-within (candidate 10) #t 0.001)
    (check-within (candidate 11) #f 0.001)
    (check-within (candidate 12) #t 0.001)
    (check-within (candidate 13) #f 0.001)
    (check-within (candidate 16) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183981
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 146 (RKT) - HumanEval_146_specialFilter
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Write a function that takes a list of numbers as input and returns 
;; the number of elements in the list that are greater than 10 and both 
;; first and last digits of a number are odd (1, 3, 5, 7, 9).
;; For example:
;; >>> (specialFilter (list 15 -73 14 -15))
;; 1
;; >>> (specialFilter (list 33 -2 -3 45 21 109))
;; 2

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate specialFilter))
    (check-within (candidate (list 5 -2 1 -5)) 0 0.001)
    (check-within (candidate (list 15 -73 14 -15)) 1 0.001)
    (check-within (candidate (list 33 -2 -3 45 21 109)) 2 0.001)
    (check-within (candidate (list 43 -12 93 125 121 109)) 4 0.001)
    (check-within (candidate (list 71 -2 -33 75 21 19)) 3 0.001)
    (check-within (candidate (list 1)) 0 0.001)
    (check-within (candidate (list )) 0 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Write a function that takes a list of numbers as input and returns 
;; the number of elements in the list that are greater than 10 and both 
;; first and last digits of a number are odd (1, 3, 5, 7, 9).
;; For example:
;; >>> (specialFilter (list 15 -73 14 -15))
;; 1
;; >>> (specialFilter (list 33 -2 -3 45 21 109))
;; 2

;; Count the numbers in `nums` that are > 10 and whose
;; first and last decimal digits are odd.
(define (specialFilter nums)
  ;; Return true if `n` is an integer whose first and last digits are odd.
  (define (odd-first-last? n)
    (and (integer? n)
         (> n 10)
         (let* ([last (modulo n 10)]
                [first (let loop ([x n])
                         (if (< x 10)
                             x
                             (loop (quotient x 10))))])
           (and (odd? first) (odd? last)))))
  
  ;; Use `filter` to keep only the numbers that satisfy the predicate
  ;; and then return the length of that list.
  (length (filter odd-first-last? nums)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate specialFilter))
    (check-within (candidate (list 5 -2 1 -5)) 0 0.001)
    (check-within (candidate (list 15 -73 14 -15)) 1 0.001)
    (check-within (candidate (list 33 -2 -3 45 21 109)) 2 0.001)
    (check-within (candidate (list 43 -12 93 125 121 109)) 4 0.001)
    (check-within (candidate (list 71 -2 -33 75 21 19)) 3 0.001)
    (check-within (candidate (list 1)) 0 0.001)
    (check-within (candidate (list )) 0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828001
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Write a function that takes a list of numbers as input and returns 
;; the number of elements in the list that are greater than 10 and both 
;; first and last digits of a number are odd (1, 3, 5, 7, 9).
;; For example:
;; >>> (specialFilter (list 15 -73 14 -15))
;; 1
;; >>> (specialFilter (list 33 -2 -3 45 21 109))
;; 2

;; Write a function that takes a list of numbers as input and returns 
;; the number of elements in the list that are greater than 10 and both 
;; first and last digits of a number are odd (1, 3, 5, 7, 9).
;; For example:
;; >>> (specialFilter (list 15 -73 14 -15))
;; 1
;; >>> (specialFilter (list 33 -2 -3 45 21 109))
;; 2
(define (specialFilter nums)
  ;; Helper: check if a digit is odd
  (define (odd? n)
    (= 1 (modulo n 2)))

  ;; Helper: get the first digit of a non‑negative integer
  (define (first-digit n)
    (let loop ((x n))
      (if (< x 10)
          x
          (loop (quotient x 10)))))

  ;; Recursive fold that counts qualifying elements
  (define (count-special lst acc)
    (if (null? lst)
        acc
        (let ((n (car lst)))
          (if (and (> n 10)                     ; >10
                   (odd? (first-digit (abs n))) ; first digit odd
                   (odd? (modulo (abs n) 10)))   ; last digit odd
              (count-special (cdr lst) (+ acc 1))
              (count-special (cdr lst) acc)))))

  (count-special nums 0))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate specialFilter))
    (check-within (candidate (list 5 -2 1 -5)) 0 0.001)
    (check-within (candidate (list 15 -73 14 -15)) 1 0.001)
    (check-within (candidate (list 33 -2 -3 45 21 109)) 2 0.001)
    (check-within (candidate (list 43 -12 93 125 121 109)) 4 0.001)
    (check-within (candidate (list 71 -2 -33 75 21 19)) 3 0.001)
    (check-within (candidate (list 1)) 0 0.001)
    (check-within (candidate (list )) 0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828001
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Write a function that takes a list of numbers as input and returns 
;; the number of elements in the list that are greater than 10 and both 
;; first and last digits of a number are odd (1, 3, 5, 7, 9).
;; For example:
;; >>> (specialFilter (list 15 -73 14 -15))
;; 1
;; >>> (specialFilter (list 33 -2 -3 45 21 109))
;; 2

;; Count how many numbers in the list are
;; 1. greater than 10
;; 2. have an odd first digit
;; 3. have an odd last digit
(define (specialFilter nums)
  ;; Helper: return the first (most‑significant) digit of a positive integer
  (define (first-digit n)
    (if (< n 10)
        n
        (first-digit (quotient n 10))))

  ;; Predicate that checks all three conditions for a single number
  (define (qualify? n)
    (and (> n 10)
         (odd? (first-digit n))
         (odd? (modulo n 10))))

  ;; Count the qualifying elements
  (length (filter qualify? nums)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate specialFilter))
    (check-within (candidate (list 5 -2 1 -5)) 0 0.001)
    (check-within (candidate (list 15 -73 14 -15)) 1 0.001)
    (check-within (candidate (list 33 -2 -3 45 21 109)) 2 0.001)
    (check-within (candidate (list 43 -12 93 125 121 109)) 4 0.001)
    (check-within (candidate (list 71 -2 -33 75 21 19)) 3 0.001)
    (check-within (candidate (list 1)) 0 0.001)
    (check-within (candidate (list )) 0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828001
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Write a function that takes a list of numbers as input and returns 
;; the number of elements in the list that are greater than 10 and both 
;; first and last digits of a number are odd (1, 3, 5, 7, 9).
;; For example:
;; >>> (specialFilter (list 15 -73 14 -15))
;; 1
;; >>> (specialFilter (list 33 -2 -3 45 21 109))
;; 2

;; Returns the number of elements in `nums` that are greater than 10
;; **and** whose first and last digits are both odd (1, 3, 5, 7, 9).
(define (specialFilter nums)
  ;; Helper: get the first digit of a (possibly negative) integer.
  (define (first-digit n)
    (let loop ([x (abs n)])
      (if (< x 10)
          x
          (loop (quotient x 10)))))

  ;; Helper: test whether a single digit is odd.
  (define (odd? d) (= (remainder d 2) 1))

  ;; Predicate for a number that satisfies the required conditions.
  (define (special? n)
    (and (> n 10)
         (odd? (first-digit n))
         (odd? (remainder n 10))))

  ;; Count all elements that satisfy `special?`.
  (length (filter special? nums)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate specialFilter))
    (check-within (candidate (list 5 -2 1 -5)) 0 0.001)
    (check-within (candidate (list 15 -73 14 -15)) 1 0.001)
    (check-within (candidate (list 33 -2 -3 45 21 109)) 2 0.001)
    (check-within (candidate (list 43 -12 93 125 121 109)) 4 0.001)
    (check-within (candidate (list 71 -2 -33 75 21 19)) 3 0.001)
    (check-within (candidate (list 1)) 0 0.001)
    (check-within (candidate (list )) 0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828001
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 149 (RKT) - HumanEval_149_sorted_list_sum
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Write a function that accepts a list of strings as a parameter,
;; deletes the strings that have odd lengths from it,
;; and returns the resulted list with a sorted order,
;; The list is always a list of strings and never a list of numbers,
;; and it may contain duplicates.
;; The order of the list should be ascending by length of each word, and you
;; should return the list sorted by that rule.
;; If two words have the same length, sort the list alphabetically.
;; The function should return a list of strings in sorted order.
;; You may assume that all words will have the same length.
;; For example:
;; >>> (list_sort (list "aa" "a" "aaa"))
;; (list "aa")
;; >>> (list_sort (list "ab" "a" "aaa" "cd"))
;; (list "ab" "cd")

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sorted_list_sum))
    (check-within (candidate (list "aa" "a" "aaa")) (list "aa") 0.001)
    (check-within (candidate (list "school" "AI" "asdf" "b")) (list "AI" "asdf" "school") 0.001)
    (check-within (candidate (list "d" "b" "c" "a")) (list ) 0.001)
    (check-within (candidate (list "d" "dcba" "abcd" "a")) (list "abcd" "dcba") 0.001)
    (check-within (candidate (list "AI" "ai" "au")) (list "AI" "ai" "au") 0.001)
    (check-within (candidate (list "a" "b" "b" "c" "c" "a")) (list ) 0.001)
    (check-within (candidate (list "aaaa" "bbbb" "dd" "cc")) (list "cc" "dd" "aaaa" "bbbb") 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Write a function that accepts a list of strings as a parameter,
;; deletes the strings that have odd lengths from it,
;; and returns the resulted list with a sorted order,
;; The list is always a list of strings and never a list of numbers,
;; and it may contain duplicates.
;; The order of the list should be ascending by length of each word, and you
;; should return the list sorted by that rule.
;; If two words have the same length, sort the list alphabetically.
;; The function should return a list of strings in sorted order.
;; You may assume that all words will have the same length.
;; For example:
;; >>> (list_sort (list "aa" "a" "aaa"))
;; (list "aa")
;; >>> (list_sort (list "ab" "a" "aaa" "cd"))
;; (list "ab" "cd")

;; Write a function that accepts a list of strings as a parameter,
;; deletes the strings that have odd lengths from it,
;; and returns the resulted list with a sorted order,
;; The list is always a list of strings and never a list of numbers,
;; and it may contain duplicates.
;; The order of the list should be ascending by length of each word, and you
;; should return the list sorted by that rule.
;; If two words have the same length, sort the list alphabetically.
;; The function should return a list of strings in sorted order.
;; You may assume that all words will have the same length.
;; For example:
;; >>> (list_sort (list "aa" "a" "aaa"))
;; (list "aa")
;; >>> (list_sort (list "ab" "a" "aaa" "cd"))
;; (list "ab" "cd")
(define (sorted_list_sum lst)
  ;; Keep only strings with even length
  (define even-strings
    (filter (lambda (s) (even? (string-length s))) lst))
  ;; Sort by length first, then alphabetically
  (sort even-strings
        (lambda (a b)
          (cond [(< (string-length a) (string-length b)) #t]
                [(> (string-length a) (string-length b)) #f]
                [else (string<? a b)]))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sorted_list_sum))
    (check-within (candidate (list "aa" "a" "aaa")) (list "aa") 0.001)
    (check-within (candidate (list "school" "AI" "asdf" "b")) (list "AI" "asdf" "school") 0.001)
    (check-within (candidate (list "d" "b" "c" "a")) (list ) 0.001)
    (check-within (candidate (list "d" "dcba" "abcd" "a")) (list "abcd" "dcba") 0.001)
    (check-within (candidate (list "AI" "ai" "au")) (list "AI" "ai" "au") 0.001)
    (check-within (candidate (list "a" "b" "b" "c" "c" "a")) (list ) 0.001)
    (check-within (candidate (list "aaaa" "bbbb" "dd" "cc")) (list "cc" "dd" "aaaa" "bbbb") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828004
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Write a function that accepts a list of strings as a parameter,
;; deletes the strings that have odd lengths from it,
;; and returns the resulted list with a sorted order,
;; The list is always a list of strings and never a list of numbers,
;; and it may contain duplicates.
;; The order of the list should be ascending by length of each word, and you
;; should return the list sorted by that rule.
;; If two words have the same length, sort the list alphabetically.
;; The function should return a list of strings in sorted order.
;; You may assume that all words will have the same length.
;; For example:
;; >>> (list_sort (list "aa" "a" "aaa"))
;; (list "aa")
;; >>> (list_sort (list "ab" "a" "aaa" "cd"))
;; (list "ab" "cd")

;; Delete all strings that have odd lengths from the input list,
;; then return the remaining strings sorted first by length (ascending)
;; and, for equal lengths, alphabetically.
(define (sorted_list_sum lst)
  ;; Keep only even‑length strings
  (define even-strings
    (filter (lambda (s) (even? (string-length s))) lst))

  ;; Comparator: first by length, then alphabetically
  (define (compare a b)
    (cond
      [(< (string-length a) (string-length b)) #t]
      [(> (string-length a) (string-length b)) #f]
      [else (string<? a b)]))

  ;; Sort and return
  (sort even-strings compare))

;; Examples
(displayln (sorted_list_sum (list "aa" "a" "aaa")))   ; => '("aa")
(displayln (sorted_list_sum (list "ab" "a" "aaa" "cd"))) ; => '("ab" "cd")
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sorted_list_sum))
    (check-within (candidate (list "aa" "a" "aaa")) (list "aa") 0.001)
    (check-within (candidate (list "school" "AI" "asdf" "b")) (list "AI" "asdf" "school") 0.001)
    (check-within (candidate (list "d" "b" "c" "a")) (list ) 0.001)
    (check-within (candidate (list "d" "dcba" "abcd" "a")) (list "abcd" "dcba") 0.001)
    (check-within (candidate (list "AI" "ai" "au")) (list "AI" "ai" "au") 0.001)
    (check-within (candidate (list "a" "b" "b" "c" "c" "a")) (list ) 0.001)
    (check-within (candidate (list "aaaa" "bbbb" "dd" "cc")) (list "cc" "dd" "aaaa" "bbbb") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828004
STDOUT:
(aa)
(ab cd)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Write a function that accepts a list of strings as a parameter,
;; deletes the strings that have odd lengths from it,
;; and returns the resulted list with a sorted order,
;; The list is always a list of strings and never a list of numbers,
;; and it may contain duplicates.
;; The order of the list should be ascending by length of each word, and you
;; should return the list sorted by that rule.
;; If two words have the same length, sort the list alphabetically.
;; The function should return a list of strings in sorted order.
;; You may assume that all words will have the same length.
;; For example:
;; >>> (list_sort (list "aa" "a" "aaa"))
;; (list "aa")
;; >>> (list_sort (list "ab" "a" "aaa" "cd"))
;; (list "ab" "cd")

;; Delete all strings with odd lengths, then sort the remaining strings
;; first by ascending length and then alphabetically for equal lengths.
(define (sorted_list_sum lst)
  ;; Keep only even‑length strings
  (define even-words
    (filter (lambda (s) (even? (string-length s))) lst))
  ;; Comparator: shorter first; if equal length, alphabetical
  (define cmp
    (lambda (a b)
      (or (< (string-length a) (string-length b))
          (and (= (string-length a) (string-length b))
               (string<? a b)))))
  ;; Sort and return
  (sort even-words cmp))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sorted_list_sum))
    (check-within (candidate (list "aa" "a" "aaa")) (list "aa") 0.001)
    (check-within (candidate (list "school" "AI" "asdf" "b")) (list "AI" "asdf" "school") 0.001)
    (check-within (candidate (list "d" "b" "c" "a")) (list ) 0.001)
    (check-within (candidate (list "d" "dcba" "abcd" "a")) (list "abcd" "dcba") 0.001)
    (check-within (candidate (list "AI" "ai" "au")) (list "AI" "ai" "au") 0.001)
    (check-within (candidate (list "a" "b" "b" "c" "c" "a")) (list ) 0.001)
    (check-within (candidate (list "aaaa" "bbbb" "dd" "cc")) (list "cc" "dd" "aaaa" "bbbb") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828004
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Write a function that accepts a list of strings as a parameter,
;; deletes the strings that have odd lengths from it,
;; and returns the resulted list with a sorted order,
;; The list is always a list of strings and never a list of numbers,
;; and it may contain duplicates.
;; The order of the list should be ascending by length of each word, and you
;; should return the list sorted by that rule.
;; If two words have the same length, sort the list alphabetically.
;; The function should return a list of strings in sorted order.
;; You may assume that all words will have the same length.
;; For example:
;; >>> (list_sort (list "aa" "a" "aaa"))
;; (list "aa")
;; >>> (list_sort (list "ab" "a" "aaa" "cd"))
;; (list "ab" "cd")

;; Delete strings with odd lengths and return the remaining strings
;; sorted first by ascending length and then alphabetically for ties.
(define (sorted_list_sum lst)
  ;; Keep only strings whose length is even
  (define even-strings
    (filter (lambda (s) (even? (string-length s))) lst))

  ;; Sort by length, then alphabetically
  (sort even-strings
        (lambda (a b)
          (let* ((la (string-length a))
                 (lb (string-length b)))
            (cond
              [(< la lb) #t]
              [(> la lb) #f]
              [else (string<? a b)])))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sorted_list_sum))
    (check-within (candidate (list "aa" "a" "aaa")) (list "aa") 0.001)
    (check-within (candidate (list "school" "AI" "asdf" "b")) (list "AI" "asdf" "school") 0.001)
    (check-within (candidate (list "d" "b" "c" "a")) (list ) 0.001)
    (check-within (candidate (list "d" "dcba" "abcd" "a")) (list "abcd" "dcba") 0.001)
    (check-within (candidate (list "AI" "ai" "au")) (list "AI" "ai" "au") 0.001)
    (check-within (candidate (list "a" "b" "b" "c" "c" "a")) (list ) 0.001)
    (check-within (candidate (list "aaaa" "bbbb" "dd" "cc")) (list "cc" "dd" "aaaa" "bbbb") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828004
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 151 (RKT) - HumanEval_151_double_the_difference
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given a list of numbers, return the sum of squares of the numbers
;; in the list that are odd. Ignore numbers that are negative or not integers.
;; >>> (double_the_difference (list 1 3 2 0))
;; 10
;; >>> (double_the_difference (list -1 -2 0))
;; 0
;; >>> (double_the_difference (list 9 -2))
;; 81
;; >>> (double_the_difference (list 0))
;; 0
;; If the input list is empty, return 0.

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate double_the_difference))
    (check-within (candidate (list )) 0 0.001)
    (check-within (candidate (list 5.0 4.0)) 25 0.001)
    (check-within (candidate (list 0.1 0.2 0.3)) 0 0.001)
    (check-within (candidate (list -10.0 -20.0 -30.0)) 0 0.001)
    (check-within (candidate (list -1.0 -2.0 8.0)) 0 0.001)
    (check-within (candidate (list 0.2 3.0 5.0)) 34 0.001)
    (check-within (candidate (list -9.0 -7.0 -5.0 -3.0 -1.0 1.0 3.0 5.0 7.0 9.0)) 165 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given a list of numbers, return the sum of squares of the numbers
;; in the list that are odd. Ignore numbers that are negative or not integers.
;; >>> (double_the_difference (list 1 3 2 0))
;; 10
;; >>> (double_the_difference (list -1 -2 0))
;; 0
;; >>> (double_the_difference (list 9 -2))
;; 81
;; >>> (double_the_difference (list 0))
;; 0
;; If the input list is empty, return 0.

;; Given a list of numbers, return the sum of squares of the numbers
;; that are odd. Ignore numbers that are negative or not integers.
;; >>> (double_the_difference (list 1 3 2 0))
;; 10
;; >>> (double_the_difference (list -1 -2 0))
;; 0
;; >>> (double_the_difference (list 9 -2))
;; 81
;; >>> (double_the_difference (list 0))
;; 0
;; If the input list is empty, return 0.
(define (double_the_difference lst)
  (foldl (lambda (n acc)
           (if (and (integer? n) (positive? n) (odd? n))
               (+ acc (* n n))
               acc))
         0
         lst))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate double_the_difference))
    (check-within (candidate (list )) 0 0.001)
    (check-within (candidate (list 5.0 4.0)) 25 0.001)
    (check-within (candidate (list 0.1 0.2 0.3)) 0 0.001)
    (check-within (candidate (list -10.0 -20.0 -30.0)) 0 0.001)
    (check-within (candidate (list -1.0 -2.0 8.0)) 0 0.001)
    (check-within (candidate (list 0.2 3.0 5.0)) 34 0.001)
    (check-within (candidate (list -9.0 -7.0 -5.0 -3.0 -1.0 1.0 3.0 5.0 7.0 9.0)) 165 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828006
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given a list of numbers, return the sum of squares of the numbers
;; in the list that are odd. Ignore numbers that are negative or not integers.
;; >>> (double_the_difference (list 1 3 2 0))
;; 10
;; >>> (double_the_difference (list -1 -2 0))
;; 0
;; >>> (double_the_difference (list 9 -2))
;; 81
;; >>> (double_the_difference (list 0))
;; 0
;; If the input list is empty, return 0.

;; Given a list of numbers, return the sum of squares of the numbers
;; that are odd. Ignore numbers that are negative or not integers.
;; >>> (double_the_difference (list 1 3 2 0))
;; 10
;; >>> (double_the_difference (list -1 -2 0))
;; 0
;; >>> (double_the_difference (list 9 -2))
;; 81
;; >>> (double_the_difference (list 0))
;; 0
;; If the input list is empty, return 0.
(define (double_the_difference lst)
  (foldl (lambda (x acc)
           (if (and (integer? x) (> x 0) (odd? x))
               (+ acc (* x x))
               acc))
         0
         lst))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate double_the_difference))
    (check-within (candidate (list )) 0 0.001)
    (check-within (candidate (list 5.0 4.0)) 25 0.001)
    (check-within (candidate (list 0.1 0.2 0.3)) 0 0.001)
    (check-within (candidate (list -10.0 -20.0 -30.0)) 0 0.001)
    (check-within (candidate (list -1.0 -2.0 8.0)) 0 0.001)
    (check-within (candidate (list 0.2 3.0 5.0)) 34 0.001)
    (check-within (candidate (list -9.0 -7.0 -5.0 -3.0 -1.0 1.0 3.0 5.0 7.0 9.0)) 165 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828006
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given a list of numbers, return the sum of squares of the numbers
;; in the list that are odd. Ignore numbers that are negative or not integers.
;; >>> (double_the_difference (list 1 3 2 0))
;; 10
;; >>> (double_the_difference (list -1 -2 0))
;; 0
;; >>> (double_the_difference (list 9 -2))
;; 81
;; >>> (double_the_difference (list 0))
;; 0
;; If the input list is empty, return 0.

;; Given a list of numbers, return the sum of squares of the numbers
;; that are odd. Ignore numbers that are negative or not integers.
;; >>> (double_the_difference (list 1 3 2 0))
;; 10
;; >>> (double_the_difference (list -1 -2 0))
;; 0
;; >>> (double_the_difference (list 9 -2))
;; 81
;; >>> (double_the_difference (list 0))
;; 0
;; If the input list is empty, return 0.
(define (double_the_difference lst)
  (foldl (lambda (x acc)
           (if (and (integer? x) (>= x 0) (odd? x))
               (+ acc (* x x))
               acc))
         0
         lst))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate double_the_difference))
    (check-within (candidate (list )) 0 0.001)
    (check-within (candidate (list 5.0 4.0)) 25 0.001)
    (check-within (candidate (list 0.1 0.2 0.3)) 0 0.001)
    (check-within (candidate (list -10.0 -20.0 -30.0)) 0 0.001)
    (check-within (candidate (list -1.0 -2.0 8.0)) 0 0.001)
    (check-within (candidate (list 0.2 3.0 5.0)) 34 0.001)
    (check-within (candidate (list -9.0 -7.0 -5.0 -3.0 -1.0 1.0 3.0 5.0 7.0 9.0)) 165 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828006
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given a list of numbers, return the sum of squares of the numbers
;; in the list that are odd. Ignore numbers that are negative or not integers.
;; >>> (double_the_difference (list 1 3 2 0))
;; 10
;; >>> (double_the_difference (list -1 -2 0))
;; 0
;; >>> (double_the_difference (list 9 -2))
;; 81
;; >>> (double_the_difference (list 0))
;; 0
;; If the input list is empty, return 0.

;; Given a list of numbers, return the sum of squares of the numbers
;; that are odd. Ignore numbers that are negative or not integers.
;; >>> (double_the_difference (list 1 3 2 0))
;; 10
;; >>> (double_the_difference (list -1 -2 0))
;; 0
;; >>> (double_the_difference (list 9 -2))
;; 81
;; >>> (double_the_difference (list 0))
;; 0
;; If the input list is empty, return 0.
(define (double_the_difference lst)
  (foldl (lambda (x acc)
           (if (and (integer? x) (> x 0) (odd? x))
               (+ acc (* x x))
               acc))
         0
         lst))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate double_the_difference))
    (check-within (candidate (list )) 0 0.001)
    (check-within (candidate (list 5.0 4.0)) 25 0.001)
    (check-within (candidate (list 0.1 0.2 0.3)) 0 0.001)
    (check-within (candidate (list -10.0 -20.0 -30.0)) 0 0.001)
    (check-within (candidate (list -1.0 -2.0 8.0)) 0 0.001)
    (check-within (candidate (list 0.2 3.0 5.0)) 34 0.001)
    (check-within (candidate (list -9.0 -7.0 -5.0 -3.0 -1.0 1.0 3.0 5.0 7.0 9.0)) 165 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755828006
STDOUT: (empty)
STDERR: (empty)
--------------------
