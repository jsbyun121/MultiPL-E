As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 60 (ML) - HumanEval_60_sum_to_n
================================================================================

PROMPT:
----------------------------------------
(**sum_to_n is a function that sums numbers from 1 to n.
 * >>> sum_to_n 30
 * 465
 * >>> sum_to_n 100
 * 5050
 * >>> sum_to_n 5
 * 15
 * >>> sum_to_n 10
 * 55
 * >>> sum_to_n 1
 * 1
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = sum_to_n in
  (assert ((candidate 1) = 1));
  (assert ((candidate 6) = 21));
  (assert ((candidate 11) = 66));
  (assert ((candidate 30) = 465));
  (assert ((candidate 100) = 5050));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**sum_to_n is a function that sums numbers from 1 to n.
 * >>> sum_to_n 30
 * 465
 * >>> sum_to_n 100
 * 5050
 * >>> sum_to_n 5
 * 15
 * >>> sum_to_n 10
 * 55
 * >>> sum_to_n 1
 * 1
*)
let sum_to_n (n : int) : int =
  n * (n + 1) / 2

let assertions =
 let candidate = sum_to_n in
  (assert ((candidate 1) = 1));
  (assert ((candidate 6) = 21));
  (assert ((candidate 11) = 66));
  (assert ((candidate 30) = 465));
  (assert ((candidate 100) = 5050));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**sum_to_n is a function that sums numbers from 1 to n.
 * >>> sum_to_n 30
 * 465
 * >>> sum_to_n 100
 * 5050
 * >>> sum_to_n 5
 * 15
 * >>> sum_to_n 10
 * 55
 * >>> sum_to_n 1
 * 1
*)
let sum_to_n (n : int) : int =
  n * (n + 1) / 2

let assertions =
 let candidate = sum_to_n in
  (assert ((candidate 1) = 1));
  (assert ((candidate 6) = 21));
  (assert ((candidate 11) = 66));
  (assert ((candidate 30) = 465));
  (assert ((candidate 100) = 5050));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**sum_to_n is a function that sums numbers from 1 to n.
 * >>> sum_to_n 30
 * 465
 * >>> sum_to_n 100
 * 5050
 * >>> sum_to_n 5
 * 15
 * >>> sum_to_n 10
 * 55
 * >>> sum_to_n 1
 * 1
*)
(* Sum all integers from 1 up to n *)
let rec sum_to_n (n : int) : int =
  if n <= 0 then 0
  else n + sum_to_n (n - 1)

let assertions =
 let candidate = sum_to_n in
  (assert ((candidate 1) = 1));
  (assert ((candidate 6) = 21));
  (assert ((candidate 11) = 66));
  (assert ((candidate 30) = 465));
  (assert ((candidate 100) = 5050));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**sum_to_n is a function that sums numbers from 1 to n.
 * >>> sum_to_n 30
 * 465
 * >>> sum_to_n 100
 * 5050
 * >>> sum_to_n 5
 * 15
 * >>> sum_to_n 10
 * 55
 * >>> sum_to_n 1
 * 1
*)
let sum_to_n (n : int) : int =
  (* Use the arithmetic series formula: 1 + 2 + ... + n = n*(n+1)/2 *)
  if n <= 0 then 0
  else n * (n + 1) / 2

let assertions =
 let candidate = sum_to_n in
  (assert ((candidate 1) = 1));
  (assert ((candidate 6) = 21));
  (assert ((candidate 11) = 66));
  (assert ((candidate 30) = 465));
  (assert ((candidate 100) = 5050));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 61 (ML) - HumanEval_61_correct_bracketing
================================================================================

PROMPT:
----------------------------------------
(**brackets is a string of "(" and ")".
 * return true if every opening bracket has a corresponding closing bracket.
 * >>> correct_bracketing "("
 * false
 * >>> correct_bracketing "()"
 * true
 * >>> correct_bracketing "(()())"
 * true
 * >>> correct_bracketing ")(()"
 * false
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = correct_bracketing in
  (assert ((candidate "()") = true));
  (assert ((candidate "(()())") = true));
  (assert ((candidate "()()(()())()") = true));
  (assert ((candidate "()()((()()())())(()()(()))") = true));
  (assert ((candidate "((()())))") = false));
  (assert ((candidate ")(()") = false));
  (assert ((candidate "(") = false));
  (assert ((candidate "((((") = false));
  (assert ((candidate ")") = false));
  (assert ((candidate "(()") = false));
  (assert ((candidate "()()(()())())(()") = false));
  (assert ((candidate "()()(()())()))()") = false));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**brackets is a string of "(" and ")".
 * return true if every opening bracket has a corresponding closing bracket.
 * >>> correct_bracketing "("
 * false
 * >>> correct_bracketing "()"
 * true
 * >>> correct_bracketing "(()())"
 * true
 * >>> correct_bracketing ")(()"
 * false
*)
let correct_bracketing (brackets : string) : bool =
  (* Auxiliary recursive function that walks through the string
     while keeping a counter of unmatched '(' characters. *)
  let rec aux i count =
    if i = String.length brackets then
      (* All characters processed – true only if no unmatched '(' remain. *)
      count = 0
    else
      match brackets.[i] with
      | '(' ->
          (* Found an opening bracket – increase the counter. *)
          aux (i + 1) (count + 1)
      | ')' ->
          (* Found a closing bracket – there must be a matching '('
             before it. If the counter is already zero, the string
             is unbalanced. *)
          if count = 0 then
            false
          else
            aux (i + 1) (count - 1)
      | _ ->
          (* Ignore any other characters – they do not affect bracketing. *)
          aux (i + 1) count
  in
  aux 0 0

let assertions =
 let candidate = correct_bracketing in
  (assert ((candidate "()") = true));
  (assert ((candidate "(()())") = true));
  (assert ((candidate "()()(()())()") = true));
  (assert ((candidate "()()((()()())())(()()(()))") = true));
  (assert ((candidate "((()())))") = false));
  (assert ((candidate ")(()") = false));
  (assert ((candidate "(") = false));
  (assert ((candidate "((((") = false));
  (assert ((candidate ")") = false));
  (assert ((candidate "(()") = false));
  (assert ((candidate "()()(()())())(()") = false));
  (assert ((candidate "()()(()())()))()") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**brackets is a string of "(" and ")".
 * return true if every opening bracket has a corresponding closing bracket.
 * >>> correct_bracketing "("
 * false
 * >>> correct_bracketing "()"
 * true
 * >>> correct_bracketing "(()())"
 * true
 * >>> correct_bracketing ")(()"
 * false
*)
(* Return true iff every opening bracket '(' has a matching closing bracket ')' *)
let correct_bracketing (brackets : string) : bool =
  let n = String.length brackets in
  let rec aux i count =
    if i = n then count = 0
    else
      match String.get brackets i with
      | '(' -> aux (i + 1) (count + 1)
      | ')' ->
          if count = 0 then false
          else aux (i + 1) (count - 1)
      | _ -> aux (i + 1) count   (* ignore any other character *)
  in
  aux 0 0

let assertions =
 let candidate = correct_bracketing in
  (assert ((candidate "()") = true));
  (assert ((candidate "(()())") = true));
  (assert ((candidate "()()(()())()") = true));
  (assert ((candidate "()()((()()())())(()()(()))") = true));
  (assert ((candidate "((()())))") = false));
  (assert ((candidate ")(()") = false));
  (assert ((candidate "(") = false));
  (assert ((candidate "((((") = false));
  (assert ((candidate ")") = false));
  (assert ((candidate "(()") = false));
  (assert ((candidate "()()(()())())(()") = false));
  (assert ((candidate "()()(()())()))()") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**brackets is a string of "(" and ")".
 * return true if every opening bracket has a corresponding closing bracket.
 * >>> correct_bracketing "("
 * false
 * >>> correct_bracketing "()"
 * true
 * >>> correct_bracketing "(()())"
 * true
 * >>> correct_bracketing ")(()"
 * false
*)
let correct_bracketing (brackets : string) : bool =
  (* Use a counter as a stack depth: +1 for '(', -1 for ')' *)
  let rec aux i depth =
    if i = String.length brackets then depth = 0
    else
      match brackets.[i] with
      | '(' -> aux (i + 1) (depth + 1)
      | ')' ->
          (* If we encounter a closing bracket when depth is 0, the
             brackets are unbalanced. *)
          if depth = 0 then false
          else aux (i + 1) (depth - 1)
      | _ -> aux (i + 1) depth   (* ignore any other characters *)
  in
  aux 0 0

let assertions =
 let candidate = correct_bracketing in
  (assert ((candidate "()") = true));
  (assert ((candidate "(()())") = true));
  (assert ((candidate "()()(()())()") = true));
  (assert ((candidate "()()((()()())())(()()(()))") = true));
  (assert ((candidate "((()())))") = false));
  (assert ((candidate ")(()") = false));
  (assert ((candidate "(") = false));
  (assert ((candidate "((((") = false));
  (assert ((candidate ")") = false));
  (assert ((candidate "(()") = false));
  (assert ((candidate "()()(()())())(()") = false));
  (assert ((candidate "()()(()())()))()") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**brackets is a string of "(" and ")".
 * return true if every opening bracket has a corresponding closing bracket.
 * >>> correct_bracketing "("
 * false
 * >>> correct_bracketing "()"
 * true
 * >>> correct_bracketing "(()())"
 * true
 * >>> correct_bracketing ")(()"
 * false
*)
(* Check if a string of parentheses is correctly balanced. *)
let correct_bracketing (brackets : string) : bool =
  let len = String.length brackets in
  let rec aux i count =
    if i = len then count = 0
    else
      match brackets.[i] with
      | '(' -> aux (i + 1) (count + 1)
      | ')' ->
          if count = 0 then false
          else aux (i + 1) (count - 1)
      | _ -> aux (i + 1) count  (* ignore any other characters *)
  in
  aux 0 0

let assertions =
 let candidate = correct_bracketing in
  (assert ((candidate "()") = true));
  (assert ((candidate "(()())") = true));
  (assert ((candidate "()()(()())()") = true));
  (assert ((candidate "()()((()()())())(()()(()))") = true));
  (assert ((candidate "((()())))") = false));
  (assert ((candidate ")(()") = false));
  (assert ((candidate "(") = false));
  (assert ((candidate "((((") = false));
  (assert ((candidate ")") = false));
  (assert ((candidate "(()") = false));
  (assert ((candidate "()()(()())())(()") = false));
  (assert ((candidate "()()(()())()))()") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 64 (ML) - HumanEval_64_vowels_count
================================================================================

PROMPT:
----------------------------------------
(**Write a function vowels_count which takes a string representing
 * a word as input and returns the number of vowels in the string.
 * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
 * vowel, but only when it is at the end of the given word.
 * Example:
 * >>> vowels_count "abcde"
 * 2
 * >>> vowels_count "ACEDY"
 * 3
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = vowels_count in
  (assert ((candidate "abcde") = 2));
  (assert ((candidate "Alone") = 3));
  (assert ((candidate "key") = 2));
  (assert ((candidate "bye") = 1));
  (assert ((candidate "keY") = 2));
  (assert ((candidate "bYe") = 1));
  (assert ((candidate "ACEDY") = 3));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Write a function vowels_count which takes a string representing
 * a word as input and returns the number of vowels in the string.
 * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
 * vowel, but only when it is at the end of the given word.
 * Example:
 * >>> vowels_count "abcde"
 * 2
 * >>> vowels_count "ACEDY"
 * 3
*)
let vowels_count (s : string) : int =
  let len = String.length s in
  (* If the string is empty, there are no vowels. *)
  if len = 0 then 0
  else
    let count = ref 0 in
    for i = 0 to len - 1 do
      let c = s.[i] in
      (* Count the standard vowels regardless of case. *)
      if c = 'a' || c = 'e' || c = 'i' || c = 'o' || c = 'u' ||
         c = 'A' || c = 'E' || c = 'I' || c = 'O' || c = 'U'
      then incr count
      (* Count 'y' only when it is the last character. *)
      else if (c = 'y' || c = 'Y') && i = len - 1 then incr count
    done;
    !count

let assertions =
 let candidate = vowels_count in
  (assert ((candidate "abcde") = 2));
  (assert ((candidate "Alone") = 3));
  (assert ((candidate "key") = 2));
  (assert ((candidate "bye") = 1));
  (assert ((candidate "keY") = 2));
  (assert ((candidate "bYe") = 1));
  (assert ((candidate "ACEDY") = 3));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Write a function vowels_count which takes a string representing
 * a word as input and returns the number of vowels in the string.
 * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
 * vowel, but only when it is at the end of the given word.
 * Example:
 * >>> vowels_count "abcde"
 * 2
 * >>> vowels_count "ACEDY"
 * 3
*)
let vowels_count (s : string) : int =
  let len = String.length s in
  let rec aux i acc =
    if i = len then acc
    else
      let c = Char.lowercase_ascii s.[i] in
      let acc =
        if c = 'a' || c = 'e' || c = 'i' || c = 'o' || c = 'u'
        then acc + 1
        else if c = 'y' && i = len - 1
        then acc + 1
        else acc
      in
      aux (i + 1) acc
  in
  aux 0 0

let assertions =
 let candidate = vowels_count in
  (assert ((candidate "abcde") = 2));
  (assert ((candidate "Alone") = 3));
  (assert ((candidate "key") = 2));
  (assert ((candidate "bye") = 1));
  (assert ((candidate "keY") = 2));
  (assert ((candidate "bYe") = 1));
  (assert ((candidate "ACEDY") = 3));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Write a function vowels_count which takes a string representing
 * a word as input and returns the number of vowels in the string.
 * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
 * vowel, but only when it is at the end of the given word.
 * Example:
 * >>> vowels_count "abcde"
 * 2
 * >>> vowels_count "ACEDY"
 * 3
*)
(* Count the number of vowels in a string.  
   Vowels are 'a', 'e', 'i', 'o', 'u' (case‑insensitive).  
   The letter 'y' is considered a vowel only when it appears as the last
   character of the string. *)
let vowels_count (s : string) : int =
  let len = String.length s in
  let rec aux i acc =
    if i >= len then acc
    else
      let c = String.get s i in
      let lower = Char.lowercase_ascii c in
      let is_vowel =
        lower = 'a' || lower = 'e' || lower = 'i' || lower = 'o' || lower = 'u'
        || (lower = 'y' && i = len - 1)
      in
      aux (i + 1) (if is_vowel then acc + 1 else acc)
  in
  aux 0 0

let assertions =
 let candidate = vowels_count in
  (assert ((candidate "abcde") = 2));
  (assert ((candidate "Alone") = 3));
  (assert ((candidate "key") = 2));
  (assert ((candidate "bye") = 1));
  (assert ((candidate "keY") = 2));
  (assert ((candidate "bYe") = 1));
  (assert ((candidate "ACEDY") = 3));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Write a function vowels_count which takes a string representing
 * a word as input and returns the number of vowels in the string.
 * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
 * vowel, but only when it is at the end of the given word.
 * Example:
 * >>> vowels_count "abcde"
 * 2
 * >>> vowels_count "ACEDY"
 * 3
*)
let vowels_count (s : string) : int =
  let len = String.length s in
  let rec aux i acc =
    if i >= len then acc
    else
      let c = s.[i] in
      let acc' =
        match c with
        | 'a' | 'e' | 'i' | 'o' | 'u'
        | 'A' | 'E' | 'I' | 'O' | 'U' -> acc + 1
        | 'y' | 'Y' when i = len - 1 -> acc + 1
        | _ -> acc
      in
      aux (i + 1) acc'
  in
  aux 0 0

let assertions =
 let candidate = vowels_count in
  (assert ((candidate "abcde") = 2));
  (assert ((candidate "Alone") = 3));
  (assert ((candidate "key") = 2));
  (assert ((candidate "bye") = 1));
  (assert ((candidate "keY") = 2));
  (assert ((candidate "bYe") = 1));
  (assert ((candidate "ACEDY") = 3));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183717
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 72 (ML) - HumanEval_72_will_it_fly
================================================================================

PROMPT:
----------------------------------------
(**Write a function that returns true if the object q will fly, and false otherwise.
 * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
 * Example:
 * >>> will_it_fly [1; 2] 5
 * false
 * # 1+2 is less than the maximum possible weight, but it's unbalanced.
 * >>> will_it_fly [3; 2; 3] 1
 * false
 * # it's balanced, but 3+2+3 is more than the maximum possible weight.
 * >>> will_it_fly [3; 2; 3] 9
 * true
 * # 3+2+3 is less than the maximum possible weight, and it's balanced.
 * >>> will_it_fly [3] 5
 * true
 * # 3 is less than the maximum possible weight, and it's balanced.
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = will_it_fly in
  (assert ((candidate [3; 2; 3] 9) = true));
  (assert ((candidate [1; 2] 5) = false));
  (assert ((candidate [3] 5) = true));
  (assert ((candidate [3; 2; 3] 1) = false));
  (assert ((candidate [1; 2; 3] 6) = false));
  (assert ((candidate [5] 5) = true));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Write a function that returns true if the object q will fly, and false otherwise.
 * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
 * Example:
 * >>> will_it_fly [1; 2] 5
 * false
 * # 1+2 is less than the maximum possible weight, but it's unbalanced.
 * >>> will_it_fly [3; 2; 3] 1
 * false
 * # it's balanced, but 3+2+3 is more than the maximum possible weight.
 * >>> will_it_fly [3; 2; 3] 9
 * true
 * # 3+2+3 is less than the maximum possible weight, and it's balanced.
 * >>> will_it_fly [3] 5
 * true
 * # 3 is less than the maximum possible weight, and it's balanced.
*)
let will_it_fly (q : int list) (w : int) : bool =
  (* Helper to test if a list is a palindrome *)
  let is_palindrome l = l = List.rev l in
  (* Compute the sum of the list *)
  let sum = List.fold_left (+) 0 q in
  (* The object will fly only if it’s balanced and the sum is ≤ w *)
  is_palindrome q && sum <= w

let assertions =
 let candidate = will_it_fly in
  (assert ((candidate [3; 2; 3] 9) = true));
  (assert ((candidate [1; 2] 5) = false));
  (assert ((candidate [3] 5) = true));
  (assert ((candidate [3; 2; 3] 1) = false));
  (assert ((candidate [1; 2; 3] 6) = false));
  (assert ((candidate [5] 5) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183718
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Write a function that returns true if the object q will fly, and false otherwise.
 * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
 * Example:
 * >>> will_it_fly [1; 2] 5
 * false
 * # 1+2 is less than the maximum possible weight, but it's unbalanced.
 * >>> will_it_fly [3; 2; 3] 1
 * false
 * # it's balanced, but 3+2+3 is more than the maximum possible weight.
 * >>> will_it_fly [3; 2; 3] 9
 * true
 * # 3+2+3 is less than the maximum possible weight, and it's balanced.
 * >>> will_it_fly [3] 5
 * true
 * # 3 is less than the maximum possible weight, and it's balanced.
*)
let will_it_fly (q : int list) (w : int) : bool =
  let is_palindrome l = l = List.rev l in
  let sum = List.fold_left (+) 0 q in
  is_palindrome q && sum <= w

let assertions =
 let candidate = will_it_fly in
  (assert ((candidate [3; 2; 3] 9) = true));
  (assert ((candidate [1; 2] 5) = false));
  (assert ((candidate [3] 5) = true));
  (assert ((candidate [3; 2; 3] 1) = false));
  (assert ((candidate [1; 2; 3] 6) = false));
  (assert ((candidate [5] 5) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183718
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Write a function that returns true if the object q will fly, and false otherwise.
 * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
 * Example:
 * >>> will_it_fly [1; 2] 5
 * false
 * # 1+2 is less than the maximum possible weight, but it's unbalanced.
 * >>> will_it_fly [3; 2; 3] 1
 * false
 * # it's balanced, but 3+2+3 is more than the maximum possible weight.
 * >>> will_it_fly [3; 2; 3] 9
 * true
 * # 3+2+3 is less than the maximum possible weight, and it's balanced.
 * >>> will_it_fly [3] 5
 * true
 * # 3 is less than the maximum possible weight, and it's balanced.
*)
(* Returns true if the list `q` is a palindrome and its sum is <= `w`. *)
let will_it_fly (q : int list) (w : int) : bool =
  (* Helper: check whether two lists are identical. *)
  let rec equal_lists l1 l2 =
    match l1, l2 with
    | [], [] -> true
    | x :: xs, y :: ys -> x = y && equal_lists xs ys
    | _ -> false
  in
  (* `q` is a palindrome iff it equals its reverse. *)
  let is_palindrome = equal_lists q (List.rev q) in
  (* Sum of the elements. *)
  let sum = List.fold_left (+) 0 q in
  (* Final condition. *)
  is_palindrome && sum <= w

let assertions =
 let candidate = will_it_fly in
  (assert ((candidate [3; 2; 3] 9) = true));
  (assert ((candidate [1; 2] 5) = false));
  (assert ((candidate [3] 5) = true));
  (assert ((candidate [3; 2; 3] 1) = false));
  (assert ((candidate [1; 2; 3] 6) = false));
  (assert ((candidate [5] 5) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183718
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Write a function that returns true if the object q will fly, and false otherwise.
 * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
 * Example:
 * >>> will_it_fly [1; 2] 5
 * false
 * # 1+2 is less than the maximum possible weight, but it's unbalanced.
 * >>> will_it_fly [3; 2; 3] 1
 * false
 * # it's balanced, but 3+2+3 is more than the maximum possible weight.
 * >>> will_it_fly [3; 2; 3] 9
 * true
 * # 3+2+3 is less than the maximum possible weight, and it's balanced.
 * >>> will_it_fly [3] 5
 * true
 * # 3 is less than the maximum possible weight, and it's balanced.
*)
let will_it_fly (q : int list) (w : int) : bool =
  (* Helper: check whether a list is a palindrome *)
  let is_palindrome l =
    l = List.rev l
  in
  (* Compute the sum of the list *)
  let total = List.fold_left (+) 0 q in
  (* The object will fly iff it is balanced and its weight is within limits *)
  is_palindrome q && total <= w

let assertions =
 let candidate = will_it_fly in
  (assert ((candidate [3; 2; 3] 9) = true));
  (assert ((candidate [1; 2] 5) = false));
  (assert ((candidate [3] 5) = true));
  (assert ((candidate [3; 2; 3] 1) = false));
  (assert ((candidate [1; 2; 3] 6) = false));
  (assert ((candidate [5] 5) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183718
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 73 (ML) - HumanEval_73_smallest_change
================================================================================

PROMPT:
----------------------------------------
(**Given a list arr of integers, find the minimum number of elements that
 * need to be changed to make the list palindromic. A palindromic list is a list that
 * is read the same backwards and forwards. In one change, you can change one element to any other element.
 * For example:
 * >>> smallest_change [1; 2; 3; 5; 4; 7; 9; 6]
 * 4
 * >>> smallest_change [1; 2; 3; 4; 3; 2; 2]
 * 1
 * >>> smallest_change [1; 2; 3; 2; 1]
 * 0
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = smallest_change in
  (assert ((candidate [1; 2; 3; 5; 4; 7; 9; 6]) = 4));
  (assert ((candidate [1; 2; 3; 4; 3; 2; 2]) = 1));
  (assert ((candidate [1; 4; 2]) = 1));
  (assert ((candidate [1; 4; 4; 2]) = 1));
  (assert ((candidate [1; 2; 3; 2; 1]) = 0));
  (assert ((candidate [3; 1; 1; 3]) = 0));
  (assert ((candidate [1]) = 0));
  (assert ((candidate [0; 1]) = 1));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given a list arr of integers, find the minimum number of elements that
 * need to be changed to make the list palindromic. A palindromic list is a list that
 * is read the same backwards and forwards. In one change, you can change one element to any other element.
 * For example:
 * >>> smallest_change [1; 2; 3; 5; 4; 7; 9; 6]
 * 4
 * >>> smallest_change [1; 2; 3; 4; 3; 2; 2]
 * 1
 * >>> smallest_change [1; 2; 3; 2; 1]
 * 0
*)
(* Convert the list to an array for O(1) random access *)
let smallest_change (arr : int list) : int =
  let a = Array.of_list arr in
  let n = Array.length a in
  let rec aux i acc =
    if i >= n / 2 then acc
    else
      let acc' =
        if a.(i) <> a.(n - 1 - i) then acc + 1 else acc
      in
      aux (i + 1) acc'
  in
  aux 0 0

let assertions =
 let candidate = smallest_change in
  (assert ((candidate [1; 2; 3; 5; 4; 7; 9; 6]) = 4));
  (assert ((candidate [1; 2; 3; 4; 3; 2; 2]) = 1));
  (assert ((candidate [1; 4; 2]) = 1));
  (assert ((candidate [1; 4; 4; 2]) = 1));
  (assert ((candidate [1; 2; 3; 2; 1]) = 0));
  (assert ((candidate [3; 1; 1; 3]) = 0));
  (assert ((candidate [1]) = 0));
  (assert ((candidate [0; 1]) = 1));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183718
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given a list arr of integers, find the minimum number of elements that
 * need to be changed to make the list palindromic. A palindromic list is a list that
 * is read the same backwards and forwards. In one change, you can change one element to any other element.
 * For example:
 * >>> smallest_change [1; 2; 3; 5; 4; 7; 9; 6]
 * 4
 * >>> smallest_change [1; 2; 3; 4; 3; 2; 2]
 * 1
 * >>> smallest_change [1; 2; 3; 2; 1]
 * 0
*)
(** Find the minimal number of changes needed to make a list palindromic. *)
let smallest_change (arr : int list) : int =
  (* Convert the list to an array for O(1) random access *)
  let a = Array.of_list arr in
  let n  = Array.length a in

  (* Recursively compare symmetric elements. *)
  let rec aux i =
    if i >= n / 2 then 0
    else if a.(i) <> a.(n - 1 - i) then 1 + aux (i + 1)
    else aux (i + 1)
  in
  aux 0

let assertions =
 let candidate = smallest_change in
  (assert ((candidate [1; 2; 3; 5; 4; 7; 9; 6]) = 4));
  (assert ((candidate [1; 2; 3; 4; 3; 2; 2]) = 1));
  (assert ((candidate [1; 4; 2]) = 1));
  (assert ((candidate [1; 4; 4; 2]) = 1));
  (assert ((candidate [1; 2; 3; 2; 1]) = 0));
  (assert ((candidate [3; 1; 1; 3]) = 0));
  (assert ((candidate [1]) = 0));
  (assert ((candidate [0; 1]) = 1));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183718
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given a list arr of integers, find the minimum number of elements that
 * need to be changed to make the list palindromic. A palindromic list is a list that
 * is read the same backwards and forwards. In one change, you can change one element to any other element.
 * For example:
 * >>> smallest_change [1; 2; 3; 5; 4; 7; 9; 6]
 * 4
 * >>> smallest_change [1; 2; 3; 4; 3; 2; 2]
 * 1
 * >>> smallest_change [1; 2; 3; 2; 1]
 * 0
*)
let smallest_change (arr : int list) : int =
  let a = Array.of_list arr in
  let n = Array.length a in
  let rec loop i =
    if i >= n / 2 then 0
    else
      let diff = if a.(i) <> a.(n - 1 - i) then 1 else 0 in
      diff + loop (i + 1)
  in
  loop 0

let assertions =
 let candidate = smallest_change in
  (assert ((candidate [1; 2; 3; 5; 4; 7; 9; 6]) = 4));
  (assert ((candidate [1; 2; 3; 4; 3; 2; 2]) = 1));
  (assert ((candidate [1; 4; 2]) = 1));
  (assert ((candidate [1; 4; 4; 2]) = 1));
  (assert ((candidate [1; 2; 3; 2; 1]) = 0));
  (assert ((candidate [3; 1; 1; 3]) = 0));
  (assert ((candidate [1]) = 0));
  (assert ((candidate [0; 1]) = 1));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183718
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given a list arr of integers, find the minimum number of elements that
 * need to be changed to make the list palindromic. A palindromic list is a list that
 * is read the same backwards and forwards. In one change, you can change one element to any other element.
 * For example:
 * >>> smallest_change [1; 2; 3; 5; 4; 7; 9; 6]
 * 4
 * >>> smallest_change [1; 2; 3; 4; 3; 2; 2]
 * 1
 * >>> smallest_change [1; 2; 3; 2; 1]
 * 0
*)
let smallest_change (arr : int list) : int =
  let a = Array.of_list arr in
  let n = Array.length a in
  let rec aux i acc =
    if i >= n / 2 then acc
    else if a.(i) <> a.(n - 1 - i) then aux (i + 1) (acc + 1)
    else aux (i + 1) acc
  in
  aux 0 0

let assertions =
 let candidate = smallest_change in
  (assert ((candidate [1; 2; 3; 5; 4; 7; 9; 6]) = 4));
  (assert ((candidate [1; 2; 3; 4; 3; 2; 2]) = 1));
  (assert ((candidate [1; 4; 2]) = 1));
  (assert ((candidate [1; 4; 4; 2]) = 1));
  (assert ((candidate [1; 2; 3; 2; 1]) = 0));
  (assert ((candidate [3; 1; 1; 3]) = 0));
  (assert ((candidate [1]) = 0));
  (assert ((candidate [0; 1]) = 1));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183718
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 74 (ML) - HumanEval_74_total_match
================================================================================

PROMPT:
----------------------------------------
(**Write a function that accepts two lists of strings and returns the list that has 
 * total number of chars in the all strings of the list less than the other list.
 * if the two lists have the same number of chars, return the first list.
 * Examples
 * >>> total_match [] []
 * []
 * >>> total_match ["hi"; "admin"] ["hI"; "Hi"]
 * ["hI"; "Hi"]
 * >>> total_match ["hi"; "admin"] ["hi"; "hi"; "admin"; "project"]
 * ["hi"; "admin"]
 * >>> total_match ["hi"; "admin"] ["hI"; "hi"; "hi"]
 * ["hI"; "hi"; "hi"]
 * >>> total_match ["4"] ["1"; "2"; "3"; "4"; "5"]
 * ["4"]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = total_match in
  (assert ((candidate [] []) = []));
  (assert ((candidate ["hi"; "admin"] ["hi"; "hi"]) = ["hi"; "hi"]));
  (assert ((candidate ["hi"; "admin"] ["hi"; "hi"; "admin"; "project"]) = ["hi"; "admin"]));
  (assert ((candidate ["4"] ["1"; "2"; "3"; "4"; "5"]) = ["4"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "Hi"]) = ["hI"; "Hi"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "hi"; "hi"]) = ["hI"; "hi"; "hi"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "hi"; "hii"]) = ["hi"; "admin"]));
  (assert ((candidate [] ["this"]) = []));
  (assert ((candidate ["this"] []) = []));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Write a function that accepts two lists of strings and returns the list that has 
 * total number of chars in the all strings of the list less than the other list.
 * if the two lists have the same number of chars, return the first list.
 * Examples
 * >>> total_match [] []
 * []
 * >>> total_match ["hi"; "admin"] ["hI"; "Hi"]
 * ["hI"; "Hi"]
 * >>> total_match ["hi"; "admin"] ["hi"; "hi"; "admin"; "project"]
 * ["hi"; "admin"]
 * >>> total_match ["hi"; "admin"] ["hI"; "hi"; "hi"]
 * ["hI"; "hi"; "hi"]
 * >>> total_match ["4"] ["1"; "2"; "3"; "4"; "5"]
 * ["4"]
*)
let total_match (lst1 : string list) (lst2 : string list) : string list =
  (* Helper to compute the total number of characters in a string list *)
  let total_len lst =
    List.fold_left (fun acc s -> acc + String.length s) 0 lst
  in
  let len1 = total_len lst1 in
  let len2 = total_len lst2 in
  (* Return the list with the smaller total length; if equal, return the first list *)
  if len1 <= len2 then lst1 else lst2

let assertions =
 let candidate = total_match in
  (assert ((candidate [] []) = []));
  (assert ((candidate ["hi"; "admin"] ["hi"; "hi"]) = ["hi"; "hi"]));
  (assert ((candidate ["hi"; "admin"] ["hi"; "hi"; "admin"; "project"]) = ["hi"; "admin"]));
  (assert ((candidate ["4"] ["1"; "2"; "3"; "4"; "5"]) = ["4"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "Hi"]) = ["hI"; "Hi"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "hi"; "hi"]) = ["hI"; "hi"; "hi"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "hi"; "hii"]) = ["hi"; "admin"]));
  (assert ((candidate [] ["this"]) = []));
  (assert ((candidate ["this"] []) = []));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Write a function that accepts two lists of strings and returns the list that has 
 * total number of chars in the all strings of the list less than the other list.
 * if the two lists have the same number of chars, return the first list.
 * Examples
 * >>> total_match [] []
 * []
 * >>> total_match ["hi"; "admin"] ["hI"; "Hi"]
 * ["hI"; "Hi"]
 * >>> total_match ["hi"; "admin"] ["hi"; "hi"; "admin"; "project"]
 * ["hi"; "admin"]
 * >>> total_match ["hi"; "admin"] ["hI"; "hi"; "hi"]
 * ["hI"; "hi"; "hi"]
 * >>> total_match ["4"] ["1"; "2"; "3"; "4"; "5"]
 * ["4"]
*)
let total_match (lst1 : string list) (lst2 : string list) : string list =
  (* Helper to compute the total number of characters in a list of strings *)
  let sum_len lst =
    List.fold_left (fun acc s -> acc + String.length s) 0 lst
  in
  let sum1 = sum_len lst1 in
  let sum2 = sum_len lst2 in
  (* Return the list with fewer total characters, or the first one if equal *)
  if sum1 <= sum2 then lst1 else lst2

let assertions =
 let candidate = total_match in
  (assert ((candidate [] []) = []));
  (assert ((candidate ["hi"; "admin"] ["hi"; "hi"]) = ["hi"; "hi"]));
  (assert ((candidate ["hi"; "admin"] ["hi"; "hi"; "admin"; "project"]) = ["hi"; "admin"]));
  (assert ((candidate ["4"] ["1"; "2"; "3"; "4"; "5"]) = ["4"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "Hi"]) = ["hI"; "Hi"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "hi"; "hi"]) = ["hI"; "hi"; "hi"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "hi"; "hii"]) = ["hi"; "admin"]));
  (assert ((candidate [] ["this"]) = []));
  (assert ((candidate ["this"] []) = []));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Write a function that accepts two lists of strings and returns the list that has 
 * total number of chars in the all strings of the list less than the other list.
 * if the two lists have the same number of chars, return the first list.
 * Examples
 * >>> total_match [] []
 * []
 * >>> total_match ["hi"; "admin"] ["hI"; "Hi"]
 * ["hI"; "Hi"]
 * >>> total_match ["hi"; "admin"] ["hi"; "hi"; "admin"; "project"]
 * ["hi"; "admin"]
 * >>> total_match ["hi"; "admin"] ["hI"; "hi"; "hi"]
 * ["hI"; "hi"; "hi"]
 * >>> total_match ["4"] ["1"; "2"; "3"; "4"; "5"]
 * ["4"]
*)
let total_match (lst1 : string list) (lst2 : string list) : string list =
  (* Helper to compute the total number of characters in a list of strings *)
  let sum_chars lst =
    List.fold_left (fun acc s -> acc + String.length s) 0 lst
  in
  let s1 = sum_chars lst1 in
  let s2 = sum_chars lst2 in
  (* If the first list has fewer (or equal) characters, return it;
     otherwise return the second list. *)
  if s1 <= s2 then lst1 else lst2

let assertions =
 let candidate = total_match in
  (assert ((candidate [] []) = []));
  (assert ((candidate ["hi"; "admin"] ["hi"; "hi"]) = ["hi"; "hi"]));
  (assert ((candidate ["hi"; "admin"] ["hi"; "hi"; "admin"; "project"]) = ["hi"; "admin"]));
  (assert ((candidate ["4"] ["1"; "2"; "3"; "4"; "5"]) = ["4"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "Hi"]) = ["hI"; "Hi"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "hi"; "hi"]) = ["hI"; "hi"; "hi"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "hi"; "hii"]) = ["hi"; "admin"]));
  (assert ((candidate [] ["this"]) = []));
  (assert ((candidate ["this"] []) = []));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Write a function that accepts two lists of strings and returns the list that has 
 * total number of chars in the all strings of the list less than the other list.
 * if the two lists have the same number of chars, return the first list.
 * Examples
 * >>> total_match [] []
 * []
 * >>> total_match ["hi"; "admin"] ["hI"; "Hi"]
 * ["hI"; "Hi"]
 * >>> total_match ["hi"; "admin"] ["hi"; "hi"; "admin"; "project"]
 * ["hi"; "admin"]
 * >>> total_match ["hi"; "admin"] ["hI"; "hi"; "hi"]
 * ["hI"; "hi"; "hi"]
 * >>> total_match ["4"] ["1"; "2"; "3"; "4"; "5"]
 * ["4"]
*)
let total_match (lst1 : string list) (lst2 : string list) : string list =
  (* Helper to compute the total length of all strings in a list *)
  let total_len lst =
    List.fold_left (fun acc s -> acc + String.length s) 0 lst
  in
  let t1 = total_len lst1 in
  let t2 = total_len lst2 in
  if t1 <= t2 then lst1 else lst2

let assertions =
 let candidate = total_match in
  (assert ((candidate [] []) = []));
  (assert ((candidate ["hi"; "admin"] ["hi"; "hi"]) = ["hi"; "hi"]));
  (assert ((candidate ["hi"; "admin"] ["hi"; "hi"; "admin"; "project"]) = ["hi"; "admin"]));
  (assert ((candidate ["4"] ["1"; "2"; "3"; "4"; "5"]) = ["4"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "Hi"]) = ["hI"; "Hi"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "hi"; "hi"]) = ["hI"; "hi"; "hi"]));
  (assert ((candidate ["hi"; "admin"] ["hI"; "hi"; "hii"]) = ["hi"; "admin"]));
  (assert ((candidate [] ["this"]) = []));
  (assert ((candidate ["this"] []) = []));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 75 (ML) - HumanEval_75_is_multiply_prime
================================================================================

PROMPT:
----------------------------------------
(**Write a function that returns true if the given number is the multiplication of 3 prime numbers
 * and false otherwise.
 * Knowing that (a) is less then 100. 
 * Example:
 * >>> is_multiply_prime 30
 * true
 * 30 = 2 * 3 * 5
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = is_multiply_prime in
  (assert ((candidate 5) = false));
  (assert ((candidate 30) = true));
  (assert ((candidate 8) = true));
  (assert ((candidate 10) = false));
  (assert ((candidate 125) = true));
  (assert ((candidate 105) = true));
  (assert ((candidate 126) = false));
  (assert ((candidate 729) = false));
  (assert ((candidate 891) = false));
  (assert ((candidate 1001) = true));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Write a function that returns true if the given number is the multiplication of 3 prime numbers
 * and false otherwise.
 * Knowing that (a) is less then 100. 
 * Example:
 * >>> is_multiply_prime 30
 * true
 * 30 = 2 * 3 * 5
*)
(* Helper function to check if a number is prime *)
let is_prime n =
  if n < 2 then false
  else
    let rec aux d =
      if d * d > n then true
      else if n mod d = 0 then false
      else aux (d + 1)
    in
    aux 2

(* Main function: true if a is a product of exactly three primes *)
let is_multiply_prime (a : int) : bool =
  if a <= 1 then false
  else
    let rec factor n d count =
      if d * d > n then
        (* Remaining n is either 1 or a prime *)
        if n = 1 then count
        else count + 1
      else if n mod d = 0 then
        (* Found a prime factor d *)
        factor (n / d) d (count + 1)
      else
        factor n (d + 1) count
    in
    factor a 2 0 = 3

let assertions =
 let candidate = is_multiply_prime in
  (assert ((candidate 5) = false));
  (assert ((candidate 30) = true));
  (assert ((candidate 8) = true));
  (assert ((candidate 10) = false));
  (assert ((candidate 125) = true));
  (assert ((candidate 105) = true));
  (assert ((candidate 126) = false));
  (assert ((candidate 729) = false));
  (assert ((candidate 891) = false));
  (assert ((candidate 1001) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Write a function that returns true if the given number is the multiplication of 3 prime numbers
 * and false otherwise.
 * Knowing that (a) is less then 100. 
 * Example:
 * >>> is_multiply_prime 30
 * true
 * 30 = 2 * 3 * 5
*)
(* Check if a number is prime *)
let is_prime (n : int) : bool =
  if n <= 1 then false
  else
    let rec loop i =
      if i * i > n then true
      else if n mod i = 0 then false
      else loop (i + 1)
    in
    loop 2

(* Return true iff a is the product of exactly three prime numbers *)
let is_multiply_prime (a : int) : bool =
  if a <= 1 then false
  else
    let rec aux n i count =
      if n = 1 then count
      else if i * i > n then
        (* Remaining n is prime (or 1) *)
        if is_prime n then count + 1 else count
      else if n mod i = 0 then
        (* i divides n *)
        if is_prime i then aux (n / i) i (count + 1)
        else aux n (i + 1) count
      else
        aux n (i + 1) count
    in
    aux a 2 0 = 3

let assertions =
 let candidate = is_multiply_prime in
  (assert ((candidate 5) = false));
  (assert ((candidate 30) = true));
  (assert ((candidate 8) = true));
  (assert ((candidate 10) = false));
  (assert ((candidate 125) = true));
  (assert ((candidate 105) = true));
  (assert ((candidate 126) = false));
  (assert ((candidate 729) = false));
  (assert ((candidate 891) = false));
  (assert ((candidate 1001) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Write a function that returns true if the given number is the multiplication of 3 prime numbers
 * and false otherwise.
 * Knowing that (a) is less then 100. 
 * Example:
 * >>> is_multiply_prime 30
 * true
 * 30 = 2 * 3 * 5
*)
let is_multiply_prime (a : int) : bool =
  (* Helper to find a prime factor of n, starting from f *)
  let rec find_factor f n =
    if f * f > n then n          (* n itself is prime *)
    else if n mod f = 0 then f   (* f is a factor *)
    else find_factor (f + 1) n
  in

  (* Recursive factorisation that counts prime factors *)
  let rec factor n count =
    if n = 1 then count
    else
      let f = find_factor 2 n in
      factor (n / f) (count + 1)
  in

  (* 1 or less cannot be a product of primes *)
  if a <= 1 then false
  else factor a 0 = 3

let assertions =
 let candidate = is_multiply_prime in
  (assert ((candidate 5) = false));
  (assert ((candidate 30) = true));
  (assert ((candidate 8) = true));
  (assert ((candidate 10) = false));
  (assert ((candidate 125) = true));
  (assert ((candidate 105) = true));
  (assert ((candidate 126) = false));
  (assert ((candidate 729) = false));
  (assert ((candidate 891) = false));
  (assert ((candidate 1001) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Write a function that returns true if the given number is the multiplication of 3 prime numbers
 * and false otherwise.
 * Knowing that (a) is less then 100. 
 * Example:
 * >>> is_multiply_prime 30
 * true
 * 30 = 2 * 3 * 5
*)
(* Returns true iff the given integer a is the product of exactly three prime numbers *)
let is_multiply_prime (a : int) : bool =
  (* Quick check for trivial cases *)
  if a <= 1 then false
  else
    (* List of primes up to 100 – enough for factorising any a < 100 *)
    let primes = [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47;
                  53; 59; 61; 67; 71; 73; 79; 83; 89; 97] in

    (* Recursively count prime factors (with multiplicity) *)
    let rec count_factors n primes count =
      if n = 1 then count
      else match primes with
        | [] -> count + 1  (* remaining n is a prime > 97, but this cannot happen for a < 100 *)
        | p :: ps ->
          if n mod p = 0
          then count_factors (n / p) primes (count + 1)
          else count_factors n ps count
    in

    (* Count the factors and compare with 3 *)
    count_factors a primes 0 = 3

let assertions =
 let candidate = is_multiply_prime in
  (assert ((candidate 5) = false));
  (assert ((candidate 30) = true));
  (assert ((candidate 8) = true));
  (assert ((candidate 10) = false));
  (assert ((candidate 125) = true));
  (assert ((candidate 105) = true));
  (assert ((candidate 126) = false));
  (assert ((candidate 729) = false));
  (assert ((candidate 891) = false));
  (assert ((candidate 1001) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 76 (ML) - HumanEval_76_is_simple_power
================================================================================

PROMPT:
----------------------------------------
(**Your task is to write a function that returns true if a number x is a simple
 * power of n and false in other cases.
 * x is a simple power of n if n**int=x
 * For example:
 * >>> is_simple_power 1 4
 * true
 * >>> is_simple_power 2 2
 * true
 * >>> is_simple_power 8 2
 * true
 * >>> is_simple_power 3 2
 * false
 * >>> is_simple_power 3 1
 * false
 * >>> is_simple_power 5 3
 * false
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = is_simple_power in
  (assert ((candidate 16 2) = true));
  (assert ((candidate 143214 16) = false));
  (assert ((candidate 4 2) = true));
  (assert ((candidate 9 3) = true));
  (assert ((candidate 16 4) = true));
  (assert ((candidate 24 2) = false));
  (assert ((candidate 128 4) = false));
  (assert ((candidate 12 6) = false));
  (assert ((candidate 1 1) = true));
  (assert ((candidate 1 12) = true));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Your task is to write a function that returns true if a number x is a simple
 * power of n and false in other cases.
 * x is a simple power of n if n**int=x
 * For example:
 * >>> is_simple_power 1 4
 * true
 * >>> is_simple_power 2 2
 * true
 * >>> is_simple_power 8 2
 * true
 * >>> is_simple_power 3 2
 * false
 * >>> is_simple_power 3 1
 * false
 * >>> is_simple_power 5 3
 * false
*)
(* Returns true iff x is a simple power of n, i.e. there exists an integer k ≥ 0
   such that n ** k = x. *)
let is_simple_power (x : int) (n : int) : bool =
  (* Handle the trivial cases first *)
  if x = 1 then true                     (* n⁰ = 1 for any n *)
  else if n = 0 then (x = 0)             (* 0⁰ is undefined, but 0ᵏ = 0 for k > 0 *)
  else if n = 1 then false               (* 1ᵏ = 1 only, so any x ≠ 1 fails *)
  else
    (* Recursive loop that multiplies by n until we either hit x or exceed it.
       We compare absolute values to handle negative n correctly. *)
    let rec loop acc =
      if acc = x then true
      else if abs acc > abs x then false
      else loop (acc * n)
    in
    loop n

let assertions =
 let candidate = is_simple_power in
  (assert ((candidate 16 2) = true));
  (assert ((candidate 143214 16) = false));
  (assert ((candidate 4 2) = true));
  (assert ((candidate 9 3) = true));
  (assert ((candidate 16 4) = true));
  (assert ((candidate 24 2) = false));
  (assert ((candidate 128 4) = false));
  (assert ((candidate 12 6) = false));
  (assert ((candidate 1 1) = true));
  (assert ((candidate 1 12) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Your task is to write a function that returns true if a number x is a simple
 * power of n and false in other cases.
 * x is a simple power of n if n**int=x
 * For example:
 * >>> is_simple_power 1 4
 * true
 * >>> is_simple_power 2 2
 * true
 * >>> is_simple_power 8 2
 * true
 * >>> is_simple_power 3 2
 * false
 * >>> is_simple_power 3 1
 * false
 * >>> is_simple_power 5 3
 * false
*)
(* is_simple_power : int -> int -> bool
   Returns true iff x is a simple power of n (i.e. x = n^k for some integer k ≥ 0). *)
let is_simple_power (x : int) (n : int) : bool =
  (* Basic sanity checks: only positive integers make sense for this definition. *)
  if x <= 0 || n <= 0 then false
  else if n = 1 then x = 1                (* 1^k = 1 for any k, so only 1 is a power of 1 *)
  else
    let rec loop v =
      if v = 1 then true                  (* reached the base case: n^0 = 1 *)
      else if v mod n <> 0 then false    (* not divisible by n → cannot be a power *)
      else loop (v / n)                  (* continue dividing by n *)
    in
    loop x

let assertions =
 let candidate = is_simple_power in
  (assert ((candidate 16 2) = true));
  (assert ((candidate 143214 16) = false));
  (assert ((candidate 4 2) = true));
  (assert ((candidate 9 3) = true));
  (assert ((candidate 16 4) = true));
  (assert ((candidate 24 2) = false));
  (assert ((candidate 128 4) = false));
  (assert ((candidate 12 6) = false));
  (assert ((candidate 1 1) = true));
  (assert ((candidate 1 12) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Your task is to write a function that returns true if a number x is a simple
 * power of n and false in other cases.
 * x is a simple power of n if n**int=x
 * For example:
 * >>> is_simple_power 1 4
 * true
 * >>> is_simple_power 2 2
 * true
 * >>> is_simple_power 8 2
 * true
 * >>> is_simple_power 3 2
 * false
 * >>> is_simple_power 3 1
 * false
 * >>> is_simple_power 5 3
 * false
*)
(* is_simple_power : int -> int -> bool
   Returns true iff x is a simple power of n, i.e.
   there exists an integer k ≥ 0 such that n ** k = x.
   The implementation works for positive, negative, and zero bases
   (with the usual convention that 0⁰ is undefined). *)

let rec is_simple_power (x : int) (n : int) : bool =
  (* 1 is a power of any n (n⁰ = 1) *)
  if x = 1 then true
  (* 0 is only a power of n when n = 0 and the exponent is > 0,
     but 0⁰ is undefined.  For simplicity we treat 0 as not a
     simple power of any n. *)
  else if x = 0 then false
  (* n = 1 can only generate 1 (1⁰ = 1).  Since x ≠ 1 here,
     we return false. *)
  else if n = 1 then false
  (* n = 0 cannot produce any positive x, so false. *)
  else if n = 0 then false
  (* If x is not divisible by n, it cannot be a power of n. *)
  else if x mod n <> 0 then false
  (* Otherwise, divide x by n and recurse. *)
  else is_simple_power (x / n) n

let assertions =
 let candidate = is_simple_power in
  (assert ((candidate 16 2) = true));
  (assert ((candidate 143214 16) = false));
  (assert ((candidate 4 2) = true));
  (assert ((candidate 9 3) = true));
  (assert ((candidate 16 4) = true));
  (assert ((candidate 24 2) = false));
  (assert ((candidate 128 4) = false));
  (assert ((candidate 12 6) = false));
  (assert ((candidate 1 1) = true));
  (assert ((candidate 1 12) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Your task is to write a function that returns true if a number x is a simple
 * power of n and false in other cases.
 * x is a simple power of n if n**int=x
 * For example:
 * >>> is_simple_power 1 4
 * true
 * >>> is_simple_power 2 2
 * true
 * >>> is_simple_power 8 2
 * true
 * >>> is_simple_power 3 2
 * false
 * >>> is_simple_power 3 1
 * false
 * >>> is_simple_power 5 3
 * false
*)
(* Return true if x is a simple power of n (i.e. n ** k = x for some k ≥ 0). *)
let is_simple_power (x : int) (n : int) : bool =
  (* Special cases first *)
  if n = 0 then
    (* 0 ** k = 0 for k > 0; 0 ** 0 is undefined. *)
    x = 0
  else if x = 0 then
    (* Any non‑zero base raised to a positive exponent gives 0. *)
    true
  else if x = 1 then
    (* n ** 0 = 1 for every n ≠ 0. *)
    true
  else if n = 1 then
    (* 1 ** k = 1 for every k, so only 1 is a power of 1. *)
    x = 1
  else if n = -1 then
    (* (-1) ** k = 1 if k even, -1 if k odd. *)
    x = 1 || x = -1
  else if x = -1 then
    (* Only -1 is a power of -1; handled above. *)
    false
  else
    (* General case: n ≠ 0, ±1 and |x| > 1. *)
    (* If the signs cannot match, it can’t be a power. *)
    if (n > 0 && x < 0) || (n < 0 && x > 0) then
      false
    else
      (* Repeatedly divide x by n while it remains divisible. *)
      let rec loop acc =
        if acc mod n = 0 then
          let acc' = acc / n in
          if acc' = 1 then true else loop acc'
        else
          false
      in
      loop x

let assertions =
 let candidate = is_simple_power in
  (assert ((candidate 16 2) = true));
  (assert ((candidate 143214 16) = false));
  (assert ((candidate 4 2) = true));
  (assert ((candidate 9 3) = true));
  (assert ((candidate 16 4) = true));
  (assert ((candidate 24 2) = false));
  (assert ((candidate 128 4) = false));
  (assert ((candidate 12 6) = false));
  (assert ((candidate 1 1) = true));
  (assert ((candidate 1 12) = true));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 78 (ML) - HumanEval_78_hex_key
================================================================================

PROMPT:
----------------------------------------
(**You have been tasked to write a function that receives 
 * a hexadecimal number as a string and counts the number of hexadecimal 
 * digits that are primes (prime number, or a prime, is a natural number 
 * greater than 1 that is not a product of two smaller natural numbers).
 * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
 * Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
 * So you have to determine a number of the following digits: 2, 3, 5, 7, 
 * B (=decimal 11), D (=decimal 13).
 * Note: you may assume the input is always correct or empty string, 
 * and symbols A,B,C,D,E,F are always uppercase.
 * Examples:
 * >>> hex_key "AB"
 * 1
 * >>> hex_key "1077E"
 * 2
 * >>> hex_key "ABED1A33"
 * 4
 * >>> hex_key "123456789ABCDEF0"
 * 6
 * >>> hex_key "2020"
 * 2
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = hex_key in
  (assert ((candidate "AB") = 1));
  (assert ((candidate "1077E") = 2));
  (assert ((candidate "ABED1A33") = 4));
  (assert ((candidate "2020") = 2));
  (assert ((candidate "123456789ABCDEF0") = 6));
  (assert ((candidate "112233445566778899AABBCCDDEEFF00") = 12));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**You have been tasked to write a function that receives 
 * a hexadecimal number as a string and counts the number of hexadecimal 
 * digits that are primes (prime number, or a prime, is a natural number 
 * greater than 1 that is not a product of two smaller natural numbers).
 * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
 * Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
 * So you have to determine a number of the following digits: 2, 3, 5, 7, 
 * B (=decimal 11), D (=decimal 13).
 * Note: you may assume the input is always correct or empty string, 
 * and symbols A,B,C,D,E,F are always uppercase.
 * Examples:
 * >>> hex_key "AB"
 * 1
 * >>> hex_key "1077E"
 * 2
 * >>> hex_key "ABED1A33"
 * 4
 * >>> hex_key "123456789ABCDEF0"
 * 6
 * >>> hex_key "2020"
 * 2
*)
(* Count the prime hexadecimal digits in a string *)
let hex_key (num : string) : int =
  (* Helper that tells whether a character is one of the prime hex digits *)
  let is_prime_hex = function
    | '2' | '3' | '5' | '7' | 'B' | 'D' -> true
    | _ -> false
  in
  (* Accumulate the count while iterating over the string *)
  String.fold_left (fun acc c ->
      if is_prime_hex c then acc + 1 else acc
    ) 0 num

let assertions =
 let candidate = hex_key in
  (assert ((candidate "AB") = 1));
  (assert ((candidate "1077E") = 2));
  (assert ((candidate "ABED1A33") = 4));
  (assert ((candidate "2020") = 2));
  (assert ((candidate "123456789ABCDEF0") = 6));
  (assert ((candidate "112233445566778899AABBCCDDEEFF00") = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**You have been tasked to write a function that receives 
 * a hexadecimal number as a string and counts the number of hexadecimal 
 * digits that are primes (prime number, or a prime, is a natural number 
 * greater than 1 that is not a product of two smaller natural numbers).
 * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
 * Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
 * So you have to determine a number of the following digits: 2, 3, 5, 7, 
 * B (=decimal 11), D (=decimal 13).
 * Note: you may assume the input is always correct or empty string, 
 * and symbols A,B,C,D,E,F are always uppercase.
 * Examples:
 * >>> hex_key "AB"
 * 1
 * >>> hex_key "1077E"
 * 2
 * >>> hex_key "ABED1A33"
 * 4
 * >>> hex_key "123456789ABCDEF0"
 * 6
 * >>> hex_key "2020"
 * 2
*)
(* Count the number of hexadecimal digits that are prime. *)
let hex_key (num : string) : int =
  (* Characters that represent prime numbers in hexadecimal *)
  let primes = "2357BD" in
  (* Iterate over each character in the input string and accumulate the count *)
  String.fold_left
    (fun acc c -> if String.contains primes c then acc + 1 else acc)
    0
    num

let assertions =
 let candidate = hex_key in
  (assert ((candidate "AB") = 1));
  (assert ((candidate "1077E") = 2));
  (assert ((candidate "ABED1A33") = 4));
  (assert ((candidate "2020") = 2));
  (assert ((candidate "123456789ABCDEF0") = 6));
  (assert ((candidate "112233445566778899AABBCCDDEEFF00") = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**You have been tasked to write a function that receives 
 * a hexadecimal number as a string and counts the number of hexadecimal 
 * digits that are primes (prime number, or a prime, is a natural number 
 * greater than 1 that is not a product of two smaller natural numbers).
 * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
 * Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
 * So you have to determine a number of the following digits: 2, 3, 5, 7, 
 * B (=decimal 11), D (=decimal 13).
 * Note: you may assume the input is always correct or empty string, 
 * and symbols A,B,C,D,E,F are always uppercase.
 * Examples:
 * >>> hex_key "AB"
 * 1
 * >>> hex_key "1077E"
 * 2
 * >>> hex_key "ABED1A33"
 * 4
 * >>> hex_key "123456789ABCDEF0"
 * 6
 * >>> hex_key "2020"
 * 2
*)
(* Count how many hexadecimal digits in the input string are prime numbers.
   Prime hex digits are: 2, 3, 5, 7, B (11), D (13). *)
let hex_key (num : string) : int =
  (* String of all prime hexadecimal characters *)
  let primes = "2357BD" in
  (* Scan the string and accumulate the count *)
  String.fold_left
    (fun acc c -> if String.contains primes c then acc + 1 else acc)
    0
    num

let assertions =
 let candidate = hex_key in
  (assert ((candidate "AB") = 1));
  (assert ((candidate "1077E") = 2));
  (assert ((candidate "ABED1A33") = 4));
  (assert ((candidate "2020") = 2));
  (assert ((candidate "123456789ABCDEF0") = 6));
  (assert ((candidate "112233445566778899AABBCCDDEEFF00") = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**You have been tasked to write a function that receives 
 * a hexadecimal number as a string and counts the number of hexadecimal 
 * digits that are primes (prime number, or a prime, is a natural number 
 * greater than 1 that is not a product of two smaller natural numbers).
 * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
 * Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
 * So you have to determine a number of the following digits: 2, 3, 5, 7, 
 * B (=decimal 11), D (=decimal 13).
 * Note: you may assume the input is always correct or empty string, 
 * and symbols A,B,C,D,E,F are always uppercase.
 * Examples:
 * >>> hex_key "AB"
 * 1
 * >>> hex_key "1077E"
 * 2
 * >>> hex_key "ABED1A33"
 * 4
 * >>> hex_key "123456789ABCDEF0"
 * 6
 * >>> hex_key "2020"
 * 2
*)
let hex_key (num : string) : int =
  let prime_chars = "2357BD" in
  String.fold_left
    (fun acc c -> if String.contains prime_chars c then acc + 1 else acc)
    0
    num

let assertions =
 let candidate = hex_key in
  (assert ((candidate "AB") = 1));
  (assert ((candidate "1077E") = 2));
  (assert ((candidate "ABED1A33") = 4));
  (assert ((candidate "2020") = 2));
  (assert ((candidate "123456789ABCDEF0") = 6));
  (assert ((candidate "112233445566778899AABBCCDDEEFF00") = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 80 (ML) - HumanEval_80_is_happy
================================================================================

PROMPT:
----------------------------------------
(**You are given a string s.
 * Your task is to check if the string is hapml or not.
 * A string is hapml if its length is at least 3 and every 3 consecutive letters are distinct
 * For example:
 * >>> is_happy "a"
 * false
 * >>> is_happy "aa"
 * false
 * >>> is_happy "abcd"
 * true
 * >>> is_happy "aabb"
 * false
 * >>> is_happy "adb"
 * true
 * >>> is_happy "xyy"
 * false
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = is_happy in
  (assert ((candidate "a") = false));
  (assert ((candidate "aa") = false));
  (assert ((candidate "abcd") = true));
  (assert ((candidate "aabb") = false));
  (assert ((candidate "adb") = true));
  (assert ((candidate "xyy") = false));
  (assert ((candidate "iopaxpoi") = true));
  (assert ((candidate "iopaxioi") = false));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**You are given a string s.
 * Your task is to check if the string is hapml or not.
 * A string is hapml if its length is at least 3 and every 3 consecutive letters are distinct
 * For example:
 * >>> is_happy "a"
 * false
 * >>> is_happy "aa"
 * false
 * >>> is_happy "abcd"
 * true
 * >>> is_happy "aabb"
 * false
 * >>> is_happy "adb"
 * true
 * >>> is_happy "xyy"
 * false
*)
let is_happy (s : string) : bool =
  let n = String.length s in
  if n < 3 then false
  else
    let rec aux i =
      if i > n - 3 then true
      else
        let a = s.[i] in
        let b = s.[i + 1] in
        let c = s.[i + 2] in
        if a <> b && a <> c && b <> c then aux (i + 1)
        else false
    in
    aux 0

let assertions =
 let candidate = is_happy in
  (assert ((candidate "a") = false));
  (assert ((candidate "aa") = false));
  (assert ((candidate "abcd") = true));
  (assert ((candidate "aabb") = false));
  (assert ((candidate "adb") = true));
  (assert ((candidate "xyy") = false));
  (assert ((candidate "iopaxpoi") = true));
  (assert ((candidate "iopaxioi") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**You are given a string s.
 * Your task is to check if the string is hapml or not.
 * A string is hapml if its length is at least 3 and every 3 consecutive letters are distinct
 * For example:
 * >>> is_happy "a"
 * false
 * >>> is_happy "aa"
 * false
 * >>> is_happy "abcd"
 * true
 * >>> is_happy "aabb"
 * false
 * >>> is_happy "adb"
 * true
 * >>> is_happy "xyy"
 * false
*)
let is_happy (s : string) : bool =
  let n = String.length s in
  if n < 3 then false
  else
    let rec aux i =
      if i > n - 3 then true
      else
        let c1 = s.[i] in
        let c2 = s.[i + 1] in
        let c3 = s.[i + 2] in
        if c1 = c2 || c1 = c3 || c2 = c3 then false
        else aux (i + 1)
    in
    aux 0

let assertions =
 let candidate = is_happy in
  (assert ((candidate "a") = false));
  (assert ((candidate "aa") = false));
  (assert ((candidate "abcd") = true));
  (assert ((candidate "aabb") = false));
  (assert ((candidate "adb") = true));
  (assert ((candidate "xyy") = false));
  (assert ((candidate "iopaxpoi") = true));
  (assert ((candidate "iopaxioi") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**You are given a string s.
 * Your task is to check if the string is hapml or not.
 * A string is hapml if its length is at least 3 and every 3 consecutive letters are distinct
 * For example:
 * >>> is_happy "a"
 * false
 * >>> is_happy "aa"
 * false
 * >>> is_happy "abcd"
 * true
 * >>> is_happy "aabb"
 * false
 * >>> is_happy "adb"
 * true
 * >>> is_happy "xyy"
 * false
*)
(* Check whether a string is "hapml" (happy) *)
let is_happy (s : string) : bool =
  let n = String.length s in
  if n < 3 then
    false
  else
    let rec loop i =
      if i > n - 3 then
        true
      else
        let a = s.[i] in
        let b = s.[i + 1] in
        let c = s.[i + 2] in
        if a = b || a = c || b = c then
          false
        else
          loop (i + 1)
    in
    loop 0

let assertions =
 let candidate = is_happy in
  (assert ((candidate "a") = false));
  (assert ((candidate "aa") = false));
  (assert ((candidate "abcd") = true));
  (assert ((candidate "aabb") = false));
  (assert ((candidate "adb") = true));
  (assert ((candidate "xyy") = false));
  (assert ((candidate "iopaxpoi") = true));
  (assert ((candidate "iopaxioi") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**You are given a string s.
 * Your task is to check if the string is hapml or not.
 * A string is hapml if its length is at least 3 and every 3 consecutive letters are distinct
 * For example:
 * >>> is_happy "a"
 * false
 * >>> is_happy "aa"
 * false
 * >>> is_happy "abcd"
 * true
 * >>> is_happy "aabb"
 * false
 * >>> is_happy "adb"
 * true
 * >>> is_happy "xyy"
 * false
*)
let is_happy (s : string) : bool =
  let len = String.length s in
  if len < 3 then
    false
  else
    let rec loop i =
      if i > len - 3 then
        true
      else
        let a = s.[i] in
        let b = s.[i+1] in
        let c = s.[i+2] in
        if a <> b && a <> c && b <> c then
          loop (i + 1)
        else
          false
    in
    loop 0

let assertions =
 let candidate = is_happy in
  (assert ((candidate "a") = false));
  (assert ((candidate "aa") = false));
  (assert ((candidate "abcd") = true));
  (assert ((candidate "aabb") = false));
  (assert ((candidate "adb") = true));
  (assert ((candidate "xyy") = false));
  (assert ((candidate "iopaxpoi") = true));
  (assert ((candidate "iopaxioi") = false));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183719
STDOUT: (empty)
STDERR: (empty)
--------------------
