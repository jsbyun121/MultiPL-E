As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 53 (RKT) - HumanEval_53_add
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Add two numbers x and y
;; >>> (add 2 3)
;; 5
;; >>> (add 5 7)
;; 12

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-within (candidate 0 1) 1 0.001)
    (check-within (candidate 1 0) 1 0.001)
    (check-within (candidate 2 3) 5 0.001)
    (check-within (candidate 5 7) 12 0.001)
    (check-within (candidate 7 5) 12 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Add two numbers x and y
;; >>> (add 2 3)
;; 5
;; >>> (add 5 7)
;; 12
(define (add x y)
  (+ x y))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-within (candidate 0 1) 1 0.001)
    (check-within (candidate 1 0) 1 0.001)
    (check-within (candidate 2 3) 5 0.001)
    (check-within (candidate 5 7) 12 0.001)
    (check-within (candidate 7 5) 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183875
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Add two numbers x and y
;; >>> (add 2 3)
;; 5
;; >>> (add 5 7)
;; 12

;; Add two numbers x and y
;; >>> (add 2 3)
;; 5
;; >>> (add 5 7)
;; 12
(define (add x y)
  (+ x y))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-within (candidate 0 1) 1 0.001)
    (check-within (candidate 1 0) 1 0.001)
    (check-within (candidate 2 3) 5 0.001)
    (check-within (candidate 5 7) 12 0.001)
    (check-within (candidate 7 5) 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183875
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Add two numbers x and y
;; >>> (add 2 3)
;; 5
;; >>> (add 5 7)
;; 12

;; Add two numbers x and y
;; >>> (add 2 3)
;; 5
;; >>> (add 5 7)
;; 12
(define (add x y)
  (+ x y))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-within (candidate 0 1) 1 0.001)
    (check-within (candidate 1 0) 1 0.001)
    (check-within (candidate 2 3) 5 0.001)
    (check-within (candidate 5 7) 12 0.001)
    (check-within (candidate 7 5) 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183875
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Add two numbers x and y
;; >>> (add 2 3)
;; 5
;; >>> (add 5 7)
;; 12

;; Add two numbers x and y
;; >>> (add 2 3)
;; 5
;; >>> (add 5 7)
;; 12
(define (add x y)
  (+ x y))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-within (candidate 0 1) 1 0.001)
    (check-within (candidate 1 0) 1 0.001)
    (check-within (candidate 2 3) 5 0.001)
    (check-within (candidate 5 7) 12 0.001)
    (check-within (candidate 7 5) 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183875
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 54 (RKT) - HumanEval_54_same_chars
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Check if two words have the same characters.
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddeddabc")
;; #t
;; >>> (same_chars "abcd" "dddddddabc")
;; #t
;; >>> (same_chars "dddddddabc" "abcd")
;; #t
;; >>> (same_chars "eabcd" "dddddddabc")
;; #f
;; >>> (same_chars "abcd" "dddddddabce")
;; #f
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddddabc")
;; #f

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate same_chars))
    (check-within (candidate "eabcdzzzz" "dddzzzzzzzddeddabc") #t 0.001)
    (check-within (candidate "abcd" "dddddddabc") #t 0.001)
    (check-within (candidate "dddddddabc" "abcd") #t 0.001)
    (check-within (candidate "eabcd" "dddddddabc") #f 0.001)
    (check-within (candidate "abcd" "dddddddabcf") #f 0.001)
    (check-within (candidate "eabcdzzzz" "dddzzzzzzzddddabc") #f 0.001)
    (check-within (candidate "aabb" "aaccc") #f 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Check if two words have the same characters.
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddeddabc")
;; #t
;; >>> (same_chars "abcd" "dddddddabc")
;; #t
;; >>> (same_chars "dddddddabc" "abcd")
;; #t
;; >>> (same_chars "eabcd" "dddddddabc")
;; #f
;; >>> (same_chars "abcd" "dddddddabce")
;; #f
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddddabc")
;; #f
(require racket/set)

;; Check if two words have the same characters.
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddeddabc")
;; #t
;; >>> (same_chars "abcd" "dddddddabc")
;; #t
;; >>> (same_chars "dddddddabc" "abcd")
;; #t
;; >>> (same_chars "eabcd" "dddddddabc")
;; #f
;; >>> (same_chars "abcd" "dddddddabce")
;; #f
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddddabc")
;; #f
(define (same_chars s0 s1)
  (define s0-set (apply set (string->list s0)))
  (define s1-set (apply set (string->list s1)))
  (set=? s0-set s1-set))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate same_chars))
    (check-within (candidate "eabcdzzzz" "dddzzzzzzzddeddabc") #t 0.001)
    (check-within (candidate "abcd" "dddddddabc") #t 0.001)
    (check-within (candidate "dddddddabc" "abcd") #t 0.001)
    (check-within (candidate "eabcd" "dddddddabc") #f 0.001)
    (check-within (candidate "abcd" "dddddddabcf") #f 0.001)
    (check-within (candidate "eabcdzzzz" "dddzzzzzzzddddabc") #f 0.001)
    (check-within (candidate "aabb" "aaccc") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183876
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Check if two words have the same characters.
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddeddabc")
;; #t
;; >>> (same_chars "abcd" "dddddddabc")
;; #t
;; >>> (same_chars "dddddddabc" "abcd")
;; #t
;; >>> (same_chars "eabcd" "dddddddabc")
;; #f
;; >>> (same_chars "abcd" "dddddddabce")
;; #f
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddddabc")
;; #f

;; Check if two words have the same characters.
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddeddabc")
;; #t
;; >>> (same_chars "abcd" "dddddddabc")
;; #t
;; >>> (same_chars "dddddddabc" "abcd")
;; #t
;; >>> (same_chars "eabcd" "dddddddabc")
;; #f
;; >>> (same_chars "abcd" "dddddddabce")
;; #f
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddddabc")
;; #f
(define (same_chars s0 s1)
  (let* ([l0 (string->list s0)]
         [l1 (string->list s1)]
         [u0 (sort (remove-duplicates l0) char<?)]
         [u1 (sort (remove-duplicates l1) char<?)])
    (equal? u0 u1)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate same_chars))
    (check-within (candidate "eabcdzzzz" "dddzzzzzzzddeddabc") #t 0.001)
    (check-within (candidate "abcd" "dddddddabc") #t 0.001)
    (check-within (candidate "dddddddabc" "abcd") #t 0.001)
    (check-within (candidate "eabcd" "dddddddabc") #f 0.001)
    (check-within (candidate "abcd" "dddddddabcf") #f 0.001)
    (check-within (candidate "eabcdzzzz" "dddzzzzzzzddddabc") #f 0.001)
    (check-within (candidate "aabb" "aaccc") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183876
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Check if two words have the same characters.
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddeddabc")
;; #t
;; >>> (same_chars "abcd" "dddddddabc")
;; #t
;; >>> (same_chars "dddddddabc" "abcd")
;; #t
;; >>> (same_chars "eabcd" "dddddddabc")
;; #f
;; >>> (same_chars "abcd" "dddddddabce")
;; #f
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddddabc")
;; #f

(require racket/set)

;; Check if two words have the same characters.
(define (same_chars s0 s1)
  (set=? (list->set (string->list s0))
         (list->set (string->list s1))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate same_chars))
    (check-within (candidate "eabcdzzzz" "dddzzzzzzzddeddabc") #t 0.001)
    (check-within (candidate "abcd" "dddddddabc") #t 0.001)
    (check-within (candidate "dddddddabc" "abcd") #t 0.001)
    (check-within (candidate "eabcd" "dddddddabc") #f 0.001)
    (check-within (candidate "abcd" "dddddddabcf") #f 0.001)
    (check-within (candidate "eabcdzzzz" "dddzzzzzzzddddabc") #f 0.001)
    (check-within (candidate "aabb" "aaccc") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183876
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Check if two words have the same characters.
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddeddabc")
;; #t
;; >>> (same_chars "abcd" "dddddddabc")
;; #t
;; >>> (same_chars "dddddddabc" "abcd")
;; #t
;; >>> (same_chars "eabcd" "dddddddabc")
;; #f
;; >>> (same_chars "abcd" "dddddddabce")
;; #f
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddddabc")
;; #f

(require racket/set)

;; Check if two words have the same characters.
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddeddabc")
;; #t
;; >>> (same_chars "abcd" "dddddddabc")
;; #t
;; >>> (same_chars "dddddddabc" "abcd")
;; #t
;; >>> (same_chars "eabcd" "dddddddabc")
;; #f
;; >>> (same_chars "abcd" "dddddddabce")
;; #f
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddddabc")
;; #f
(define (same_chars s0 s1)
  (let* ([set0 (apply set (string->list s0))]
         [set1 (apply set (string->list s1))])
    (set=? set0 set1)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate same_chars))
    (check-within (candidate "eabcdzzzz" "dddzzzzzzzddeddabc") #t 0.001)
    (check-within (candidate "abcd" "dddddddabc") #t 0.001)
    (check-within (candidate "dddddddabc" "abcd") #t 0.001)
    (check-within (candidate "eabcd" "dddddddabc") #f 0.001)
    (check-within (candidate "abcd" "dddddddabcf") #f 0.001)
    (check-within (candidate "eabcdzzzz" "dddzzzzzzzddddabc") #f 0.001)
    (check-within (candidate "aabb" "aaccc") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183876
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 60 (RKT) - HumanEval_60_sum_to_n
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; sum_to_n is a function that sums numbers from 1 to n.
;; >>> (sum_to_n 30)
;; 465
;; >>> (sum_to_n 100)
;; 5050
;; >>> (sum_to_n 5)
;; 15
;; >>> (sum_to_n 10)
;; 55
;; >>> (sum_to_n 1)
;; 1

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_to_n))
    (check-within (candidate 1) 1 0.001)
    (check-within (candidate 6) 21 0.001)
    (check-within (candidate 11) 66 0.001)
    (check-within (candidate 30) 465 0.001)
    (check-within (candidate 100) 5050 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; sum_to_n is a function that sums numbers from 1 to n.
;; >>> (sum_to_n 30)
;; 465
;; >>> (sum_to_n 100)
;; 5050
;; >>> (sum_to_n 5)
;; 15
;; >>> (sum_to_n 10)
;; 55
;; >>> (sum_to_n 1)
;; 1

;; sum_to_n is a function that sums numbers from 1 to n.
;; >>> (sum_to_n 30)
;; 465
;; >>> (sum_to_n 100)
;; 5050
;; >>> (sum_to_n 5)
;; 15
;; >>> (sum_to_n 10)
;; 55
;; >>> (sum_to_n 1)
;; 1
(define (sum_to_n n)
  ;; Base case: if n is 0 or negative, the sum is 0.
  (if (<= n 0)
      0
      ;; Recursive step: sum n with the sum of numbers up to n-1.
      (+ n (sum_to_n (sub1 n)))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_to_n))
    (check-within (candidate 1) 1 0.001)
    (check-within (candidate 6) 21 0.001)
    (check-within (candidate 11) 66 0.001)
    (check-within (candidate 30) 465 0.001)
    (check-within (candidate 100) 5050 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183881
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; sum_to_n is a function that sums numbers from 1 to n.
;; >>> (sum_to_n 30)
;; 465
;; >>> (sum_to_n 100)
;; 5050
;; >>> (sum_to_n 5)
;; 15
;; >>> (sum_to_n 10)
;; 55
;; >>> (sum_to_n 1)
;; 1

;; sum_to_n is a function that sums numbers from 1 to n.
;; >>> (sum_to_n 30)
;; 465
;; >>> (sum_to_n 100)
;; 5050
;; >>> (sum_to_n 5)
;; 15
;; >>> (sum_to_n 10)
;; 55
;; >>> (sum_to_n 1)
;; 1
(define (sum_to_n n)
  (if (<= n 1)
      n
      (+ n (sum_to_n (- n 1)))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_to_n))
    (check-within (candidate 1) 1 0.001)
    (check-within (candidate 6) 21 0.001)
    (check-within (candidate 11) 66 0.001)
    (check-within (candidate 30) 465 0.001)
    (check-within (candidate 100) 5050 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183881
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; sum_to_n is a function that sums numbers from 1 to n.
;; >>> (sum_to_n 30)
;; 465
;; >>> (sum_to_n 100)
;; 5050
;; >>> (sum_to_n 5)
;; 15
;; >>> (sum_to_n 10)
;; 55
;; >>> (sum_to_n 1)
;; 1

;; sum_to_n is a function that sums numbers from 1 to n.
;; >>> (sum_to_n 30)
;; 465
;; >>> (sum_to_n 100)
;; 5050
;; >>> (sum_to_n 5)
;; 15
;; >>> (sum_to_n 10)
;; 55
;; >>> (sum_to_n 1)
;; 1
(define (sum_to_n n)
  (if (zero? n)
      0
      (+ n (sum_to_n (- n 1)))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_to_n))
    (check-within (candidate 1) 1 0.001)
    (check-within (candidate 6) 21 0.001)
    (check-within (candidate 11) 66 0.001)
    (check-within (candidate 30) 465 0.001)
    (check-within (candidate 100) 5050 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183881
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; sum_to_n is a function that sums numbers from 1 to n.
;; >>> (sum_to_n 30)
;; 465
;; >>> (sum_to_n 100)
;; 5050
;; >>> (sum_to_n 5)
;; 15
;; >>> (sum_to_n 10)
;; 55
;; >>> (sum_to_n 1)
;; 1

;; sum_to_n is a function that sums numbers from 1 to n.
;; >>> (sum_to_n 30)
;; 465
;; >>> (sum_to_n 100)
;; 5050
;; >>> (sum_to_n 5)
;; 15
;; >>> (sum_to_n 10)
;; 55
;; >>> (sum_to_n 1)
;; 1
(define (sum_to_n n)
  ;; Using the arithmetic series formula: n * (n + 1) / 2
  (/ (* n (+ n 1)) 2))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sum_to_n))
    (check-within (candidate 1) 1 0.001)
    (check-within (candidate 6) 21 0.001)
    (check-within (candidate 11) 66 0.001)
    (check-within (candidate 30) 465 0.001)
    (check-within (candidate 100) 5050 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183881
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 61 (RKT) - HumanEval_61_correct_bracketing
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-within (candidate "()") #t 0.001)
    (check-within (candidate "(()())") #t 0.001)
    (check-within (candidate "()()(()())()") #t 0.001)
    (check-within (candidate "()()((()()())())(()()(()))") #t 0.001)
    (check-within (candidate "((()())))") #f 0.001)
    (check-within (candidate ")(()") #f 0.001)
    (check-within (candidate "(") #f 0.001)
    (check-within (candidate "((((") #f 0.001)
    (check-within (candidate ")") #f 0.001)
    (check-within (candidate "(()") #f 0.001)
    (check-within (candidate "()()(()())())(()") #f 0.001)
    (check-within (candidate "()()(()())()))()") #f 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f
(define (correct_bracketing brackets)
  (define len (string-length brackets))
  (define (check i count)
    (cond
      [(>= i len) (= count 0)]                     ; finished: balanced iff count is 0
      [else
       (define c (string-ref brackets i))
       (cond
         [(char=? c #\() (check (add1 i) (add1 count))]   ; open bracket: increase count
         [(char=? c #\)) (if (zero? count)                ; close bracket
                             #f                            ; but nothing to match
                             (check (add1 i) (sub1 count)))]
         [else (error "invalid character in input")] )]))
  (check 0 0))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-within (candidate "()") #t 0.001)
    (check-within (candidate "(()())") #t 0.001)
    (check-within (candidate "()()(()())()") #t 0.001)
    (check-within (candidate "()()((()()())())(()()(()))") #t 0.001)
    (check-within (candidate "((()())))") #f 0.001)
    (check-within (candidate ")(()") #f 0.001)
    (check-within (candidate "(") #f 0.001)
    (check-within (candidate "((((") #f 0.001)
    (check-within (candidate ")") #f 0.001)
    (check-within (candidate "(()") #f 0.001)
    (check-within (candidate "()()(()())())(()") #f 0.001)
    (check-within (candidate "()()(()())()))()") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183882
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f
(define (correct_bracketing brackets)
  ;; Helper: recursively process the string while keeping a balance counter.
  ;; `balance` counts the number of unmatched '(' seen so far.
  (let loop ((idx 0) (balance 0))
    (cond
      ;; If we reach the end, the sequence is correct iff balance is zero.
      [(>= idx (string-length brackets)) (= balance 0)]

      ;; If the current character is an opening bracket, increase balance.
      [(char=? (string-ref brackets idx) #\()
       (loop (+ idx 1) (+ balance 1))]

      ;; If the current character is a closing bracket,
      ;; we must have a previous unmatched '('.
      [(char=? (string-ref brackets idx) #\))
       (if (> balance 0)
           (loop (+ idx 1) (- balance 1))
           #f)]

      ;; For any other character (shouldn't occur) just skip it.
      [else
       (loop (+ idx 1) balance)])))

;; Test cases
(displayln (correct_bracketing "("))          ; => #f
(displayln (correct_bracketing "()"))         ; => #t
(displayln (correct_bracketing "(()())"))     ; => #t
(displayln (correct_bracketing ")(()"))       ; => #f
(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-within (candidate "()") #t 0.001)
    (check-within (candidate "(()())") #t 0.001)
    (check-within (candidate "()()(()())()") #t 0.001)
    (check-within (candidate "()()((()()())())(()()(()))") #t 0.001)
    (check-within (candidate "((()())))") #f 0.001)
    (check-within (candidate ")(()") #f 0.001)
    (check-within (candidate "(") #f 0.001)
    (check-within (candidate "((((") #f 0.001)
    (check-within (candidate ")") #f 0.001)
    (check-within (candidate "(()") #f 0.001)
    (check-within (candidate "()()(()())())(()") #f 0.001)
    (check-within (candidate "()()(()())()))()") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183882
STDOUT:
#f
#t
#t
#f
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f
(define (correct_bracketing brackets)
  ;; Helper that walks the string while keeping a balance counter.
  (let loop ([i 0] [balance 0])
    (cond
      ;; If we've processed the whole string, it's correct only if balance is 0.
      [(>= i (string-length brackets))
       (zero? balance)]
      ;; If we see an opening bracket, increment balance.
      [(char=? (string-ref brackets i) #\()
       (loop (+ i 1) (+ balance 1))]
      ;; If we see a closing bracket, decrement balance.
      ;; If balance would go negative, it's already invalid.
      [(char=? (string-ref brackets i) #\))
       (if (< balance 1)
           #f
           (loop (+ i 1) (- balance 1)))]
      ;; For any other character (not expected), just skip it.
      [else
       (loop (+ i 1) balance)])))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-within (candidate "()") #t 0.001)
    (check-within (candidate "(()())") #t 0.001)
    (check-within (candidate "()()(()())()") #t 0.001)
    (check-within (candidate "()()((()()())())(()()(()))") #t 0.001)
    (check-within (candidate "((()())))") #f 0.001)
    (check-within (candidate ")(()") #f 0.001)
    (check-within (candidate "(") #f 0.001)
    (check-within (candidate "((((") #f 0.001)
    (check-within (candidate ")") #f 0.001)
    (check-within (candidate "(()") #f 0.001)
    (check-within (candidate "()()(()())())(()") #f 0.001)
    (check-within (candidate "()()(()())()))()") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183882
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f
(define (correct_bracketing brackets)
  ;; Helper that walks the string keeping a balance counter.
  ;; `balance` is the number of unmatched '(' seen so far.
  (define (helper idx balance)
    (cond
      ;; End of string: balanced if and only if balance is zero.
      [(>= idx (string-length brackets))
       (= balance 0)]
      ;; Encounter an opening bracket: increase balance.
      [(char=? (string-ref brackets idx) #\()
       (helper (add1 idx) (+ balance 1))]
      ;; Encounter a closing bracket: decrease balance if possible.
      [(char=? (string-ref brackets idx) #\))
       (if (> balance 0)
           (helper (add1 idx) (- balance 1))
           #f)]
      ;; Any other character (shouldn't happen) just skip it.
      [else
       (helper (add1 idx) balance)]))
  ;; Start recursion at the first character with an empty balance.
  (helper 0 0))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-within (candidate "()") #t 0.001)
    (check-within (candidate "(()())") #t 0.001)
    (check-within (candidate "()()(()())()") #t 0.001)
    (check-within (candidate "()()((()()())())(()()(()))") #t 0.001)
    (check-within (candidate "((()())))") #f 0.001)
    (check-within (candidate ")(()") #f 0.001)
    (check-within (candidate "(") #f 0.001)
    (check-within (candidate "((((") #f 0.001)
    (check-within (candidate ")") #f 0.001)
    (check-within (candidate "(()") #f 0.001)
    (check-within (candidate "()()(()())())(()") #f 0.001)
    (check-within (candidate "()()(()())()))()") #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183882
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 64 (RKT) - HumanEval_64_vowels_count
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Write a function vowels_count which takes a string representing
;; a word as input and returns the number of vowels in the string.
;; Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
;; vowel, but only when it is at the end of the given word.
;; Example:
;; >>> (vowels_count "abcde")
;; 2
;; >>> (vowels_count "ACEDY")
;; 3

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate vowels_count))
    (check-within (candidate "abcde") 2 0.001)
    (check-within (candidate "Alone") 3 0.001)
    (check-within (candidate "key") 2 0.001)
    (check-within (candidate "bye") 1 0.001)
    (check-within (candidate "keY") 2 0.001)
    (check-within (candidate "bYe") 1 0.001)
    (check-within (candidate "ACEDY") 3 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Write a function vowels_count which takes a string representing
;; a word as input and returns the number of vowels in the string.
;; Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
;; vowel, but only when it is at the end of the given word.
;; Example:
;; >>> (vowels_count "abcde")
;; 2
;; >>> (vowels_count "ACEDY")
;; 3

;; Write a function vowels_count which takes a string representing
;; a word as input and returns the number of vowels in the string.
;; Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
;; vowel, but only when it is at the end of the given word.
;; Example:
;; >>> (vowels_count "abcde")
;; 2
;; >>> (vowels_count "ACEDY")
;; 3

(define (vowels_count s)
  (define len (string-length s))

  ;; Helpers to test characters
  (define (vowel? c)
    (or (char-ci=? c #\a)
        (char-ci=? c #\e)
        (char-ci=? c #\i)
        (char-ci=? c #\o)
        (char-ci=? c #\u)))

  (define (y? c)
    (or (char=? c #\y) (char=? c #\Y)))

  ;; Iterate over the string and count
  (let loop ((i 0) (cnt 0))
    (if (= i len)
        cnt
        (let ((c (string-ref s i)))
          (loop (add1 i)
                (cond
                  [(vowel? c) (add1 cnt)]
                  [(and (y? c) (= i (sub1 len))) (add1 cnt)]
                  [else cnt]))))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate vowels_count))
    (check-within (candidate "abcde") 2 0.001)
    (check-within (candidate "Alone") 3 0.001)
    (check-within (candidate "key") 2 0.001)
    (check-within (candidate "bye") 1 0.001)
    (check-within (candidate "keY") 2 0.001)
    (check-within (candidate "bYe") 1 0.001)
    (check-within (candidate "ACEDY") 3 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183885
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Write a function vowels_count which takes a string representing
;; a word as input and returns the number of vowels in the string.
;; Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
;; vowel, but only when it is at the end of the given word.
;; Example:
;; >>> (vowels_count "abcde")
;; 2
;; >>> (vowels_count "ACEDY")
;; 3

;; Write a function vowels_count which takes a string representing
;; a word as input and returns the number of vowels in the string.
;; Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
;; vowel, but only when it is at the end of the given word.
;; Example:
;; >>> (vowels_count "abcde")
;; 2
;; >>> (vowels_count "ACEDY")
;; 3
(define (vowels_count s)
  (define len (string-length s))
  (define (is-vowel? ch)
    (member (char-downcase ch) '(#\a #\e #\i #\o #\u)))
  (define (is-y? ch)
    (or (eq? ch #\y) (eq? ch #\Y)))
  (let loop ((i 0) (count 0))
    (if (= i len)
        count
        (let ((ch (string-ref s i)))
          (cond
            [(is-vowel? ch) (loop (+ i 1) (+ count 1))]
            [(and (is-y? ch) (= i (- len 1))) (loop (+ i 1) (+ count 1))]
            [else (loop (+ i 1) count)])))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate vowels_count))
    (check-within (candidate "abcde") 2 0.001)
    (check-within (candidate "Alone") 3 0.001)
    (check-within (candidate "key") 2 0.001)
    (check-within (candidate "bye") 1 0.001)
    (check-within (candidate "keY") 2 0.001)
    (check-within (candidate "bYe") 1 0.001)
    (check-within (candidate "ACEDY") 3 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183885
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Write a function vowels_count which takes a string representing
;; a word as input and returns the number of vowels in the string.
;; Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
;; vowel, but only when it is at the end of the given word.
;; Example:
;; >>> (vowels_count "abcde")
;; 2
;; >>> (vowels_count "ACEDY")
;; 3

;; Count vowels in a string.
;; Vowels: a, e, i, o, u (case‑insensitive).
;; 'y' is counted only if it is the last character of the string.
(define (vowels_count s)
  (define n (string-length s))
  (for/sum ([i (in-range n)])
    (let ([c (char-downcase (string-ref s i))])
      (cond
        [(or (eq? c #\a) (eq? c #\e) (eq? c #\i)
             (eq? c #\o) (eq? c #\u))
         1]
        [(and (eq? c #\y) (= i (- n 1))) 1]
        [else 0]))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate vowels_count))
    (check-within (candidate "abcde") 2 0.001)
    (check-within (candidate "Alone") 3 0.001)
    (check-within (candidate "key") 2 0.001)
    (check-within (candidate "bye") 1 0.001)
    (check-within (candidate "keY") 2 0.001)
    (check-within (candidate "bYe") 1 0.001)
    (check-within (candidate "ACEDY") 3 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183885
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Write a function vowels_count which takes a string representing
;; a word as input and returns the number of vowels in the string.
;; Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
;; vowel, but only when it is at the end of the given word.
;; Example:
;; >>> (vowels_count "abcde")
;; 2
;; >>> (vowels_count "ACEDY")
;; 3

;; Write a function vowels_count which takes a string representing
;; a word as input and returns the number of vowels in the string.
;; Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
;; vowel, but only when it is at the end of the given word.
;; Example:
;; >>> (vowels_count "abcde")
;; 2
;; >>> (vowels_count "ACEDY")
;; 3
(define (vowels_count s)
  ;; Convert the string to lowercase to make the check case‑insensitive
  (define s-lower (string-downcase s))
  (define n (string-length s-lower))

  (define (char-vowel? c idx)
    (cond
      [(member c '(#\a #\e #\i #\o #\u)) #t]   ; standard vowels
      [(and (eq? c #\y) (= idx (- n 1))) #t]   ; 'y' only at the end
      [else #f]))

  ;; Iterate over the string and count the vowels
  (define (count-idx i acc)
    (if (>= i n)
        acc
        (count-idx (add1 i)
                   (if (char-vowel? (string-ref s-lower i) i)
                       (add1 acc)
                       acc))))

  (count-idx 0 0))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate vowels_count))
    (check-within (candidate "abcde") 2 0.001)
    (check-within (candidate "Alone") 3 0.001)
    (check-within (candidate "key") 2 0.001)
    (check-within (candidate "bye") 1 0.001)
    (check-within (candidate "keY") 2 0.001)
    (check-within (candidate "bYe") 1 0.001)
    (check-within (candidate "ACEDY") 3 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183885
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 66 (RKT) - HumanEval_66_digitSum
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "abAB") 131 0.001)
    (check-within (candidate "abcCd") 67 0.001)
    (check-within (candidate "helloE") 69 0.001)
    (check-within (candidate "woArBld") 131 0.001)
    (check-within (candidate "aAaaaXa") 153 0.001)
    (check-within (candidate " How are yOu?") 151 0.001)
    (check-within (candidate "You arE Very Smart") 327 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153

;; Task
;; Write a function that takes a string as input and returns the sum of the
;; upper characters only' ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153

(define (digitSum s)
  ;; Sum the ASCII codes of all uppercase letters in the string `s`.
  (foldl
   (lambda (c acc)
     (if (and (char>=? c #\A) (char<=? c #\Z))
         (+ acc (char->integer c))
         acc))
   0
   (string->list s)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "abAB") 131 0.001)
    (check-within (candidate "abcCd") 67 0.001)
    (check-within (candidate "helloE") 69 0.001)
    (check-within (candidate "woArBld") 131 0.001)
    (check-within (candidate "aAaaaXa") 153 0.001)
    (check-within (candidate " How are yOu?") 151 0.001)
    (check-within (candidate "You arE Very Smart") 327 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183887
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153

(define (digitSum s)
  (define len (string-length s))
  (for/sum ([i (in-range len)])
    (let ([c (string-ref s i)])
      (if (char-upper-case? c)
          (char->integer c)
          0))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "abAB") 131 0.001)
    (check-within (candidate "abcCd") 67 0.001)
    (check-within (candidate "helloE") 69 0.001)
    (check-within (candidate "woArBld") 131 0.001)
    (check-within (candidate "aAaaaXa") 153 0.001)
    (check-within (candidate " How are yOu?") 151 0.001)
    (check-within (candidate "You arE Very Smart") 327 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183887
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153

;; Task
;; Write a function that takes a string as input and returns the sum of the
;; upper characters only' ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153

(define (digitSum s)
  ;; Convert the string to a list of characters, then fold over that list
  ;; accumulating the sum of ASCII codes for any uppercase character.
  (foldl (lambda (c acc)
           (if (char-upper-case? c)
               (+ acc (char->integer c))
               acc))
         0
         (string->list s)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "abAB") 131 0.001)
    (check-within (candidate "abcCd") 67 0.001)
    (check-within (candidate "helloE") 69 0.001)
    (check-within (candidate "woArBld") 131 0.001)
    (check-within (candidate "aAaaaXa") 153 0.001)
    (check-within (candidate " How are yOu?") 151 0.001)
    (check-within (candidate "You arE Very Smart") 327 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183887
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153

;; Task
;; Write a function that takes a string as input and returns the sum of the
;; upper characters only' ASCII codes.

(define (digitSum s)
  ;; Convert the string to a list of characters and fold over it,
  ;; accumulating the ASCII codes of uppercase letters only.
  (foldl (lambda (c acc)
           (if (char-upper-case? c)
               (+ acc (char->integer c))
               acc))
         0
         (string->list s)))

;; Examples
(displayln (digitSum ""))          ; => 0
(displayln (digitSum "abAB"))      ; => 131
(displayln (digitSum "abcCd"))     ; => 67
(displayln (digitSum "helloE"))    ; => 69
(displayln (digitSum "woArBld"))   ; => 131
(displayln (digitSum "aAaaaXa"))   ; => 153
(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "abAB") 131 0.001)
    (check-within (candidate "abcCd") 67 0.001)
    (check-within (candidate "helloE") 69 0.001)
    (check-within (candidate "woArBld") 131 0.001)
    (check-within (candidate "aAaaaXa") 153 0.001)
    (check-within (candidate " How are yOu?") 151 0.001)
    (check-within (candidate "You arE Very Smart") 327 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183887
STDOUT:
0
131
67
69
131
153
STDERR: (empty)
--------------------

================================================================================
PROBLEM 72 (RKT) - HumanEval_72_will_it_fly
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Write a function that returns #t if the object q will fly, and #f otherwise.
;; The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
;; Example:
;; >>> (will_it_fly (list 1 2) 5)
;; #f
;; # 1+2 is less than the maximum possible weight, but it's unbalanced.
;; >>> (will_it_fly (list 3 2 3) 1)
;; #f
;; # it's balanced, but 3+2+3 is more than the maximum possible weight.
;; >>> (will_it_fly (list 3 2 3) 9)
;; #t
;; # 3+2+3 is less than the maximum possible weight, and it's balanced.
;; >>> (will_it_fly (list 3) 5)
;; #t
;; # 3 is less than the maximum possible weight, and it's balanced.

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate will_it_fly))
    (check-within (candidate (list 3 2 3) 9) #t 0.001)
    (check-within (candidate (list 1 2) 5) #f 0.001)
    (check-within (candidate (list 3) 5) #t 0.001)
    (check-within (candidate (list 3 2 3) 1) #f 0.001)
    (check-within (candidate (list 1 2 3) 6) #f 0.001)
    (check-within (candidate (list 5) 5) #t 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Write a function that returns #t if the object q will fly, and #f otherwise.
;; The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
;; Example:
;; >>> (will_it_fly (list 1 2) 5)
;; #f
;; # 1+2 is less than the maximum possible weight, but it's unbalanced.
;; >>> (will_it_fly (list 3 2 3) 1)
;; #f
;; # it's balanced, but 3+2+3 is more than the maximum possible weight.
;; >>> (will_it_fly (list 3 2 3) 9)
;; #t
;; # 3+2+3 is less than the maximum possible weight, and it's balanced.
;; >>> (will_it_fly (list 3) 5)
;; #t
;; # 3 is less than the maximum possible weight, and it's balanced.

;; Helper function: check if a list is a palindrome
(define (palindrome? lst)
  (equal? lst (reverse lst)))

;; Helper function: compute sum of elements in a list
(define (sum-list lst)
  (foldl + 0 lst))

;; Main function
(define (will_it_fly q w)
  (and (palindrome? q)
       (<= (sum-list q) w)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate will_it_fly))
    (check-within (candidate (list 3 2 3) 9) #t 0.001)
    (check-within (candidate (list 1 2) 5) #f 0.001)
    (check-within (candidate (list 3) 5) #t 0.001)
    (check-within (candidate (list 3 2 3) 1) #f 0.001)
    (check-within (candidate (list 1 2 3) 6) #f 0.001)
    (check-within (candidate (list 5) 5) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183892
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Write a function that returns #t if the object q will fly, and #f otherwise.
;; The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
;; Example:
;; >>> (will_it_fly (list 1 2) 5)
;; #f
;; # 1+2 is less than the maximum possible weight, but it's unbalanced.
;; >>> (will_it_fly (list 3 2 3) 1)
;; #f
;; # it's balanced, but 3+2+3 is more than the maximum possible weight.
;; >>> (will_it_fly (list 3 2 3) 9)
;; #t
;; # 3+2+3 is less than the maximum possible weight, and it's balanced.
;; >>> (will_it_fly (list 3) 5)
;; #t
;; # 3 is less than the maximum possible weight, and it's balanced.

;; Helper: check if a list is a palindrome
(define (palindrome? lst)
  (equal? lst (reverse lst)))

;; Main function: return #t if the list q is balanced (palindromic)
;; and the sum of its elements is less than or equal to w.
(define (will_it_fly q w)
  (and (palindrome? q)
       (<= (apply + q) w)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate will_it_fly))
    (check-within (candidate (list 3 2 3) 9) #t 0.001)
    (check-within (candidate (list 1 2) 5) #f 0.001)
    (check-within (candidate (list 3) 5) #t 0.001)
    (check-within (candidate (list 3 2 3) 1) #f 0.001)
    (check-within (candidate (list 1 2 3) 6) #f 0.001)
    (check-within (candidate (list 5) 5) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183892
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Write a function that returns #t if the object q will fly, and #f otherwise.
;; The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
;; Example:
;; >>> (will_it_fly (list 1 2) 5)
;; #f
;; # 1+2 is less than the maximum possible weight, but it's unbalanced.
;; >>> (will_it_fly (list 3 2 3) 1)
;; #f
;; # it's balanced, but 3+2+3 is more than the maximum possible weight.
;; >>> (will_it_fly (list 3 2 3) 9)
;; #t
;; # 3+2+3 is less than the maximum possible weight, and it's balanced.
;; >>> (will_it_fly (list 3) 5)
;; #t
;; # 3 is less than the maximum possible weight, and it's balanced.

;; Returns #t if the list `q` is palindromic and its sum of elements
;; is less than or equal to `w`. Otherwise returns #f.
(define (will_it_fly q w)
  (and (equal? q (reverse q))          ; check for palindrome
       (<= (foldl + 0 q) w)))          ; sum of elements
(require rackunit)

(define (test-humaneval) 

  (let (( candidate will_it_fly))
    (check-within (candidate (list 3 2 3) 9) #t 0.001)
    (check-within (candidate (list 1 2) 5) #f 0.001)
    (check-within (candidate (list 3) 5) #t 0.001)
    (check-within (candidate (list 3 2 3) 1) #f 0.001)
    (check-within (candidate (list 1 2 3) 6) #f 0.001)
    (check-within (candidate (list 5) 5) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183892
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Write a function that returns #t if the object q will fly, and #f otherwise.
;; The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
;; Example:
;; >>> (will_it_fly (list 1 2) 5)
;; #f
;; # 1+2 is less than the maximum possible weight, but it's unbalanced.
;; >>> (will_it_fly (list 3 2 3) 1)
;; #f
;; # it's balanced, but 3+2+3 is more than the maximum possible weight.
;; >>> (will_it_fly (list 3 2 3) 9)
;; #t
;; # 3+2+3 is less than the maximum possible weight, and it's balanced.
;; >>> (will_it_fly (list 3) 5)
;; #t
;; # 3 is less than the maximum possible weight, and it's balanced.

;; Write a function that returns #t if the object q will fly, and #f otherwise.
;; The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
;; Example:
;; >>> (will_it_fly (list 1 2) 5)
;; #f
;; # 1+2 is less than the maximum possible weight, but it's unbalanced.
;; >>> (will_it_fly (list 3 2 3) 1)
;; #f
;; # it's balanced, but 3+2+3 is more than the maximum possible weight.
;; >>> (will_it_fly (list 3 2 3) 9)
;; #t
;; # 3+2+3 is less than the maximum possible weight, and it's balanced.
;; >>> (will_it_fly (list 3) 5)
;; #t
;; # 3 is less than the maximum possible weight, and it's balanced.

(define (will_it_fly q w)
  (and (equal? q (reverse q))
       (<= (apply + 0 q) w)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate will_it_fly))
    (check-within (candidate (list 3 2 3) 9) #t 0.001)
    (check-within (candidate (list 1 2) 5) #f 0.001)
    (check-within (candidate (list 3) 5) #t 0.001)
    (check-within (candidate (list 3 2 3) 1) #f 0.001)
    (check-within (candidate (list 1 2 3) 6) #f 0.001)
    (check-within (candidate (list 5) 5) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183892
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 74 (RKT) - HumanEval_74_total_match
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Write a function that accepts two lists of strings and returns the list that has 
;; total number of chars in the all strings of the list less than the other list.
;; if the two lists have the same number of chars, return the first list.
;; Examples
;; >>> (total_match (list ) (list ))
;; (list )
;; >>> (total_match (list "hi" "admin") (list "hI" "Hi"))
;; (list "hI" "Hi")
;; >>> (total_match (list "hi" "admin") (list "hi" "hi" "admin" "project"))
;; (list "hi" "admin")
;; >>> (total_match (list "hi" "admin") (list "hI" "hi" "hi"))
;; (list "hI" "hi" "hi")
;; >>> (total_match (list "4") (list "1" "2" "3" "4" "5"))
;; (list "4")

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate total_match))
    (check-within (candidate (list ) (list )) (list ) 0.001)
    (check-within (candidate (list "hi" "admin") (list "hi" "hi")) (list "hi" "hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hi" "hi" "admin" "project")) (list "hi" "admin") 0.001)
    (check-within (candidate (list "4") (list "1" "2" "3" "4" "5")) (list "4") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "Hi")) (list "hI" "Hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "hi" "hi")) (list "hI" "hi" "hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "hi" "hii")) (list "hi" "admin") 0.001)
    (check-within (candidate (list ) (list "this")) (list ) 0.001)
    (check-within (candidate (list "this") (list )) (list ) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Write a function that accepts two lists of strings and returns the list that has 
;; total number of chars in the all strings of the list less than the other list.
;; if the two lists have the same number of chars, return the first list.
;; Examples
;; >>> (total_match (list ) (list ))
;; (list )
;; >>> (total_match (list "hi" "admin") (list "hI" "Hi"))
;; (list "hI" "Hi")
;; >>> (total_match (list "hi" "admin") (list "hi" "hi" "admin" "project"))
;; (list "hi" "admin")
;; >>> (total_match (list "hi" "admin") (list "hI" "hi" "hi"))
;; (list "hI" "hi" "hi")
;; >>> (total_match (list "4") (list "1" "2" "3" "4" "5"))
;; (list "4")

;; Write a function that accepts two lists of strings and returns the list that has 
;; total number of chars in the all strings of the list less than the other list.
;; if the two lists have the same number of chars, return the first list.
;; Examples
;; >>> (total_match (list ) (list ))
;; (list )
;; >>> (total_match (list "hi" "admin") (list "hI" "Hi"))
;; (list "hI" "Hi")
;; >>> (total_match (list "hi" "admin") (list "hi" "hi" "admin" "project"))
;; (list "hi" "admin")
;; >>> (total_match (list "hi" "admin") (list "hI" "hi" "hi"))
;; (list "hI" "hi" "hi")
;; >>> (total_match (list "4") (list "1" "2" "3" "4" "5"))
;; (list "4")

(define (total_match lst1 lst2)
  ;; Helper to compute the total number of characters in a list of strings
  (define (total-chars lst)
    (foldl (lambda (s acc) (+ acc (string-length s))) 0 lst))

  (let* ([t1 (total-chars lst1)]
         [t2 (total-chars lst2)])
    (cond
      [(< t1 t2) lst1]   ; lst1 has fewer total chars
      [(> t1 t2) lst2]   ; lst2 has fewer total chars
      [else lst1])))     ; equal totals, return first list
(require rackunit)

(define (test-humaneval) 

  (let (( candidate total_match))
    (check-within (candidate (list ) (list )) (list ) 0.001)
    (check-within (candidate (list "hi" "admin") (list "hi" "hi")) (list "hi" "hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hi" "hi" "admin" "project")) (list "hi" "admin") 0.001)
    (check-within (candidate (list "4") (list "1" "2" "3" "4" "5")) (list "4") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "Hi")) (list "hI" "Hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "hi" "hi")) (list "hI" "hi" "hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "hi" "hii")) (list "hi" "admin") 0.001)
    (check-within (candidate (list ) (list "this")) (list ) 0.001)
    (check-within (candidate (list "this") (list )) (list ) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183894
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Write a function that accepts two lists of strings and returns the list that has 
;; total number of chars in the all strings of the list less than the other list.
;; if the two lists have the same number of chars, return the first list.
;; Examples
;; >>> (total_match (list ) (list ))
;; (list )
;; >>> (total_match (list "hi" "admin") (list "hI" "Hi"))
;; (list "hI" "Hi")
;; >>> (total_match (list "hi" "admin") (list "hi" "hi" "admin" "project"))
;; (list "hi" "admin")
;; >>> (total_match (list "hi" "admin") (list "hI" "hi" "hi"))
;; (list "hI" "hi" "hi")
;; >>> (total_match (list "4") (list "1" "2" "3" "4" "5"))
;; (list "4")

;; Returns the list that has fewer total characters.
;; If both lists have the same total, the first list is returned.
(define (total_match lst1 lst2)
  (define (total-strings lst)
    (apply + (map string-length lst)))
  (let ([t1 (total-strings lst1)]
        [t2 (total-strings lst2)])
    (cond
      [(< t1 t2) lst1]
      [(< t2 t1) lst2]
      [else lst1])))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate total_match))
    (check-within (candidate (list ) (list )) (list ) 0.001)
    (check-within (candidate (list "hi" "admin") (list "hi" "hi")) (list "hi" "hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hi" "hi" "admin" "project")) (list "hi" "admin") 0.001)
    (check-within (candidate (list "4") (list "1" "2" "3" "4" "5")) (list "4") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "Hi")) (list "hI" "Hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "hi" "hi")) (list "hI" "hi" "hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "hi" "hii")) (list "hi" "admin") 0.001)
    (check-within (candidate (list ) (list "this")) (list ) 0.001)
    (check-within (candidate (list "this") (list )) (list ) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183894
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Write a function that accepts two lists of strings and returns the list that has 
;; total number of chars in the all strings of the list less than the other list.
;; if the two lists have the same number of chars, return the first list.
;; Examples
;; >>> (total_match (list ) (list ))
;; (list )
;; >>> (total_match (list "hi" "admin") (list "hI" "Hi"))
;; (list "hI" "Hi")
;; >>> (total_match (list "hi" "admin") (list "hi" "hi" "admin" "project"))
;; (list "hi" "admin")
;; >>> (total_match (list "hi" "admin") (list "hI" "hi" "hi"))
;; (list "hI" "hi" "hi")
;; >>> (total_match (list "4") (list "1" "2" "3" "4" "5"))
;; (list "4")

;; Write a function that accepts two lists of strings and returns the list that has 
;; total number of chars in the all strings of the list less than the other list.
;; if the two lists have the same number of chars, return the first list.
;; Examples
;; >>> (total_match (list ) (list ))
;; (list )
;; >>> (total_match (list "hi" "admin") (list "hI" "Hi"))
;; (list "hI" "Hi")
;; >>> (total_match (list "hi" "admin") (list "hi" "hi" "admin" "project"))
;; (list "hi" "admin")
;; >>> (total_match (list "hi" "admin") (list "hI" "hi" "hi"))
;; (list "hI" "hi" "hi")
;; >>> (total_match (list "4") (list "1" "2" "3" "4" "5"))
;; (list "4")
(define (total_match lst1 lst2)
  (let* ([sum1 (apply + (map string-length lst1))]
         [sum2 (apply + (map string-length lst2))])
    (if (<= sum1 sum2)
        lst1
        lst2)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate total_match))
    (check-within (candidate (list ) (list )) (list ) 0.001)
    (check-within (candidate (list "hi" "admin") (list "hi" "hi")) (list "hi" "hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hi" "hi" "admin" "project")) (list "hi" "admin") 0.001)
    (check-within (candidate (list "4") (list "1" "2" "3" "4" "5")) (list "4") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "Hi")) (list "hI" "Hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "hi" "hi")) (list "hI" "hi" "hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "hi" "hii")) (list "hi" "admin") 0.001)
    (check-within (candidate (list ) (list "this")) (list ) 0.001)
    (check-within (candidate (list "this") (list )) (list ) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183894
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Write a function that accepts two lists of strings and returns the list that has 
;; total number of chars in the all strings of the list less than the other list.
;; if the two lists have the same number of chars, return the first list.
;; Examples
;; >>> (total_match (list ) (list ))
;; (list )
;; >>> (total_match (list "hi" "admin") (list "hI" "Hi"))
;; (list "hI" "Hi")
;; >>> (total_match (list "hi" "admin") (list "hi" "hi" "admin" "project"))
;; (list "hi" "admin")
;; >>> (total_match (list "hi" "admin") (list "hI" "hi" "hi"))
;; (list "hI" "hi" "hi")
;; >>> (total_match (list "4") (list "1" "2" "3" "4" "5"))
;; (list "4")

;; Write a function that accepts two lists of strings and returns the list that has 
;; total number of chars in the all strings of the list less than the other list.
;; if the two lists have the same number of chars, return the first list.

(define (total_match lst1 lst2)
  ;; Helper that computes the total number of characters in a list of strings
  (define (total-length lst)
    (foldl (lambda (s acc) (+ (string-length s) acc)) 0 lst))
  (let ([len1 (total-length lst1)]
        [len2 (total-length lst2)])
    (if (<= len1 len2)
        lst1
        lst2)))

;; Example usage
;; (total_match (list "hi" "admin") (list "hI" "Hi"))   ; => (list "hI" "Hi")
;; (total_match (list "hi" "admin") (list "hi" "hi" "admin" "project")) ; => (list "hi" "admin")
;; (total_match (list "4") (list "1" "2" "3" "4" "5")) ; => (list "4")
(require rackunit)

(define (test-humaneval) 

  (let (( candidate total_match))
    (check-within (candidate (list ) (list )) (list ) 0.001)
    (check-within (candidate (list "hi" "admin") (list "hi" "hi")) (list "hi" "hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hi" "hi" "admin" "project")) (list "hi" "admin") 0.001)
    (check-within (candidate (list "4") (list "1" "2" "3" "4" "5")) (list "4") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "Hi")) (list "hI" "Hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "hi" "hi")) (list "hI" "hi" "hi") 0.001)
    (check-within (candidate (list "hi" "admin") (list "hI" "hi" "hii")) (list "hi" "admin") 0.001)
    (check-within (candidate (list ) (list "this")) (list ) 0.001)
    (check-within (candidate (list "this") (list )) (list ) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183894
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 76 (RKT) - HumanEval_76_is_simple_power
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; #t
;; >>> (is_simple_power 2 2)
;; #t
;; >>> (is_simple_power 8 2)
;; #t
;; >>> (is_simple_power 3 2)
;; #f
;; >>> (is_simple_power 3 1)
;; #f
;; >>> (is_simple_power 5 3)
;; #f

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-within (candidate 16 2) #t 0.001)
    (check-within (candidate 143214 16) #f 0.001)
    (check-within (candidate 4 2) #t 0.001)
    (check-within (candidate 9 3) #t 0.001)
    (check-within (candidate 16 4) #t 0.001)
    (check-within (candidate 24 2) #f 0.001)
    (check-within (candidate 128 4) #f 0.001)
    (check-within (candidate 12 6) #f 0.001)
    (check-within (candidate 1 1) #t 0.001)
    (check-within (candidate 1 12) #t 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; #t
;; >>> (is_simple_power 2 2)
;; #t
;; >>> (is_simple_power 8 2)
;; #t
;; >>> (is_simple_power 3 2)
;; #f
;; >>> (is_simple_power 3 1)
;; #f
;; >>> (is_simple_power 5 3)
;; #f

;; Return #t if `x` is a simple power of `n` (i.e. n**k = x for some integer k),
;; otherwise return #f.
(define (is_simple_power x n)
  ;; Handle edge cases first
  (cond
    ;; If n is 1, the only power is 1 itself
    [(= n 1) (= x 1)]

    ;; If n is 0, only 0^k = 0 for k > 0; 0^0 is undefined
    [(= n 0) (and (> x 0) (= x 0))]   ; effectively only true for x==0

    ;; For all other cases, we require positive integers
    [(or (< x 1) (< n 1)) #f]

    ;; Recursive check: repeatedly divide by n while divisible
    [else
     (let loop ((curr x))
       (cond
         [(= curr 1) #t]                          ; reached 1 → power found
         [(zero? (modulo curr n)) (loop (/ curr n))] ; divisible, keep going
         [else #f]))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-within (candidate 16 2) #t 0.001)
    (check-within (candidate 143214 16) #f 0.001)
    (check-within (candidate 4 2) #t 0.001)
    (check-within (candidate 9 3) #t 0.001)
    (check-within (candidate 16 4) #t 0.001)
    (check-within (candidate 24 2) #f 0.001)
    (check-within (candidate 128 4) #f 0.001)
    (check-within (candidate 12 6) #f 0.001)
    (check-within (candidate 1 1) #t 0.001)
    (check-within (candidate 1 12) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183910
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; #t
;; >>> (is_simple_power 2 2)
;; #t
;; >>> (is_simple_power 8 2)
;; #t
;; >>> (is_simple_power 3 2)
;; #f
;; >>> (is_simple_power 3 1)
;; #f
;; >>> (is_simple_power 5 3)
;; #f

;; Returns #t if `x` is a simple power of `n` (i.e. n**k = x for some integer k),
;; otherwise returns #f.
(define (is_simple_power x n)
  (cond
    ;; Reject non‑integers
    [(or (not (integer? x)) (not (integer? n))) #f]
    ;; Special cases for n = 0 or n = 1
    [(= n 1) (= x 1)]
    [(= n 0) (= x 0)]   ; 0^k = 0 only for k>0, 0^0 is treated as false
    ;; x must be at least 1 for any positive base
    [(< x 1) #f]
    ;; General case: keep dividing by n while divisible
    [else
     (let loop ([y x])
       (cond
         [(= y 1) #t]                     ; reached 1 → success
         [(zero? (modulo y n)) (loop (quotient y n))] ; divisible → continue
         [else #f]))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-within (candidate 16 2) #t 0.001)
    (check-within (candidate 143214 16) #f 0.001)
    (check-within (candidate 4 2) #t 0.001)
    (check-within (candidate 9 3) #t 0.001)
    (check-within (candidate 16 4) #t 0.001)
    (check-within (candidate 24 2) #f 0.001)
    (check-within (candidate 128 4) #f 0.001)
    (check-within (candidate 12 6) #f 0.001)
    (check-within (candidate 1 1) #t 0.001)
    (check-within (candidate 1 12) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183910
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; #t
;; >>> (is_simple_power 2 2)
;; #t
;; >>> (is_simple_power 8 2)
;; #t
;; >>> (is_simple_power 3 2)
;; #f
;; >>> (is_simple_power 3 1)
;; #f
;; >>> (is_simple_power 5 3)
;; #f

;; Return #t if `x` is a simple power of `n` (i.e. there exists an integer
;; k such that n^k = x), otherwise return #f.
;;
;; Examples:
;;   (is_simple_power 1 4)   => #t   ; 4^0 = 1
;;   (is_simple_power 2 2)   => #t   ; 2^1 = 2
;;   (is_simple_power 8 2)   => #t   ; 2^3 = 8
;;   (is_simple_power 3 2)   => #f
;;   (is_simple_power 3 1)   => #f
;;   (is_simple_power 5 3)   => #f

(define (is_simple_power x n)
  ;; Basic sanity checks: we only consider positive integers.
  (cond
    [(or (< x 1) (< n 1)) #f]          ; negative or zero inputs are out of scope
    [(= n 1) (= x 1)]                  ; only 1^0 = 1
    [(= x 1) #t]                       ; n^0 = 1 for any n>0
    [else
     ;; Repeatedly divide `x` by `n` as long as it is divisible.
     ;; If we eventually reach 1, then `x` is a power of `n`.
     (let loop ([y x])
       (cond
         [(= y 1) #t]                   ; reached the base case
         [(zero? (modulo y n))          ; divisible by `n`
          (loop (/ y n))]
         [else #f]))]))

;; Test cases
(displayln (is_simple_power 1 4))   ; #t
(displayln (is_simple_power 2 2))   ; #t
(displayln (is_simple_power 8 2))   ; #t
(displayln (is_simple_power 3 2))   ; #f
(displayln (is_simple_power 3 1))   ; #f
(displayln (is_simple_power 5 3))   ; #f
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-within (candidate 16 2) #t 0.001)
    (check-within (candidate 143214 16) #f 0.001)
    (check-within (candidate 4 2) #t 0.001)
    (check-within (candidate 9 3) #t 0.001)
    (check-within (candidate 16 4) #t 0.001)
    (check-within (candidate 24 2) #f 0.001)
    (check-within (candidate 128 4) #f 0.001)
    (check-within (candidate 12 6) #f 0.001)
    (check-within (candidate 1 1) #t 0.001)
    (check-within (candidate 1 12) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183910
STDOUT:
#t
#t
#t
#f
#f
#f
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; #t
;; >>> (is_simple_power 2 2)
;; #t
;; >>> (is_simple_power 8 2)
;; #t
;; >>> (is_simple_power 3 2)
;; #f
;; >>> (is_simple_power 3 1)
;; #f
;; >>> (is_simple_power 5 3)
;; #f

;; Returns #t if `x` is a simple power of `n` (i.e. there exists an integer
;; `k` such that n^k = x), otherwise returns #f.
(define (is_simple_power x n)
  (cond
    ;; Negative numbers are not considered simple powers in this context.
    [(or (< x 0) (< n 0)) #f]

    ;; 1 is a power of any n (n^0 = 1).
    [(= x 1) #t]

    ;; Special handling for n = 1: only 1 is a power of 1.
    [(= n 1) #f]

    ;; Special handling for n = 0: only 0 is a positive power of 0.
    [(= n 0) (= x 0)]

    ;; General case: repeatedly divide by n while divisible.
    [else
     (let loop ([current x])
       (cond
         [(= current 1) #t]
         [(zero? (modulo current n))
          (loop (/ current n))]
         [else #f]))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-within (candidate 16 2) #t 0.001)
    (check-within (candidate 143214 16) #f 0.001)
    (check-within (candidate 4 2) #t 0.001)
    (check-within (candidate 9 3) #t 0.001)
    (check-within (candidate 16 4) #t 0.001)
    (check-within (candidate 24 2) #f 0.001)
    (check-within (candidate 128 4) #f 0.001)
    (check-within (candidate 12 6) #f 0.001)
    (check-within (candidate 1 1) #t 0.001)
    (check-within (candidate 1 12) #t 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183910
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 78 (RKT) - HumanEval_78_hex_key
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-within (candidate "AB") 1 0.001)
    (check-within (candidate "1077E") 2 0.001)
    (check-within (candidate "ABED1A33") 4 0.001)
    (check-within (candidate "2020") 2 0.001)
    (check-within (candidate "123456789ABCDEF0") 6 0.001)
    (check-within (candidate "112233445566778899AABBCCDDEEFF00") 12 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2

;; Count how many hexadecimal digits in `num` are prime.
;; Prime hexadecimal digits are: 2, 3, 5, 7, B (11), D (13).

(define (hex_key num)
  ;; Helper predicate: is the character a prime hex digit?
  (define (prime? c)
    (member c '(#\2 #\3 #\5 #\7 #\B #\D)))

  ;; Fold over the string, incrementing the counter when a prime digit
  ;; is encountered.
  (foldl (lambda (c acc)
           (if (prime? c)
               (+ acc 1)
               acc))
         0
         (string->list num)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-within (candidate "AB") 1 0.001)
    (check-within (candidate "1077E") 2 0.001)
    (check-within (candidate "ABED1A33") 4 0.001)
    (check-within (candidate "2020") 2 0.001)
    (check-within (candidate "123456789ABCDEF0") 6 0.001)
    (check-within (candidate "112233445566778899AABBCCDDEEFF00") 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183912
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2

;; Count the number of hexadecimal digits in `num` that are prime
(define (hex_key num)
  ;; List of prime hexadecimal characters
  (define primes '(#\2 #\3 #\5 #\7 #\B #\D))
  ;; Convert the string to a list of characters, map each to 1 if it is
  ;; in `primes` otherwise 0, and sum the results.
  (apply + (map (lambda (c)
                  (if (member c primes) 1 0))
                (string->list num))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-within (candidate "AB") 1 0.001)
    (check-within (candidate "1077E") 2 0.001)
    (check-within (candidate "ABED1A33") 4 0.001)
    (check-within (candidate "2020") 2 0.001)
    (check-within (candidate "123456789ABCDEF0") 6 0.001)
    (check-within (candidate "112233445566778899AABBCCDDEEFF00") 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183912
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2

;; Count how many hexadecimal digits in `num` are prime.
;; Prime hexadecimal digits are 2, 3, 5, 7, B (11), D (13).
(define (hex_key num)
  (define prime-digits '(#\2 #\3 #\5 #\7 #\B #\D))
  (define chars (string->list num))
  (length (filter (lambda (c) (member c prime-digits)) chars)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-within (candidate "AB") 1 0.001)
    (check-within (candidate "1077E") 2 0.001)
    (check-within (candidate "ABED1A33") 4 0.001)
    (check-within (candidate "2020") 2 0.001)
    (check-within (candidate "123456789ABCDEF0") 6 0.001)
    (check-within (candidate "112233445566778899AABBCCDDEEFF00") 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183912
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2

;; Count how many hexadecimal digits in the string `num` are prime.
;; Prime hex digits: 2, 3, 5, 7, B (11), D (13).

(define (hex_key num)
  ;; List of prime hexadecimal characters
  (define primes (list #\2 #\3 #\5 #\7 #\B #\D))

  ;; Sum over each character: 1 if it's a prime digit, 0 otherwise
  (for/sum ([c (in-string num)])
    (if (member c primes) 1 0)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-within (candidate "AB") 1 0.001)
    (check-within (candidate "1077E") 2 0.001)
    (check-within (candidate "ABED1A33") 4 0.001)
    (check-within (candidate "2020") 2 0.001)
    (check-within (candidate "123456789ABCDEF0") 6 0.001)
    (check-within (candidate "112233445566778899AABBCCDDEEFF00") 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183912
STDOUT: (empty)
STDERR: (empty)
--------------------
