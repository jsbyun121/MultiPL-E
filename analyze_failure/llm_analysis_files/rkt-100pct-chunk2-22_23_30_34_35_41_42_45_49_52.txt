As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 22 (RKT) - HumanEval_22_filter_integers
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Filter given list of any rktthon values only for integers
;; >>> (filter_integers (list "a" 3.14 5))
;; (list 5)
;; >>> (filter_integers (list 1 2 3 "abc" #hash() (list )))
;; (list 1 2 3)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_integers))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 4 #hash() (list ) 23.2 9 "adasd")) (list 4 9) 0.001)
    (check-within (candidate (list 3 "c" 3 3 "a" "b")) (list 3 3 3) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Filter given list of any rktthon values only for integers
;; >>> (filter_integers (list "a" 3.14 5))
;; (list 5)
;; >>> (filter_integers (list 1 2 3 "abc" #hash() (list )))
;; (list 1 2 3)

;; Filter given list of any rktthon values only for integers
;; >>> (filter_integers (list "a" 3.14 5))
;; (list 5)
;; >>> (filter_integers (list 1 2 3 "abc" #hash() (list )))
;; (list 1 2 3)
(define (filter_integers values)
  (filter integer? values))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_integers))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 4 #hash() (list ) 23.2 9 "adasd")) (list 4 9) 0.001)
    (check-within (candidate (list 3 "c" 3 3 "a" "b")) (list 3 3 3) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183835
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Filter given list of any rktthon values only for integers
;; >>> (filter_integers (list "a" 3.14 5))
;; (list 5)
;; >>> (filter_integers (list 1 2 3 "abc" #hash() (list )))
;; (list 1 2 3)

;; Filter given list of any rktthon values only for integers
;; >>> (filter_integers (list "a" 3.14 5))
;; (list 5)
;; >>> (filter_integers (list 1 2 3 "abc" #hash() (list )))
;; (list 1 2 3)

(define (filter_integers values)
  (filter integer? values))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_integers))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 4 #hash() (list ) 23.2 9 "adasd")) (list 4 9) 0.001)
    (check-within (candidate (list 3 "c" 3 3 "a" "b")) (list 3 3 3) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183835
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Filter given list of any rktthon values only for integers
;; >>> (filter_integers (list "a" 3.14 5))
;; (list 5)
;; >>> (filter_integers (list 1 2 3 "abc" #hash() (list )))
;; (list 1 2 3)
(define (filter_integers values)
  (filter integer? values))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_integers))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 4 #hash() (list ) 23.2 9 "adasd")) (list 4 9) 0.001)
    (check-within (candidate (list 3 "c" 3 3 "a" "b")) (list 3 3 3) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183835
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Filter given list of any rktthon values only for integers
;; >>> (filter_integers (list "a" 3.14 5))
;; (list 5)
;; >>> (filter_integers (list 1 2 3 "abc" #hash() (list )))
;; (list 1 2 3)
(define (filter_integers values)
  (filter integer? values))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_integers))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 4 #hash() (list ) 23.2 9 "adasd")) (list 4 9) 0.001)
    (check-within (candidate (list 3 "c" 3 3 "a" "b")) (list 3 3 3) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183835
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 23 (RKT) - HumanEval_23_strlen
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Return length of given string
;; >>> (strlen "")
;; 0
;; >>> (strlen "abc")
;; 3

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate strlen))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "x") 1 0.001)
    (check-within (candidate "asdasnakj") 9 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Return length of given string
;; >>> (strlen "")
;; 0
;; >>> (strlen "abc")
;; 3

;; Return length of given string
;; >>> (strlen "")
;; 0
;; >>> (strlen "abc")
;; 3
(define (strlen string)
  (string-length string))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate strlen))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "x") 1 0.001)
    (check-within (candidate "asdasnakj") 9 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183836
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Return length of given string
;; >>> (strlen "")
;; 0
;; >>> (strlen "abc")
;; 3

;; Return length of given string
;; >>> (strlen "")
;; 0
;; >>> (strlen "abc")
;; 3
(define (strlen string)
  (string-length string))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate strlen))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "x") 1 0.001)
    (check-within (candidate "asdasnakj") 9 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183836
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Return length of given string
;; >>> (strlen "")
;; 0
;; >>> (strlen "abc")
;; 3

;; Return length of given string
;; >>> (strlen "")
;; 0
;; >>> (strlen "abc")
;; 3
(define (strlen string)
  (string-length string))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate strlen))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "x") 1 0.001)
    (check-within (candidate "asdasnakj") 9 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183836
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Return length of given string
;; >>> (strlen "")
;; 0
;; >>> (strlen "abc")
;; 3

;; Return length of given string
;; >>> (strlen "")
;; 0
;; >>> (strlen "abc")
;; 3
(define (strlen string)
  (string-length string))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate strlen))
    (check-within (candidate "") 0 0.001)
    (check-within (candidate "x") 1 0.001)
    (check-within (candidate "asdasnakj") 9 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183836
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 30 (RKT) - HumanEval_30_get_positive
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Return only positive numbers in the list.
;; >>> (get_positive (list -1 2 -4 5 6))
;; (list 2 5 6)
;; >>> (get_positive (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; (list 5 3 2 3 9 123 1)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_positive))
    (check-within (candidate (list -1 -2 4 5 6)) (list 4 5 6) 0.001)
    (check-within (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1) 0.001)
    (check-within (candidate (list -1 -2)) (list ) 0.001)
    (check-within (candidate (list )) (list ) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Return only positive numbers in the list.
;; >>> (get_positive (list -1 2 -4 5 6))
;; (list 2 5 6)
;; >>> (get_positive (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; (list 5 3 2 3 9 123 1)

;; Return only positive numbers in the list.
;; >>> (get_positive (list -1 2 -4 5 6))
;; (list 2 5 6)
;; >>> (get_positive (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; (list 5 3 2 3 9 123 1)
(define (get_positive l)
  (filter positive? l))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_positive))
    (check-within (candidate (list -1 -2 4 5 6)) (list 4 5 6) 0.001)
    (check-within (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1) 0.001)
    (check-within (candidate (list -1 -2)) (list ) 0.001)
    (check-within (candidate (list )) (list ) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183856
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Return only positive numbers in the list.
;; >>> (get_positive (list -1 2 -4 5 6))
;; (list 2 5 6)
;; >>> (get_positive (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; (list 5 3 2 3 9 123 1)
(define (get_positive l)
  (cond
    [(null? l) '()]
    [(positive? (car l))
     (cons (car l) (get_positive (cdr l)))]
    [else
     (get_positive (cdr l))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_positive))
    (check-within (candidate (list -1 -2 4 5 6)) (list 4 5 6) 0.001)
    (check-within (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1) 0.001)
    (check-within (candidate (list -1 -2)) (list ) 0.001)
    (check-within (candidate (list )) (list ) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183856
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Return only positive numbers in the list.
;; >>> (get_positive (list -1 2 -4 5 6))
;; (list 2 5 6)
;; >>> (get_positive (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; (list 5 3 2 3 9 123 1)
(define (get_positive l)
  (filter (lambda (x) (> x 0)) l))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_positive))
    (check-within (candidate (list -1 -2 4 5 6)) (list 4 5 6) 0.001)
    (check-within (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1) 0.001)
    (check-within (candidate (list -1 -2)) (list ) 0.001)
    (check-within (candidate (list )) (list ) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183856
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Return only positive numbers in the list.
;; >>> (get_positive (list -1 2 -4 5 6))
;; (list 2 5 6)
;; >>> (get_positive (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; (list 5 3 2 3 9 123 1)

;; Return only positive numbers in the list.
;; >>> (get_positive (list -1 2 -4 5 6))
;; (list 2 5 6)
;; >>> (get_positive (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; (list 5 3 2 3 9 123 1)
(define (get_positive l)
  (filter (lambda (x) (> x 0)) l))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_positive))
    (check-within (candidate (list -1 -2 4 5 6)) (list 4 5 6) 0.001)
    (check-within (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1) 0.001)
    (check-within (candidate (list -1 -2)) (list ) 0.001)
    (check-within (candidate (list )) (list ) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183856
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 34 (RKT) - HumanEval_34_unique
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Return sorted unique elements in a list
;; >>> (unique (list 5 3 5 2 3 3 9 0 123))
;; (list 0 2 3 5 9 123)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate unique))
    (check-within (candidate (list 5 3 5 2 3 3 9 0 123)) (list 0 2 3 5 9 123) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Return sorted unique elements in a list
;; >>> (unique (list 5 3 5 2 3 3 9 0 123))
;; (list 0 2 3 5 9 123)
;; Return sorted unique elements in a list
;; >>> (unique (list 5 3 5 2 3 3 9 0 123))
;; (list 0 2 3 5 9 123)
(define (unique l)
  (sort (remove-duplicates l) <))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate unique))
    (check-within (candidate (list 5 3 5 2 3 3 9 0 123)) (list 0 2 3 5 9 123) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183859
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Return sorted unique elements in a list
;; >>> (unique (list 5 3 5 2 3 3 9 0 123))
;; (list 0 2 3 5 9 123)

;; Return sorted unique elements in a list
;; >>> (unique (list 5 3 5 2 3 3 9 0 123))
;; (list 0 2 3 5 9 123)
(define (unique l)
  (sort (remove-duplicates l) <))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate unique))
    (check-within (candidate (list 5 3 5 2 3 3 9 0 123)) (list 0 2 3 5 9 123) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183859
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Return sorted unique elements in a list
;; >>> (unique (list 5 3 5 2 3 3 9 0 123))
;; (list 0 2 3 5 9 123)

;; Return sorted unique elements in a list
;; >>> (unique (list 5 3 5 2 3 3 9 0 123))
;; (list 0 2 3 5 9 123)
(define (unique l)
  (sort (remove-duplicates l) <))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate unique))
    (check-within (candidate (list 5 3 5 2 3 3 9 0 123)) (list 0 2 3 5 9 123) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183859
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Return sorted unique elements in a list
;; >>> (unique (list 5 3 5 2 3 3 9 0 123))
;; (list 0 2 3 5 9 123)

;; Return sorted unique elements in a list
;; >>> (unique (list 5 3 5 2 3 3 9 0 123))
;; (list 0 2 3 5 9 123)
(define (unique l)
  (sort (remove-duplicates l) <))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate unique))
    (check-within (candidate (list 5 3 5 2 3 3 9 0 123)) (list 0 2 3 5 9 123) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183859
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 35 (RKT) - HumanEval_35_max_element
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Return maximum element in the list.
;; >>> (max_element (list 1 2 3))
;; 3
;; >>> (max_element (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; 123

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_element))
    (check-within (candidate (list 1 2 3)) 3 0.001)
    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 124 1 -10)) 124 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Return maximum element in the list.
;; >>> (max_element (list 1 2 3))
;; 3
;; >>> (max_element (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; 123

;; Return maximum element in the list.
;; >>> (max_element (list 1 2 3))
;; 3
;; >>> (max_element (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; 123
(define (max_element l)
  (cond
    [(null? l)          ; Empty list: no maximum
     (error "max_element: empty list has no maximum")]
    [(null? (cdr l))    ; Only one element left
     (car l)]
    [else
     (let ([rest-max (max_element (cdr l))])
       (if (> (car l) rest-max)
           (car l)
           rest-max))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_element))
    (check-within (candidate (list 1 2 3)) 3 0.001)
    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 124 1 -10)) 124 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183860
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Return maximum element in the list.
;; >>> (max_element (list 1 2 3))
;; 3
;; >>> (max_element (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; 123

;; Return maximum element in the list.
;; >>> (max_element (list 1 2 3))
;; 3
;; >>> (max_element (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; 123

(define (max_element l)
  (cond
    [(null? l)
     (error 'max_element "empty list")]
    [else
     (foldl max (first l) l)]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_element))
    (check-within (candidate (list 1 2 3)) 3 0.001)
    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 124 1 -10)) 124 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183860
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Return maximum element in the list.
;; >>> (max_element (list 1 2 3))
;; 3
;; >>> (max_element (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; 123

;; Return maximum element in the list.
;; >>> (max_element (list 1 2 3))
;; 3
;; >>> (max_element (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; 123
(define (max_element l)
  (cond
    [(empty? l) (error 'max_element "empty list has no maximum")]
    [(empty? (cdr l)) (car l)]          ; only one element left
    [else
     (let ([rest-max (max_element (cdr l))])
       (if (> (car l) rest-max)
           (car l)
           rest-max))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_element))
    (check-within (candidate (list 1 2 3)) 3 0.001)
    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 124 1 -10)) 124 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183860
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Return maximum element in the list.
;; >>> (max_element (list 1 2 3))
;; 3
;; >>> (max_element (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; 123

;; Return maximum element in the list.
;; >>> (max_element (list 1 2 3))
;; 3
;; >>> (max_element (list 5 3 -5 2 -3 3 9 0 123 1 -10))
;; 123
(define (max_element l)
  (cond
    [(null? l)
     (error "max_element: empty list")]
    [else
     (foldl max (car l) (cdr l))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_element))
    (check-within (candidate (list 1 2 3)) 3 0.001)
    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 124 1 -10)) 124 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183860
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 41 (RKT) - HumanEval_41_car_race_collision
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-within (candidate 2) 4 0.001)
    (check-within (candidate 3) 9 0.001)
    (check-within (candidate 4) 16 0.001)
    (check-within (candidate 8) 64 0.001)
    (check-within (candidate 10) 100 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.
(define (car_race_collision n)
  (* n n))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-within (candidate 2) 4 0.001)
    (check-within (candidate 3) 9 0.001)
    (check-within (candidate 4) 16 0.001)
    (check-within (candidate 8) 64 0.001)
    (check-within (candidate 10) 100 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183865
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right; simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.
(define (car_race_collision n)
  ;; Each left‑to‑right car will meet every right‑to‑left car exactly once.
  (* n n))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-within (candidate 2) 4 0.001)
    (check-within (candidate 3) 9 0.001)
    (check-within (candidate 4) 16 0.001)
    (check-within (candidate 8) 64 0.001)
    (check-within (candidate 10) 100 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183865
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right; simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.
(define (car_race_collision n)
  ;; Each left‑to‑right car collides with every right‑to‑left car once.
  (* n n))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-within (candidate 2) 4 0.001)
    (check-within (candidate 3) 9 0.001)
    (check-within (candidate 4) 16 0.001)
    (check-within (candidate 8) 64 0.001)
    (check-within (candidate 10) 100 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183865
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.

;; The number of collisions is simply the product of the two groups.
;; Each left‑to‑right car will meet each right‑to‑left car exactly once,
;; so the total number of collisions is n * n.
(define (car_race_collision n)
  (* n n))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-within (candidate 2) 4 0.001)
    (check-within (candidate 3) 9 0.001)
    (check-within (candidate 4) 16 0.001)
    (check-within (candidate 8) 64 0.001)
    (check-within (candidate 10) 100 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183865
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 42 (RKT) - HumanEval_42_incr_list
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Return list with elements incremented by 1.
;; >>> (incr_list (list 1 2 3))
;; (list 2 3 4)
;; >>> (incr_list (list 5 3 5 2 3 3 9 0 123))
;; (list 6 4 6 3 4 4 10 1 124)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate incr_list))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 3 2 1)) (list 4 3 2) 0.001)
    (check-within (candidate (list 5 2 5 2 3 3 9 0 123)) (list 6 3 6 3 4 4 10 1 124) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Return list with elements incremented by 1.
;; >>> (incr_list (list 1 2 3))
;; (list 2 3 4)
;; >>> (incr_list (list 5 3 5 2 3 3 9 0 123))
;; (list 6 4 6 3 4 4 10 1 124)
(define (incr_list l)
  (map (lambda (x) (+ x 1)) l))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate incr_list))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 3 2 1)) (list 4 3 2) 0.001)
    (check-within (candidate (list 5 2 5 2 3 3 9 0 123)) (list 6 3 6 3 4 4 10 1 124) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183866
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Return list with elements incremented by 1.
;; >>> (incr_list (list 1 2 3))
;; (list 2 3 4)
;; >>> (incr_list (list 5 3 5 2 3 3 9 0 123))
;; (list 6 4 6 3 4 4 10 1 124)

;; Return list with elements incremented by 1.
;; >>> (incr_list (list 1 2 3))
;; (list 2 3 4)
;; >>> (incr_list (list 5 3 5 2 3 3 9 0 123))
;; (list 6 4 6 3 4 4 10 1 124)
(define (incr_list l)
  (map add1 l))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate incr_list))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 3 2 1)) (list 4 3 2) 0.001)
    (check-within (candidate (list 5 2 5 2 3 3 9 0 123)) (list 6 3 6 3 4 4 10 1 124) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183866
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Return list with elements incremented by 1.
;; >>> (incr_list (list 1 2 3))
;; (list 2 3 4)
;; >>> (incr_list (list 5 3 5 2 3 3 9 0 123))
;; (list 6 4 6 3 4 4 10 1 124)

;; Return list with elements incremented by 1.
;; >>> (incr_list (list 1 2 3))
;; (list 2 3 4)
;; >>> (incr_list (list 5 3 5 2 3 3 9 0 123))
;; (list 6 4 6 3 4 4 10 1 124)
(define (incr_list l)
  (map (lambda (x) (+ x 1)) l))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate incr_list))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 3 2 1)) (list 4 3 2) 0.001)
    (check-within (candidate (list 5 2 5 2 3 3 9 0 123)) (list 6 3 6 3 4 4 10 1 124) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183866
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Return list with elements incremented by 1.
;; >>> (incr_list (list 1 2 3))
;; (list 2 3 4)
;; >>> (incr_list (list 5 3 5 2 3 3 9 0 123))
;; (list 6 4 6 3 4 4 10 1 124)

;; Return list with elements incremented by 1.
;; >>> (incr_list (list 1 2 3))
;; (list 2 3 4)
;; >>> (incr_list (list 5 3 5 2 3 3 9 0 123))
;; (list 6 4 6 3 4 4 10 1 124)
(define (incr_list l)
  (map add1 l))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate incr_list))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 3 2 1)) (list 4 3 2) 0.001)
    (check-within (candidate (list 5 2 5 2 3 3 9 0 123)) (list 6 3 6 3 4 4 10 1 124) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183866
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 45 (RKT) - HumanEval_45_triangle_area
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given length of a side and high return area for a triangle.
;; >>> (triangle_area 5 3)
;; 7.5

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate triangle_area))
    (check-within (candidate 5 3) 7.5 0.001)
    (check-within (candidate 2 2) 2.0 0.001)
    (check-within (candidate 10 8) 40.0 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given length of a side and high return area for a triangle.
;; >>> (triangle_area 5 3)
;; 7.5

;; Given length of a side and height return the area for a triangle.
;; >>> (triangle_area 5 3)
;; 7.5
(define (triangle_area a h)
  (* a h 0.5))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate triangle_area))
    (check-within (candidate 5 3) 7.5 0.001)
    (check-within (candidate 2 2) 2.0 0.001)
    (check-within (candidate 10 8) 40.0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183868
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given length of a side and high return area for a triangle.
;; >>> (triangle_area 5 3)
;; 7.5
(define (triangle_area a h)
  (* a h 0.5))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate triangle_area))
    (check-within (candidate 5 3) 7.5 0.001)
    (check-within (candidate 2 2) 2.0 0.001)
    (check-within (candidate 10 8) 40.0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183868
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given length of a side and high return area for a triangle.
;; >>> (triangle_area 5 3)
;; 7.5
(define (triangle_area a h)
  (* 0.5 a h))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate triangle_area))
    (check-within (candidate 5 3) 7.5 0.001)
    (check-within (candidate 2 2) 2.0 0.001)
    (check-within (candidate 10 8) 40.0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183868
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given length of a side and high return area for a triangle.
;; >>> (triangle_area 5 3)
;; 7.5

;; Given length of a side and height return area for a triangle.
;; >>> (triangle_area 5 3)
;; 7.5
(define (triangle_area a h)
  (/ (* a h) 2))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate triangle_area))
    (check-within (candidate 5 3) 7.5 0.001)
    (check-within (candidate 2 2) 2.0 0.001)
    (check-within (candidate 10 8) 40.0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183868
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 49 (RKT) - HumanEval_49_modp
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-within (candidate 3 5) 3 0.001)
    (check-within (candidate 1101 101) 2 0.001)
    (check-within (candidate 0 101) 1 0.001)
    (check-within (candidate 3 11) 8 0.001)
    (check-within (candidate 100 101) 1 0.001)
    (check-within (candidate 30 5) 4 0.001)
    (check-within (candidate 31 5) 3 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1

(define (modp n p)
  ;; Fast modular exponentiation: compute 2^n mod p.
  (define (powmod base exp mod)
    (let loop ([b base] [e exp] [acc 1])
      (cond
        [(zero? e) acc]                                   ; finished
        [(odd? e)
         ;; multiply by base when exponent bit is 1
         (loop (modulo (* b b) mod)          ; square base
               (quotient e 2)                 ; shift exponent right
               (modulo (* acc b) mod))]       ; accumulate result
        [else
         (loop (modulo (* b b) mod)
               (quotient e 2)
               acc)])))
  (powmod 2 n p))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-within (candidate 3 5) 3 0.001)
    (check-within (candidate 1101 101) 2 0.001)
    (check-within (candidate 0 101) 1 0.001)
    (check-within (candidate 3 11) 8 0.001)
    (check-within (candidate 100 101) 1 0.001)
    (check-within (candidate 30 5) 4 0.001)
    (check-within (candidate 31 5) 3 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183872
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1
(define (modp n p)
  ;; Helper: modular exponentiation by squaring
  (define (powmod base exp mod)
    (cond [(zero? exp) 1]
          [(even? exp)
           (let ([half (powmod base (quotient exp 2) mod)])
             (modulo (* half half) mod))]
          [else
           (modulo (* base (powmod base (- exp 1) mod)) mod)]))
  ;; Compute 2^n mod p
  (modulo (powmod 2 n p) p))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-within (candidate 3 5) 3 0.001)
    (check-within (candidate 1101 101) 2 0.001)
    (check-within (candidate 0 101) 1 0.001)
    (check-within (candidate 3 11) 8 0.001)
    (check-within (candidate 100 101) 1 0.001)
    (check-within (candidate 30 5) 4 0.001)
    (check-within (candidate 31 5) 3 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183872
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1
(define (modp n p)
  ;; Fast modular exponentiation: compute (2^n) mod p.
  (let loop ((exp n)          ; remaining exponent
             (result 1)       ; accumulated result
             (base (modulo 2 p))) ; current base (2 mod p)
    (cond
      [(zero? exp) result]                                 ; done
      [(odd? exp)   ; if exp is odd, multiply result by base
       (loop (quotient exp 2)
             (modulo (* result base) p)
             (modulo (* base base) p))]
      [else
       (loop (quotient exp 2)
             result
             (modulo (* base base) p))])))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-within (candidate 3 5) 3 0.001)
    (check-within (candidate 1101 101) 2 0.001)
    (check-within (candidate 0 101) 1 0.001)
    (check-within (candidate 3 11) 8 0.001)
    (check-within (candidate 100 101) 1 0.001)
    (check-within (candidate 30 5) 4 0.001)
    (check-within (candidate 31 5) 3 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183872
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1
(define (modp n p)
  ;; Helper: binary exponentiation with modulo
  (define (pow-iter base exp acc)
    (cond [(zero? exp) acc]
          [(odd? exp)
           (pow-iter (modulo (* base base) p)
                     (arithmetic-shift exp -1)
                     (modulo (* acc base) p))]
          [else
           (pow-iter (modulo (* base base) p)
                     (arithmetic-shift exp -1)
                     acc)]))
  (pow-iter 2 n 1))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-within (candidate 3 5) 3 0.001)
    (check-within (candidate 1101 101) 2 0.001)
    (check-within (candidate 0 101) 1 0.001)
    (check-within (candidate 3 11) 8 0.001)
    (check-within (candidate 100 101) 1 0.001)
    (check-within (candidate 30 5) 4 0.001)
    (check-within (candidate 31 5) 3 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183872
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 52 (RKT) - HumanEval_52_below_threshold
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Return #t if all numbers in the list l are below threshold t.
;; >>> (below_threshold (list 1 2 4 10) 100)
;; #t
;; >>> (below_threshold (list 1 20 4 10) 5)
;; #f

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate below_threshold))
    (check-within (candidate (list 1 2 4 10) 100) #t 0.001)
    (check-within (candidate (list 1 20 4 10) 5) #f 0.001)
    (check-within (candidate (list 1 20 4 10) 21) #t 0.001)
    (check-within (candidate (list 1 20 4 10) 22) #t 0.001)
    (check-within (candidate (list 1 8 4 10) 11) #t 0.001)
    (check-within (candidate (list 1 8 4 10) 10) #f 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Return #t if all numbers in the list l are below threshold t.
;; >>> (below_threshold (list 1 2 4 10) 100)
;; #t
;; >>> (below_threshold (list 1 20 4 10) 5)
;; #f

;; Return #t if all numbers in the list l are below threshold t.
;; >>> (below_threshold (list 1 2 4 10) 100)
;; #t
;; >>> (below_threshold (list 1 20 4 10) 5)
;; #f
(define (below_threshold l t)
  (andmap (lambda (x) (< x t)) l))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate below_threshold))
    (check-within (candidate (list 1 2 4 10) 100) #t 0.001)
    (check-within (candidate (list 1 20 4 10) 5) #f 0.001)
    (check-within (candidate (list 1 20 4 10) 21) #t 0.001)
    (check-within (candidate (list 1 20 4 10) 22) #t 0.001)
    (check-within (candidate (list 1 8 4 10) 11) #t 0.001)
    (check-within (candidate (list 1 8 4 10) 10) #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183874
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Return #t if all numbers in the list l are below threshold t.
;; >>> (below_threshold (list 1 2 4 10) 100)
;; #t
;; >>> (below_threshold (list 1 20 4 10) 5)
;; #f

;; Return #t if all numbers in the list l are below threshold t.
;; >>> (below_threshold (list 1 2 4 10) 100)
;; #t
;; >>> (below_threshold (list 1 20 4 10) 5)
;; #f
(define (below_threshold l t)
  (cond
    [(empty? l) #t]
    [else (and (< (first l) t)
               (below_threshold (rest l) t))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate below_threshold))
    (check-within (candidate (list 1 2 4 10) 100) #t 0.001)
    (check-within (candidate (list 1 20 4 10) 5) #f 0.001)
    (check-within (candidate (list 1 20 4 10) 21) #t 0.001)
    (check-within (candidate (list 1 20 4 10) 22) #t 0.001)
    (check-within (candidate (list 1 8 4 10) 11) #t 0.001)
    (check-within (candidate (list 1 8 4 10) 10) #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183874
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Return #t if all numbers in the list l are below threshold t.
;; >>> (below_threshold (list 1 2 4 10) 100)
;; #t
;; >>> (below_threshold (list 1 20 4 10) 5)
;; #f

;; Return #t if all numbers in the list l are below threshold t.
;; >>> (below_threshold (list 1 2 4 10) 100)
;; #t
;; >>> (below_threshold (list 1 20 4 10) 5)
;; #f
(define (below_threshold l t)
  (cond
    [(empty? l) #t]                                 ; empty list → true
    [else (and (< (first l) t) (below_threshold (rest l) t))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate below_threshold))
    (check-within (candidate (list 1 2 4 10) 100) #t 0.001)
    (check-within (candidate (list 1 20 4 10) 5) #f 0.001)
    (check-within (candidate (list 1 20 4 10) 21) #t 0.001)
    (check-within (candidate (list 1 20 4 10) 22) #t 0.001)
    (check-within (candidate (list 1 8 4 10) 11) #t 0.001)
    (check-within (candidate (list 1 8 4 10) 10) #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183874
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Return #t if all numbers in the list l are below threshold t.
;; >>> (below_threshold (list 1 2 4 10) 100)
;; #t
;; >>> (below_threshold (list 1 20 4 10) 5)
;; #f

;; Return #t if all numbers in the list l are below threshold t.
;; >>> (below_threshold (list 1 2 4 10) 100)
;; #t
;; >>> (below_threshold (list 1 20 4 10) 5)
;; #f
(define (below_threshold l t)
  (andmap (lambda (x) (< x t)) l))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate below_threshold))
    (check-within (candidate (list 1 2 4 10) 100) #t 0.001)
    (check-within (candidate (list 1 20 4 10) 5) #f 0.001)
    (check-within (candidate (list 1 20 4 10) 21) #t 0.001)
    (check-within (candidate (list 1 20 4 10) 22) #t 0.001)
    (check-within (candidate (list 1 8 4 10) 11) #t 0.001)
    (check-within (candidate (list 1 8 4 10) 10) #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183874
STDOUT: (empty)
STDERR: (empty)
--------------------
