As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 36 (LUA) - HumanEval_36_fizz_buzz
================================================================================

PROMPT:
----------------------------------------
-- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
-- >>> fizz_buzz(50)
-- 0
-- >>> fizz_buzz(78)
-- 2
-- >>> fizz_buzz(79)
-- 3

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = fizz_buzz
    lu.assertEquals(candidate(50), 0)
    lu.assertEquals(candidate(78), 2)
    lu.assertEquals(candidate(79), 3)
    lu.assertEquals(candidate(100), 3)
    lu.assertEquals(candidate(200), 6)
    lu.assertEquals(candidate(4000), 192)
    lu.assertEquals(candidate(10000), 639)
    lu.assertEquals(candidate(100000), 8026)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
-- >>> fizz_buzz(50)
-- 0
-- >>> fizz_buzz(78)
-- 2
-- >>> fizz_buzz(79)
-- 3
local function fizz_buzz(n)
    local count = 0
    for i = 1, n - 1 do
        if i % 11 == 0 or i % 13 == 0 then
            local s = tostring(i)
            for j = 1, #s do
                if s:sub(j, j) == '7' then
                    count = count + 1
                end
            end
        end
    end
    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = fizz_buzz
    lu.assertEquals(candidate(50), 0)
    lu.assertEquals(candidate(78), 2)
    lu.assertEquals(candidate(79), 3)
    lu.assertEquals(candidate(100), 3)
    lu.assertEquals(candidate(200), 6)
    lu.assertEquals(candidate(4000), 192)
    lu.assertEquals(candidate(10000), 639)
    lu.assertEquals(candidate(100000), 8026)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154468
STDOUT:
.
Ran 1 tests in 0.066 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
-- >>> fizz_buzz(50)
-- 0
-- >>> fizz_buzz(78)
-- 2
-- >>> fizz_buzz(79)
-- 3
-- Return the number of times the digit 7 appears in integers less than n
-- which are divisible by 11 or 13.
-- >>> fizz_buzz(50)
-- 0
-- >>> fizz_buzz(78)
-- 2
-- >>> fizz_buzz(79)
-- 3
local function fizz_buzz(n)
    if n <= 1 then
        return 0
    end

    local count = 0
    for i = 1, n - 1 do
        if i % 11 == 0 or i % 13 == 0 then
            local s = tostring(i)
            for j = 1, #s do
                if s:sub(j, j) == "7" then
                    count = count + 1
                end
            end
        end
    end
    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = fizz_buzz
    lu.assertEquals(candidate(50), 0)
    lu.assertEquals(candidate(78), 2)
    lu.assertEquals(candidate(79), 3)
    lu.assertEquals(candidate(100), 3)
    lu.assertEquals(candidate(200), 6)
    lu.assertEquals(candidate(4000), 192)
    lu.assertEquals(candidate(10000), 639)
    lu.assertEquals(candidate(100000), 8026)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154468
STDOUT:
.
Ran 1 tests in 0.064 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
-- >>> fizz_buzz(50)
-- 0
-- >>> fizz_buzz(78)
-- 2
-- >>> fizz_buzz(79)
-- 3
local function fizz_buzz(n)
  local count = 0
  if n <= 1 then return 0 end
  for i = 1, n - 1 do
    if i % 11 == 0 or i % 13 == 0 then
      local s = tostring(i)
      for j = 1, #s do
        if s:sub(j, j) == '7' then
          count = count + 1
        end
      end
    end
  end
  return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = fizz_buzz
    lu.assertEquals(candidate(50), 0)
    lu.assertEquals(candidate(78), 2)
    lu.assertEquals(candidate(79), 3)
    lu.assertEquals(candidate(100), 3)
    lu.assertEquals(candidate(200), 6)
    lu.assertEquals(candidate(4000), 192)
    lu.assertEquals(candidate(10000), 639)
    lu.assertEquals(candidate(100000), 8026)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154468
STDOUT:
.
Ran 1 tests in 0.067 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
-- >>> fizz_buzz(50)
-- 0
-- >>> fizz_buzz(78)
-- 2
-- >>> fizz_buzz(79)
-- 3
-- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
-- >>> fizz_buzz(50)
-- 0
-- >>> fizz_buzz(78)
-- 2
-- >>> fizz_buzz(79)
-- 3
local function fizz_buzz(n)
    local count = 0
    for i = 1, n - 1 do
        if i % 11 == 0 or i % 13 == 0 then
            local s = tostring(i)
            for j = 1, #s do
                if s:sub(j, j) == '7' then
                    count = count + 1
                end
            end
        end
    end
    return count
end
lu = require('luaunit')

function test_humaneval()
local candidate = fizz_buzz
    lu.assertEquals(candidate(50), 0)
    lu.assertEquals(candidate(78), 2)
    lu.assertEquals(candidate(79), 3)
    lu.assertEquals(candidate(100), 3)
    lu.assertEquals(candidate(200), 6)
    lu.assertEquals(candidate(4000), 192)
    lu.assertEquals(candidate(10000), 639)
    lu.assertEquals(candidate(100000), 8026)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154468
STDOUT:
.
Ran 1 tests in 0.064 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 39 (LUA) - HumanEval_39_prime_fib
================================================================================

PROMPT:
----------------------------------------
-- prime_fib returns n-th number that is a Fibonacci number and it's also prime.
-- >>> prime_fib(1)
-- 2
-- >>> prime_fib(2)
-- 3
-- >>> prime_fib(3)
-- 5
-- >>> prime_fib(4)
-- 13
-- >>> prime_fib(5)
-- 89

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = prime_fib
    lu.assertEquals(candidate(1), 2)
    lu.assertEquals(candidate(2), 3)
    lu.assertEquals(candidate(3), 5)
    lu.assertEquals(candidate(4), 13)
    lu.assertEquals(candidate(5), 89)
    lu.assertEquals(candidate(6), 233)
    lu.assertEquals(candidate(7), 1597)
    lu.assertEquals(candidate(8), 28657)
    lu.assertEquals(candidate(9), 514229)
    lu.assertEquals(candidate(10), 433494437)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- prime_fib returns n-th number that is a Fibonacci number and it's also prime.
-- >>> prime_fib(1)
-- 2
-- >>> prime_fib(2)
-- 3
-- >>> prime_fib(3)
-- 5
-- >>> prime_fib(4)
-- 13
-- >>> prime_fib(5)
-- 89
-- Returns the n‑th Fibonacci number that is also prime.
-- Example:
--   prime_fib(1) → 2
--   prime_fib(2) → 3
--   prime_fib(3) → 5
--   prime_fib(4) → 13
--   prime_fib(5) → 89

local function is_prime(num)
    if num < 2 then return false end
    if num == 2 then return true end
    if num % 2 == 0 then return false end
    local limit = math.floor(math.sqrt(num))
    for i = 3, limit, 2 do
        if num % i == 0 then
            return false
        end
    end
    return true
end

local function prime_fib(n)
    assert(type(n) == "number" and n > 0, "n must be a positive integer")
    local count = 0
    local a, b = 1, 1   -- Fibonacci seeds (1, 1)
    while true do
        local next = a + b
        a, b = b, next
        if is_prime(next) then
            count = count + 1
            if count == n then
                return next
            end
        end
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = prime_fib
    lu.assertEquals(candidate(1), 2)
    lu.assertEquals(candidate(2), 3)
    lu.assertEquals(candidate(3), 5)
    lu.assertEquals(candidate(4), 13)
    lu.assertEquals(candidate(5), 89)
    lu.assertEquals(candidate(6), 233)
    lu.assertEquals(candidate(7), 1597)
    lu.assertEquals(candidate(8), 28657)
    lu.assertEquals(candidate(9), 514229)
    lu.assertEquals(candidate(10), 433494437)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154468
STDOUT:
.
Ran 1 tests in 0.003 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- prime_fib returns n-th number that is a Fibonacci number and it's also prime.
-- >>> prime_fib(1)
-- 2
-- >>> prime_fib(2)
-- 3
-- >>> prime_fib(3)
-- 5
-- >>> prime_fib(4)
-- 13
-- >>> prime_fib(5)
-- 89
-- Helper function to test primality
local function is_prime(num)
    if num < 2 then return false end
    if num == 2 or num == 3 then return true end
    if num % 2 == 0 then return false end

    local limit = math.floor(math.sqrt(num))
    for i = 3, limit, 2 do
        if num % i == 0 then
            return false
        end
    end
    return true
end

-- Returns the n‑th Fibonacci number that is also prime
local function prime_fib(n)
    local count = 0
    local a, b = 0, 1  -- Starting Fibonacci numbers

    while true do
        local c = a + b   -- Next Fibonacci number
        a, b = b, c

        if is_prime(c) then
            count = count + 1
            if count == n then
                return c
            end
        end
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = prime_fib
    lu.assertEquals(candidate(1), 2)
    lu.assertEquals(candidate(2), 3)
    lu.assertEquals(candidate(3), 5)
    lu.assertEquals(candidate(4), 13)
    lu.assertEquals(candidate(5), 89)
    lu.assertEquals(candidate(6), 233)
    lu.assertEquals(candidate(7), 1597)
    lu.assertEquals(candidate(8), 28657)
    lu.assertEquals(candidate(9), 514229)
    lu.assertEquals(candidate(10), 433494437)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154468
STDOUT:
.
Ran 1 tests in 0.004 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- prime_fib returns n-th number that is a Fibonacci number and it's also prime.
-- >>> prime_fib(1)
-- 2
-- >>> prime_fib(2)
-- 3
-- >>> prime_fib(3)
-- 5
-- >>> prime_fib(4)
-- 13
-- >>> prime_fib(5)
-- 89
-- Return the n‑th Fibonacci number that is also prime.
-- Example:
--   prime_fib(1) → 2
--   prime_fib(2) → 3
--   prime_fib(3) → 5
--   prime_fib(4) → 13
--   prime_fib(5) → 89
local function prime_fib(n)
  if n < 1 then
    error("n must be a positive integer")
  end

  -- Simple primality test (suitable for the small values we encounter here).
  local function is_prime(num)
    if num < 2 then return false end
    if num == 2 or num == 3 then return true end
    if num % 2 == 0 then return false end
    local limit = math.floor(math.sqrt(num))
    for i = 3, limit, 2 do
      if num % i == 0 then
        return false
      end
    end
    return true
  end

  local count = 0
  local a, b = 1, 1  -- F1, F2

  while true do
    local next = a + b
    a, b = b, next

    if is_prime(next) then
      count = count + 1
      if count == n then
        return next
      end
    end
  end
end
lu = require('luaunit')

function test_humaneval()
local candidate = prime_fib
    lu.assertEquals(candidate(1), 2)
    lu.assertEquals(candidate(2), 3)
    lu.assertEquals(candidate(3), 5)
    lu.assertEquals(candidate(4), 13)
    lu.assertEquals(candidate(5), 89)
    lu.assertEquals(candidate(6), 233)
    lu.assertEquals(candidate(7), 1597)
    lu.assertEquals(candidate(8), 28657)
    lu.assertEquals(candidate(9), 514229)
    lu.assertEquals(candidate(10), 433494437)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154468
STDOUT:
.
Ran 1 tests in 0.004 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- prime_fib returns n-th number that is a Fibonacci number and it's also prime.
-- >>> prime_fib(1)
-- 2
-- >>> prime_fib(2)
-- 3
-- >>> prime_fib(3)
-- 5
-- >>> prime_fib(4)
-- 13
-- >>> prime_fib(5)
-- 89
-- Returns the n‑th Fibonacci number that is also prime.
-- Example:
--   prime_fib(1) → 2
--   prime_fib(2) → 3
--   prime_fib(3) → 5
--   prime_fib(4) → 13
--   prime_fib(5) → 89

-- Simple primality test (trial division)
local function is_prime(num)
    if num < 2 then return false end
    if num % 2 == 0 then return num == 2 end
    local i = 3
    while i * i <= num do
        if num % i == 0 then return false end
        i = i + 2
    end
    return true
end

local function prime_fib(n)
    if n <= 0 then
        error("n must be a positive integer")
    end

    local count = 0
    local a, b = 0, 1   -- start with F0 = 0, F1 = 1

    while count < n do
        a, b = b, a + b  -- generate next Fibonacci number
        if is_prime(a) then
            count = count + 1
            if count == n then
                return a
            end
        end
    end
end

-- Example usage:
-- print(prime_fib(5))  -- prints 89
lu = require('luaunit')

function test_humaneval()
local candidate = prime_fib
    lu.assertEquals(candidate(1), 2)
    lu.assertEquals(candidate(2), 3)
    lu.assertEquals(candidate(3), 5)
    lu.assertEquals(candidate(4), 13)
    lu.assertEquals(candidate(5), 89)
    lu.assertEquals(candidate(6), 233)
    lu.assertEquals(candidate(7), 1597)
    lu.assertEquals(candidate(8), 28657)
    lu.assertEquals(candidate(9), 514229)
    lu.assertEquals(candidate(10), 433494437)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154468
STDOUT:
.
Ran 1 tests in 0.005 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 40 (LUA) - HumanEval_40_triples_sum_to_zero
================================================================================

PROMPT:
----------------------------------------
-- triples_sum_to_zero takes a table of integers as an input.
-- it returns true if there are three distinct elements in the table that
-- sum to zero, and false otherwise.
-- >>> triples_sum_to_zero({1, 3, 5, 0})
-- false
-- >>> triples_sum_to_zero({1, 3, -2, 1})
-- true
-- >>> triples_sum_to_zero({1, 2, 3, 7})
-- false
-- >>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})
-- true
-- >>> triples_sum_to_zero({1})
-- false

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = triples_sum_to_zero
    lu.assertEquals(candidate({1, 3, 5, 0}), false)
    lu.assertEquals(candidate({1, 3, 5, -1}), false)
    lu.assertEquals(candidate({1, 3, -2, 1}), true)
    lu.assertEquals(candidate({1, 2, 3, 7}), false)
    lu.assertEquals(candidate({1, 2, 5, 7}), false)
    lu.assertEquals(candidate({2, 4, -5, 3, 9, 7}), true)
    lu.assertEquals(candidate({1}), false)
    lu.assertEquals(candidate({1, 3, 5, -100}), false)
    lu.assertEquals(candidate({100, 3, 5, -100}), false)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- triples_sum_to_zero takes a table of integers as an input.
-- it returns true if there are three distinct elements in the table that
-- sum to zero, and false otherwise.
-- >>> triples_sum_to_zero({1, 3, 5, 0})
-- false
-- >>> triples_sum_to_zero({1, 3, -2, 1})
-- true
-- >>> triples_sum_to_zero({1, 2, 3, 7})
-- false
-- >>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})
-- true
-- >>> triples_sum_to_zero({1})
-- false
-- Return true if there exist three distinct elements in table `l` that sum to zero.
-- Otherwise return false.
local function triples_sum_to_zero(l)
    local n = #l
    if n < 3 then
        return false
    end

    -- Build a mapping from value to all indices where it occurs.
    local value_to_indices = {}
    for idx, val in ipairs(l) do
        if not value_to_indices[val] then
            value_to_indices[val] = {}
        end
        table.insert(value_to_indices[val], idx)
    end

    -- Check all pairs (i, j) and look for a third distinct index k.
    for i = 1, n - 2 do
        for j = i + 1, n - 1 do
            local target = -(l[i] + l[j])
            local indices = value_to_indices[target]
            if indices then
                for _, k in ipairs(indices) do
                    if k ~= i and k ~= j then
                        return true
                    end
                end
            end
        end
    end

    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = triples_sum_to_zero
    lu.assertEquals(candidate({1, 3, 5, 0}), false)
    lu.assertEquals(candidate({1, 3, 5, -1}), false)
    lu.assertEquals(candidate({1, 3, -2, 1}), true)
    lu.assertEquals(candidate({1, 2, 3, 7}), false)
    lu.assertEquals(candidate({1, 2, 5, 7}), false)
    lu.assertEquals(candidate({2, 4, -5, 3, 9, 7}), true)
    lu.assertEquals(candidate({1}), false)
    lu.assertEquals(candidate({1, 3, 5, -100}), false)
    lu.assertEquals(candidate({100, 3, 5, -100}), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154468
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- triples_sum_to_zero takes a table of integers as an input.
-- it returns true if there are three distinct elements in the table that
-- sum to zero, and false otherwise.
-- >>> triples_sum_to_zero({1, 3, 5, 0})
-- false
-- >>> triples_sum_to_zero({1, 3, -2, 1})
-- true
-- >>> triples_sum_to_zero({1, 2, 3, 7})
-- false
-- >>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})
-- true
-- >>> triples_sum_to_zero({1})
-- false
-- triples_sum_to_zero takes a table of integers as an input.
-- it returns true if there are three distinct elements in the table that
-- sum to zero, and false otherwise.
-- >>> triples_sum_to_zero({1, 3, 5, 0})
-- false
-- >>> triples_sum_to_zero({1, 3, -2, 1})
-- true
-- >>> triples_sum_to_zero({1, 2, 3, 7})
-- false
-- >>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})
-- true
-- >>> triples_sum_to_zero({1})
-- false
local function triples_sum_to_zero(l)
    local n = #l
    if n < 3 then return false end

    -- iterate over the first element of the triplet
    for i = 1, n - 2 do
        -- build a frequency table for all elements after i
        local freq = {}
        for k = i + 1, n do
            freq[l[k]] = (freq[l[k]] or 0) + 1
        end

        -- iterate over the second element of the triplet
        for j = i + 1, n - 1 do
            -- remove l[j] from the frequency table because we need k > j
            freq[l[j]] = freq[l[j]] - 1
            if freq[l[j]] == 0 then
                freq[l[j]] = nil
            end

            local target = -(l[i] + l[j])
            if freq[target] then
                return true
            end
        end
    end

    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = triples_sum_to_zero
    lu.assertEquals(candidate({1, 3, 5, 0}), false)
    lu.assertEquals(candidate({1, 3, 5, -1}), false)
    lu.assertEquals(candidate({1, 3, -2, 1}), true)
    lu.assertEquals(candidate({1, 2, 3, 7}), false)
    lu.assertEquals(candidate({1, 2, 5, 7}), false)
    lu.assertEquals(candidate({2, 4, -5, 3, 9, 7}), true)
    lu.assertEquals(candidate({1}), false)
    lu.assertEquals(candidate({1, 3, 5, -100}), false)
    lu.assertEquals(candidate({100, 3, 5, -100}), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154468
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- triples_sum_to_zero takes a table of integers as an input.
-- it returns true if there are three distinct elements in the table that
-- sum to zero, and false otherwise.
-- >>> triples_sum_to_zero({1, 3, 5, 0})
-- false
-- >>> triples_sum_to_zero({1, 3, -2, 1})
-- true
-- >>> triples_sum_to_zero({1, 2, 3, 7})
-- false
-- >>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})
-- true
-- >>> triples_sum_to_zero({1})
-- false
local function triples_sum_to_zero(l)
  local n = #l
  if n < 3 then
    return false
  end

  -- Build a map from value to all indices where it appears
  local value_to_indices = {}
  for idx, val in ipairs(l) do
    if not value_to_indices[val] then
      value_to_indices[val] = {}
    end
    table.insert(value_to_indices[val], idx)
  end

  -- Check every pair (i, j) for a third element that completes the sum
  for i = 1, n - 2 do
    for j = i + 1, n - 1 do
      local target = -(l[i] + l[j])
      local indices = value_to_indices[target]
      if indices then
        for _, k in ipairs(indices) do
          if k ~= i and k ~= j then
            return true
          end
        end
      end
    end
  end

  return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = triples_sum_to_zero
    lu.assertEquals(candidate({1, 3, 5, 0}), false)
    lu.assertEquals(candidate({1, 3, 5, -1}), false)
    lu.assertEquals(candidate({1, 3, -2, 1}), true)
    lu.assertEquals(candidate({1, 2, 3, 7}), false)
    lu.assertEquals(candidate({1, 2, 5, 7}), false)
    lu.assertEquals(candidate({2, 4, -5, 3, 9, 7}), true)
    lu.assertEquals(candidate({1}), false)
    lu.assertEquals(candidate({1, 3, 5, -100}), false)
    lu.assertEquals(candidate({100, 3, 5, -100}), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154468
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- triples_sum_to_zero takes a table of integers as an input.
-- it returns true if there are three distinct elements in the table that
-- sum to zero, and false otherwise.
-- >>> triples_sum_to_zero({1, 3, 5, 0})
-- false
-- >>> triples_sum_to_zero({1, 3, -2, 1})
-- true
-- >>> triples_sum_to_zero({1, 2, 3, 7})
-- false
-- >>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})
-- true
-- >>> triples_sum_to_zero({1})
-- false
-- triples_sum_to_zero takes a table of integers as an input.
-- It returns true if there are three distinct elements in the table that
-- sum to zero, and false otherwise.
-- >>> triples_sum_to_zero({1, 3, 5, 0})
-- false
-- >>> triples_sum_to_zero({1, 3, -2, 1})
-- true
-- >>> triples_sum_to_zero({1, 2, 3, 7})
-- false
-- >>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})
-- true
-- >>> triples_sum_to_zero({1})
-- false
local function triples_sum_to_zero(l)
  local n = #l
  if n < 3 then
    return false
  end

  -- Build a map from value to the list of indices where it occurs
  local index_map = {}
  for idx, val in ipairs(l) do
    index_map[val] = index_map[val] or {}
    table.insert(index_map[val], idx)
  end

  -- Check every pair (i, j) with i < j and look for a k > j
  for i = 1, n - 2 do
    for j = i + 1, n - 1 do
      local target = -(l[i] + l[j])
      local candidates = index_map[target]
      if candidates then
        for _, k in ipairs(candidates) do
          if k > j then
            return true
          end
        end
      end
    end
  end

  return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = triples_sum_to_zero
    lu.assertEquals(candidate({1, 3, 5, 0}), false)
    lu.assertEquals(candidate({1, 3, 5, -1}), false)
    lu.assertEquals(candidate({1, 3, -2, 1}), true)
    lu.assertEquals(candidate({1, 2, 3, 7}), false)
    lu.assertEquals(candidate({1, 2, 5, 7}), false)
    lu.assertEquals(candidate({2, 4, -5, 3, 9, 7}), true)
    lu.assertEquals(candidate({1}), false)
    lu.assertEquals(candidate({1, 3, 5, -100}), false)
    lu.assertEquals(candidate({100, 3, 5, -100}), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154468
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 42 (LUA) - HumanEval_42_incr_list
================================================================================

PROMPT:
----------------------------------------
-- Return table with elements incremented by 1.
-- >>> incr_list({1, 2, 3})
-- {2, 3, 4}
-- >>> incr_list({5, 3, 5, 2, 3, 3, 9, 0, 123})
-- {6, 4, 6, 3, 4, 4, 10, 1, 124}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = incr_list
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({3, 2, 1}), {4, 3, 2})
    lu.assertEquals(candidate({5, 2, 5, 2, 3, 3, 9, 0, 123}), {6, 3, 6, 3, 4, 4, 10, 1, 124})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Return table with elements incremented by 1.
-- >>> incr_list({1, 2, 3})
-- {2, 3, 4}
-- >>> incr_list({5, 3, 5, 2, 3, 3, 9, 0, 123})
-- {6, 4, 6, 3, 4, 4, 10, 1, 124}
-- Increment each numeric element in a table by 1
-- @param l table: input list of numbers
-- @return table: a new table with each element increased by 1
local function incr_list(l)
    local res = {}
    for i, v in ipairs(l) do
        res[i] = v + 1
    end
    return res
end
lu = require('luaunit')

function test_humaneval()
local candidate = incr_list
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({3, 2, 1}), {4, 3, 2})
    lu.assertEquals(candidate({5, 2, 5, 2, 3, 3, 9, 0, 123}), {6, 3, 6, 3, 4, 4, 10, 1, 124})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Return table with elements incremented by 1.
-- >>> incr_list({1, 2, 3})
-- {2, 3, 4}
-- >>> incr_list({5, 3, 5, 2, 3, 3, 9, 0, 123})
-- {6, 4, 6, 3, 4, 4, 10, 1, 124}
-- Increment every numeric element in a table by 1 and return a new table
local function incr_list(l)
    -- Create a new table to hold the incremented values
    local result = {}

    -- Iterate over the input table using ipairs to preserve order
    for i, v in ipairs(l) do
        -- Ensure the value is numeric before incrementing
        if type(v) == "number" then
            result[i] = v + 1
        else
            -- If the element is not a number, keep it unchanged
            result[i] = v
        end
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = incr_list
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({3, 2, 1}), {4, 3, 2})
    lu.assertEquals(candidate({5, 2, 5, 2, 3, 3, 9, 0, 123}), {6, 3, 6, 3, 4, 4, 10, 1, 124})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Return table with elements incremented by 1.
-- >>> incr_list({1, 2, 3})
-- {2, 3, 4}
-- >>> incr_list({5, 3, 5, 2, 3, 3, 9, 0, 123})
-- {6, 4, 6, 3, 4, 4, 10, 1, 124}
local function incr_list(l)
  local res = {}
  for i, v in ipairs(l) do
    res[i] = v + 1
  end
  return res
end
lu = require('luaunit')

function test_humaneval()
local candidate = incr_list
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({3, 2, 1}), {4, 3, 2})
    lu.assertEquals(candidate({5, 2, 5, 2, 3, 3, 9, 0, 123}), {6, 3, 6, 3, 4, 4, 10, 1, 124})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Return table with elements incremented by 1.
-- >>> incr_list({1, 2, 3})
-- {2, 3, 4}
-- >>> incr_list({5, 3, 5, 2, 3, 3, 9, 0, 123})
-- {6, 4, 6, 3, 4, 4, 10, 1, 124}
local function incr_list(l)
  local res = {}
  for i, v in ipairs(l) do
    res[i] = v + 1
  end
  return res
end
lu = require('luaunit')

function test_humaneval()
local candidate = incr_list
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({3, 2, 1}), {4, 3, 2})
    lu.assertEquals(candidate({5, 2, 5, 2, 3, 3, 9, 0, 123}), {6, 3, 6, 3, 4, 4, 10, 1, 124})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 43 (LUA) - HumanEval_43_pairs_sum_to_zero
================================================================================

PROMPT:
----------------------------------------
-- pairs_sum_to_zero takes a table of integers as an input.
-- it returns true if there are two distinct elements in the table that
-- sum to zero, and false otherwise.
-- >>> pairs_sum_to_zero({1, 3, 5, 0})
-- false
-- >>> pairs_sum_to_zero({1, 3, -2, 1})
-- false
-- >>> pairs_sum_to_zero({1, 2, 3, 7})
-- false
-- >>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})
-- true
-- >>> pairs_sum_to_zero({1})
-- false

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = pairs_sum_to_zero
    lu.assertEquals(candidate({1, 3, 5, 0}), false)
    lu.assertEquals(candidate({1, 3, -2, 1}), false)
    lu.assertEquals(candidate({1, 2, 3, 7}), false)
    lu.assertEquals(candidate({2, 4, -5, 3, 5, 7}), true)
    lu.assertEquals(candidate({1}), false)
    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 30}), true)
    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 31}), true)
    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 30}), false)
    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 31}), false)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- pairs_sum_to_zero takes a table of integers as an input.
-- it returns true if there are two distinct elements in the table that
-- sum to zero, and false otherwise.
-- >>> pairs_sum_to_zero({1, 3, 5, 0})
-- false
-- >>> pairs_sum_to_zero({1, 3, -2, 1})
-- false
-- >>> pairs_sum_to_zero({1, 2, 3, 7})
-- false
-- >>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})
-- true
-- >>> pairs_sum_to_zero({1})
-- false
-- Returns true if there exist two distinct elements in `l`
-- whose sum is zero, otherwise returns false.
local function pairs_sum_to_zero(l)
  -- Build a frequency table for all values in the list.
  local freq = {}
  for _, v in ipairs(l) do
    freq[v] = (freq[v] or 0) + 1
  end

  -- Check each unique value.
  for val, count in pairs(freq) do
    if val == 0 then
      -- Need at least two zeros to form a pair (0 + 0 = 0).
      if count >= 2 then
        return true
      end
    else
      -- For non‑zero values, just see if the opposite exists.
      if freq[-val] then
        return true
      end
    end
  end

  return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = pairs_sum_to_zero
    lu.assertEquals(candidate({1, 3, 5, 0}), false)
    lu.assertEquals(candidate({1, 3, -2, 1}), false)
    lu.assertEquals(candidate({1, 2, 3, 7}), false)
    lu.assertEquals(candidate({2, 4, -5, 3, 5, 7}), true)
    lu.assertEquals(candidate({1}), false)
    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 30}), true)
    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 31}), true)
    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 30}), false)
    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 31}), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- pairs_sum_to_zero takes a table of integers as an input.
-- it returns true if there are two distinct elements in the table that
-- sum to zero, and false otherwise.
-- >>> pairs_sum_to_zero({1, 3, 5, 0})
-- false
-- >>> pairs_sum_to_zero({1, 3, -2, 1})
-- false
-- >>> pairs_sum_to_zero({1, 2, 3, 7})
-- false
-- >>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})
-- true
-- >>> pairs_sum_to_zero({1})
-- false
-- pairs_sum_to_zero takes a table of integers as an input.
-- it returns true if there are two distinct elements in the table that
-- sum to zero, and false otherwise.
-- >>> pairs_sum_to_zero({1, 3, 5, 0})
-- false
-- >>> pairs_sum_to_zero({1, 3, -2, 1})
-- false
-- >>> pairs_sum_to_zero({1, 2, 3, 7})
-- false
-- >>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})
-- true
-- >>> pairs_sum_to_zero({1})
-- false
local function pairs_sum_to_zero(l)
    -- Table to keep track of numbers we have seen.
    local seen = {}
    for _, n in ipairs(l) do
        if n == 0 then
            -- For zero we need at least two occurrences.
            if seen[0] then
                return true
            else
                seen[0] = true
            end
        else
            -- For any other number, check if its negation has been seen.
            if seen[-n] then
                return true
            else
                seen[n] = true
            end
        end
    end
    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = pairs_sum_to_zero
    lu.assertEquals(candidate({1, 3, 5, 0}), false)
    lu.assertEquals(candidate({1, 3, -2, 1}), false)
    lu.assertEquals(candidate({1, 2, 3, 7}), false)
    lu.assertEquals(candidate({2, 4, -5, 3, 5, 7}), true)
    lu.assertEquals(candidate({1}), false)
    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 30}), true)
    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 31}), true)
    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 30}), false)
    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 31}), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- pairs_sum_to_zero takes a table of integers as an input.
-- it returns true if there are two distinct elements in the table that
-- sum to zero, and false otherwise.
-- >>> pairs_sum_to_zero({1, 3, 5, 0})
-- false
-- >>> pairs_sum_to_zero({1, 3, -2, 1})
-- false
-- >>> pairs_sum_to_zero({1, 2, 3, 7})
-- false
-- >>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})
-- true
-- >>> pairs_sum_to_zero({1})
-- false
-- Returns true if any two distinct elements of `l` sum to zero.
-- Uses a hash table to track seen values and handles the special
-- case of zero (needs at least two zeros to form a pair).
local function pairs_sum_to_zero(l)
    if #l < 2 then
        return false
    end

    local seen = {}
    local zeroCount = 0

    -- First pass: count occurrences and store seen values
    for _, v in ipairs(l) do
        if v == 0 then
            zeroCount = zeroCount + 1
        end
        seen[v] = (seen[v] or 0) + 1
    end

    -- Second pass: look for a complementary value
    for _, v in ipairs(l) do
        local complement = -v
        if seen[complement] then
            if complement ~= v then
                return true  -- distinct values
            elseif complement == v and seen[complement] > 1 then
                return true  -- two zeros or two equal non-zero numbers
            end
        end
    end

    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = pairs_sum_to_zero
    lu.assertEquals(candidate({1, 3, 5, 0}), false)
    lu.assertEquals(candidate({1, 3, -2, 1}), false)
    lu.assertEquals(candidate({1, 2, 3, 7}), false)
    lu.assertEquals(candidate({2, 4, -5, 3, 5, 7}), true)
    lu.assertEquals(candidate({1}), false)
    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 30}), true)
    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 31}), true)
    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 30}), false)
    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 31}), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- pairs_sum_to_zero takes a table of integers as an input.
-- it returns true if there are two distinct elements in the table that
-- sum to zero, and false otherwise.
-- >>> pairs_sum_to_zero({1, 3, 5, 0})
-- false
-- >>> pairs_sum_to_zero({1, 3, -2, 1})
-- false
-- >>> pairs_sum_to_zero({1, 2, 3, 7})
-- false
-- >>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})
-- true
-- >>> pairs_sum_to_zero({1})
-- false
-- pairs_sum_to_zero takes a table of integers as an input.
-- It returns true if there are two distinct elements in the table that
-- sum to zero, and false otherwise.
-- >>> pairs_sum_to_zero({1, 3, 5, 0})
-- false
-- >>> pairs_sum_to_zero({1, 3, -2, 1})
-- false
-- >>> pairs_sum_to_zero({1, 2, 3, 7})
-- false
-- >>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})
-- true
-- >>> pairs_sum_to_zero({1})
-- false
local function pairs_sum_to_zero(l)
    -- Use a set to keep track of numbers we've seen.
    local seen = {}
    for _, x in ipairs(l) do
        -- Check for the complementary number.
        if seen[-x] then
            return true
        end
        -- Special case: zero needs two distinct occurrences.
        if x == 0 then
            if seen[0] then
                return true
            end
        end
        seen[x] = true
    end
    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = pairs_sum_to_zero
    lu.assertEquals(candidate({1, 3, 5, 0}), false)
    lu.assertEquals(candidate({1, 3, -2, 1}), false)
    lu.assertEquals(candidate({1, 2, 3, 7}), false)
    lu.assertEquals(candidate({2, 4, -5, 3, 5, 7}), true)
    lu.assertEquals(candidate({1}), false)
    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 30}), true)
    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 31}), true)
    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 30}), false)
    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 31}), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 44 (LUA) - HumanEval_44_change_base
================================================================================

PROMPT:
----------------------------------------
-- Change numerical base of input number x to base.
-- return string representation after the conversion.
-- base numbers are less than 10.
-- >>> change_base(8, 3)
-- '22'
-- >>> change_base(8, 2)
-- '1000'
-- >>> change_base(7, 2)
-- '111'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = change_base
    lu.assertEquals(candidate(8, 3), '22')
    lu.assertEquals(candidate(9, 3), '100')
    lu.assertEquals(candidate(234, 2), '11101010')
    lu.assertEquals(candidate(16, 2), '10000')
    lu.assertEquals(candidate(8, 2), '1000')
    lu.assertEquals(candidate(7, 2), '111')
    lu.assertEquals(candidate(2, 3), '2')
    lu.assertEquals(candidate(3, 4), '3')
    lu.assertEquals(candidate(4, 5), '4')
    lu.assertEquals(candidate(5, 6), '5')
    lu.assertEquals(candidate(6, 7), '6')
    lu.assertEquals(candidate(7, 8), '7')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Change numerical base of input number x to base.
-- return string representation after the conversion.
-- base numbers are less than 10.
-- >>> change_base(8, 3)
-- '22'
-- >>> change_base(8, 2)
-- '1000'
-- >>> change_base(7, 2)
-- '111'
-- Change numerical base of input number x to base.
-- return string representation after the conversion.
-- base numbers are less than 10.
-- >>> change_base(8, 3)
-- '22'
-- >>> change_base(8, 2)
-- '1000'
-- >>> change_base(7, 2)
-- '111'
local function change_base(x, base)
    -- Handle zero explicitly
    if x == 0 then
        return "0"
    end

    local digits = {}
    while x > 0 do
        local digit = x % base
        table.insert(digits, 1, tostring(digit))  -- prepend to maintain order
        x = math.floor(x / base)
    end

    return table.concat(digits)
end
lu = require('luaunit')

function test_humaneval()
local candidate = change_base
    lu.assertEquals(candidate(8, 3), '22')
    lu.assertEquals(candidate(9, 3), '100')
    lu.assertEquals(candidate(234, 2), '11101010')
    lu.assertEquals(candidate(16, 2), '10000')
    lu.assertEquals(candidate(8, 2), '1000')
    lu.assertEquals(candidate(7, 2), '111')
    lu.assertEquals(candidate(2, 3), '2')
    lu.assertEquals(candidate(3, 4), '3')
    lu.assertEquals(candidate(4, 5), '4')
    lu.assertEquals(candidate(5, 6), '5')
    lu.assertEquals(candidate(6, 7), '6')
    lu.assertEquals(candidate(7, 8), '7')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Change numerical base of input number x to base.
-- return string representation after the conversion.
-- base numbers are less than 10.
-- >>> change_base(8, 3)
-- '22'
-- >>> change_base(8, 2)
-- '1000'
-- >>> change_base(7, 2)
-- '111'
local function change_base(x, base)
    if x == 0 then
        return "0"
    end

    local digits = {}
    while x > 0 do
        local remainder = x % base
        table.insert(digits, 1, tostring(remainder))
        x = math.floor(x / base)
    end

    return table.concat(digits)
end
lu = require('luaunit')

function test_humaneval()
local candidate = change_base
    lu.assertEquals(candidate(8, 3), '22')
    lu.assertEquals(candidate(9, 3), '100')
    lu.assertEquals(candidate(234, 2), '11101010')
    lu.assertEquals(candidate(16, 2), '10000')
    lu.assertEquals(candidate(8, 2), '1000')
    lu.assertEquals(candidate(7, 2), '111')
    lu.assertEquals(candidate(2, 3), '2')
    lu.assertEquals(candidate(3, 4), '3')
    lu.assertEquals(candidate(4, 5), '4')
    lu.assertEquals(candidate(5, 6), '5')
    lu.assertEquals(candidate(6, 7), '6')
    lu.assertEquals(candidate(7, 8), '7')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Change numerical base of input number x to base.
-- return string representation after the conversion.
-- base numbers are less than 10.
-- >>> change_base(8, 3)
-- '22'
-- >>> change_base(8, 2)
-- '1000'
-- >>> change_base(7, 2)
-- '111'
-- Change numerical base of input number x to base.
-- Return string representation after the conversion.
-- base numbers are less than 10.
-- >>> change_base(8, 3)
-- '22'
-- >>> change_base(8, 2)
-- '1000'
-- >>> change_base(7, 2)
-- '111'
local function change_base(x, base)
    if x == 0 then
        return "0"
    end

    local result = ""

    while x > 0 do
        local digit = x % base
        result = tostring(digit) .. result
        x = math.floor(x / base)
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = change_base
    lu.assertEquals(candidate(8, 3), '22')
    lu.assertEquals(candidate(9, 3), '100')
    lu.assertEquals(candidate(234, 2), '11101010')
    lu.assertEquals(candidate(16, 2), '10000')
    lu.assertEquals(candidate(8, 2), '1000')
    lu.assertEquals(candidate(7, 2), '111')
    lu.assertEquals(candidate(2, 3), '2')
    lu.assertEquals(candidate(3, 4), '3')
    lu.assertEquals(candidate(4, 5), '4')
    lu.assertEquals(candidate(5, 6), '5')
    lu.assertEquals(candidate(6, 7), '6')
    lu.assertEquals(candidate(7, 8), '7')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Change numerical base of input number x to base.
-- return string representation after the conversion.
-- base numbers are less than 10.
-- >>> change_base(8, 3)
-- '22'
-- >>> change_base(8, 2)
-- '1000'
-- >>> change_base(7, 2)
-- '111'
-- Change numerical base of input number x to base.
-- return string representation after the conversion.
-- base numbers are less than 10.
-- >>> change_base(8, 3)
-- '22'
-- >>> change_base(8, 2)
-- '1000'
-- >>> change_base(7, 2)
-- '111'
local function change_base(x, base)
    -- Handle the special case where x is 0
    if x == 0 then
        return "0"
    end

    local digits = {}
    local n = x

    -- Repeatedly divide by the base and store the remainders
    while n > 0 do
        local r = n % base
        table.insert(digits, tostring(r))
        n = math.floor(n / base)
    end

    -- The digits are collected in reverse order, so reverse them
    local result = {}
    for i = #digits, 1, -1 do
        result[#result + 1] = digits[i]
    end

    return table.concat(result)
end
lu = require('luaunit')

function test_humaneval()
local candidate = change_base
    lu.assertEquals(candidate(8, 3), '22')
    lu.assertEquals(candidate(9, 3), '100')
    lu.assertEquals(candidate(234, 2), '11101010')
    lu.assertEquals(candidate(16, 2), '10000')
    lu.assertEquals(candidate(8, 2), '1000')
    lu.assertEquals(candidate(7, 2), '111')
    lu.assertEquals(candidate(2, 3), '2')
    lu.assertEquals(candidate(3, 4), '3')
    lu.assertEquals(candidate(4, 5), '4')
    lu.assertEquals(candidate(5, 6), '5')
    lu.assertEquals(candidate(6, 7), '6')
    lu.assertEquals(candidate(7, 8), '7')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 45 (LUA) - HumanEval_45_triangle_area
================================================================================

PROMPT:
----------------------------------------
-- Given length of a side and high return area for a triangle.
-- >>> triangle_area(5, 3)
-- 7.5

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = triangle_area
    lu.assertEquals(candidate(5, 3), 7.5)
    lu.assertEquals(candidate(2, 2), 2.0)
    lu.assertEquals(candidate(10, 8), 40.0)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given length of a side and high return area for a triangle.
-- >>> triangle_area(5, 3)
-- 7.5
-- Calculate the area of a triangle using the base (a) and height (h)
local function triangle_area(a, h)
    return 0.5 * a * h
end
lu = require('luaunit')

function test_humaneval()
local candidate = triangle_area
    lu.assertEquals(candidate(5, 3), 7.5)
    lu.assertEquals(candidate(2, 2), 2.0)
    lu.assertEquals(candidate(10, 8), 40.0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given length of a side and high return area for a triangle.
-- >>> triangle_area(5, 3)
-- 7.5
-- Computes the area of a triangle given one side length `a` and its corresponding height `h`.
-- Example:
--   triangle_area(5, 3)  --> 7.5
local function triangle_area(a, h)
    return 0.5 * a * h
end
lu = require('luaunit')

function test_humaneval()
local candidate = triangle_area
    lu.assertEquals(candidate(5, 3), 7.5)
    lu.assertEquals(candidate(2, 2), 2.0)
    lu.assertEquals(candidate(10, 8), 40.0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given length of a side and high return area for a triangle.
-- >>> triangle_area(5, 3)
-- 7.5
local function triangle_area(a, h)
    return a * h / 2
end
lu = require('luaunit')

function test_humaneval()
local candidate = triangle_area
    lu.assertEquals(candidate(5, 3), 7.5)
    lu.assertEquals(candidate(2, 2), 2.0)
    lu.assertEquals(candidate(10, 8), 40.0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given length of a side and high return area for a triangle.
-- >>> triangle_area(5, 3)
-- 7.5
local function triangle_area(a, h)
    return (a * h) / 2
end
lu = require('luaunit')

function test_humaneval()
local candidate = triangle_area
    lu.assertEquals(candidate(5, 3), 7.5)
    lu.assertEquals(candidate(2, 2), 2.0)
    lu.assertEquals(candidate(10, 8), 40.0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 46 (LUA) - HumanEval_46_fib4
================================================================================

PROMPT:
----------------------------------------
-- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
-- fib4(0) -> 0
-- fib4(1) -> 0
-- fib4(2) -> 2
-- fib4(3) -> 0
-- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
-- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
-- >>> fib4(5)
-- 4
-- >>> fib4(6)
-- 8
-- >>> fib4(7)
-- 14

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = fib4
    lu.assertEquals(candidate(5), 4)
    lu.assertEquals(candidate(8), 28)
    lu.assertEquals(candidate(10), 104)
    lu.assertEquals(candidate(12), 386)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
-- fib4(0) -> 0
-- fib4(1) -> 0
-- fib4(2) -> 2
-- fib4(3) -> 0
-- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
-- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
-- >>> fib4(5)
-- 4
-- >>> fib4(6)
-- 8
-- >>> fib4(7)
-- 14
local function fib4(n)
  -- Validate input
  if n < 0 then
    error("n must be a non‑negative integer")
  end

  -- Base cases
  if n == 0 or n == 1 or n == 3 then
    return 0
  elseif n == 2 then
    return 2
  end

  -- Iteratively compute the sequence using four rolling variables
  local a, b, c, d = 0, 0, 2, 0  -- fib4(0), fib4(1), fib4(2), fib4(3)

  for i = 4, n do
    local next_val = a + b + c + d
    a, b, c, d = b, c, d, next_val
  end

  return d
end
lu = require('luaunit')

function test_humaneval()
local candidate = fib4
    lu.assertEquals(candidate(5), 4)
    lu.assertEquals(candidate(8), 28)
    lu.assertEquals(candidate(10), 104)
    lu.assertEquals(candidate(12), 386)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
-- fib4(0) -> 0
-- fib4(1) -> 0
-- fib4(2) -> 2
-- fib4(3) -> 0
-- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
-- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
-- >>> fib4(5)
-- 4
-- >>> fib4(6)
-- 8
-- >>> fib4(7)
-- 14
-- Efficient, non‑recursive implementation of the fib4 sequence
local function fib4(n)
    -- Handle the base cases directly
    if n == 0 or n == 1 then
        return 0
    elseif n == 2 then
        return 2
    elseif n == 3 then
        return 0
    end

    -- We only need the last four values to compute the next one.
    local a, b, c, d = 0, 0, 2, 0  -- fib4(0), fib4(1), fib4(2), fib4(3)

    for i = 4, n do
        local next_val = a + b + c + d
        a, b, c, d = b, c, d, next_val
    end

    return d
end
lu = require('luaunit')

function test_humaneval()
local candidate = fib4
    lu.assertEquals(candidate(5), 4)
    lu.assertEquals(candidate(8), 28)
    lu.assertEquals(candidate(10), 104)
    lu.assertEquals(candidate(12), 386)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
-- fib4(0) -> 0
-- fib4(1) -> 0
-- fib4(2) -> 2
-- fib4(3) -> 0
-- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
-- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
-- >>> fib4(5)
-- 4
-- >>> fib4(6)
-- 8
-- >>> fib4(7)
-- 14
-- Efficient iterative implementation of the Fib4 sequence
-- Uses only constant extra space by keeping the last four values.
local function fib4(n)
    if n == 0 or n == 1 then
        return 0
    elseif n == 2 then
        return 2
    elseif n == 3 then
        return 0
    end

    -- Initialize the first four terms
    local a, b, c, d = 0, 0, 2, 0  -- a=fib4(0), b=fib4(1), c=fib4(2), d=fib4(3)

    for i = 4, n do
        local next = a + b + c + d
        a, b, c, d = b, c, d, next
    end

    return d
end

-- Example usage:
-- print(fib4(5))  --> 4
-- print(fib4(6))  --> 8
-- print(fib4(7))  --> 14
lu = require('luaunit')

function test_humaneval()
local candidate = fib4
    lu.assertEquals(candidate(5), 4)
    lu.assertEquals(candidate(8), 28)
    lu.assertEquals(candidate(10), 104)
    lu.assertEquals(candidate(12), 386)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
-- fib4(0) -> 0
-- fib4(1) -> 0
-- fib4(2) -> 2
-- fib4(3) -> 0
-- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
-- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
-- >>> fib4(5)
-- 4
-- >>> fib4(6)
-- 8
-- >>> fib4(7)
-- 14
-- Efficient iterative implementation of the fib4 sequence
-- fib4(0) = 0
-- fib4(1) = 0
-- fib4(2) = 2
-- fib4(3) = 0
-- fib4(n) = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)  for n >= 4

local function fib4(n)
    -- Handle base cases directly
    if n == 0 then return 0 end
    if n == 1 then return 0 end
    if n == 2 then return 2 end
    if n == 3 then return 0 end

    -- Initialize the four most recent values
    local a, b, c, d = 0, 0, 2, 0  -- corresponds to fib4(0), fib4(1), fib4(2), fib4(3)

    -- Iterate from 4 up to n
    for i = 4, n do
        local next_val = a + b + c + d  -- fib4(i)
        -- Shift the window: a becomes b, b becomes c, c becomes d, d becomes next_val
        a, b, c, d = b, c, d, next_val
    end

    return d  -- d now holds fib4(n)
end
lu = require('luaunit')

function test_humaneval()
local candidate = fib4
    lu.assertEquals(candidate(5), 4)
    lu.assertEquals(candidate(8), 28)
    lu.assertEquals(candidate(10), 104)
    lu.assertEquals(candidate(12), 386)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 48 (LUA) - HumanEval_48_is_palindrome
================================================================================

PROMPT:
----------------------------------------
-- Checks if given string is a palindrome
-- >>> is_palindrome('')
-- true
-- >>> is_palindrome('aba')
-- true
-- >>> is_palindrome('aaaaa')
-- true
-- >>> is_palindrome('zbcd')
-- false

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = is_palindrome
    lu.assertEquals(candidate(''), true)
    lu.assertEquals(candidate('aba'), true)
    lu.assertEquals(candidate('aaaaa'), true)
    lu.assertEquals(candidate('zbcd'), false)
    lu.assertEquals(candidate('xywyx'), true)
    lu.assertEquals(candidate('xywyz'), false)
    lu.assertEquals(candidate('xywzx'), false)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Checks if given string is a palindrome
-- >>> is_palindrome('')
-- true
-- >>> is_palindrome('aba')
-- true
-- >>> is_palindrome('aaaaa')
-- true
-- >>> is_palindrome('zbcd')
-- false
-- Checks if given string is a palindrome
-- >>> is_palindrome('')
-- true
-- >>> is_palindrome('aba')
-- true
-- >>> is_palindrome('aaaaa')
-- true
-- >>> is_palindrome('zbcd')
-- false
local function is_palindrome(text)
    -- Treat nil as an empty string to avoid errors
    text = text or ""
    -- Compare the string with its reversed version
    return text == string.reverse(text)
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_palindrome
    lu.assertEquals(candidate(''), true)
    lu.assertEquals(candidate('aba'), true)
    lu.assertEquals(candidate('aaaaa'), true)
    lu.assertEquals(candidate('zbcd'), false)
    lu.assertEquals(candidate('xywyx'), true)
    lu.assertEquals(candidate('xywyz'), false)
    lu.assertEquals(candidate('xywzx'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Checks if given string is a palindrome
-- >>> is_palindrome('')
-- true
-- >>> is_palindrome('aba')
-- true
-- >>> is_palindrome('aaaaa')
-- true
-- >>> is_palindrome('zbcd')
-- false
-- Checks if given string is a palindrome
-- >>> is_palindrome('')
-- true
-- >>> is_palindrome('aba')
-- true
-- >>> is_palindrome('aaaaa')
-- true
-- >>> is_palindrome('zbcd')
-- false
local function is_palindrome(text)
    -- Treat nil or non-string inputs as empty string for safety
    if type(text) ~= "string" then
        text = tostring(text)
    end
    return text == string.reverse(text)
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_palindrome
    lu.assertEquals(candidate(''), true)
    lu.assertEquals(candidate('aba'), true)
    lu.assertEquals(candidate('aaaaa'), true)
    lu.assertEquals(candidate('zbcd'), false)
    lu.assertEquals(candidate('xywyx'), true)
    lu.assertEquals(candidate('xywyz'), false)
    lu.assertEquals(candidate('xywzx'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Checks if given string is a palindrome
-- >>> is_palindrome('')
-- true
-- >>> is_palindrome('aba')
-- true
-- >>> is_palindrome('aaaaa')
-- true
-- >>> is_palindrome('zbcd')
-- false
local function is_palindrome(text)
  return text == text:reverse()
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_palindrome
    lu.assertEquals(candidate(''), true)
    lu.assertEquals(candidate('aba'), true)
    lu.assertEquals(candidate('aaaaa'), true)
    lu.assertEquals(candidate('zbcd'), false)
    lu.assertEquals(candidate('xywyx'), true)
    lu.assertEquals(candidate('xywyz'), false)
    lu.assertEquals(candidate('xywzx'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Checks if given string is a palindrome
-- >>> is_palindrome('')
-- true
-- >>> is_palindrome('aba')
-- true
-- >>> is_palindrome('aaaaa')
-- true
-- >>> is_palindrome('zbcd')
-- false
local function is_palindrome(text)
  return text == string.reverse(text)
end
lu = require('luaunit')

function test_humaneval()
local candidate = is_palindrome
    lu.assertEquals(candidate(''), true)
    lu.assertEquals(candidate('aba'), true)
    lu.assertEquals(candidate('aaaaa'), true)
    lu.assertEquals(candidate('zbcd'), false)
    lu.assertEquals(candidate('xywyx'), true)
    lu.assertEquals(candidate('xywyz'), false)
    lu.assertEquals(candidate('xywzx'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 49 (LUA) - HumanEval_49_modp
================================================================================

PROMPT:
----------------------------------------
-- Return 2^n modulo p (be aware of numerics).
-- >>> modp(3, 5)
-- 3
-- >>> modp(1101, 101)
-- 2
-- >>> modp(0, 101)
-- 1
-- >>> modp(3, 11)
-- 8
-- >>> modp(100, 101)
-- 1

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = modp
    lu.assertEquals(candidate(3, 5), 3)
    lu.assertEquals(candidate(1101, 101), 2)
    lu.assertEquals(candidate(0, 101), 1)
    lu.assertEquals(candidate(3, 11), 8)
    lu.assertEquals(candidate(100, 101), 1)
    lu.assertEquals(candidate(30, 5), 4)
    lu.assertEquals(candidate(31, 5), 3)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Return 2^n modulo p (be aware of numerics).
-- >>> modp(3, 5)
-- 3
-- >>> modp(1101, 101)
-- 2
-- >>> modp(0, 101)
-- 1
-- >>> modp(3, 11)
-- 8
-- >>> modp(100, 101)
-- 1
-- Return 2^n modulo p (be aware of numerics).
-- >>> modp(3, 5)
-- 3
-- >>> modp(1101, 101)
-- 2
-- >>> modp(0, 101)
-- 1
-- >>> modp(3, 11)
-- 8
-- >>> modp(100, 101)
-- 1
local function modp(n, p)
    -- Handle the trivial case first
    if n == 0 then
        return 1 % p
    end

    -- Fast modular exponentiation: compute (2^n) % p
    local result = 1 % p
    local base   = 2 % p
    local exp    = n

    while exp > 0 do
        if exp % 2 == 1 then
            result = (result * base) % p
        end
        base = (base * base) % p
        exp = exp // 2
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = modp
    lu.assertEquals(candidate(3, 5), 3)
    lu.assertEquals(candidate(1101, 101), 2)
    lu.assertEquals(candidate(0, 101), 1)
    lu.assertEquals(candidate(3, 11), 8)
    lu.assertEquals(candidate(100, 101), 1)
    lu.assertEquals(candidate(30, 5), 4)
    lu.assertEquals(candidate(31, 5), 3)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Return 2^n modulo p (be aware of numerics).
-- >>> modp(3, 5)
-- 3
-- >>> modp(1101, 101)
-- 2
-- >>> modp(0, 101)
-- 1
-- >>> modp(3, 11)
-- 8
-- >>> modp(100, 101)
-- 1
-- Return 2^n modulo p (be aware of numerics).
-- >>> modp(3, 5)
-- 3
-- >>> modp(1101, 101)
-- 2
-- >>> modp(0, 101)
-- 1
-- >>> modp(3, 11)
-- 8
-- >>> modp(100, 101)
-- 1
local function modp(n, p)
    -- Fast modular exponentiation: compute (2^n) % p
    local result = 1 % p          -- 2^0 ≡ 1 (mod p)
    local base   = 2 % p          -- base = 2 (mod p)

    while n > 0 do
        if n % 2 == 1 then
            result = (result * base) % p
        end
        base = (base * base) % p
        n = math.floor(n / 2)
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = modp
    lu.assertEquals(candidate(3, 5), 3)
    lu.assertEquals(candidate(1101, 101), 2)
    lu.assertEquals(candidate(0, 101), 1)
    lu.assertEquals(candidate(3, 11), 8)
    lu.assertEquals(candidate(100, 101), 1)
    lu.assertEquals(candidate(30, 5), 4)
    lu.assertEquals(candidate(31, 5), 3)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Return 2^n modulo p (be aware of numerics).
-- >>> modp(3, 5)
-- 3
-- >>> modp(1101, 101)
-- 2
-- >>> modp(0, 101)
-- 1
-- >>> modp(3, 11)
-- 8
-- >>> modp(100, 101)
-- 1
-- Return 2^n modulo p (be aware of numerics).
-- >>> modp(3, 5)
-- 3
-- >>> modp(1101, 101)
-- 2
-- >>> modp(0, 101)
-- 1
-- >>> modp(3, 11)
-- 8
-- >>> modp(100, 101)
-- 1
local function modp(n, p)
    -- Fast exponentiation by squaring
    local result = 1 % p          -- 1 modulo p
    local base   = 2 % p          -- 2 modulo p
    local exp    = n

    while exp > 0 do
        if exp % 2 == 1 then
            result = (result * base) % p
        end
        base = (base * base) % p
        exp = math.floor(exp / 2)
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = modp
    lu.assertEquals(candidate(3, 5), 3)
    lu.assertEquals(candidate(1101, 101), 2)
    lu.assertEquals(candidate(0, 101), 1)
    lu.assertEquals(candidate(3, 11), 8)
    lu.assertEquals(candidate(100, 101), 1)
    lu.assertEquals(candidate(30, 5), 4)
    lu.assertEquals(candidate(31, 5), 3)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Return 2^n modulo p (be aware of numerics).
-- >>> modp(3, 5)
-- 3
-- >>> modp(1101, 101)
-- 2
-- >>> modp(0, 101)
-- 1
-- >>> modp(3, 11)
-- 8
-- >>> modp(100, 101)
-- 1
-- Return 2^n modulo p (be aware of numerics).
-- >>> modp(3, 5)
-- 3
-- >>> modp(1101, 101)
-- 2
-- >>> modp(0, 101)
-- 1
-- >>> modp(3, 11)
-- 8
-- >>> modp(100, 101)
-- 1
local function modp(n, p)
    if p == 0 then
        error("modulus p must be non‑zero")
    end
    local result = 1 % p          -- 2^0 % p
    local base   = 2 % p          -- current power of 2
    local exp    = n

    while exp > 0 do
        if exp % 2 == 1 then
            result = (result * base) % p
        end
        base = (base * base) % p
        exp  = math.floor(exp / 2)
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = modp
    lu.assertEquals(candidate(3, 5), 3)
    lu.assertEquals(candidate(1101, 101), 2)
    lu.assertEquals(candidate(0, 101), 1)
    lu.assertEquals(candidate(3, 11), 8)
    lu.assertEquals(candidate(100, 101), 1)
    lu.assertEquals(candidate(30, 5), 4)
    lu.assertEquals(candidate(31, 5), 3)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154469
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------
