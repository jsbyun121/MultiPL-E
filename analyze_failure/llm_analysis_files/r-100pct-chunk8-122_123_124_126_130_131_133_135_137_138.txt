As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 122 (R) - HumanEval_122_add_elements
================================================================================

PROMPT:
----------------------------------------
# Given a non-empty vector of integers arr and an integer k, return
# the sum of the elements with at most two digits from the first k elements of arr.
# Example:
# >>> add_elements(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4)
# 24
# Constraints:
#     1. 1 <= len(arr) <= 100
#     2. 1 <= k <= len(arr)

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- add_elements
    stopifnot(isTRUE(all.equal(candidate(c(1, -2, -3, 41, 57, 76, 87, 88, 99), 3), -4)))
    stopifnot(isTRUE(all.equal(candidate(c(111, 121, 3, 4000, 5, 6), 2), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(11, 21, 3, 90, 5, 6, 7, 8, 9), 4), 125)))
    stopifnot(isTRUE(all.equal(candidate(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4), 24)))
    stopifnot(isTRUE(all.equal(candidate(c(1), 1), 1)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given a non-empty vector of integers arr and an integer k, return
# the sum of the elements with at most two digits from the first k elements of arr.
# Example:
# >>> add_elements(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4)
# 24
# Constraints:
#     1. 1 <= len(arr) <= 100
#     2. 1 <= k <= len(arr)
add_elements <- function(arr, k) {
  # Take the first k elements
  first_k <- arr[seq_len(k)]
  
  # Count the number of digits for each element (ignoring sign)
  digit_counts <- nchar(as.character(abs(first_k)))
  
  # Sum only those with at most two digits
  sum(first_k[digit_counts <= 2])
}
test_humaneval <- function() {
    candidate <- add_elements
    stopifnot(isTRUE(all.equal(candidate(c(1, -2, -3, 41, 57, 76, 87, 88, 99), 3), -4)))
    stopifnot(isTRUE(all.equal(candidate(c(111, 121, 3, 4000, 5, 6), 2), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(11, 21, 3, 90, 5, 6, 7, 8, 9), 4), 125)))
    stopifnot(isTRUE(all.equal(candidate(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4), 24)))
    stopifnot(isTRUE(all.equal(candidate(c(1), 1), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183792
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given a non-empty vector of integers arr and an integer k, return
# the sum of the elements with at most two digits from the first k elements of arr.
# Example:
# >>> add_elements(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4)
# 24
# Constraints:
#     1. 1 <= len(arr) <= 100
#     2. 1 <= k <= len(arr)
add_elements <- function(arr, k) {
  # Ensure k is within bounds
  k <- max(1, min(k, length(arr)))
  
  # Take the first k elements
  sub_arr <- arr[1:k]
  
  # Count the number of decimal digits for each element
  # (use abs to ignore sign, and nchar handles 0 correctly)
  digit_counts <- nchar(as.character(abs(sub_arr)))
  
  # Select elements with at most two digits
  selected <- sub_arr[digit_counts <= 2]
  
  # Return the sum (0 if none are selected)
  sum(selected, na.rm = TRUE)
}
test_humaneval <- function() {
    candidate <- add_elements
    stopifnot(isTRUE(all.equal(candidate(c(1, -2, -3, 41, 57, 76, 87, 88, 99), 3), -4)))
    stopifnot(isTRUE(all.equal(candidate(c(111, 121, 3, 4000, 5, 6), 2), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(11, 21, 3, 90, 5, 6, 7, 8, 9), 4), 125)))
    stopifnot(isTRUE(all.equal(candidate(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4), 24)))
    stopifnot(isTRUE(all.equal(candidate(c(1), 1), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183792
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given a non-empty vector of integers arr and an integer k, return
# the sum of the elements with at most two digits from the first k elements of arr.
# Example:
# >>> add_elements(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4)
# 24
# Constraints:
#     1. 1 <= len(arr) <= 100
#     2. 1 <= k <= len(arr)
add_elements <- function(arr, k) {
  # Take the first k elements
  first_k <- arr[1:k]
  
  # Count digits for each element (use abs to ignore sign)
  digit_counts <- nchar(as.character(abs(first_k)))
  
  # Keep only those with at most two digits
  selected <- first_k[digit_counts <= 2]
  
  # Return the sum (sum of numeric(0) is 0, so no special case needed)
  sum(selected)
}
test_humaneval <- function() {
    candidate <- add_elements
    stopifnot(isTRUE(all.equal(candidate(c(1, -2, -3, 41, 57, 76, 87, 88, 99), 3), -4)))
    stopifnot(isTRUE(all.equal(candidate(c(111, 121, 3, 4000, 5, 6), 2), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(11, 21, 3, 90, 5, 6, 7, 8, 9), 4), 125)))
    stopifnot(isTRUE(all.equal(candidate(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4), 24)))
    stopifnot(isTRUE(all.equal(candidate(c(1), 1), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183792
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given a non-empty vector of integers arr and an integer k, return
# the sum of the elements with at most two digits from the first k elements of arr.
# Example:
# >>> add_elements(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4)
# 24
# Constraints:
#     1. 1 <= len(arr) <= 100
#     2. 1 <= k <= len(arr)
add_elements <- function(arr, k) {
  # Take the first k elements
  first_k <- arr[1:k]
  
  # Keep only those with at most two digits (i.e., |value| < 100)
  two_digit <- first_k[abs(first_k) < 100]
  
  # Return the sum of the filtered elements
  sum(two_digit)
}
test_humaneval <- function() {
    candidate <- add_elements
    stopifnot(isTRUE(all.equal(candidate(c(1, -2, -3, 41, 57, 76, 87, 88, 99), 3), -4)))
    stopifnot(isTRUE(all.equal(candidate(c(111, 121, 3, 4000, 5, 6), 2), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(11, 21, 3, 90, 5, 6, 7, 8, 9), 4), 125)))
    stopifnot(isTRUE(all.equal(candidate(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4), 24)))
    stopifnot(isTRUE(all.equal(candidate(c(1), 1), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183792
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 123 (R) - HumanEval_123_get_odd_collatz
================================================================================

PROMPT:
----------------------------------------
# Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.
# The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
# as follows: start with any positive integer n. Then each term is obtained from the 
# previous term as follows: if the previous term is even, the next term is one half of 
# the previous term. If the previous term is odd, the next term is 3 times the previous
# term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
# Note: 
#     1. Collatz(1) is [1].
#     2. returned list sorted in increasing order.
# For example:
# get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
# >>> get_odd_collatz(5)
# c(1, 5)

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- get_odd_collatz
    stopifnot(isTRUE(all.equal(candidate(14), c(1, 5, 7, 11, 13, 17))))
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 5))))
    stopifnot(isTRUE(all.equal(candidate(12), c(1, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1))))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.
# The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
# as follows: start with any positive integer n. Then each term is obtained from the 
# previous term as follows: if the previous term is even, the next term is one half of 
# the previous term. If the previous term is odd, the next term is 3 times the previous
# term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
# Note: 
#     1. Collatz(1) is [1].
#     2. returned list sorted in increasing order.
# For example:
# get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
# >>> get_odd_collatz(5)
# c(1, 5)
# Function to return the sorted list of odd numbers in the Collatz sequence
get_odd_collatz <- function(n) {
  # Validate input
  if (!is.numeric(n) || length(n) != 1 || n <= 0 || n != floor(n)) {
    stop("`n` must be a positive integer")
  }
  
  odds <- integer()  # vector to store odd terms
  
  # Generate the Collatz sequence until we reach 1
  while (n != 1) {
    if (n %% 2 == 1) {          # odd term
      odds <- c(odds, n)
    }
    if (n %% 2 == 0) {          # even term
      n <- n / 2
    } else {                    # odd term
      n <- 3 * n + 1
    }
  }
  
  # Include the final 1
  odds <- c(odds, 1)
  
  # Return the sorted list of odd numbers
  sort(odds)
}
test_humaneval <- function() {
    candidate <- get_odd_collatz
    stopifnot(isTRUE(all.equal(candidate(14), c(1, 5, 7, 11, 13, 17))))
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 5))))
    stopifnot(isTRUE(all.equal(candidate(12), c(1, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183793
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.
# The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
# as follows: start with any positive integer n. Then each term is obtained from the 
# previous term as follows: if the previous term is even, the next term is one half of 
# the previous term. If the previous term is odd, the next term is 3 times the previous
# term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
# Note: 
#     1. Collatz(1) is [1].
#     2. returned list sorted in increasing order.
# For example:
# get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
# >>> get_odd_collatz(5)
# c(1, 5)
# get_odd_collatz returns a sorted numeric vector containing all odd numbers
# that appear in the Collatz sequence starting from the given positive integer n.
# The sequence is generated until it reaches 1, and the odd values are collected
# and returned in increasing order.
get_odd_collatz <- function(n) {
  if (!is.numeric(n) || length(n) != 1 || n <= 0 || n != floor(n)) {
    stop("n must be a positive integer")
  }
  
  odd_vals <- numeric(0)          # vector to hold odd numbers
  
  # Generate the Collatz sequence until we hit 1
  while (n > 1) {
    if (n %% 2 == 1) {            # if n is odd, store it
      odd_vals <- c(odd_vals, n)
    }
    # Next term in the sequence
    n <- if (n %% 2 == 0) n / 2 else 3 * n + 1
  }
  
  # 1 is always part of the sequence and is odd
  odd_vals <- c(odd_vals, 1)
  
  # Return the sorted, unique list of odd values
  sort(unique(odd_vals))
}
test_humaneval <- function() {
    candidate <- get_odd_collatz
    stopifnot(isTRUE(all.equal(candidate(14), c(1, 5, 7, 11, 13, 17))))
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 5))))
    stopifnot(isTRUE(all.equal(candidate(12), c(1, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183793
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.
# The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
# as follows: start with any positive integer n. Then each term is obtained from the 
# previous term as follows: if the previous term is even, the next term is one half of 
# the previous term. If the previous term is odd, the next term is 3 times the previous
# term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
# Note: 
#     1. Collatz(1) is [1].
#     2. returned list sorted in increasing order.
# For example:
# get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
# >>> get_odd_collatz(5)
# c(1, 5)
# Returns a sorted vector of the odd numbers that appear in the Collatz sequence
# starting from a positive integer `n`.
#
# Example:
#   get_odd_collatz(5)  # returns c(1, 5)
#
get_odd_collatz <- function(n) {
  # Input validation
  if (!is.numeric(n) || length(n) != 1 || n <= 0 || n != floor(n)) {
    stop("`n` must be a single positive integer")
  }
  
  odds <- numeric(0)   # vector to hold odd numbers
  current <- n
  
  repeat {
    # If the current number is odd, store it
    if (current %% 2 == 1) {
      odds <- c(odds, current)
    }
    
    # Stop when we reach 1
    if (current == 1) break
    
    # Apply the Collatz rule
    if (current %% 2 == 0) {
      current <- current / 2
    } else {
      current <- 3 * current + 1
    }
  }
  
  # Return the odd numbers sorted in ascending order
  sort(odds)
}
test_humaneval <- function() {
    candidate <- get_odd_collatz
    stopifnot(isTRUE(all.equal(candidate(14), c(1, 5, 7, 11, 13, 17))))
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 5))))
    stopifnot(isTRUE(all.equal(candidate(12), c(1, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183793
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.
# The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
# as follows: start with any positive integer n. Then each term is obtained from the 
# previous term as follows: if the previous term is even, the next term is one half of 
# the previous term. If the previous term is odd, the next term is 3 times the previous
# term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
# Note: 
#     1. Collatz(1) is [1].
#     2. returned list sorted in increasing order.
# For example:
# get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
# >>> get_odd_collatz(5)
# c(1, 5)
get_odd_collatz <- function(n) {
  # Validate input
  if (!is.numeric(n) || length(n) != 1 || n <= 0 || n != as.integer(n)) {
    stop("n must be a positive integer")
  }
  
  odds <- integer()   # vector to store odd numbers
  current <- n
  
  repeat {
    # Store odd numbers
    if (current %% 2 == 1) {
      odds <- c(odds, current)
    }
    
    # Stop when we reach 1
    if (current == 1) break
    
    # Compute next term in the Collatz sequence
    if (current %% 2 == 0) {
      current <- current / 2
    } else {
      current <- 3 * current + 1
    }
  }
  
  # Return sorted list of odd numbers
  sort(odds)
}
test_humaneval <- function() {
    candidate <- get_odd_collatz
    stopifnot(isTRUE(all.equal(candidate(14), c(1, 5, 7, 11, 13, 17))))
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 5))))
    stopifnot(isTRUE(all.equal(candidate(12), c(1, 3, 5))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183793
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 124 (R) - HumanEval_124_valid_date
================================================================================

PROMPT:
----------------------------------------
# You have to write a function which validates a given date string and
# returns TRUE if the date is valid otherwise FALSE.
# The date is valid if all of the following rules are satisfied:
# 1. The date string is not empty.
# 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
# 3. The months should not be less than 1 or higher than 12.
# 4. The date should be in the format: mm-dd-yyyy
# >>> valid_date('03-11-2000')
# TRUE
# >>> valid_date('15-01-2012')
# FALSE
# >>> valid_date('04-0-2040')
# FALSE
# >>> valid_date('06-04-2020')
# TRUE
# >>> valid_date('06/04/2020')
# FALSE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- valid_date
    stopifnot(isTRUE(all.equal(candidate('03-11-2000'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('15-01-2012'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-0-2040'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('06-04-2020'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('01-01-2007'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('03-32-2011'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-31-3000'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('06-06-2005'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('21-31-2000'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-12-2003'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('04122003'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('20030412'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2003-04'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2003-04-12'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-2003'), FALSE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# You have to write a function which validates a given date string and
# returns TRUE if the date is valid otherwise FALSE.
# The date is valid if all of the following rules are satisfied:
# 1. The date string is not empty.
# 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
# 3. The months should not be less than 1 or higher than 12.
# 4. The date should be in the format: mm-dd-yyyy
# >>> valid_date('03-11-2000')
# TRUE
# >>> valid_date('15-01-2012')
# FALSE
# >>> valid_date('04-0-2040')
# FALSE
# >>> valid_date('06-04-2020')
# TRUE
# >>> valid_date('06/04/2020')
# FALSE
valid_date <- function(date) {
  # 1. Check that the input is a non‑empty string
  if (is.null(date) || !is.character(date) || nchar(trimws(date)) == 0) {
    return(FALSE)
  }
  
  # Trim any surrounding whitespace
  date <- trimws(date)
  
  # 4. Ensure the format is mm-dd-yyyy (two digits for month/day, four for year)
  if (!grepl("^\\d{2}-\\d{2}-\\d{4}$", date)) {
    return(FALSE)
  }
  
  # Split the string into components
  parts <- strsplit(date, "-")[[1]]
  month <- as.integer(parts[1])
  day   <- as.integer(parts[2])
  year  <- as.integer(parts[3])   # year is not used for validation but we check it’s numeric
  
  # 3. Validate month range
  if (is.na(month) || month < 1 || month > 12) {
    return(FALSE)
  }
  
  # 2. Validate day range based on month
  if (month %in% c(1, 3, 5, 7, 8, 10, 12)) {
    if (is.na(day) || day < 1 || day > 31) return(FALSE)
  } else if (month %in% c(4, 6, 9, 11)) {
    if (is.na(day) || day < 1 || day > 30) return(FALSE)
  } else if (month == 2) {
    if (is.na(day) || day < 1 || day > 29) return(FALSE)
  }
  
  # All checks passed
  return(TRUE)
}
test_humaneval <- function() {
    candidate <- valid_date
    stopifnot(isTRUE(all.equal(candidate('03-11-2000'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('15-01-2012'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-0-2040'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('06-04-2020'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('01-01-2007'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('03-32-2011'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-31-3000'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('06-06-2005'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('21-31-2000'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-12-2003'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('04122003'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('20030412'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2003-04'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2003-04-12'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-2003'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183793
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# You have to write a function which validates a given date string and
# returns TRUE if the date is valid otherwise FALSE.
# The date is valid if all of the following rules are satisfied:
# 1. The date string is not empty.
# 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
# 3. The months should not be less than 1 or higher than 12.
# 4. The date should be in the format: mm-dd-yyyy
# >>> valid_date('03-11-2000')
# TRUE
# >>> valid_date('15-01-2012')
# FALSE
# >>> valid_date('04-0-2040')
# FALSE
# >>> valid_date('06-04-2020')
# TRUE
# >>> valid_date('06/04/2020')
# FALSE
valid_date <- function(date) {
  # 1. Check for non‑empty string
  if (is.null(date) || date == "") return(FALSE)
  
  # 4. Check format mm-dd-yyyy
  if (!grepl("^\\d{2}-\\d{2}-\\d{4}$", date)) return(FALSE)
  
  # Split into components
  parts <- strsplit(date, "-")[[1]]
  month <- as.integer(parts[1])
  day   <- as.integer(parts[2])
  # year <- as.integer(parts[3])  # year is not validated
  
  # 3. Validate month range
  if (is.na(month) || month < 1 || month > 12) return(FALSE)
  
  # 2. Validate day range based on month
  if (is.na(day) || day < 1) return(FALSE)
  
  max_day <- switch(as.character(month),
                    "1" = 31, "2" = 29, "3" = 31, "4" = 30,
                    "5" = 31, "6" = 30, "7" = 31, "8" = 31,
                    "9" = 30, "10" = 31, "11" = 30, "12" = 31)
  if (day > max_day) return(FALSE)
  
  TRUE
}
test_humaneval <- function() {
    candidate <- valid_date
    stopifnot(isTRUE(all.equal(candidate('03-11-2000'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('15-01-2012'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-0-2040'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('06-04-2020'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('01-01-2007'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('03-32-2011'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-31-3000'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('06-06-2005'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('21-31-2000'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-12-2003'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('04122003'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('20030412'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2003-04'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2003-04-12'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-2003'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183793
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# You have to write a function which validates a given date string and
# returns TRUE if the date is valid otherwise FALSE.
# The date is valid if all of the following rules are satisfied:
# 1. The date string is not empty.
# 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
# 3. The months should not be less than 1 or higher than 12.
# 4. The date should be in the format: mm-dd-yyyy
# >>> valid_date('03-11-2000')
# TRUE
# >>> valid_date('15-01-2012')
# FALSE
# >>> valid_date('04-0-2040')
# FALSE
# >>> valid_date('06-04-2020')
# TRUE
# >>> valid_date('06/04/2020')
# FALSE
valid_date <- function(date) {
  # 1. Date string must not be empty
  if (is.null(date) || nchar(date) == 0) {
    return(FALSE)
  }

  # 4. Date must match the pattern mm-dd-yyyy
  if (!grepl("^\\d{2}-\\d{2}-\\d{4}$", date)) {
    return(FALSE)
  }

  # Split the string into month, day, year
  parts <- strsplit(date, "-")[[1]]
  month <- as.integer(parts[1])
  day   <- as.integer(parts[2])
  year  <- as.integer(parts[3])

  # 3. Months must be between 1 and 12
  if (is.na(month) || month < 1 || month > 12) {
    return(FALSE)
  }

  # 2. Days must be in valid range for the month
  if (is.na(day) || day < 1) {
    return(FALSE)
  }

  if (month %in% c(1, 3, 5, 7, 8, 10, 12)) {
    if (day > 31) return(FALSE)
  } else if (month %in% c(4, 6, 9, 11)) {
    if (day > 30) return(FALSE)
  } else if (month == 2) {
    if (day > 29) return(FALSE)   # February: max 29 days (no leap‑year check needed)
  }

  # All checks passed
  return(TRUE)
}
test_humaneval <- function() {
    candidate <- valid_date
    stopifnot(isTRUE(all.equal(candidate('03-11-2000'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('15-01-2012'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-0-2040'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('06-04-2020'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('01-01-2007'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('03-32-2011'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-31-3000'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('06-06-2005'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('21-31-2000'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-12-2003'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('04122003'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('20030412'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2003-04'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2003-04-12'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-2003'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183793
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# You have to write a function which validates a given date string and
# returns TRUE if the date is valid otherwise FALSE.
# The date is valid if all of the following rules are satisfied:
# 1. The date string is not empty.
# 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
# 3. The months should not be less than 1 or higher than 12.
# 4. The date should be in the format: mm-dd-yyyy
# >>> valid_date('03-11-2000')
# TRUE
# >>> valid_date('15-01-2012')
# FALSE
# >>> valid_date('04-0-2040')
# FALSE
# >>> valid_date('06-04-2020')
# TRUE
# >>> valid_date('06/04/2020')
# FALSE
valid_date <- function(date) {
  # 1. Empty string check
  if (is.null(date) || nchar(date) == 0) return(FALSE)
  
  # 4. Format check: mm-dd-yyyy (two digits for month/day, four for year)
  # Regex explanation:
  #   ^(0[1-9]|1[0-2])   -> month 01-12
  #   -(0[1-9]|[12][0-9]|3[01]) -> day 01-31
  #   -(\\d{4})          -> year 0000-9999
  #   $                  -> end of string
  pattern <- "^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-(\\d{4})$"
  if (!grepl(pattern, date)) return(FALSE)
  
  # Extract components
  parts <- strsplit(date, "-")[[1]]
  month <- as.integer(parts[1])
  day   <- as.integer(parts[2])
  # year <- as.integer(parts[3])  # year is not used for validation
  
  # 3. Month bounds already enforced by regex, but keep for safety
  if (month < 1 || month > 12) return(FALSE)
  
  # 2. Day bounds per month
  if (month %in% c(1,3,5,7,8,10,12)) {
    if (day < 1 || day > 31) return(FALSE)
  } else if (month %in% c(4,6,9,11)) {
    if (day < 1 || day > 30) return(FALSE)
  } else if (month == 2) {
    if (day < 1 || day > 29) return(FALSE)
  }
  
  # All checks passed
  return(TRUE)
}
test_humaneval <- function() {
    candidate <- valid_date
    stopifnot(isTRUE(all.equal(candidate('03-11-2000'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('15-01-2012'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-0-2040'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('06-04-2020'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('01-01-2007'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('03-32-2011'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-31-3000'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('06-06-2005'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('21-31-2000'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-12-2003'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('04122003'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('20030412'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2003-04'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('2003-04-12'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('04-2003'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183793
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 126 (R) - HumanEval_126_is_sorted
================================================================================

PROMPT:
----------------------------------------
# Given a list of numbers, return whether or not they are sorted
# in ascending order. If list has more than 1 duplicate of the same
# number, return FALSE. Assume no negative numbers and only integers.
# Examples
# >>> is_sorted(c(5))
# TRUE
# >>> is_sorted(c(1, 2, 3, 4, 5))
# TRUE
# >>> is_sorted(c(1, 3, 2, 4, 5))
# FALSE
# >>> is_sorted(c(1, 2, 3, 4, 5, 6))
# TRUE
# >>> is_sorted(c(1, 2, 3, 4, 5, 6, 7))
# TRUE
# >>> is_sorted(c(1, 3, 2, 4, 5, 6, 7))
# FALSE
# >>> is_sorted(c(1, 2, 2, 3, 3, 4))
# TRUE
# >>> is_sorted(c(1, 2, 2, 2, 3, 4))
# FALSE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- is_sorted
    stopifnot(isTRUE(all.equal(candidate(c(5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 2, 3, 4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 3, 3, 4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 3, 3, 4)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), TRUE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given a list of numbers, return whether or not they are sorted
# in ascending order. If list has more than 1 duplicate of the same
# number, return FALSE. Assume no negative numbers and only integers.
# Examples
# >>> is_sorted(c(5))
# TRUE
# >>> is_sorted(c(1, 2, 3, 4, 5))
# TRUE
# >>> is_sorted(c(1, 3, 2, 4, 5))
# FALSE
# >>> is_sorted(c(1, 2, 3, 4, 5, 6))
# TRUE
# >>> is_sorted(c(1, 2, 3, 4, 5, 6, 7))
# TRUE
# >>> is_sorted(c(1, 3, 2, 4, 5, 6, 7))
# FALSE
# >>> is_sorted(c(1, 2, 2, 3, 3, 4))
# TRUE
# >>> is_sorted(c(1, 2, 2, 2, 3, 4))
# FALSE
is_sorted <- function(lst) {
  # Empty or single‑element list is trivially sorted
  if (length(lst) <= 1) return(TRUE)
  
  # Check that the list is non‑decreasing
  if (any(diff(lst) < 0)) return(FALSE)
  
  # Count occurrences of each number
  counts <- table(lst)
  
  # No number should appear more than twice
  if (any(counts > 2)) return(FALSE)
  
  TRUE
}
test_humaneval <- function() {
    candidate <- is_sorted
    stopifnot(isTRUE(all.equal(candidate(c(5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 2, 3, 4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 3, 3, 4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 3, 3, 4)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183794
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given a list of numbers, return whether or not they are sorted
# in ascending order. If list has more than 1 duplicate of the same
# number, return FALSE. Assume no negative numbers and only integers.
# Examples
# >>> is_sorted(c(5))
# TRUE
# >>> is_sorted(c(1, 2, 3, 4, 5))
# TRUE
# >>> is_sorted(c(1, 3, 2, 4, 5))
# FALSE
# >>> is_sorted(c(1, 2, 3, 4, 5, 6))
# TRUE
# >>> is_sorted(c(1, 2, 3, 4, 5, 6, 7))
# TRUE
# >>> is_sorted(c(1, 3, 2, 4, 5, 6, 7))
# FALSE
# >>> is_sorted(c(1, 2, 2, 3, 3, 4))
# TRUE
# >>> is_sorted(c(1, 2, 2, 2, 3, 4))
# FALSE
is_sorted <- function(lst) {
  # An empty list or a single element is trivially sorted
  if (length(lst) <= 1) return(TRUE)
  
  # 1. Check ascending order (non‑decreasing)
  if (!all(diff(lst) >= 0)) return(FALSE)
  
  # 2. Count occurrences of each value
  counts <- table(lst)
  
  # 3. Ensure no value appears more than twice
  if (any(counts > 2)) return(FALSE)
  
  # If both conditions pass, the list satisfies the requirements
  return(TRUE)
}
test_humaneval <- function() {
    candidate <- is_sorted
    stopifnot(isTRUE(all.equal(candidate(c(5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 2, 3, 4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 3, 3, 4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 3, 3, 4)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183794
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given a list of numbers, return whether or not they are sorted
# in ascending order. If list has more than 1 duplicate of the same
# number, return FALSE. Assume no negative numbers and only integers.
# Examples
# >>> is_sorted(c(5))
# TRUE
# >>> is_sorted(c(1, 2, 3, 4, 5))
# TRUE
# >>> is_sorted(c(1, 3, 2, 4, 5))
# FALSE
# >>> is_sorted(c(1, 2, 3, 4, 5, 6))
# TRUE
# >>> is_sorted(c(1, 2, 3, 4, 5, 6, 7))
# TRUE
# >>> is_sorted(c(1, 3, 2, 4, 5, 6, 7))
# FALSE
# >>> is_sorted(c(1, 2, 2, 3, 3, 4))
# TRUE
# >>> is_sorted(c(1, 2, 2, 2, 3, 4))
# FALSE
is_sorted <- function(lst) {
  # Empty or single element lists are considered sorted
  if (length(lst) <= 1) return(TRUE)

  # Check ascending order
  if (!all(diff(lst) >= 0)) return(FALSE)

  # Check that no value occurs more than twice
  if (any(table(lst) > 2)) return(FALSE)

  TRUE
}
test_humaneval <- function() {
    candidate <- is_sorted
    stopifnot(isTRUE(all.equal(candidate(c(5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 2, 3, 4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 3, 3, 4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 3, 3, 4)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183794
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given a list of numbers, return whether or not they are sorted
# in ascending order. If list has more than 1 duplicate of the same
# number, return FALSE. Assume no negative numbers and only integers.
# Examples
# >>> is_sorted(c(5))
# TRUE
# >>> is_sorted(c(1, 2, 3, 4, 5))
# TRUE
# >>> is_sorted(c(1, 3, 2, 4, 5))
# FALSE
# >>> is_sorted(c(1, 2, 3, 4, 5, 6))
# TRUE
# >>> is_sorted(c(1, 2, 3, 4, 5, 6, 7))
# TRUE
# >>> is_sorted(c(1, 3, 2, 4, 5, 6, 7))
# FALSE
# >>> is_sorted(c(1, 2, 2, 3, 3, 4))
# TRUE
# >>> is_sorted(c(1, 2, 2, 2, 3, 4))
# FALSE
is_sorted <- function(lst) {
  # Empty or single‑element vectors are trivially sorted
  if (length(lst) <= 1) return(TRUE)

  # 1. Check that the sequence is non‑decreasing (ascending)
  if (any(diff(lst) < 0)) return(FALSE)

  # 2. Count occurrences of each number
  counts <- table(lst)

  # 3. Ensure no number appears more than twice
  if (any(counts > 2)) return(FALSE)

  # All conditions satisfied
  TRUE
}
test_humaneval <- function() {
    candidate <- is_sorted
    stopifnot(isTRUE(all.equal(candidate(c(5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 2, 3, 4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 3, 3, 4)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 3, 3, 4)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183794
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 130 (R) - HumanEval_130_tri
================================================================================

PROMPT:
----------------------------------------
# Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
# the last couple centuries. However, what people don't know is Tribonacci sequence.
# Tribonacci sequence is defined by the recurrence:
# tri(1) = 3
# tri(n) = 1 + n / 2, if n is even.
# tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
# For example:
# tri(2) = 1 + (2 / 2) = 2
# tri(4) = 3
# tri(3) = tri(2) + tri(1) + tri(4)
#        = 2 + 3 + 3 = 8 
# You are given a non-negative integer number n, you have to a return a list of the 
# first n + 1 numbers of the Tribonacci sequence.
# Examples:
# >>> tri(3)
# c(1, 3, 2, 8)

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- tri
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 3, 2, 8))))
    stopifnot(isTRUE(all.equal(candidate(4), c(1, 3, 2, 8, 3))))
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 3, 2, 8, 3, 15))))
    stopifnot(isTRUE(all.equal(candidate(6), c(1, 3, 2, 8, 3, 15, 4))))
    stopifnot(isTRUE(all.equal(candidate(7), c(1, 3, 2, 8, 3, 15, 4, 24))))
    stopifnot(isTRUE(all.equal(candidate(8), c(1, 3, 2, 8, 3, 15, 4, 24, 5))))
    stopifnot(isTRUE(all.equal(candidate(9), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35))))
    stopifnot(isTRUE(all.equal(candidate(20), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11))))
    stopifnot(isTRUE(all.equal(candidate(0), c(1))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1, 3))))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
# the last couple centuries. However, what people don't know is Tribonacci sequence.
# Tribonacci sequence is defined by the recurrence:
# tri(1) = 3
# tri(n) = 1 + n / 2, if n is even.
# tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
# For example:
# tri(2) = 1 + (2 / 2) = 2
# tri(4) = 3
# tri(3) = tri(2) + tri(1) + tri(4)
#        = 2 + 3 + 3 = 8 
# You are given a non-negative integer number n, you have to a return a list of the 
# first n + 1 numbers of the Tribonacci sequence.
# Examples:
# >>> tri(3)
# c(1, 3, 2, 8)
#' Compute the first n+1 Tribonacci numbers
#'
#' @param n A non‑negative integer.
#' @return A numeric vector of length n+1 containing tri(0), tri(1), …, tri(n).
#' @examples
#' tri(3)   # returns c(1, 3, 2, 8)
#' tri(0)   # returns c(1)
#' tri(10)
#' @export
tri <- function(n) {
  if (!is.numeric(n) || length(n) != 1 || n < 0 || floor(n) != n) {
    stop("n must be a non‑negative integer")
  }
  
  # Cache for memoisation
  cache <- new.env(parent = emptyenv())
  
  # Helper to compute tri(k) recursively
  getTri <- function(k) {
    key <- as.character(k)
    if (exists(key, envir = cache, inherits = FALSE)) {
      return(get(key, envir = cache, inherits = FALSE))
    }
    
    # Base cases
    if (k == 0) {
      val <- 1
    } else if (k == 1) {
      val <- 3
    } else if (k == 2) {
      val <- 2
    } else if (k %% 2 == 0) {          # even k
      val <- 1 + k / 2
    } else {                           # odd k
      # For odd k we need tri(k+1) first
      val <- getTri(k - 1) + getTri(k - 2) + getTri(k + 1)
    }
    
    assign(key, val, envir = cache)
    val
  }
  
  # Build the result vector
  res <- numeric(n + 1)
  for (i in 0:n) {
    res[i + 1] <- getTri(i)
  }
  res
}
test_humaneval <- function() {
    candidate <- tri
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 3, 2, 8))))
    stopifnot(isTRUE(all.equal(candidate(4), c(1, 3, 2, 8, 3))))
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 3, 2, 8, 3, 15))))
    stopifnot(isTRUE(all.equal(candidate(6), c(1, 3, 2, 8, 3, 15, 4))))
    stopifnot(isTRUE(all.equal(candidate(7), c(1, 3, 2, 8, 3, 15, 4, 24))))
    stopifnot(isTRUE(all.equal(candidate(8), c(1, 3, 2, 8, 3, 15, 4, 24, 5))))
    stopifnot(isTRUE(all.equal(candidate(9), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35))))
    stopifnot(isTRUE(all.equal(candidate(20), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11))))
    stopifnot(isTRUE(all.equal(candidate(0), c(1))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1, 3))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183797
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
# the last couple centuries. However, what people don't know is Tribonacci sequence.
# Tribonacci sequence is defined by the recurrence:
# tri(1) = 3
# tri(n) = 1 + n / 2, if n is even.
# tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
# For example:
# tri(2) = 1 + (2 / 2) = 2
# tri(4) = 3
# tri(3) = tri(2) + tri(1) + tri(4)
#        = 2 + 3 + 3 = 8 
# You are given a non-negative integer number n, you have to a return a list of the 
# first n + 1 numbers of the Tribonacci sequence.
# Examples:
# >>> tri(3)
# c(1, 3, 2, 8)
tri <- function(n) {
  # We need to compute up to n+1 to satisfy the recurrence for odd n
  seq <- numeric(n + 2)          # indices 1:(n+2) correspond to tri(0) … tri(n+1)
  
  for (k in 0:n) {
    if (k == 1) {                # base case tri(1) = 3
      seq[2] <- 3
    } else if (k %% 2 == 0) {    # even k: tri(k) = 1 + k/2
      seq[k + 1] <- 1 + k/2
    } else {                     # odd k > 1: tri(k) = tri(k-1)+tri(k-2)+tri(k+1)
      # tri(k+1) is even, so we can compute it now
      seq[k + 2] <- 1 + (k + 1)/2
      seq[k + 1] <- seq[k] + seq[k - 1] + seq[k + 2]
    }
  }
  
  # Return the first n+1 numbers (tri(0) … tri(n))
  seq[1:(n + 1)]
}
test_humaneval <- function() {
    candidate <- tri
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 3, 2, 8))))
    stopifnot(isTRUE(all.equal(candidate(4), c(1, 3, 2, 8, 3))))
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 3, 2, 8, 3, 15))))
    stopifnot(isTRUE(all.equal(candidate(6), c(1, 3, 2, 8, 3, 15, 4))))
    stopifnot(isTRUE(all.equal(candidate(7), c(1, 3, 2, 8, 3, 15, 4, 24))))
    stopifnot(isTRUE(all.equal(candidate(8), c(1, 3, 2, 8, 3, 15, 4, 24, 5))))
    stopifnot(isTRUE(all.equal(candidate(9), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35))))
    stopifnot(isTRUE(all.equal(candidate(20), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11))))
    stopifnot(isTRUE(all.equal(candidate(0), c(1))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1, 3))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183797
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
# the last couple centuries. However, what people don't know is Tribonacci sequence.
# Tribonacci sequence is defined by the recurrence:
# tri(1) = 3
# tri(n) = 1 + n / 2, if n is even.
# tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
# For example:
# tri(2) = 1 + (2 / 2) = 2
# tri(4) = 3
# tri(3) = tri(2) + tri(1) + tri(4)
#        = 2 + 3 + 3 = 8 
# You are given a non-negative integer number n, you have to a return a list of the 
# first n + 1 numbers of the Tribonacci sequence.
# Examples:
# >>> tri(3)
# c(1, 3, 2, 8)
tri <- function(n) {
  # Ensure n is a non‑negative integer
  if (!is.numeric(n) || length(n) != 1 || n < 0 || floor(n) != n) {
    stop("n must be a non‑negative integer")
  }
  
  # Create a vector of length n+1 (indices 0 … n)
  res <- numeric(n + 1)
  
  # Base cases
  res[1] <- 1  # tri(0)
  if (n >= 1) res[2] <- 3  # tri(1)
  
  # Compute remaining terms
  if (n >= 2) {
    for (i in 2:n) {          # i corresponds to n in the recurrence
      if (i %% 2 == 0) {      # even
        res[i + 1] <- 1 + i / 2
      } else {                # odd
        # tri(i) uses tri(i+1) which is even, so we can compute it on the fly
        next_even <- i + 1
        val_next_even <- 1 + next_even / 2
        res[i + 1] <- res[i] + res[i - 1] + val_next_even
      }
    }
  }
  
  # Return the vector of length n+1 (tri(0) … tri(n))
  return(res)
}
test_humaneval <- function() {
    candidate <- tri
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 3, 2, 8))))
    stopifnot(isTRUE(all.equal(candidate(4), c(1, 3, 2, 8, 3))))
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 3, 2, 8, 3, 15))))
    stopifnot(isTRUE(all.equal(candidate(6), c(1, 3, 2, 8, 3, 15, 4))))
    stopifnot(isTRUE(all.equal(candidate(7), c(1, 3, 2, 8, 3, 15, 4, 24))))
    stopifnot(isTRUE(all.equal(candidate(8), c(1, 3, 2, 8, 3, 15, 4, 24, 5))))
    stopifnot(isTRUE(all.equal(candidate(9), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35))))
    stopifnot(isTRUE(all.equal(candidate(20), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11))))
    stopifnot(isTRUE(all.equal(candidate(0), c(1))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1, 3))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183797
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
# the last couple centuries. However, what people don't know is Tribonacci sequence.
# Tribonacci sequence is defined by the recurrence:
# tri(1) = 3
# tri(n) = 1 + n / 2, if n is even.
# tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
# For example:
# tri(2) = 1 + (2 / 2) = 2
# tri(4) = 3
# tri(3) = tri(2) + tri(1) + tri(4)
#        = 2 + 3 + 3 = 8 
# You are given a non-negative integer number n, you have to a return a list of the 
# first n + 1 numbers of the Tribonacci sequence.
# Examples:
# >>> tri(3)
# c(1, 3, 2, 8)
#' Compute the first n+1 Tribonacci numbers.
#'
#' @param n Non‑negative integer.
#' @return Numeric vector of length n+1 containing tri(0), tri(1), …, tri(n).
#' @examples
#' tri(3)   # returns c(1, 3, 2, 8)
#' tri(0)   # returns c(1)
#' tri(5)   # returns c(1, 3, 2, 8, 3, 4)
tri <- function(n) {
  # Environment used as a memoisation cache
  memo <- new.env(parent = emptyenv())

  # Recursive helper that returns tri(k)
  get_tri <- function(k) {
    key <- as.character(k)
    if (exists(key, envir = memo, inherits = FALSE)) {
      return(memo[[key]])
    }

    # Base cases
    if (k == 0) {
      val <- 1
    } else if (k == 1) {
      val <- 3
    } else if (k %% 2 == 0) {          # even k
      val <- 1 + k / 2
    } else {                           # odd k
      # k is odd → k+1 is even, so we can compute it directly
      val_k1 <- get_tri(k + 1)         # tri(k+1)
      val_k_1 <- get_tri(k - 1)        # tri(k-1) (even)
      val_k_2 <- get_tri(k - 2)        # tri(k-2) (may be odd or base)
      val <- val_k_1 + val_k_2 + val_k1
    }

    memo[[key]] <- val
    return(val)
  }

  # Build the result vector
  res <- numeric(n + 1)
  for (i in 0:n) {
    res[i + 1] <- get_tri(i)
  }
  res
}
test_humaneval <- function() {
    candidate <- tri
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 3, 2, 8))))
    stopifnot(isTRUE(all.equal(candidate(4), c(1, 3, 2, 8, 3))))
    stopifnot(isTRUE(all.equal(candidate(5), c(1, 3, 2, 8, 3, 15))))
    stopifnot(isTRUE(all.equal(candidate(6), c(1, 3, 2, 8, 3, 15, 4))))
    stopifnot(isTRUE(all.equal(candidate(7), c(1, 3, 2, 8, 3, 15, 4, 24))))
    stopifnot(isTRUE(all.equal(candidate(8), c(1, 3, 2, 8, 3, 15, 4, 24, 5))))
    stopifnot(isTRUE(all.equal(candidate(9), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35))))
    stopifnot(isTRUE(all.equal(candidate(20), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11))))
    stopifnot(isTRUE(all.equal(candidate(0), c(1))))
    stopifnot(isTRUE(all.equal(candidate(1), c(1, 3))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183797
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 131 (R) - HumanEval_131_digits
================================================================================

PROMPT:
----------------------------------------
# Given a positive integer n, return the product of the odd digits.
# Return 0 if all digits are even.
# For example:
# >>> digits(1)
# 1
# >>> digits(4)
# 0
# >>> digits(235)
# 15

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- digits
    stopifnot(isTRUE(all.equal(candidate(5), 5)))
    stopifnot(isTRUE(all.equal(candidate(54), 5)))
    stopifnot(isTRUE(all.equal(candidate(120), 1)))
    stopifnot(isTRUE(all.equal(candidate(5014), 5)))
    stopifnot(isTRUE(all.equal(candidate(98765), 315)))
    stopifnot(isTRUE(all.equal(candidate(5576543), 2625)))
    stopifnot(isTRUE(all.equal(candidate(2468), 0)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given a positive integer n, return the product of the odd digits.
# Return 0 if all digits are even.
# For example:
# >>> digits(1)
# 1
# >>> digits(4)
# 0
# >>> digits(235)
# 15
digits <- function(n) {
  # Split the number into its individual digits
  d <- as.integer(strsplit(as.character(n), "")[[1]])
  
  # Keep only the odd digits
  odd <- d[d %% 2 == 1]
  
  # If there are no odd digits, return 0; otherwise return their product
  if (length(odd) == 0) {
    0
  } else {
    prod(odd)
  }
}
test_humaneval <- function() {
    candidate <- digits
    stopifnot(isTRUE(all.equal(candidate(5), 5)))
    stopifnot(isTRUE(all.equal(candidate(54), 5)))
    stopifnot(isTRUE(all.equal(candidate(120), 1)))
    stopifnot(isTRUE(all.equal(candidate(5014), 5)))
    stopifnot(isTRUE(all.equal(candidate(98765), 315)))
    stopifnot(isTRUE(all.equal(candidate(5576543), 2625)))
    stopifnot(isTRUE(all.equal(candidate(2468), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183797
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given a positive integer n, return the product of the odd digits.
# Return 0 if all digits are even.
# For example:
# >>> digits(1)
# 1
# >>> digits(4)
# 0
# >>> digits(235)
# 15
digits <- function(n) {
  # Convert the number to a character vector of its digits
  digits_vec <- as.integer(strsplit(as.character(n), "")[[1]])
  
  # Keep only the odd digits
  odd_digits <- digits_vec[digits_vec %% 2 == 1]
  
  # If there are no odd digits, return 0; otherwise return the product
  if (length(odd_digits) == 0) {
    return(0)
  } else {
    return(prod(odd_digits))
  }
}
test_humaneval <- function() {
    candidate <- digits
    stopifnot(isTRUE(all.equal(candidate(5), 5)))
    stopifnot(isTRUE(all.equal(candidate(54), 5)))
    stopifnot(isTRUE(all.equal(candidate(120), 1)))
    stopifnot(isTRUE(all.equal(candidate(5014), 5)))
    stopifnot(isTRUE(all.equal(candidate(98765), 315)))
    stopifnot(isTRUE(all.equal(candidate(5576543), 2625)))
    stopifnot(isTRUE(all.equal(candidate(2468), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183797
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given a positive integer n, return the product of the odd digits.
# Return 0 if all digits are even.
# For example:
# >>> digits(1)
# 1
# >>> digits(4)
# 0
# >>> digits(235)
# 15
digits <- function(n) {
  # Convert number to a vector of its digits
  d <- as.integer(strsplit(as.character(n), "")[[1]])
  
  # Keep only the odd digits
  odd_digits <- d[d %% 2 == 1]
  
  # If there are no odd digits, return 0; otherwise return their product
  if (length(odd_digits) == 0) {
    return(0)
  } else {
    return(prod(odd_digits))
  }
}
test_humaneval <- function() {
    candidate <- digits
    stopifnot(isTRUE(all.equal(candidate(5), 5)))
    stopifnot(isTRUE(all.equal(candidate(54), 5)))
    stopifnot(isTRUE(all.equal(candidate(120), 1)))
    stopifnot(isTRUE(all.equal(candidate(5014), 5)))
    stopifnot(isTRUE(all.equal(candidate(98765), 315)))
    stopifnot(isTRUE(all.equal(candidate(5576543), 2625)))
    stopifnot(isTRUE(all.equal(candidate(2468), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183797
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given a positive integer n, return the product of the odd digits.
# Return 0 if all digits are even.
# For example:
# >>> digits(1)
# 1
# >>> digits(4)
# 0
# >>> digits(235)
# 15
digits <- function(n) {
  # Convert the number to a character string and split into individual digits
  digit_vec <- as.integer(strsplit(as.character(n), "")[[1]])
  
  # Keep only the odd digits
  odd_digits <- digit_vec[digit_vec %% 2 == 1]
  
  # If there are no odd digits, return 0; otherwise return their product
  if (length(odd_digits) == 0) {
    return(0)
  } else {
    return(prod(odd_digits))
  }
}
test_humaneval <- function() {
    candidate <- digits
    stopifnot(isTRUE(all.equal(candidate(5), 5)))
    stopifnot(isTRUE(all.equal(candidate(54), 5)))
    stopifnot(isTRUE(all.equal(candidate(120), 1)))
    stopifnot(isTRUE(all.equal(candidate(5014), 5)))
    stopifnot(isTRUE(all.equal(candidate(98765), 315)))
    stopifnot(isTRUE(all.equal(candidate(5576543), 2625)))
    stopifnot(isTRUE(all.equal(candidate(2468), 0)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183797
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 133 (R) - HumanEval_133_sum_squares
================================================================================

PROMPT:
----------------------------------------
# You are given a list of numbers.
# You need to return the sum of squared numbers in the given list,
# round each element in the list to the upper int(Ceiling) first.
# Examples:
# >>> lst(c(1.0, 2.0, 3.0))
# 14
# >>> lst(c(1.0, 4.0, 9.0))
# 98
# >>> lst(c(1.0, 3.0, 5.0, 7.0))
# 84
# >>> lst(c(1.4, 4.2, 0.0))
# 29
# >>> lst(c(-2.4, 1.0, 1.0))
# 6

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- sum_squares
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 3.0, 5.0, 7.0)), 84)))
    stopifnot(isTRUE(all.equal(candidate(c(1.4, 4.2, 0.0)), 29)))
    stopifnot(isTRUE(all.equal(candidate(c(-2.4, 1.0, 1.0)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(100.0, 1.0, 15.0, 2.0)), 10230)))
    stopifnot(isTRUE(all.equal(candidate(c(10000.0, 10000.0)), 200000000)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 4.6, 6.3)), 75)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 17.9, 18.9, 19.9)), 1086)))
    stopifnot(isTRUE(all.equal(candidate(c(0.0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0, 1.0, 0.0)), 2)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# You are given a list of numbers.
# You need to return the sum of squared numbers in the given list,
# round each element in the list to the upper int(Ceiling) first.
# Examples:
# >>> lst(c(1.0, 2.0, 3.0))
# 14
# >>> lst(c(1.0, 4.0, 9.0))
# 98
# >>> lst(c(1.0, 3.0, 5.0, 7.0))
# 84
# >>> lst(c(1.4, 4.2, 0.0))
# 29
# >>> lst(c(-2.4, 1.0, 1.0))
# 6
sum_squares <- function(lst) {
  # Round each element up to the nearest integer,
  # square the result, and sum all squared values.
  sum(ceiling(lst)^2)
}
test_humaneval <- function() {
    candidate <- sum_squares
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 3.0, 5.0, 7.0)), 84)))
    stopifnot(isTRUE(all.equal(candidate(c(1.4, 4.2, 0.0)), 29)))
    stopifnot(isTRUE(all.equal(candidate(c(-2.4, 1.0, 1.0)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(100.0, 1.0, 15.0, 2.0)), 10230)))
    stopifnot(isTRUE(all.equal(candidate(c(10000.0, 10000.0)), 200000000)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 4.6, 6.3)), 75)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 17.9, 18.9, 19.9)), 1086)))
    stopifnot(isTRUE(all.equal(candidate(c(0.0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0, 1.0, 0.0)), 2)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183798
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# You are given a list of numbers.
# You need to return the sum of squared numbers in the given list,
# round each element in the list to the upper int(Ceiling) first.
# Examples:
# >>> lst(c(1.0, 2.0, 3.0))
# 14
# >>> lst(c(1.0, 4.0, 9.0))
# 98
# >>> lst(c(1.0, 3.0, 5.0, 7.0))
# 84
# >>> lst(c(1.4, 4.2, 0.0))
# 29
# >>> lst(c(-2.4, 1.0, 1.0))
# 6
sum_squares <- function(lst) {
  sum(ceiling(lst)^2)
}
test_humaneval <- function() {
    candidate <- sum_squares
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 3.0, 5.0, 7.0)), 84)))
    stopifnot(isTRUE(all.equal(candidate(c(1.4, 4.2, 0.0)), 29)))
    stopifnot(isTRUE(all.equal(candidate(c(-2.4, 1.0, 1.0)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(100.0, 1.0, 15.0, 2.0)), 10230)))
    stopifnot(isTRUE(all.equal(candidate(c(10000.0, 10000.0)), 200000000)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 4.6, 6.3)), 75)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 17.9, 18.9, 19.9)), 1086)))
    stopifnot(isTRUE(all.equal(candidate(c(0.0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0, 1.0, 0.0)), 2)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183798
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# You are given a list of numbers.
# You need to return the sum of squared numbers in the given list,
# round each element in the list to the upper int(Ceiling) first.
# Examples:
# >>> lst(c(1.0, 2.0, 3.0))
# 14
# >>> lst(c(1.0, 4.0, 9.0))
# 98
# >>> lst(c(1.0, 3.0, 5.0, 7.0))
# 84
# >>> lst(c(1.4, 4.2, 0.0))
# 29
# >>> lst(c(-2.4, 1.0, 1.0))
# 6
sum_squares <- function(lst) {
  # Apply ceiling to each element, square the result, and sum them
  sum((ceiling(lst))^2)
}
test_humaneval <- function() {
    candidate <- sum_squares
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 3.0, 5.0, 7.0)), 84)))
    stopifnot(isTRUE(all.equal(candidate(c(1.4, 4.2, 0.0)), 29)))
    stopifnot(isTRUE(all.equal(candidate(c(-2.4, 1.0, 1.0)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(100.0, 1.0, 15.0, 2.0)), 10230)))
    stopifnot(isTRUE(all.equal(candidate(c(10000.0, 10000.0)), 200000000)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 4.6, 6.3)), 75)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 17.9, 18.9, 19.9)), 1086)))
    stopifnot(isTRUE(all.equal(candidate(c(0.0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0, 1.0, 0.0)), 2)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183798
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# You are given a list of numbers.
# You need to return the sum of squared numbers in the given list,
# round each element in the list to the upper int(Ceiling) first.
# Examples:
# >>> lst(c(1.0, 2.0, 3.0))
# 14
# >>> lst(c(1.0, 4.0, 9.0))
# 98
# >>> lst(c(1.0, 3.0, 5.0, 7.0))
# 84
# >>> lst(c(1.4, 4.2, 0.0))
# 29
# >>> lst(c(-2.4, 1.0, 1.0))
# 6
sum_squares <- function(lst) {
  sum((ceiling(lst))^2)
}
test_humaneval <- function() {
    candidate <- sum_squares
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 3.0, 5.0, 7.0)), 84)))
    stopifnot(isTRUE(all.equal(candidate(c(1.4, 4.2, 0.0)), 29)))
    stopifnot(isTRUE(all.equal(candidate(c(-2.4, 1.0, 1.0)), 6)))
    stopifnot(isTRUE(all.equal(candidate(c(100.0, 1.0, 15.0, 2.0)), 10230)))
    stopifnot(isTRUE(all.equal(candidate(c(10000.0, 10000.0)), 200000000)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 4.6, 6.3)), 75)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 17.9, 18.9, 19.9)), 1086)))
    stopifnot(isTRUE(all.equal(candidate(c(0.0)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(-1.0, 1.0, 0.0)), 2)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183798
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 135 (R) - HumanEval_135_can_arrange
================================================================================

PROMPT:
----------------------------------------
# Create a function which returns the largest index of an element which
# is not greater than or equal to the element immediately preceding it. If
# no such element exists then return -1. The given vector will not contain
# duplicate values.
# Examples:
# >>> can_arrange(c(1, 2, 4, 3, 5))
# 3
# >>> can_arrange(c(1, 2, 3))
# -1

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- can_arrange
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 3, 5)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 5)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2, 5, 6, 7, 8, 9, 10)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 8, 5, 7, 3)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c()), -1)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Create a function which returns the largest index of an element which
# is not greater than or equal to the element immediately preceding it. If
# no such element exists then return -1. The given vector will not contain
# duplicate values.
# Examples:
# >>> can_arrange(c(1, 2, 4, 3, 5))
# 3
# >>> can_arrange(c(1, 2, 3))
# -1
# Create a function which returns the largest index of an element which
# is not greater than or equal to the element immediately preceding it.
# If no such element exists then return -1. The given vector will not contain
# duplicate values.
# Examples:
# >>> can_arrange(c(1, 2, 4, 3, 5))
# 3
# >>> can_arrange(c(1, 2, 3))
# -1
can_arrange <- function(arr) {
  n <- length(arr)
  if (n <= 1) {
    return(-1)
  }
  # Compare each element with its predecessor
  cond <- arr[-1] < arr[-n]
  # Indices relative to the second element onward
  idx <- which(cond)
  if (length(idx) == 0) {
    return(-1)
  }
  # idx already gives the zero‑based index (since R indices start at 1)
  # and we want the largest such index.
  return(max(idx))
}
test_humaneval <- function() {
    candidate <- can_arrange
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 3, 5)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 5)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2, 5, 6, 7, 8, 9, 10)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 8, 5, 7, 3)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c()), -1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183799
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Create a function which returns the largest index of an element which
# is not greater than or equal to the element immediately preceding it. If
# no such element exists then return -1. The given vector will not contain
# duplicate values.
# Examples:
# >>> can_arrange(c(1, 2, 4, 3, 5))
# 3
# >>> can_arrange(c(1, 2, 3))
# -1
# Create a function which returns the largest index of an element which
# is not greater than or equal to the element immediately preceding it. If
# no such element exists then return -1. The given vector will not contain
# duplicate values.
# Examples:
# >>> can_arrange(c(1, 2, 4, 3, 5))
# 3
# >>> can_arrange(c(1, 2, 3))
# -1
can_arrange <- function(arr) {
  # If there are fewer than 2 elements, no comparison is possible
  if (length(arr) < 2) {
    return(-1)
  }
  
  # Find indices (0‑based) where the element is strictly less than its predecessor
  # arr[-1] is the vector starting from the second element,
  # arr[-length(arr)] is the vector ending at the second‑to‑last element.
  # The indices returned by which() are 1‑based relative to arr[-1], i.e.
  # they correspond to the 0‑based indices we want.
  idx <- which(arr[-1] < arr[-length(arr)])
  
  # If no such index exists, return -1
  if (length(idx) == 0) {
    return(-1)
  }
  
  # Return the largest such index
  return(max(idx))
}
test_humaneval <- function() {
    candidate <- can_arrange
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 3, 5)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 5)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2, 5, 6, 7, 8, 9, 10)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 8, 5, 7, 3)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c()), -1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183799
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Create a function which returns the largest index of an element which
# is not greater than or equal to the element immediately preceding it. If
# no such element exists then return -1. The given vector will not contain
# duplicate values.
# Examples:
# >>> can_arrange(c(1, 2, 4, 3, 5))
# 3
# >>> can_arrange(c(1, 2, 3))
# -1
can_arrange <- function(arr) {
  # Return the largest 0‑based index of an element that is *strictly* less
  # than its immediate predecessor. If no such element exists, return -1.
  #
  # Example:
  #   arr = c(1, 2, 4, 3, 5)
  #   indices (0‑based) that satisfy arr[i] < arr[i-1]: 3
  #   (because arr[4] == 3 < arr[3] == 4)
  #
  # Edge cases:
  #   • If arr has fewer than 2 elements, there is no predecessor to compare,
  #     so we return -1.
  #   • The function works for any numeric vector (no duplicates are assumed
  #     but the logic would still hold).

  n <- length(arr)
  if (n < 2) {
    return(-1L)
  }

  # Track the largest 0‑based index found
  max_idx <- -1L

  # Iterate over 1‑based indices 2..n (i.e., positions with a predecessor)
  for (i in 2:n) {
    if (arr[i] < arr[i - 1]) {
      # Convert to 0‑based index: i-1
      idx0 <- i - 1L
      if (idx0 > max_idx) {
        max_idx <- idx0
      }
    }
  }

  return(max_idx)
}
test_humaneval <- function() {
    candidate <- can_arrange
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 3, 5)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 5)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2, 5, 6, 7, 8, 9, 10)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 8, 5, 7, 3)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c()), -1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183799
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Create a function which returns the largest index of an element which
# is not greater than or equal to the element immediately preceding it. If
# no such element exists then return -1. The given vector will not contain
# duplicate values.
# Examples:
# >>> can_arrange(c(1, 2, 4, 3, 5))
# 3
# >>> can_arrange(c(1, 2, 3))
# -1
# Create a function which returns the largest index of an element which
# is not greater than or equal to the element immediately preceding it.
# If no such element exists then return -1. The given vector will not contain
# duplicate values.
#
# Examples:
# >>> can_arrange(c(1, 2, 4, 3, 5))
# 3
# >>> can_arrange(c(1, 2, 3))
# -1
can_arrange <- function(arr) {
  n <- length(arr)
  if (n <= 1) {
    return(-1)
  }
  # Search from the end for the first index where arr[i] < arr[i-1]
  for (i in seq(n, 2)) {
    if (arr[i] < arr[i - 1]) {
      # Return 0‑based index: i-1
      return(i - 1)
    }
  }
  return(-1)
}
test_humaneval <- function() {
    candidate <- can_arrange
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 3, 5)), 3)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 5)), -1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2, 5, 6, 7, 8, 9, 10)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(4, 8, 5, 7, 3)), 4)))
    stopifnot(isTRUE(all.equal(candidate(c()), -1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183799
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 137 (R) - HumanEval_137_compare_one
================================================================================

PROMPT:
----------------------------------------
# Create a function that takes integers, floats, or strings representing
# real numbers, and returns the larger variable in its given variable type.
# Return NULL if the values are equal.
# Note: If a real number is represented as a string, the floating point might be . or ,
# >>> compare_one(1, 2.5)
# 2.5
# >>> compare_one(1, '2,3')
# '2,3'
# >>> compare_one('5,1', '6')
# '6'
# >>> compare_one('1', 1)
# NULL

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- compare_one
    stopifnot(isTRUE(all.equal(candidate(1, 2), 2)))
    stopifnot(isTRUE(all.equal(candidate(1, 2.5), 2.5)))
    stopifnot(isTRUE(all.equal(candidate(2, 3), 3)))
    stopifnot(isTRUE(all.equal(candidate(5, 6), 6)))
    stopifnot(isTRUE(all.equal(candidate(1, '2,3'), '2,3')))
    stopifnot(isTRUE(all.equal(candidate('5,1', '6'), '6')))
    stopifnot(isTRUE(all.equal(candidate('1', '2'), '2')))
    stopifnot(isTRUE(all.equal(candidate('1', 1), NULL)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Create a function that takes integers, floats, or strings representing
# real numbers, and returns the larger variable in its given variable type.
# Return NULL if the values are equal.
# Note: If a real number is represented as a string, the floating point might be . or ,
# >>> compare_one(1, 2.5)
# 2.5
# >>> compare_one(1, '2,3')
# '2,3'
# >>> compare_one('5,1', '6')
# '6'
# >>> compare_one('1', 1)
# NULL
compare_one <- function(a, b) {
  # Helper to extract numeric value and keep original representation
  get_value <- function(x) {
    if (is.character(x)) {
      # Replace comma with dot for decimal separator
      num_str <- gsub(",", ".", x, fixed = TRUE)
      val <- as.numeric(num_str)
      list(val = val, orig = x)
    } else if (is.numeric(x) || is.integer(x)) {
      list(val = as.numeric(x), orig = x)
    } else {
      stop("Unsupported type: only numeric or character values are allowed.")
    }
  }
  
  va <- get_value(a)
  vb <- get_value(b)
  
  # If either conversion failed, treat as NA (no comparison possible)
  if (is.na(va$val) || is.na(vb$val)) {
    return(NULL)
  }
  
  if (va$val > vb$val) {
    return(va$orig)
  } else if (va$val < vb$val) {
    return(vb$orig)
  } else {
    # Values are equal
    return(NULL)
  }
}
test_humaneval <- function() {
    candidate <- compare_one
    stopifnot(isTRUE(all.equal(candidate(1, 2), 2)))
    stopifnot(isTRUE(all.equal(candidate(1, 2.5), 2.5)))
    stopifnot(isTRUE(all.equal(candidate(2, 3), 3)))
    stopifnot(isTRUE(all.equal(candidate(5, 6), 6)))
    stopifnot(isTRUE(all.equal(candidate(1, '2,3'), '2,3')))
    stopifnot(isTRUE(all.equal(candidate('5,1', '6'), '6')))
    stopifnot(isTRUE(all.equal(candidate('1', '2'), '2')))
    stopifnot(isTRUE(all.equal(candidate('1', 1), NULL)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183800
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Create a function that takes integers, floats, or strings representing
# real numbers, and returns the larger variable in its given variable type.
# Return NULL if the values are equal.
# Note: If a real number is represented as a string, the floating point might be . or ,
# >>> compare_one(1, 2.5)
# 2.5
# >>> compare_one(1, '2,3')
# '2,3'
# >>> compare_one('5,1', '6')
# '6'
# >>> compare_one('1', 1)
# NULL
# Function to compare two values that may be numeric or character strings
# representing real numbers.  The function returns the larger value in its
# original type, or NULL if they are equal.
compare_one <- function(a, b) {
  # Helper to convert a value to numeric for comparison
  to_num <- function(x) {
    if (is.character(x)) {
      # Replace comma decimal separator with dot, then convert
      as.numeric(gsub(",", ".", x))
    } else {
      as.numeric(x)
    }
  }

  # Convert both arguments to numeric
  num_a <- to_num(a)
  num_b <- to_num(b)

  # If the numeric values are equal, return NULL
  if (isTRUE(all.equal(num_a, num_b))) {
    return(NULL)
  }

  # Return the original value that corresponds to the larger numeric value
  if (num_a > num_b) {
    return(a)
  } else {
    return(b)
  }
}
test_humaneval <- function() {
    candidate <- compare_one
    stopifnot(isTRUE(all.equal(candidate(1, 2), 2)))
    stopifnot(isTRUE(all.equal(candidate(1, 2.5), 2.5)))
    stopifnot(isTRUE(all.equal(candidate(2, 3), 3)))
    stopifnot(isTRUE(all.equal(candidate(5, 6), 6)))
    stopifnot(isTRUE(all.equal(candidate(1, '2,3'), '2,3')))
    stopifnot(isTRUE(all.equal(candidate('5,1', '6'), '6')))
    stopifnot(isTRUE(all.equal(candidate('1', '2'), '2')))
    stopifnot(isTRUE(all.equal(candidate('1', 1), NULL)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183800
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Create a function that takes integers, floats, or strings representing
# real numbers, and returns the larger variable in its given variable type.
# Return NULL if the values are equal.
# Note: If a real number is represented as a string, the floating point might be . or ,
# >>> compare_one(1, 2.5)
# 2.5
# >>> compare_one(1, '2,3')
# '2,3'
# >>> compare_one('5,1', '6')
# '6'
# >>> compare_one('1', 1)
# NULL
# Create a function that takes integers, floats, or strings representing
# real numbers, and returns the larger variable in its given variable type.
# Return NULL if the values are equal.
# Note: If a real number is represented as a string, the floating point might be . or ,
# >>> compare_one(1, 2.5)
# 2.5
# >>> compare_one(1, '2,3')
# '2,3'
# >>> compare_one('5,1', '6')
# '6'
# >>> compare_one('1', 1)
# NULL
compare_one <- function(a, b) {
  # Helper: convert input to numeric for comparison
  to_num <- function(x) {
    if (is.numeric(x)) {
      return(x)
    } else if (is.character(x)) {
      # Replace comma with dot for decimal separator
      x_clean <- gsub(",", ".", x, fixed = TRUE)
      as.numeric(x_clean)
    } else {
      stop("Unsupported type: only numeric or character allowed")
    }
  }
  
  # Convert both inputs to numeric
  num_a <- to_num(a)
  num_b <- to_num(b)
  
  # Handle parsing errors
  if (is.na(num_a) || is.na(num_b)) {
    stop("Could not parse numeric values")
  }
  
  # Compare numeric values
  if (num_a > num_b) {
    return(a)  # return the original type of 'a'
  } else if (num_b > num_a) {
    return(b)  # return the original type of 'b'
  } else {
    return(NULL)  # values are equal
  }
}
test_humaneval <- function() {
    candidate <- compare_one
    stopifnot(isTRUE(all.equal(candidate(1, 2), 2)))
    stopifnot(isTRUE(all.equal(candidate(1, 2.5), 2.5)))
    stopifnot(isTRUE(all.equal(candidate(2, 3), 3)))
    stopifnot(isTRUE(all.equal(candidate(5, 6), 6)))
    stopifnot(isTRUE(all.equal(candidate(1, '2,3'), '2,3')))
    stopifnot(isTRUE(all.equal(candidate('5,1', '6'), '6')))
    stopifnot(isTRUE(all.equal(candidate('1', '2'), '2')))
    stopifnot(isTRUE(all.equal(candidate('1', 1), NULL)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183800
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Create a function that takes integers, floats, or strings representing
# real numbers, and returns the larger variable in its given variable type.
# Return NULL if the values are equal.
# Note: If a real number is represented as a string, the floating point might be . or ,
# >>> compare_one(1, 2.5)
# 2.5
# >>> compare_one(1, '2,3')
# '2,3'
# >>> compare_one('5,1', '6')
# '6'
# >>> compare_one('1', 1)
# NULL
compare_one <- function(a, b) {
  # Helper to convert a value to numeric, handling commas as decimal separators
  to_numeric <- function(x) {
    if (is.numeric(x)) {
      return(x)
    }
    # Replace comma with dot and convert to numeric
    num <- as.numeric(gsub(",", ".", x))
    return(num)
  }

  # Convert both arguments to numeric for comparison
  val_a <- to_numeric(a)
  val_b <- to_numeric(b)

  # If the numeric values are equal, return NULL
  if (identical(val_a, val_b) || (is.na(val_a) && is.na(val_b))) {
    return(NULL)
  }

  # Determine which original value is larger
  if (val_a > val_b) {
    return(a)
  } else {
    return(b)
  }
}
test_humaneval <- function() {
    candidate <- compare_one
    stopifnot(isTRUE(all.equal(candidate(1, 2), 2)))
    stopifnot(isTRUE(all.equal(candidate(1, 2.5), 2.5)))
    stopifnot(isTRUE(all.equal(candidate(2, 3), 3)))
    stopifnot(isTRUE(all.equal(candidate(5, 6), 6)))
    stopifnot(isTRUE(all.equal(candidate(1, '2,3'), '2,3')))
    stopifnot(isTRUE(all.equal(candidate('5,1', '6'), '6')))
    stopifnot(isTRUE(all.equal(candidate('1', '2'), '2')))
    stopifnot(isTRUE(all.equal(candidate('1', 1), NULL)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183800
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 138 (R) - HumanEval_138_is_equal_to_sum_even
================================================================================

PROMPT:
----------------------------------------
# Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
# Example
# >>> is_equal_to_sum_even(4)
# FALSE
# >>> is_equal_to_sum_even(6)
# FALSE
# >>> is_equal_to_sum_even(8)
# TRUE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- is_equal_to_sum_even
    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(11), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(12), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(13), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(16), TRUE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
# Example
# >>> is_equal_to_sum_even(4)
# FALSE
# >>> is_equal_to_sum_even(6)
# FALSE
# >>> is_equal_to_sum_even(8)
# TRUE
# Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
# Example
# >>> is_equal_to_sum_even(4)
# FALSE
# >>> is_equal_to_sum_even(6)
# FALSE
# >>> is_equal_to_sum_even(8)
# TRUE
is_equal_to_sum_even <- function(n) {
  # Input validation: ensure a single numeric value
  if (!is.numeric(n) || length(n) != 1) {
    stop("n must be a single numeric value")
  }
  
  # The sum of four positive even numbers is even and at least 8
  # (since 2 + 2 + 2 + 2 = 8). Any even n >= 8 can be represented
  # by adjusting the smallest even numbers accordingly.
  n >= 8 && n %% 2 == 0
}
test_humaneval <- function() {
    candidate <- is_equal_to_sum_even
    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(11), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(12), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(13), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(16), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183801
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
# Example
# >>> is_equal_to_sum_even(4)
# FALSE
# >>> is_equal_to_sum_even(6)
# FALSE
# >>> is_equal_to_sum_even(8)
# TRUE
# Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
# Example
# >>> is_equal_to_sum_even(4)
# FALSE
# >>> is_equal_to_sum_even(6)
# FALSE
# >>> is_equal_to_sum_even(8)
# TRUE
is_equal_to_sum_even <- function(n) {
  # A sum of four positive even numbers is at least 2+2+2+2 = 8
  # and must be even.
  if (!is.numeric(n) || length(n) != 1) {
    stop("Input must be a single numeric value.")
  }
  return(n >= 8 && n %% 2 == 0)
}
test_humaneval <- function() {
    candidate <- is_equal_to_sum_even
    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(11), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(12), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(13), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(16), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183801
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
# Example
# >>> is_equal_to_sum_even(4)
# FALSE
# >>> is_equal_to_sum_even(6)
# FALSE
# >>> is_equal_to_sum_even(8)
# TRUE
# Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
# Example
# >>> is_equal_to_sum_even(4)
# FALSE
# >>> is_equal_to_sum_even(6)
# FALSE
# >>> is_equal_to_sum_even(8)
# TRUE
is_equal_to_sum_even <- function(n) {
  # Ensure n is a single numeric value
  if (!is.numeric(n) || length(n) != 1) {
    stop("n must be a single numeric value")
  }
  
  # n must be an even integer greater than or equal to 8
  # (the smallest possible sum of 4 positive even numbers is 2+2+2+2 = 8)
  if (n >= 8 && n %% 2 == 0) {
    return(TRUE)
  } else {
    return(FALSE)
  }
}
test_humaneval <- function() {
    candidate <- is_equal_to_sum_even
    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(11), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(12), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(13), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(16), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183801
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
# Example
# >>> is_equal_to_sum_even(4)
# FALSE
# >>> is_equal_to_sum_even(6)
# FALSE
# >>> is_equal_to_sum_even(8)
# TRUE
# Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
# Example
# >>> is_equal_to_sum_even(4)
# FALSE
# >>> is_equal_to_sum_even(6)
# FALSE
# >>> is_equal_to_sum_even(8)
# TRUE
is_equal_to_sum_even <- function(n) {
  # Input should be a single numeric value
  if (length(n) != 1 || !is.numeric(n)) {
    stop("n must be a single numeric value")
  }
  
  # A sum of four positive even numbers requires:
  # 1) n to be even
  # 2) n to be at least 8 (since 2+2+2+2 = 8)
  n >= 8 && n %% 2 == 0
}
test_humaneval <- function() {
    candidate <- is_equal_to_sum_even
    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(11), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(12), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(13), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(16), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183801
STDOUT: (empty)
STDERR: (empty)
--------------------
