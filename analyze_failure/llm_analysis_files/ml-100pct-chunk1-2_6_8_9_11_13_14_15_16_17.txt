As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 2 (ML) - HumanEval_2_truncate_number
================================================================================

PROMPT:
----------------------------------------
(**Given a positive floating point number, it can be decomposed into
 * and integer part (largest integer smaller than given number) and decimals
 * (leftover part always smaller than 1).
 * Return the decimal part of the number.
 * >>> truncate_number 3.5
 * 0.5
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = truncate_number in
  (assert ((candidate 3.5) = 0.5));
  (assert ((candidate 1.25) = 0.25));
  (assert ((candidate 123.0) = 0.0));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given a positive floating point number, it can be decomposed into
 * and integer part (largest integer smaller than given number) and decimals
 * (leftover part always smaller than 1).
 * Return the decimal part of the number.
 * >>> truncate_number 3.5
 * 0.5
*)
(** Return the fractional part of a positive floating‑point number. *)
let truncate_number (number : float) : float =
  number -. floor number

let assertions =
 let candidate = truncate_number in
  (assert ((candidate 3.5) = 0.5));
  (assert ((candidate 1.25) = 0.25));
  (assert ((candidate 123.0) = 0.0));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183709
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given a positive floating point number, it can be decomposed into
 * and integer part (largest integer smaller than given number) and decimals
 * (leftover part always smaller than 1).
 * Return the decimal part of the number.
 * >>> truncate_number 3.5
 * 0.5
*)
(* Return the fractional part of a positive floating‑point number.
   The fractional part is the number minus its integer part. *)
let truncate_number (number : float) : float =
  number -. floor number

let assertions =
 let candidate = truncate_number in
  (assert ((candidate 3.5) = 0.5));
  (assert ((candidate 1.25) = 0.25));
  (assert ((candidate 123.0) = 0.0));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183709
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given a positive floating point number, it can be decomposed into
 * and integer part (largest integer smaller than given number) and decimals
 * (leftover part always smaller than 1).
 * Return the decimal part of the number.
 * >>> truncate_number 3.5
 * 0.5
*)
let truncate_number (number : float) : float =
  number -. floor number

let assertions =
 let candidate = truncate_number in
  (assert ((candidate 3.5) = 0.5));
  (assert ((candidate 1.25) = 0.25));
  (assert ((candidate 123.0) = 0.0));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183709
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given a positive floating point number, it can be decomposed into
 * and integer part (largest integer smaller than given number) and decimals
 * (leftover part always smaller than 1).
 * Return the decimal part of the number.
 * >>> truncate_number 3.5
 * 0.5
*)
let truncate_number (number : float) : float =
  number -. floor number

let assertions =
 let candidate = truncate_number in
  (assert ((candidate 3.5) = 0.5));
  (assert ((candidate 1.25) = 0.25));
  (assert ((candidate 123.0) = 0.0));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183709
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 6 (ML) - HumanEval_6_parse_nested_parens
================================================================================

PROMPT:
----------------------------------------
(**Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
 * For each of the group, output the deepest level of nesting of parentheses.
 * E.g. (()()) has maximum two levels of nesting while ((())) has three.
 * >>> parse_nested_parens "(()()) ((())) () ((())()())"
 * [2; 3; 1; 3]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = parse_nested_parens in
  (assert ((candidate "(()()) ((())) () ((())()())") = [2; 3; 1; 3]));
  (assert ((candidate "() (()) ((())) (((())))") = [1; 2; 3; 4]));
  (assert ((candidate "(()(())((())))") = [4]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
 * For each of the group, output the deepest level of nesting of parentheses.
 * E.g. (()()) has maximum two levels of nesting while ((())) has three.
 * >>> parse_nested_parens "(()()) ((())) () ((())()())"
 * [2; 3; 1; 3]
*)
(* Parse a string containing several groups of nested parentheses separated
   by whitespace, and return a list with the maximum depth of nesting for
   each group. *)

let parse_nested_parens (paren_string : string) : int list =
  (* Helper: split a string on whitespace, discarding empty fields. *)
  let split_on_whitespace s =
    s
    |> String.split_on_char ' '
    |> List.filter (fun part -> part <> "")
  in

  (* Helper: compute the maximum depth of a single group of parentheses. *)
  let max_depth group =
    let len = String.length group in
    let rec aux i cur_depth max_depth =
      if i = len then max_depth
      else
        let c = group.[i] in
        match c with
        | '(' ->
            let new_depth = cur_depth + 1 in
            aux (i + 1) new_depth (max max_depth new_depth)
        | ')' ->
            aux (i + 1) (cur_depth - 1) max_depth
        | _ -> aux (i + 1) cur_depth max_depth
    in
    aux 0 0 0
  in

  (* Process each group and collect the depths. *)
  split_on_whitespace paren_string
  |> List.map max_depth

let assertions =
 let candidate = parse_nested_parens in
  (assert ((candidate "(()()) ((())) () ((())()())") = [2; 3; 1; 3]));
  (assert ((candidate "() (()) ((())) (((())))") = [1; 2; 3; 4]));
  (assert ((candidate "(()(())((())))") = [4]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183710
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
 * For each of the group, output the deepest level of nesting of parentheses.
 * E.g. (()()) has maximum two levels of nesting while ((())) has three.
 * >>> parse_nested_parens "(()()) ((())) () ((())()())"
 * [2; 3; 1; 3]
*)
let parse_nested_parens (paren_string : string) : int list =
  (* Split the input on spaces and ignore any empty groups that may appear
     due to consecutive spaces. *)
  let groups =
    String.split_on_char ' ' paren_string
    |> List.filter (fun g -> g <> "")
  in

  (* Compute the maximum depth of a single parenthesis group. *)
  let depth_of group =
    let max_depth = ref 0 in
    let depth    = ref 0 in
    String.iter (fun c ->
      match c with
      | '(' ->
          incr depth;
          if !depth > !max_depth then max_depth := !depth
      | ')' -> decr depth
      | _   -> ()          (* ignore any other characters, if present *)
    ) group;
    !max_depth
  in

  (* Map the depth function over all groups. *)
  List.map depth_of groups

let assertions =
 let candidate = parse_nested_parens in
  (assert ((candidate "(()()) ((())) () ((())()())") = [2; 3; 1; 3]));
  (assert ((candidate "() (()) ((())) (((())))") = [1; 2; 3; 4]));
  (assert ((candidate "(()(())((())))") = [4]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183710
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
 * For each of the group, output the deepest level of nesting of parentheses.
 * E.g. (()()) has maximum two levels of nesting while ((())) has three.
 * >>> parse_nested_parens "(()()) ((())) () ((())()())"
 * [2; 3; 1; 3]
*)
(* Compute the maximum depth of nested parentheses for each group
   separated by spaces in the input string. *)
let parse_nested_parens (paren_string : string) : int list =
  (* Split the input into individual parenthesis groups. *)
  let groups = String.split_on_char ' ' paren_string in

  (* Compute the maximum depth for a single group. *)
  let max_depth_of_group s =
    let max_depth = ref 0 in
    let depth = ref 0 in
    String.iter (fun c ->
      match c with
      | '(' ->
        depth := !depth + 1;
        if !depth > !max_depth then max_depth := !depth
      | ')' ->
        depth := !depth - 1
      | _ -> ()
    ) s;
    !max_depth
  in

  (* Process each group, ignoring empty ones. *)
  List.filter_map (fun g ->
    let g = String.trim g in
    if g = "" then None else Some (max_depth_of_group g)
  ) groups

let assertions =
 let candidate = parse_nested_parens in
  (assert ((candidate "(()()) ((())) () ((())()())") = [2; 3; 1; 3]));
  (assert ((candidate "() (()) ((())) (((())))") = [1; 2; 3; 4]));
  (assert ((candidate "(()(())((())))") = [4]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183709
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
 * For each of the group, output the deepest level of nesting of parentheses.
 * E.g. (()()) has maximum two levels of nesting while ((())) has three.
 * >>> parse_nested_parens "(()()) ((())) () ((())()())"
 * [2; 3; 1; 3]
*)
(* Compute the maximum nesting depth of each group of parentheses in the input string. *)
let parse_nested_parens (paren_string : string) : int list =
  (* Helper to compute depth of a single group *)
  let depth_of_group s =
    let len = String.length s in
    let rec aux i depth max_depth =
      if i = len then max_depth
      else
        let c = s.[i] in
        let depth' = if c = '(' then depth + 1 else depth - 1 in
        let max_depth' = if depth' > max_depth then depth' else max_depth in
        aux (i + 1) depth' max_depth'
    in
    aux 0 0 0
  in
  (* Split the input on spaces, filter out any empty fragments, and map each to its depth *)
  paren_string
  |> String.split_on_char ' '
  |> List.filter (fun g -> g <> "")
  |> List.map depth_of_group

let assertions =
 let candidate = parse_nested_parens in
  (assert ((candidate "(()()) ((())) () ((())()())") = [2; 3; 1; 3]));
  (assert ((candidate "() (()) ((())) (((())))") = [1; 2; 3; 4]));
  (assert ((candidate "(()(())((())))") = [4]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183709
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 8 (ML) - HumanEval_8_sum_product
================================================================================

PROMPT:
----------------------------------------
(**For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
 * Empty sum should be equal to 0 and empty product should be equal to 1.
 * >>> sum_product []
 * (0, 1)
 * >>> sum_product [1; 2; 3; 4]
 * (10, 24)
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = sum_product in
  (assert ((candidate []) = (0, 1)));
  (assert ((candidate [1; 1; 1]) = (3, 1)));
  (assert ((candidate [100; 0]) = (100, 0)));
  (assert ((candidate [3; 5; 7]) = (15, 105)));
  (assert ((candidate [10]) = (10, 10)));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
 * Empty sum should be equal to 0 and empty product should be equal to 1.
 * >>> sum_product []
 * (0, 1)
 * >>> sum_product [1; 2; 3; 4]
 * (10, 24)
*)
let sum_product (numbers : int list) : int * int =
  let sum  = List.fold_left (+) 0 numbers in
  let prod = List.fold_left ( * ) 1 numbers in
  (sum, prod)

let assertions =
 let candidate = sum_product in
  (assert ((candidate []) = (0, 1)));
  (assert ((candidate [1; 1; 1]) = (3, 1)));
  (assert ((candidate [100; 0]) = (100, 0)));
  (assert ((candidate [3; 5; 7]) = (15, 105)));
  (assert ((candidate [10]) = (10, 10)));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183710
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
 * Empty sum should be equal to 0 and empty product should be equal to 1.
 * >>> sum_product []
 * (0, 1)
 * >>> sum_product [1; 2; 3; 4]
 * (10, 24)
*)
(* sum_product : int list -> int * int *)
let sum_product (numbers : int list) : int * int =
  (* Use a tail‑recursive helper to keep the accumulator in the
     correct order: first the sum, then the product. *)
  let rec aux (sum : int) (prod : int) = function
    | [] -> (sum, prod)
    | x :: xs -> aux (sum + x) (prod * x) xs
  in
  aux 0 1 numbers

let assertions =
 let candidate = sum_product in
  (assert ((candidate []) = (0, 1)));
  (assert ((candidate [1; 1; 1]) = (3, 1)));
  (assert ((candidate [100; 0]) = (100, 0)));
  (assert ((candidate [3; 5; 7]) = (15, 105)));
  (assert ((candidate [10]) = (10, 10)));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183710
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
 * Empty sum should be equal to 0 and empty product should be equal to 1.
 * >>> sum_product []
 * (0, 1)
 * >>> sum_product [1; 2; 3; 4]
 * (10, 24)
*)
let sum_product (numbers : int list) : int * int =
  List.fold_left (fun (s, p) n -> (s + n, p * n)) (0, 1) numbers

let assertions =
 let candidate = sum_product in
  (assert ((candidate []) = (0, 1)));
  (assert ((candidate [1; 1; 1]) = (3, 1)));
  (assert ((candidate [100; 0]) = (100, 0)));
  (assert ((candidate [3; 5; 7]) = (15, 105)));
  (assert ((candidate [10]) = (10, 10)));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183710
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
 * Empty sum should be equal to 0 and empty product should be equal to 1.
 * >>> sum_product []
 * (0, 1)
 * >>> sum_product [1; 2; 3; 4]
 * (10, 24)
*)
let sum_product (numbers : int list) : int * int =
  List.fold_left (fun (s, p) n -> (s + n, p * n)) (0, 1) numbers

let assertions =
 let candidate = sum_product in
  (assert ((candidate []) = (0, 1)));
  (assert ((candidate [1; 1; 1]) = (3, 1)));
  (assert ((candidate [100; 0]) = (100, 0)));
  (assert ((candidate [3; 5; 7]) = (15, 105)));
  (assert ((candidate [10]) = (10, 10)));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183710
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 9 (ML) - HumanEval_9_rolling_max
================================================================================

PROMPT:
----------------------------------------
(**From a given list of integers, generate a list of rolling maximum element found until given moment
 * in the sequence.
 * >>> rolling_max [1; 2; 3; 2; 3; 4; 2]
 * [1; 2; 3; 3; 3; 4; 4]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = rolling_max in
  (assert ((candidate []) = []));
  (assert ((candidate [1; 2; 3; 4]) = [1; 2; 3; 4]));
  (assert ((candidate [4; 3; 2; 1]) = [4; 4; 4; 4]));
  (assert ((candidate [3; 2; 3; 100; 3]) = [3; 3; 3; 100; 100]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**From a given list of integers, generate a list of rolling maximum element found until given moment
 * in the sequence.
 * >>> rolling_max [1; 2; 3; 2; 3; 4; 2]
 * [1; 2; 3; 3; 3; 4; 4]
*)
(** From a given list of integers, generate a list of rolling maximum element found until given moment
 *  in the sequence.
 *  >>> rolling_max [1; 2; 3; 2; 3; 4; 2]
 *  [1; 2; 3; 3; 3; 4; 4]
*)
let rolling_max (numbers : int list) : int list =
  (* Helper that processes the list, keeping the current maximum and
     building the result in reverse order. *)
  let rec aux acc current_max = function
    | [] -> List.rev acc
    | h :: t ->
        let new_max = if h > current_max then h else current_max in
        aux (new_max :: acc) new_max t
  in
  match numbers with
  | [] -> []
  | h :: t -> aux [h] h t

let assertions =
 let candidate = rolling_max in
  (assert ((candidate []) = []));
  (assert ((candidate [1; 2; 3; 4]) = [1; 2; 3; 4]));
  (assert ((candidate [4; 3; 2; 1]) = [4; 4; 4; 4]));
  (assert ((candidate [3; 2; 3; 100; 3]) = [3; 3; 3; 100; 100]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183710
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**From a given list of integers, generate a list of rolling maximum element found until given moment
 * in the sequence.
 * >>> rolling_max [1; 2; 3; 2; 3; 4; 2]
 * [1; 2; 3; 3; 3; 4; 4]
*)
let rolling_max (numbers : int list) : int list =
  let rec aux acc current_max = function
    | [] -> List.rev acc
    | x::xs ->
        let m = max x current_max in
        aux (m::acc) m xs
  in
  match numbers with
  | [] -> []
  | x::xs -> aux [x] x xs

let assertions =
 let candidate = rolling_max in
  (assert ((candidate []) = []));
  (assert ((candidate [1; 2; 3; 4]) = [1; 2; 3; 4]));
  (assert ((candidate [4; 3; 2; 1]) = [4; 4; 4; 4]));
  (assert ((candidate [3; 2; 3; 100; 3]) = [3; 3; 3; 100; 100]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183710
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**From a given list of integers, generate a list of rolling maximum element found until given moment
 * in the sequence.
 * >>> rolling_max [1; 2; 3; 2; 3; 4; 2]
 * [1; 2; 3; 3; 3; 4; 4]
*)
(** From a given list of integers, generate a list of rolling maximum element found until given moment
 *  in the sequence.
 *  >>> rolling_max [1; 2; 3; 2; 3; 4; 2]
 *  [1; 2; 3; 3; 3; 4; 4]
*)
let rolling_max (numbers : int list) : int list =
  (* Helper that folds over the list, keeping the current maximum
     and building the result in reverse order. *)
  let rec aux (max_so_far : int) (acc_rev : int list) = function
    | [] -> List.rev acc_rev
    | x :: xs ->
        let new_max = if x > max_so_far then x else max_so_far in
        aux new_max (new_max :: acc_rev) xs
  in
  match numbers with
  | [] -> []
  | h :: t -> aux h [h] t

let assertions =
 let candidate = rolling_max in
  (assert ((candidate []) = []));
  (assert ((candidate [1; 2; 3; 4]) = [1; 2; 3; 4]));
  (assert ((candidate [4; 3; 2; 1]) = [4; 4; 4; 4]));
  (assert ((candidate [3; 2; 3; 100; 3]) = [3; 3; 3; 100; 100]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183710
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**From a given list of integers, generate a list of rolling maximum element found until given moment
 * in the sequence.
 * >>> rolling_max [1; 2; 3; 2; 3; 4; 2]
 * [1; 2; 3; 3; 3; 4; 4]
*)
let rolling_max (numbers : int list) : int list =
  (* Helper that processes the list from left to right, keeping the
     current maximum and accumulating the results in reverse order. *)
  let rec aux acc current_max = function
    | [] -> List.rev acc
    | x :: xs ->
        let new_max = if x > current_max then x else current_max in
        aux (new_max :: acc) new_max xs
  in
  match numbers with
  | [] -> []
  | x :: xs -> aux [x] x xs

let assertions =
 let candidate = rolling_max in
  (assert ((candidate []) = []));
  (assert ((candidate [1; 2; 3; 4]) = [1; 2; 3; 4]));
  (assert ((candidate [4; 3; 2; 1]) = [4; 4; 4; 4]));
  (assert ((candidate [3; 2; 3; 100; 3]) = [3; 3; 3; 100; 100]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183710
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 11 (ML) - HumanEval_11_string_xor
================================================================================

PROMPT:
----------------------------------------
(**Input are two strings a and b consisting only of 1s and 0s.
 * Perform binary XOR on these inputs and return result also as a string.
 * >>> string_xor "010" "110"
 * "100"
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = string_xor in
  (assert ((candidate "111000" "101010") = "010010"));
  (assert ((candidate "1" "1") = "0"));
  (assert ((candidate "0101" "0000") = "0101"));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Input are two strings a and b consisting only of 1s and 0s.
 * Perform binary XOR on these inputs and return result also as a string.
 * >>> string_xor "010" "110"
 * "100"
*)
let string_xor (a : string) (b : string) : string =
  (* Ensure both strings have the same length *)
  let len = String.length a in
  if String.length b <> len then
    invalid_arg "string_xor: input strings must have the same length";

  (* Allocate a mutable buffer for the result *)
  let result = Bytes.create len in

  (* Compute XOR bit by bit *)
  for i = 0 to len - 1 do
    let ca = a.[i] in
    let cb = b.[i] in
    let xor_bit = if ca = cb then '0' else '1' in
    Bytes.set result i xor_bit
  done;

  (* Convert the buffer back to an immutable string *)
  Bytes.to_string result

let assertions =
 let candidate = string_xor in
  (assert ((candidate "111000" "101010") = "010010"));
  (assert ((candidate "1" "1") = "0"));
  (assert ((candidate "0101" "0000") = "0101"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183710
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Input are two strings a and b consisting only of 1s and 0s.
 * Perform binary XOR on these inputs and return result also as a string.
 * >>> string_xor "010" "110"
 * "100"
*)
let string_xor (a : string) (b : string) : string =
  let len = String.length a in
  if String.length b <> len then
    invalid_arg "string_xor: strings must have the same length";
  let res = Bytes.create len in
  for i = 0 to len - 1 do
    let ca = String.get a i in
    let cb = String.get b i in
    let rc = if ca = cb then '0' else '1' in
    Bytes.set res i rc
  done;
  Bytes.to_string res

let assertions =
 let candidate = string_xor in
  (assert ((candidate "111000" "101010") = "010010"));
  (assert ((candidate "1" "1") = "0"));
  (assert ((candidate "0101" "0000") = "0101"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183710
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Input are two strings a and b consisting only of 1s and 0s.
 * Perform binary XOR on these inputs and return result also as a string.
 * >>> string_xor "010" "110"
 * "100"
*)
let string_xor (a : string) (b : string) : string =
  let len_a = String.length a in
  let len_b = String.length b in
  let max_len = max len_a len_b in
  let offset_a = max_len - len_a in
  let offset_b = max_len - len_b in
  let res = Bytes.create max_len in
  for i = 0 to max_len - 1 do
    let ca = if i < offset_a then '0' else a.[i - offset_a] in
    let cb = if i < offset_b then '0' else b.[i - offset_b] in
    let c = if ca = cb then '0' else '1' in
    Bytes.set res i c
  done;
  Bytes.to_string res

let assertions =
 let candidate = string_xor in
  (assert ((candidate "111000" "101010") = "010010"));
  (assert ((candidate "1" "1") = "0"));
  (assert ((candidate "0101" "0000") = "0101"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183710
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Input are two strings a and b consisting only of 1s and 0s.
 * Perform binary XOR on these inputs and return result also as a string.
 * >>> string_xor "010" "110"
 * "100"
*)
let string_xor (a : string) (b : string) : string =
  let len = String.length a in
  if String.length b <> len then
    invalid_arg "string_xor: strings must be of equal length";
  let res = Bytes.create len in
  for i = 0 to len - 1 do
    let c = if a.[i] = b.[i] then '0' else '1' in
    Bytes.set res i c
  done;
  Bytes.to_string res

let assertions =
 let candidate = string_xor in
  (assert ((candidate "111000" "101010") = "010010"));
  (assert ((candidate "1" "1") = "0"));
  (assert ((candidate "0101" "0000") = "0101"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183710
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 13 (ML) - HumanEval_13_greatest_common_divisor
================================================================================

PROMPT:
----------------------------------------
(**Return a greatest common divisor of two integers a and b
 * >>> greatest_common_divisor 3 5
 * 1
 * >>> greatest_common_divisor 25 15
 * 5
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = greatest_common_divisor in
  (assert ((candidate 3 7) = 1));
  (assert ((candidate 10 15) = 5));
  (assert ((candidate 49 14) = 7));
  (assert ((candidate 144 60) = 12));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Return a greatest common divisor of two integers a and b
 * >>> greatest_common_divisor 3 5
 * 1
 * >>> greatest_common_divisor 25 15
 * 5
*)
let greatest_common_divisor (a : int) (b : int) : int =
  let rec gcd x y =
    if y = 0 then abs x
    else gcd y (x mod y)
  in
  gcd a b

let assertions =
 let candidate = greatest_common_divisor in
  (assert ((candidate 3 7) = 1));
  (assert ((candidate 10 15) = 5));
  (assert ((candidate 49 14) = 7));
  (assert ((candidate 144 60) = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Return a greatest common divisor of two integers a and b
 * >>> greatest_common_divisor 3 5
 * 1
 * >>> greatest_common_divisor 25 15
 * 5
*)
let greatest_common_divisor (a : int) (b : int) : int =
  let rec gcd x y =
    if y = 0 then abs x
    else gcd y (x mod y)
  in
  gcd a b

let assertions =
 let candidate = greatest_common_divisor in
  (assert ((candidate 3 7) = 1));
  (assert ((candidate 10 15) = 5));
  (assert ((candidate 49 14) = 7));
  (assert ((candidate 144 60) = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Return a greatest common divisor of two integers a and b
 * >>> greatest_common_divisor 3 5
 * 1
 * >>> greatest_common_divisor 25 15
 * 5
*)
let greatest_common_divisor (a : int) (b : int) : int =
  (* Euclidean algorithm – works for positive and negative inputs *)
  let rec gcd x y =
    if y = 0 then abs x
    else gcd y (x mod y)
  in
  gcd a b

let assertions =
 let candidate = greatest_common_divisor in
  (assert ((candidate 3 7) = 1));
  (assert ((candidate 10 15) = 5));
  (assert ((candidate 49 14) = 7));
  (assert ((candidate 144 60) = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Return a greatest common divisor of two integers a and b
 * >>> greatest_common_divisor 3 5
 * 1
 * >>> greatest_common_divisor 25 15
 * 5
*)
let rec greatest_common_divisor (a : int) (b : int) : int =
  if b = 0 then
    abs a                (* handle negative inputs gracefully *)
  else
    greatest_common_divisor b (a mod b)

let assertions =
 let candidate = greatest_common_divisor in
  (assert ((candidate 3 7) = 1));
  (assert ((candidate 10 15) = 5));
  (assert ((candidate 49 14) = 7));
  (assert ((candidate 144 60) = 12));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 14 (ML) - HumanEval_14_all_prefixes
================================================================================

PROMPT:
----------------------------------------
(**Return list of all prefixes from shortest to longest of the input string
 * >>> all_prefixes "abc"
 * ["a"; "ab"; "abc"]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = all_prefixes in
  (assert ((candidate "") = []));
  (assert ((candidate "asdfgh") = ["a"; "as"; "asd"; "asdf"; "asdfg"; "asdfgh"]));
  (assert ((candidate "WWW") = ["W"; "WW"; "WWW"]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Return list of all prefixes from shortest to longest of the input string
 * >>> all_prefixes "abc"
 * ["a"; "ab"; "abc"]
*)
(* Return list of all prefixes from shortest to longest of the input string
   * >>> all_prefixes "abc"
   * ["a"; "ab"; "abc"]
*)
let all_prefixes (string : string) : string list =
  let len = String.length string in
  if len = 0 then []
  else
    List.init len (fun i -> String.sub string 0 (i + 1))

let assertions =
 let candidate = all_prefixes in
  (assert ((candidate "") = []));
  (assert ((candidate "asdfgh") = ["a"; "as"; "asd"; "asdf"; "asdfg"; "asdfgh"]));
  (assert ((candidate "WWW") = ["W"; "WW"; "WWW"]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Return list of all prefixes from shortest to longest of the input string
 * >>> all_prefixes "abc"
 * ["a"; "ab"; "abc"]
*)
let all_prefixes (s : string) : string list =
  let len = String.length s in
  let rec aux i acc =
    if i > len then List.rev acc
    else aux (i + 1) (String.sub s 0 i :: acc)
  in
  aux 1 []

let assertions =
 let candidate = all_prefixes in
  (assert ((candidate "") = []));
  (assert ((candidate "asdfgh") = ["a"; "as"; "asd"; "asdf"; "asdfg"; "asdfgh"]));
  (assert ((candidate "WWW") = ["W"; "WW"; "WWW"]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Return list of all prefixes from shortest to longest of the input string
 * >>> all_prefixes "abc"
 * ["a"; "ab"; "abc"]
*)
let all_prefixes (s : string) : string list =
  let n = String.length s in
  List.init n (fun i -> String.sub s 0 (i + 1))

let assertions =
 let candidate = all_prefixes in
  (assert ((candidate "") = []));
  (assert ((candidate "asdfgh") = ["a"; "as"; "asd"; "asdf"; "asdfg"; "asdfgh"]));
  (assert ((candidate "WWW") = ["W"; "WW"; "WWW"]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Return list of all prefixes from shortest to longest of the input string
 * >>> all_prefixes "abc"
 * ["a"; "ab"; "abc"]
*)
(* Return list of all prefixes from shortest to longest of the input string
 * >>> all_prefixes "abc"
 * ["a"; "ab"; "abc"]
 *)
let all_prefixes (string : string) : string list =
  let len = String.length string in
  let rec aux i acc =
    if i <= 0 then acc
    else aux (i - 1) (String.sub string 0 i :: acc)
  in
  aux len []

let assertions =
 let candidate = all_prefixes in
  (assert ((candidate "") = []));
  (assert ((candidate "asdfgh") = ["a"; "as"; "asd"; "asdf"; "asdfg"; "asdfgh"]));
  (assert ((candidate "WWW") = ["W"; "WW"; "WWW"]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 15 (ML) - HumanEval_15_string_sequence
================================================================================

PROMPT:
----------------------------------------
(**Return a string containing space-delimited numbers starting from 0 upto n inclusive.
 * >>> string_sequence 0
 * "0"
 * >>> string_sequence 5
 * "0 1 2 3 4 5"
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = string_sequence in
  (assert ((candidate 0) = "0"));
  (assert ((candidate 3) = "0 1 2 3"));
  (assert ((candidate 10) = "0 1 2 3 4 5 6 7 8 9 10"));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Return a string containing space-delimited numbers starting from 0 upto n inclusive.
 * >>> string_sequence 0
 * "0"
 * >>> string_sequence 5
 * "0 1 2 3 4 5"
*)
(* Return a string containing space‑delimited numbers starting from 0 up to n inclusive. *)
let string_sequence (n : int) : string =
  (* Build a list of string representations of the integers 0 .. n *)
  let numbers = List.init (n + 1) (fun i -> string_of_int i) in
  (* Join them with a single space *)
  String.concat " " numbers

let assertions =
 let candidate = string_sequence in
  (assert ((candidate 0) = "0"));
  (assert ((candidate 3) = "0 1 2 3"));
  (assert ((candidate 10) = "0 1 2 3 4 5 6 7 8 9 10"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Return a string containing space-delimited numbers starting from 0 upto n inclusive.
 * >>> string_sequence 0
 * "0"
 * >>> string_sequence 5
 * "0 1 2 3 4 5"
*)
let string_sequence (n : int) : string =
  let rec aux i acc =
    if i > n then String.concat " " (List.rev acc)
    else aux (i + 1) (string_of_int i :: acc)
  in
  aux 0 []

let assertions =
 let candidate = string_sequence in
  (assert ((candidate 0) = "0"));
  (assert ((candidate 3) = "0 1 2 3"));
  (assert ((candidate 10) = "0 1 2 3 4 5 6 7 8 9 10"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Return a string containing space-delimited numbers starting from 0 upto n inclusive.
 * >>> string_sequence 0
 * "0"
 * >>> string_sequence 5
 * "0 1 2 3 4 5"
*)
let string_sequence (n : int) : string =
  let seq = List.init (n + 1) (fun i -> string_of_int i) in
  String.concat " " seq

let assertions =
 let candidate = string_sequence in
  (assert ((candidate 0) = "0"));
  (assert ((candidate 3) = "0 1 2 3"));
  (assert ((candidate 10) = "0 1 2 3 4 5 6 7 8 9 10"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Return a string containing space-delimited numbers starting from 0 upto n inclusive.
 * >>> string_sequence 0
 * "0"
 * >>> string_sequence 5
 * "0 1 2 3 4 5"
*)
(* Return a string containing space-delimited numbers starting from 0 up to n inclusive. *)
let string_sequence (n : int) : string =
  (* Generate the list of numbers from 0 to n, convert each to a string, and join them with spaces. *)
  String.concat " " (List.init (n + 1) (fun i -> string_of_int i))

let assertions =
 let candidate = string_sequence in
  (assert ((candidate 0) = "0"));
  (assert ((candidate 3) = "0 1 2 3"));
  (assert ((candidate 10) = "0 1 2 3 4 5 6 7 8 9 10"));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 16 (ML) - HumanEval_16_count_distinct_characters
================================================================================

PROMPT:
----------------------------------------
(**Given a string, find out how many distinct characters (regardless of case) does it consist of
 * >>> count_distinct_characters "xyzXYZ"
 * 3
 * >>> count_distinct_characters "Jerry"
 * 4
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = count_distinct_characters in
  (assert ((candidate "") = 0));
  (assert ((candidate "abcde") = 5));
  (assert ((candidate "abcdecadeCADE") = 5));
  (assert ((candidate "aaaaAAAAaaaa") = 1));
  (assert ((candidate "Jerry jERRY JeRRRY") = 5));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Given a string, find out how many distinct characters (regardless of case) does it consist of
 * >>> count_distinct_characters "xyzXYZ"
 * 3
 * >>> count_distinct_characters "Jerry"
 * 4
*)
let count_distinct_characters (string : string) : int =
  (* Convert to lowercase to ignore case differences. *)
  let s_lower = String.lowercase_ascii string in
  (* Use a boolean array for ASCII characters. *)
  let seen = Array.make 256 false in
  let count = ref 0 in
  String.iter (fun c ->
    let idx = Char.code c in
    if not seen.(idx) then begin
      seen.(idx) <- true;
      incr count
    end
  ) s_lower;
  !count

let assertions =
 let candidate = count_distinct_characters in
  (assert ((candidate "") = 0));
  (assert ((candidate "abcde") = 5));
  (assert ((candidate "abcdecadeCADE") = 5));
  (assert ((candidate "aaaaAAAAaaaa") = 1));
  (assert ((candidate "Jerry jERRY JeRRRY") = 5));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Given a string, find out how many distinct characters (regardless of case) does it consist of
 * >>> count_distinct_characters "xyzXYZ"
 * 3
 * >>> count_distinct_characters "Jerry"
 * 4
*)
let count_distinct_characters (s : string) : int =
  let module CharSet = Set.Make(Char) in
  let set =
    String.fold_left
      (fun acc c -> CharSet.add (Char.lowercase_ascii c) acc)
      CharSet.empty
      s
  in
  CharSet.cardinal set

let assertions =
 let candidate = count_distinct_characters in
  (assert ((candidate "") = 0));
  (assert ((candidate "abcde") = 5));
  (assert ((candidate "abcdecadeCADE") = 5));
  (assert ((candidate "aaaaAAAAaaaa") = 1));
  (assert ((candidate "Jerry jERRY JeRRRY") = 5));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Given a string, find out how many distinct characters (regardless of case) does it consist of
 * >>> count_distinct_characters "xyzXYZ"
 * 3
 * >>> count_distinct_characters "Jerry"
 * 4
*)
(* Count distinct characters in a string, ignoring case *)
let count_distinct_characters (s : string) : int =
  (* A hash table where the key is the lower‑cased character.
     The value is irrelevant – we just need to store the key. *)
  let tbl = Hashtbl.create 16 in
  String.iter (fun c ->
    let lc = Char.lowercase_ascii c in
    (* Replace ensures that we do not raise an exception if the key already
       exists; the size of the table is the number of distinct characters. *)
    Hashtbl.replace tbl lc ();
  ) s;
  Hashtbl.length tbl

let assertions =
 let candidate = count_distinct_characters in
  (assert ((candidate "") = 0));
  (assert ((candidate "abcde") = 5));
  (assert ((candidate "abcdecadeCADE") = 5));
  (assert ((candidate "aaaaAAAAaaaa") = 1));
  (assert ((candidate "Jerry jERRY JeRRRY") = 5));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Given a string, find out how many distinct characters (regardless of case) does it consist of
 * >>> count_distinct_characters "xyzXYZ"
 * 3
 * >>> count_distinct_characters "Jerry"
 * 4
*)
(** Count the number of distinct characters in a string, ignoring case. *)
let count_distinct_characters (s : string) : int =
  (* Use a hash table to store each distinct lower‑cased character. *)
  let tbl = Hashtbl.create 16 in
  String.iter (fun c ->
    let lc = Char.lowercase_ascii c in
    if not (Hashtbl.mem tbl lc) then Hashtbl.add tbl lc ()
  ) s;
  Hashtbl.length tbl

let assertions =
 let candidate = count_distinct_characters in
  (assert ((candidate "") = 0));
  (assert ((candidate "abcde") = 5));
  (assert ((candidate "abcdecadeCADE") = 5));
  (assert ((candidate "aaaaAAAAaaaa") = 1));
  (assert ((candidate "Jerry jERRY JeRRRY") = 5));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 17 (ML) - HumanEval_17_parse_music
================================================================================

PROMPT:
----------------------------------------
(**Input to this function is a string representing musical notes in a special ASCII format.
 * Your task is to parse this string and return list of integers corresponding to how many beats does each
 * not last.
 * Here is a legend:
 * 'o' - whole note, lasts four beats
 * 'o|' - half note, lasts two beats
 * '.|' - quater note, lasts one beat
 * >>> parse_music "o o| .| o| o| .| .| .| .| o o"
 * [4; 2; 1; 2; 2; 1; 1; 1; 1; 4; 4]
*)

----------------------------------------

TEST CASES:
----------------------------------------

let assertions =
 let candidate = parse_music in
  (assert ((candidate "") = []));
  (assert ((candidate "o o o o") = [4; 4; 4; 4]));
  (assert ((candidate ".| .| .| .|") = [1; 1; 1; 1]));
  (assert ((candidate "o| o| .| .| o o o o") = [2; 2; 1; 1; 4; 4; 4; 4]));
  (assert ((candidate "o| .| o| .| o o| o o|") = [2; 1; 2; 1; 4; 2; 4; 2]));
  ()

----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
(**Input to this function is a string representing musical notes in a special ASCII format.
 * Your task is to parse this string and return list of integers corresponding to how many beats does each
 * not last.
 * Here is a legend:
 * 'o' - whole note, lasts four beats
 * 'o|' - half note, lasts two beats
 * '.|' - quater note, lasts one beat
 * >>> parse_music "o o| .| o| o| .| .| .| .| o o"
 * [4; 2; 1; 2; 2; 1; 1; 1; 1; 4; 4]
*)
(* Parses a string of musical notes and returns a list of beat counts.
   The notes are separated by whitespace. *)
let parse_music (music_string : string) : int list =
  music_string
  |> String.split_on_char ' '
  |> List.filter (fun s -> s <> "")          (* ignore empty tokens *)
  |> List.map (function
       | "o"  -> 4
       | "o|" -> 2
       | ".|" -> 1
       | _    -> failwith ("Invalid note: " ^ music_string))

let assertions =
 let candidate = parse_music in
  (assert ((candidate "") = []));
  (assert ((candidate "o o o o") = [4; 4; 4; 4]));
  (assert ((candidate ".| .| .| .|") = [1; 1; 1; 1]));
  (assert ((candidate "o| o| .| .| o o o o") = [2; 2; 1; 1; 4; 4; 4; 4]));
  (assert ((candidate "o| .| o| .| o o| o o|") = [2; 1; 2; 1; 4; 2; 4; 2]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
(**Input to this function is a string representing musical notes in a special ASCII format.
 * Your task is to parse this string and return list of integers corresponding to how many beats does each
 * not last.
 * Here is a legend:
 * 'o' - whole note, lasts four beats
 * 'o|' - half note, lasts two beats
 * '.|' - quater note, lasts one beat
 * >>> parse_music "o o| .| o| o| .| .| .| .| o o"
 * [4; 2; 1; 2; 2; 1; 1; 1; 1; 4; 4]
*)
let parse_music (music_string : string) : int list =
  (* Split the input string on spaces, trimming leading/trailing whitespace
     and filtering out any empty tokens that may arise from multiple spaces. *)
  let tokens =
    music_string
    |> String.trim
    |> String.split_on_char ' '
    |> List.filter (fun t -> t <> "")
  in
  (* Convert each token into its beat value. *)
  List.map
    (fun token ->
       match token with
       | "o"   -> 4   (* whole note *)
       | "o|"  -> 2   (* half note *)
       | ".|"  -> 1   (* quarter note *)
       | _ -> failwith ("Unknown token in music string: " ^ token))
    tokens

let assertions =
 let candidate = parse_music in
  (assert ((candidate "") = []));
  (assert ((candidate "o o o o") = [4; 4; 4; 4]));
  (assert ((candidate ".| .| .| .|") = [1; 1; 1; 1]));
  (assert ((candidate "o| o| .| .| o o o o") = [2; 2; 1; 1; 4; 4; 4; 4]));
  (assert ((candidate "o| .| o| .| o o| o o|") = [2; 1; 2; 1; 4; 2; 4; 2]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
(**Input to this function is a string representing musical notes in a special ASCII format.
 * Your task is to parse this string and return list of integers corresponding to how many beats does each
 * not last.
 * Here is a legend:
 * 'o' - whole note, lasts four beats
 * 'o|' - half note, lasts two beats
 * '.|' - quater note, lasts one beat
 * >>> parse_music "o o| .| o| o| .| .| .| .| o o"
 * [4; 2; 1; 2; 2; 1; 1; 1; 1; 4; 4]
*)
(* Parses a string of musical notes written in a simple ASCII format and
   returns a list of beat counts for each note. *)
let parse_music (music_string : string) : int list =
  (* Helper: convert a single note token to its beat value *)
  let beats_of_token = function
    | "o"  -> 4   (* whole note *)
    | "o|" -> 2   (* half note *)
    | ".|" -> 1   (* quarter note *)
    | _    -> 0   (* unknown token – treated as 0 beats *)
  in
  (* Split the input on spaces, filter out any empty tokens, and map to beats *)
  music_string
  |> String.split_on_char ' '
  |> List.filter (fun s -> s <> "")
  |> List.map beats_of_token

let assertions =
 let candidate = parse_music in
  (assert ((candidate "") = []));
  (assert ((candidate "o o o o") = [4; 4; 4; 4]));
  (assert ((candidate ".| .| .| .|") = [1; 1; 1; 1]));
  (assert ((candidate "o| o| .| .| o o o o") = [2; 2; 1; 1; 4; 4; 4; 4]));
  (assert ((candidate "o| .| o| .| o o| o o|") = [2; 1; 2; 1; 4; 2; 4; 2]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
(**Input to this function is a string representing musical notes in a special ASCII format.
 * Your task is to parse this string and return list of integers corresponding to how many beats does each
 * not last.
 * Here is a legend:
 * 'o' - whole note, lasts four beats
 * 'o|' - half note, lasts two beats
 * '.|' - quater note, lasts one beat
 * >>> parse_music "o o| .| o| o| .| .| .| .| o o"
 * [4; 2; 1; 2; 2; 1; 1; 1; 1; 4; 4]
*)
let parse_music (music_string : string) : int list =
  (* Split the string on spaces, ignoring empty tokens that may arise
     from consecutive spaces. *)
  let tokens =
    music_string
    |> String.split_on_char ' '
    |> List.filter (fun t -> t <> "")
  in
  (* Translate each token into its corresponding beat count. *)
  List.map (fun token ->
      match token with
      | "o"   -> 4          (* whole note *)
      | "o|"  -> 2          (* half note *)
      | ".|"  -> 1          (* quarter note *)
      | _     -> failwith ("Unknown token: " ^ token)
    ) tokens

let assertions =
 let candidate = parse_music in
  (assert ((candidate "") = []));
  (assert ((candidate "o o o o") = [4; 4; 4; 4]));
  (assert ((candidate ".| .| .| .|") = [1; 1; 1; 1]));
  (assert ((candidate "o| o| .| .| o o o o") = [2; 2; 1; 1; 4; 4; 4; 4]));
  (assert ((candidate "o| .| o| .| o o| o o|") = [2; 1; 2; 1; 4; 2; 4; 2]));
  ()


EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183711
STDOUT: (empty)
STDERR: (empty)
--------------------
