As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3â€“7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 5 (R) - HumanEval_5_intersperse
================================================================================

PROMPT:
----------------------------------------
# Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
# >>> intersperse(c(), 4)
# c()
# >>> intersperse(c(1, 2, 3), 4)
# c(1, 4, 2, 4, 3)

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- intersperse
    stopifnot(isTRUE(all.equal(candidate(c(), 7), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 2), 8), c(5, 8, 6, 8, 3, 8, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 2, 2), 2), c(2, 2, 2, 2, 2))))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
# >>> intersperse(c(), 4)
# c()
# >>> intersperse(c(1, 2, 3), 4)
# c(1, 4, 2, 4, 3)
# Insert a number 'delimeter' between every two consecutive elements of input list `numbers`
# >>> intersperse(c(), 4)
# c()
# >>> intersperse(c(1, 2, 3), 4)
# c(1, 4, 2, 4, 3)
intersperse <- function(numbers, delimeter) {
  n <- length(numbers)
  # If there are 0 or 1 elements, nothing to intersperse
  if (n <= 1) return(numbers)
  
  # Create a vector of the appropriate length and mode
  out <- vector(mode = mode(numbers), length = n * 2 - 1)
  
  # Place the original numbers in odd positions
  out[seq(1, length(out), by = 2)] <- numbers
  
  # Place the delimiter in even positions
  out[seq(2, length(out), by = 2)] <- delimeter
  
  out
}
test_humaneval <- function() {
    candidate <- intersperse
    stopifnot(isTRUE(all.equal(candidate(c(), 7), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 2), 8), c(5, 8, 6, 8, 3, 8, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 2, 2), 2), c(2, 2, 2, 2, 2))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183735
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
# >>> intersperse(c(), 4)
# c()
# >>> intersperse(c(1, 2, 3), 4)
# c(1, 4, 2, 4, 3)
# Insert a number 'delimeter' between every two consecutive elements of input list `numbers`
# >>> intersperse(c(), 4)
# c()
# >>> intersperse(c(1, 2, 3), 4)
# c(1, 4, 2, 4, 3)
intersperse <- function(numbers, delimeter) {
  # Handle empty input
  if (length(numbers) == 0) return(numbers)
  
  # Prepare a vector of the appropriate type and length
  result_len <- 2 * length(numbers) - 1
  result <- vector(mode = typeof(numbers), length = result_len)
  
  # Fill odd positions with the original numbers
  result[seq(1, result_len, by = 2)] <- numbers
  
  # Fill even positions with the delimiter
  result[seq(2, result_len, by = 2)] <- delimeter
  
  return(result)
}
test_humaneval <- function() {
    candidate <- intersperse
    stopifnot(isTRUE(all.equal(candidate(c(), 7), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 2), 8), c(5, 8, 6, 8, 3, 8, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 2, 2), 2), c(2, 2, 2, 2, 2))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183735
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
# >>> intersperse(c(), 4)
# c()
# >>> intersperse(c(1, 2, 3), 4)
# c(1, 4, 2, 4, 3)
# Insert a number 'delimeter' between every two consecutive elements of input list `numbers`
# >>> intersperse(c(), 4)
# c()
# >>> intersperse(c(1, 2, 3), 4)
# c(1, 4, 2, 4, 3)
intersperse <- function(numbers, delimeter) {
  n <- length(numbers)
  # For 0 or 1 element, nothing to intersperse
  if (n <= 1) {
    return(numbers)
  }
  # Create a vector of the appropriate length
  result <- vector(mode = typeof(numbers), length = 2 * n - 1)
  # Fill odd positions with the original numbers
  result[seq(1, 2 * n - 1, by = 2)] <- numbers
  # Fill even positions with the delimiter
  result[seq(2, 2 * n - 2, by = 2)] <- delimeter
  return(result)
}
test_humaneval <- function() {
    candidate <- intersperse
    stopifnot(isTRUE(all.equal(candidate(c(), 7), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 2), 8), c(5, 8, 6, 8, 3, 8, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 2, 2), 2), c(2, 2, 2, 2, 2))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183735
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
# >>> intersperse(c(), 4)
# c()
# >>> intersperse(c(1, 2, 3), 4)
# c(1, 4, 2, 4, 3)
# Insert a number 'delimeter' between every two consecutive elements of input list `numbers`
# >>> intersperse(c(), 4)
# c()
# >>> intersperse(c(1, 2, 3), 4)
# c(1, 4, 2, 4, 3)
intersperse <- function(numbers, delimeter) {
  n <- length(numbers)
  if (n <= 1) return(numbers)

  # Allocate a vector that will hold numbers and delimiters alternately
  result <- vector(mode = typeof(numbers), length = 2 * n - 1)

  # Place numbers at odd indices, delimiters at even indices
  result[seq(1, by = 2)] <- numbers
  result[seq(2, by = 2)] <- delimeter

  result
}
test_humaneval <- function() {
    candidate <- intersperse
    stopifnot(isTRUE(all.equal(candidate(c(), 7), c())))
    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 2), 8), c(5, 8, 6, 8, 3, 8, 2))))
    stopifnot(isTRUE(all.equal(candidate(c(2, 2, 2), 2), c(2, 2, 2, 2, 2))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183735
STDOUT: (empty)
STDERR:
Error in seq.default(2, by = 2) : wrong sign in 'by' argument
Calls: test_humaneval ... isTRUE -> all.equal -> candidate -> seq -> seq.default
In addition: Warning message:
In result[seq(1, by = 2)] <- numbers :
  number of items to replace is not a multiple of replacement length
Execution halted
--------------------

================================================================================
PROBLEM 22 (R) - HumanEval_22_filter_integers
================================================================================

PROMPT:
----------------------------------------
# Filter given list of any rthon values only for integers
# >>> filter_integers(list('a', 3.14, 5))
# c(5)
# >>> filter_integers(list(1, 2, 3, 'abc', list(), c()))
# c(1, 2, 3)

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- filter_integers
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(list(4, list(), c(), 23.2, 9, 'adasd')), c(4, 9))))
    stopifnot(isTRUE(all.equal(candidate(list(3, 'c', 3, 3, 'a', 'b')), c(3, 3, 3))))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Filter given list of any rthon values only for integers
# >>> filter_integers(list('a', 3.14, 5))
# c(5)
# >>> filter_integers(list(1, 2, 3, 'abc', list(), c()))
# c(1, 2, 3)
# Filter given list of any rthon values only for integers
# >>> filter_integers(list('a', 3.14, 5))
# c(5)
# >>> filter_integers(list(1, 2, 3, 'abc', list(), c()))
# c(1, 2, 3)
filter_integers <- function(values) {
  # Identify elements that are numeric and represent whole numbers
  is_int <- sapply(values, function(x) {
    # Must be numeric (or integer) and not NA
    if (!is.numeric(x) || is.na(x)) return(FALSE)
    # Check if the numeric value is an integer (whole number)
    floor(x) == x
  })
  # Return the matching elements as a numeric vector
  unlist(values[is_int])
}
test_humaneval <- function() {
    candidate <- filter_integers
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(list(4, list(), c(), 23.2, 9, 'adasd')), c(4, 9))))
    stopifnot(isTRUE(all.equal(candidate(list(3, 'c', 3, 3, 'a', 'b')), c(3, 3, 3))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183743
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Filter given list of any rthon values only for integers
# >>> filter_integers(list('a', 3.14, 5))
# c(5)
# >>> filter_integers(list(1, 2, 3, 'abc', list(), c()))
# c(1, 2, 3)
# Filter given list of any rthon values only for integers
# >>> filter_integers(list('a', 3.14, 5))
# c(5)
# >>> filter_integers(list(1, 2, 3, 'abc', list(), c()))
# c(1, 2, 3)
filter_integers <- function(values) {
  # Ensure the input is a list
  if (!is.list(values)) {
    stop("Input must be a list")
  }
  
  # Helper to determine if an element is an integer value
  is_int_value <- function(x) {
    is.numeric(x) && !is.na(x) && floor(x) == x
  }
  
  # Filter the list for integer-valued numeric elements
  ints <- Filter(is_int_value, values)
  
  # Convert the filtered list to a numeric vector
  unlist(ints, recursive = FALSE)
}
test_humaneval <- function() {
    candidate <- filter_integers
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(list(4, list(), c(), 23.2, 9, 'adasd')), c(4, 9))))
    stopifnot(isTRUE(all.equal(candidate(list(3, 'c', 3, 3, 'a', 'b')), c(3, 3, 3))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183743
STDOUT: (empty)
STDERR:
Error in candidate(c()) : Input must be a list
Calls: test_humaneval -> stopifnot -> isTRUE -> all.equal -> candidate
Execution halted
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Filter given list of any rthon values only for integers
# >>> filter_integers(list('a', 3.14, 5))
# c(5)
# >>> filter_integers(list(1, 2, 3, 'abc', list(), c()))
# c(1, 2, 3)
# Filter given list of any rthon values only for integers
# >>> filter_integers(list('a', 3.14, 5))
# c(5)
# >>> filter_integers(list(1, 2, 3, 'abc', list(), c()))
# c(1, 2, 3)
filter_integers <- function(values) {
  # Keep only elements that are numeric and represent whole numbers
  keep <- sapply(values, function(x) {
    is.numeric(x) && (is.integer(x) || floor(x) == x)
  })
  # Return a plain vector (unlisted) of the kept elements
  unlist(values[keep])
}
test_humaneval <- function() {
    candidate <- filter_integers
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(list(4, list(), c(), 23.2, 9, 'adasd')), c(4, 9))))
    stopifnot(isTRUE(all.equal(candidate(list(3, 'c', 3, 3, 'a', 'b')), c(3, 3, 3))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183743
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Filter given list of any rthon values only for integers
# >>> filter_integers(list('a', 3.14, 5))
# c(5)
# >>> filter_integers(list(1, 2, 3, 'abc', list(), c()))
# c(1, 2, 3)
# Filter given list of any rthon values only for integers
# >>> filter_integers(list('a', 3.14, 5))
# c(5)
# >>> filter_integers(list(1, 2, 3, 'abc', list(), c()))
# c(1, 2, 3)
filter_integers <- function(values) {
  # Keep only elements that are numeric and have no fractional part
  int_elements <- values[sapply(values, function(x) {
    is.numeric(x) && !is.na(x) && floor(x) == x
  })]
  # Return them as a plain vector
  unlist(int_elements)
}
test_humaneval <- function() {
    candidate <- filter_integers
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(list(4, list(), c(), 23.2, 9, 'adasd')), c(4, 9))))
    stopifnot(isTRUE(all.equal(candidate(list(3, 'c', 3, 3, 'a', 'b')), c(3, 3, 3))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183743
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 43 (R) - HumanEval_43_pairs_sum_to_zero
================================================================================

PROMPT:
----------------------------------------
# pairs_sum_to_zero takes a list of integers as an input.
# it returns TRUE if there are two distinct elements in the list that
# sum to zero, and FALSE otherwise.
# >>> pairs_sum_to_zero(c(1, 3, 5, 0))
# FALSE
# >>> pairs_sum_to_zero(c(1, 3, -2, 1))
# FALSE
# >>> pairs_sum_to_zero(c(1, 2, 3, 7))
# FALSE
# >>> pairs_sum_to_zero(c(2, 4, -5, 3, 5, 7))
# TRUE
# >>> pairs_sum_to_zero(c(1))
# FALSE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- pairs_sum_to_zero
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 5, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 30)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 31)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 30)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 31)), FALSE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# pairs_sum_to_zero takes a list of integers as an input.
# it returns TRUE if there are two distinct elements in the list that
# sum to zero, and FALSE otherwise.
# >>> pairs_sum_to_zero(c(1, 3, 5, 0))
# FALSE
# >>> pairs_sum_to_zero(c(1, 3, -2, 1))
# FALSE
# >>> pairs_sum_to_zero(c(1, 2, 3, 7))
# FALSE
# >>> pairs_sum_to_zero(c(2, 4, -5, 3, 5, 7))
# TRUE
# >>> pairs_sum_to_zero(c(1))
# FALSE
pairs_sum_to_zero <- function(l) {
  # Need at least two elements to form a pair
  if (length(l) < 2) return(FALSE)
  
  # Check each distinct pair for a sum of zero
  for (i in seq_along(l)) {
    for (j in (i + 1):length(l)) {
      if (l[i] + l[j] == 0) {
        return(TRUE)
      }
    }
  }
  
  # No pair found
  return(FALSE)
}
test_humaneval <- function() {
    candidate <- pairs_sum_to_zero
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 5, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 30)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 31)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 30)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 31)), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183753
STDOUT: (empty)
STDERR:
Error in if (l[i] + l[j] == 0) { : missing value where TRUE/FALSE needed
Calls: test_humaneval -> stopifnot -> isTRUE -> all.equal -> candidate
Execution halted
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# pairs_sum_to_zero takes a list of integers as an input.
# it returns TRUE if there are two distinct elements in the list that
# sum to zero, and FALSE otherwise.
# >>> pairs_sum_to_zero(c(1, 3, 5, 0))
# FALSE
# >>> pairs_sum_to_zero(c(1, 3, -2, 1))
# FALSE
# >>> pairs_sum_to_zero(c(1, 2, 3, 7))
# FALSE
# >>> pairs_sum_to_zero(c(2, 4, -5, 3, 5, 7))
# TRUE
# >>> pairs_sum_to_zero(c(1))
# FALSE
pairs_sum_to_zero <- function(l) {
  # Need at least two elements to form a pair
  if (length(l) < 2) return(FALSE)
  
  # Count occurrences of each value
  tbl <- table(l)
  
  # Iterate over each unique value
  for (x in names(tbl)) {
    val <- as.numeric(x)
    
    # Check if the negation exists in the list
    if (-val %in% as.numeric(names(tbl))) {
      # For zero we need at least two occurrences
      if (val != 0 || tbl[x] > 1) {
        return(TRUE)
      }
    }
  }
  
  FALSE
}
test_humaneval <- function() {
    candidate <- pairs_sum_to_zero
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 5, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 30)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 31)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 30)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 31)), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183753
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# pairs_sum_to_zero takes a list of integers as an input.
# it returns TRUE if there are two distinct elements in the list that
# sum to zero, and FALSE otherwise.
# >>> pairs_sum_to_zero(c(1, 3, 5, 0))
# FALSE
# >>> pairs_sum_to_zero(c(1, 3, -2, 1))
# FALSE
# >>> pairs_sum_to_zero(c(1, 2, 3, 7))
# FALSE
# >>> pairs_sum_to_zero(c(2, 4, -5, 3, 5, 7))
# TRUE
# >>> pairs_sum_to_zero(c(1))
# FALSE
pairs_sum_to_zero <- function(l) {
  n <- length(l)
  if (n < 2) return(FALSE)          # Need at least two elements
  
  # Check every unordered pair of indices
  for (i in seq_len(n - 1)) {
    for (j in (i + 1):n) {
      if (l[i] + l[j] == 0) {
        return(TRUE)                # Found a pair that sums to zero
      }
    }
  }
  
  FALSE                               # No such pair found
}
test_humaneval <- function() {
    candidate <- pairs_sum_to_zero
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 5, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 30)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 31)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 30)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 31)), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183753
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# pairs_sum_to_zero takes a list of integers as an input.
# it returns TRUE if there are two distinct elements in the list that
# sum to zero, and FALSE otherwise.
# >>> pairs_sum_to_zero(c(1, 3, 5, 0))
# FALSE
# >>> pairs_sum_to_zero(c(1, 3, -2, 1))
# FALSE
# >>> pairs_sum_to_zero(c(1, 2, 3, 7))
# FALSE
# >>> pairs_sum_to_zero(c(2, 4, -5, 3, 5, 7))
# TRUE
# >>> pairs_sum_to_zero(c(1))
# FALSE
pairs_sum_to_zero <- function(l) {
  n <- length(l)
  if (n < 2) return(FALSE)          # need at least two elements
  
  for (i in seq_len(n - 1)) {
    for (j in (i + 1):n) {
      if (l[i] + l[j] == 0) {
        return(TRUE)
      }
    }
  }
  
  FALSE
}
test_humaneval <- function() {
    candidate <- pairs_sum_to_zero
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 5, 7)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 30)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 31)), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 30)), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 31)), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183753
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 65 (R) - HumanEval_65_circular_shift
================================================================================

PROMPT:
----------------------------------------
# Circular shift the digits of the integer x, shift the digits right by shift
# and return the result as a string.
# If shift > number of digits, return digits reversed.
# >>> circular_shift(12, 1)
# '21'
# >>> circular_shift(12, 2)
# '12'

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- circular_shift
    stopifnot(isTRUE(all.equal(candidate(100, 2), '001')))
    stopifnot(isTRUE(all.equal(candidate(12, 2), '12')))
    stopifnot(isTRUE(all.equal(candidate(97, 8), '79')))
    stopifnot(isTRUE(all.equal(candidate(12, 1), '21')))
    stopifnot(isTRUE(all.equal(candidate(11, 101), '11')))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Circular shift the digits of the integer x, shift the digits right by shift
# and return the result as a string.
# If shift > number of digits, return digits reversed.
# >>> circular_shift(12, 1)
# '21'
# >>> circular_shift(12, 2)
# '12'
# Circular shift the digits of the integer x, shift the digits right by shift
# and return the result as a string.
# If shift > number of digits, return digits reversed.
# >>> circular_shift(12, 1)
# '21'
# >>> circular_shift(12, 2)
# '12'
circular_shift <- function(x, shift) {
  # Convert the integer to a character vector of its digits
  digits <- strsplit(as.character(x), "")[[1]]
  n <- length(digits)
  
  # If the shift exceeds the number of digits, reverse the digits
  if (shift > n) {
    return(paste(rev(digits), collapse = ""))
  }
  
  # No shift needed
  if (shift == 0) {
    return(paste(digits, collapse = ""))
  }
  
  # Circular right shift: take the last `shift` digits and prepend them
  shifted <- c(tail(digits, shift), head(digits, n - shift))
  return(paste(shifted, collapse = ""))
}
test_humaneval <- function() {
    candidate <- circular_shift
    stopifnot(isTRUE(all.equal(candidate(100, 2), '001')))
    stopifnot(isTRUE(all.equal(candidate(12, 2), '12')))
    stopifnot(isTRUE(all.equal(candidate(97, 8), '79')))
    stopifnot(isTRUE(all.equal(candidate(12, 1), '21')))
    stopifnot(isTRUE(all.equal(candidate(11, 101), '11')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183764
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Circular shift the digits of the integer x, shift the digits right by shift
# and return the result as a string.
# If shift > number of digits, return digits reversed.
# >>> circular_shift(12, 1)
# '21'
# >>> circular_shift(12, 2)
# '12'
# Circular shift the digits of the integer x, shift the digits right by shift
# and return the result as a string.
# If shift > number of digits, return digits reversed.
# >>> circular_shift(12, 1)
# '21'
# >>> circular_shift(12, 2)
# '12'
circular_shift <- function(x, shift) {
  # Convert the absolute value of x to a string of digits
  s <- as.character(abs(x))
  digits <- strsplit(s, "")[[1]]
  n <- length(digits)
  
  # If shift is greater than the number of digits, reverse the digits
  if (shift > n) {
    return(paste0(rev(digits), collapse = ""))
  }
  
  # Reduce shift to the equivalent rotation within the digit length
  shift <- shift %% n
  
  # No rotation needed
  if (shift == 0) {
    return(s)
  }
  
  # Perform the circular right shift
  rotated <- c(tail(digits, shift), digits[1:(n - shift)])
  return(paste0(rotated, collapse = ""))
}
test_humaneval <- function() {
    candidate <- circular_shift
    stopifnot(isTRUE(all.equal(candidate(100, 2), '001')))
    stopifnot(isTRUE(all.equal(candidate(12, 2), '12')))
    stopifnot(isTRUE(all.equal(candidate(97, 8), '79')))
    stopifnot(isTRUE(all.equal(candidate(12, 1), '21')))
    stopifnot(isTRUE(all.equal(candidate(11, 101), '11')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183764
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Circular shift the digits of the integer x, shift the digits right by shift
# and return the result as a string.
# If shift > number of digits, return digits reversed.
# >>> circular_shift(12, 1)
# '21'
# >>> circular_shift(12, 2)
# '12'
# Circular shift the digits of the integer x, shift the digits right by shift
# and return the result as a string.
# If shift > number of digits, return digits reversed.
# >>> circular_shift(12, 1)
# '21'
# >>> circular_shift(12, 2)
# '12'
circular_shift <- function(x, shift) {
  # Convert the integer to a character vector of its digits
  digits <- strsplit(as.character(x), "")[[1]]
  n <- length(digits)
  
  # If shift is greater than the number of digits, reverse the digits
  if (shift > n) {
    return(paste(rev(digits), collapse = ""))
  }
  
  # If shift is 0 or negative, return the original number as a string
  if (shift <= 0) {
    return(paste(digits, collapse = ""))
  }
  
  # Perform a right circular shift by `shift` positions
  # Take the last `shift` digits and put them in front
  tail_part <- digits[(n - shift + 1):n]
  head_part <- digits[1:(n - shift)]
  result <- paste(c(tail_part, head_part), collapse = "")
  return(result)
}
test_humaneval <- function() {
    candidate <- circular_shift
    stopifnot(isTRUE(all.equal(candidate(100, 2), '001')))
    stopifnot(isTRUE(all.equal(candidate(12, 2), '12')))
    stopifnot(isTRUE(all.equal(candidate(97, 8), '79')))
    stopifnot(isTRUE(all.equal(candidate(12, 1), '21')))
    stopifnot(isTRUE(all.equal(candidate(11, 101), '11')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183764
STDOUT: (empty)
STDERR:
Error in test_humaneval() : 
  isTRUE(all.equal(candidate(12, 2), "12")) is not TRUE
Calls: test_humaneval -> stopifnot
Execution halted
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Circular shift the digits of the integer x, shift the digits right by shift
# and return the result as a string.
# If shift > number of digits, return digits reversed.
# >>> circular_shift(12, 1)
# '21'
# >>> circular_shift(12, 2)
# '12'
# Circular shift the digits of the integer x, shift the digits right by shift
# and return the result as a string.
# If shift > number of digits, return digits reversed.
# >>> circular_shift(12, 1)
# '21'
# >>> circular_shift(12, 2)
# '12'
circular_shift <- function(x, shift) {
  # Convert the integer to a character vector of its digits
  digits <- strsplit(as.character(x), NULL)[[1]]
  n <- length(digits)
  
  # If shift is greater than the number of digits, return reversed digits
  if (shift > n) {
    return(paste(rev(digits), collapse = ""))
  }
  
  # Compute effective shift (right rotation)
  shift_mod <- shift %% n
  if (shift_mod == 0) {
    return(paste(digits, collapse = ""))
  }
  
  # Perform the right circular shift
  tail_part <- digits[(n - shift_mod + 1):n]
  head_part <- digits[1:(n - shift_mod)]
  result <- c(tail_part, head_part)
  
  return(paste(result, collapse = ""))
}
test_humaneval <- function() {
    candidate <- circular_shift
    stopifnot(isTRUE(all.equal(candidate(100, 2), '001')))
    stopifnot(isTRUE(all.equal(candidate(12, 2), '12')))
    stopifnot(isTRUE(all.equal(candidate(97, 8), '79')))
    stopifnot(isTRUE(all.equal(candidate(12, 1), '21')))
    stopifnot(isTRUE(all.equal(candidate(11, 101), '11')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183764
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 75 (R) - HumanEval_75_is_multiply_prime
================================================================================

PROMPT:
----------------------------------------
# Write a function that returns true if the given number is the multiplication of 3 prime numbers
# and false otherwise.
# Knowing that (a) is less then 100. 
# Example:
# >>> is_multiply_prime(30)
# TRUE
# 30 = 2 * 3 * 5

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- is_multiply_prime
    stopifnot(isTRUE(all.equal(candidate(5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(30), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(125), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(105), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(126), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(729), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(891), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1001), TRUE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Write a function that returns true if the given number is the multiplication of 3 prime numbers
# and false otherwise.
# Knowing that (a) is less then 100. 
# Example:
# >>> is_multiply_prime(30)
# TRUE
# 30 = 2 * 3 * 5
# Write a function that returns true if the given number is the multiplication of 3 prime numbers
# and false otherwise.
# Knowing that (a) is less then 100. 
# Example:
# >>> is_multiply_prime(30)
# TRUE
# 30 = 2 * 3 * 5
is_multiply_prime <- function(a) {
  # Basic checks
  if (!is.numeric(a) || length(a) != 1 || a <= 1) {
    return(FALSE)
  }
  
  n <- a
  prime_factor_count <- 0
  
  # Count prime factors (with multiplicity)
  p <- 2
  while (p * p <= n) {
    while (n %% p == 0) {
      prime_factor_count <- prime_factor_count + 1
      n <- n / p
    }
    p <- p + 1
  }
  
  # If there's any remaining prime factor larger than sqrt(original n)
  if (n > 1) {
    prime_factor_count <- prime_factor_count + 1
  }
  
  # Return TRUE only if exactly 3 prime factors were found
  return(prime_factor_count == 3)
}
test_humaneval <- function() {
    candidate <- is_multiply_prime
    stopifnot(isTRUE(all.equal(candidate(5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(30), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(125), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(105), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(126), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(729), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(891), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1001), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183769
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Write a function that returns true if the given number is the multiplication of 3 prime numbers
# and false otherwise.
# Knowing that (a) is less then 100. 
# Example:
# >>> is_multiply_prime(30)
# TRUE
# 30 = 2 * 3 * 5
# Returns TRUE if the number `a` can be expressed as a product of exactly
# three prime factors (counted with multiplicity), otherwise FALSE.
# Assumes 1 <= a < 100.
is_multiply_prime <- function(a) {
  # Basic sanity checks
  if (!is.numeric(a) || length(a) != 1 || a <= 1) return(FALSE)
  
  n <- a
  count <- 0
  i <- 2
  
  # Factor out primes up to sqrt(n)
  while (i * i <= n) {
    while (n %% i == 0) {
      count <- count + 1
      n <- n / i
      # Early exit if more than 3 factors
      if (count > 3) return(FALSE)
    }
    i <- i + 1
  }
  
  # If remaining n > 1, it's a prime factor
  if (n > 1) count <- count + 1
  
  # Return TRUE only if exactly three prime factors were found
  return(count == 3)
}
test_humaneval <- function() {
    candidate <- is_multiply_prime
    stopifnot(isTRUE(all.equal(candidate(5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(30), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(125), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(105), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(126), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(729), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(891), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1001), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183769
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Write a function that returns true if the given number is the multiplication of 3 prime numbers
# and false otherwise.
# Knowing that (a) is less then 100. 
# Example:
# >>> is_multiply_prime(30)
# TRUE
# 30 = 2 * 3 * 5
# Write a function that returns true if the given number is the multiplication of 3 prime numbers
# and false otherwise.
# Knowing that (a) is less then 100. 
# Example:
# >>> is_multiply_prime(30)
# TRUE
# 30 = 2 * 3 * 5
is_multiply_prime <- function(a) {
  # Edge cases
  if (!is.numeric(a) || length(a) != 1 || a <= 1 || a >= 100) {
    return(FALSE)
  }
  
  # Convert to integer
  a <- as.integer(a)
  if (a <= 1) return(FALSE)
  
  factors <- integer(0)
  n <- a
  
  # Trial division up to sqrt(n)
  p <- 2
  while (p * p <= n) {
    while (n %% p == 0) {
      factors <- c(factors, p)
      n <- n / p
      # Early exit if we already have more than 3 factors
      if (length(factors) > 3) return(FALSE)
    }
    p <- p + 1
  }
  
  # If there's a remaining prime factor
  if (n > 1) {
    factors <- c(factors, n)
  }
  
  # Check if we have exactly 3 prime factors
  return(length(factors) == 3)
}
test_humaneval <- function() {
    candidate <- is_multiply_prime
    stopifnot(isTRUE(all.equal(candidate(5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(30), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(125), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(105), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(126), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(729), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(891), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1001), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183769
STDOUT: (empty)
STDERR:
Error in test_humaneval() : 
  isTRUE(all.equal(candidate(125), TRUE)) is not TRUE
Calls: test_humaneval -> stopifnot
Execution halted
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Write a function that returns true if the given number is the multiplication of 3 prime numbers
# and false otherwise.
# Knowing that (a) is less then 100. 
# Example:
# >>> is_multiply_prime(30)
# TRUE
# 30 = 2 * 3 * 5
# Write a function that returns TRUE if the given number is the multiplication of 3 prime numbers
# and FALSE otherwise.
# Knowing that (a) is less then 100. 
# Example:
# >>> is_multiply_prime(30)
# TRUE
# 30 = 2 * 3 * 5

is_multiply_prime <- function(a) {
  # Basic checks
  if (!is.numeric(a) || length(a) != 1 || a < 2) {
    return(FALSE)
  }
  
  n <- a
  prime_factor_count <- 0
  i <- 2
  
  # Factorise the number and count prime factors (with multiplicity)
  while (i * i <= n) {
    while (n %% i == 0) {
      prime_factor_count <- prime_factor_count + 1
      n <- n / i
      # Early exit if we already have more than 3 factors
      if (prime_factor_count > 3) {
        return(FALSE)
      }
    }
    i <- i + 1
  }
  
  # If remaining n > 1, it's a prime factor
  if (n > 1) {
    prime_factor_count <- prime_factor_count + 1
  }
  
  # The number is a product of exactly three primes if count == 3
  return(prime_factor_count == 3)
}

# Example usage
print(is_multiply_prime(30))   # TRUE
print(is_multiply_prime(8))    # TRUE  (2 * 2 * 2)
print(is_multiply_prime(12))   # FALSE (2 * 2 * 3 has 3 primes but 12=2*2*3? actually 12=2*2*3 => 3 primes => TRUE)
print(is_multiply_prime(18))   # FALSE (2 * 3 * 3 has 3 primes => TRUE? depends on requirement)
test_humaneval <- function() {
    candidate <- is_multiply_prime
    stopifnot(isTRUE(all.equal(candidate(5), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(30), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(10), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(125), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(105), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(126), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(729), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(891), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(1001), TRUE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183769
STDOUT:
[1] TRUE
[1] TRUE
[1] TRUE
[1] TRUE
STDERR: (empty)
--------------------

================================================================================
PROBLEM 81 (R) - HumanEval_81_numerical_letter_grade
================================================================================

PROMPT:
----------------------------------------
# It is the last week of the semester and the teacher has to give the grades
# to students. The teacher has been making her own algorithm for grading.
# The only problem is, she has lost the code she used for grading.
# She has given you a list of GPAs for some students and you have to write 
# a function that can output a list of letter grades using the following table:
#          GPA       |    Letter grade
#           4.0                A+
#         > 3.7                A 
#         > 3.3                A- 
#         > 3.0                B+
#         > 2.7                B 
#         > 2.3                B-
#         > 2.0                C+
#         > 1.7                C
#         > 1.3                C-
#         > 1.0                D+ 
#         > 0.7                D 
#         > 0.0                D-
#           0.0                E
# Example:
# >>> grade_equation(c(4.0, 3, 1.7, 2, 3.5))
# c('A+', 'B', 'C-', 'C', 'A-')

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- numerical_letter_grade
    stopifnot(isTRUE(all.equal(candidate(c(4.0, 3, 1.7, 2, 3.5)), c('A+', 'B', 'C-', 'C', 'A-'))))
    stopifnot(isTRUE(all.equal(candidate(c(1.2)), c('D+'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.5)), c('D-'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.0)), c('E'))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 0.3, 1.5, 2.8, 3.3)), c('D', 'D-', 'C-', 'B', 'B+'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.0, 0.7)), c('E', 'D-'))))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# It is the last week of the semester and the teacher has to give the grades
# to students. The teacher has been making her own algorithm for grading.
# The only problem is, she has lost the code she used for grading.
# She has given you a list of GPAs for some students and you have to write 
# a function that can output a list of letter grades using the following table:
#          GPA       |    Letter grade
#           4.0                A+
#         > 3.7                A 
#         > 3.3                A- 
#         > 3.0                B+
#         > 2.7                B 
#         > 2.3                B-
#         > 2.0                C+
#         > 1.7                C
#         > 1.3                C-
#         > 1.0                D+ 
#         > 0.7                D 
#         > 0.0                D-
#           0.0                E
# Example:
# >>> grade_equation(c(4.0, 3, 1.7, 2, 3.5))
# c('A+', 'B', 'C-', 'C', 'A-')
# Function to convert numeric GPAs to letter grades
numerical_letter_grade <- function(grades) {
  sapply(grades, function(g) {
    if (is.na(g)) return(NA_character_)  # Preserve NAs if any
    
    if (g == 4.0) {
      return("A+")
    } else if (g > 3.7) {
      return("A")
    } else if (g > 3.3) {
      return("A-")
    } else if (g > 3.0) {
      return("B+")
    } else if (g > 2.7) {
      return("B")
    } else if (g > 2.3) {
      return("B-")
    } else if (g > 2.0) {
      return("C+")
    } else if (g > 1.7) {
      return("C")
    } else if (g > 1.3) {
      return("C-")
    } else if (g > 1.0) {
      return("D+")
    } else if (g > 0.7) {
      return("D")
    } else if (g > 0.0) {
      return("D-")
    } else {
      return("E")
    }
  })
}
test_humaneval <- function() {
    candidate <- numerical_letter_grade
    stopifnot(isTRUE(all.equal(candidate(c(4.0, 3, 1.7, 2, 3.5)), c('A+', 'B', 'C-', 'C', 'A-'))))
    stopifnot(isTRUE(all.equal(candidate(c(1.2)), c('D+'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.5)), c('D-'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.0)), c('E'))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 0.3, 1.5, 2.8, 3.3)), c('D', 'D-', 'C-', 'B', 'B+'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.0, 0.7)), c('E', 'D-'))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183772
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# It is the last week of the semester and the teacher has to give the grades
# to students. The teacher has been making her own algorithm for grading.
# The only problem is, she has lost the code she used for grading.
# She has given you a list of GPAs for some students and you have to write 
# a function that can output a list of letter grades using the following table:
#          GPA       |    Letter grade
#           4.0                A+
#         > 3.7                A 
#         > 3.3                A- 
#         > 3.0                B+
#         > 2.7                B 
#         > 2.3                B-
#         > 2.0                C+
#         > 1.7                C
#         > 1.3                C-
#         > 1.0                D+ 
#         > 0.7                D 
#         > 0.0                D-
#           0.0                E
# Example:
# >>> grade_equation(c(4.0, 3, 1.7, 2, 3.5))
# c('A+', 'B', 'C-', 'C', 'A-')
numerical_letter_grade <- function(grades) {
  # Ensure we are working with numeric values
  grades <- as.numeric(grades)
  
  # Vectorised mapping using nested ifelse
  letter_grades <- ifelse(grades == 4.0, "A+",
                   ifelse(grades > 3.7, "A",
                   ifelse(grades > 3.3, "A-",
                   ifelse(grades > 3.0, "B+",
                   ifelse(grades > 2.7, "B",
                   ifelse(grades > 2.3, "B-",
                   ifelse(grades > 2.0, "C+",
                   ifelse(grades > 1.7, "C",
                   ifelse(grades > 1.3, "C-",
                   ifelse(grades > 1.0, "D+",
                   ifelse(grades > 0.7, "D",
                   ifelse(grades > 0.0, "D-",
                          "E"))))))))))))

  return(letter_grades)
}
test_humaneval <- function() {
    candidate <- numerical_letter_grade
    stopifnot(isTRUE(all.equal(candidate(c(4.0, 3, 1.7, 2, 3.5)), c('A+', 'B', 'C-', 'C', 'A-'))))
    stopifnot(isTRUE(all.equal(candidate(c(1.2)), c('D+'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.5)), c('D-'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.0)), c('E'))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 0.3, 1.5, 2.8, 3.3)), c('D', 'D-', 'C-', 'B', 'B+'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.0, 0.7)), c('E', 'D-'))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183772
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# It is the last week of the semester and the teacher has to give the grades
# to students. The teacher has been making her own algorithm for grading.
# The only problem is, she has lost the code she used for grading.
# She has given you a list of GPAs for some students and you have to write 
# a function that can output a list of letter grades using the following table:
#          GPA       |    Letter grade
#           4.0                A+
#         > 3.7                A 
#         > 3.3                A- 
#         > 3.0                B+
#         > 2.7                B 
#         > 2.3                B-
#         > 2.0                C+
#         > 1.7                C
#         > 1.3                C-
#         > 1.0                D+ 
#         > 0.7                D 
#         > 0.0                D-
#           0.0                E
# Example:
# >>> grade_equation(c(4.0, 3, 1.7, 2, 3.5))
# c('A+', 'B', 'C-', 'C', 'A-')
numerical_letter_grade <- function(grades) {
  # Ensure we are working with numeric values
  grades <- as.numeric(grades)
  
  # Prepare a character vector to hold the results
  result <- character(length(grades))
  
  # Assign grades from the lowest threshold to the highest.
  # Higher thresholds override lower ones.
  result[grades > 0.0]   <- "D-"
  result[grades > 0.7]   <- "D"
  result[grades > 1.0]   <- "D+"
  result[grades > 1.3]   <- "C-"
  result[grades > 1.7]   <- "C"
  result[grades > 2.0]   <- "C+"
  result[grades > 2.3]   <- "B-"
  result[grades > 2.7]   <- "B"
  result[grades > 3.0]   <- "B+"
  result[grades > 3.3]   <- "A-"
  result[grades > 3.7]   <- "A"
  result[grades == 4.0]  <- "A+"
  result[grades == 0.0]  <- "E"
  
  # Preserve NA values if any were present in the input
  result[is.na(grades)] <- NA
  
  return(result)
}
test_humaneval <- function() {
    candidate <- numerical_letter_grade
    stopifnot(isTRUE(all.equal(candidate(c(4.0, 3, 1.7, 2, 3.5)), c('A+', 'B', 'C-', 'C', 'A-'))))
    stopifnot(isTRUE(all.equal(candidate(c(1.2)), c('D+'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.5)), c('D-'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.0)), c('E'))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 0.3, 1.5, 2.8, 3.3)), c('D', 'D-', 'C-', 'B', 'B+'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.0, 0.7)), c('E', 'D-'))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183772
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# It is the last week of the semester and the teacher has to give the grades
# to students. The teacher has been making her own algorithm for grading.
# The only problem is, she has lost the code she used for grading.
# She has given you a list of GPAs for some students and you have to write 
# a function that can output a list of letter grades using the following table:
#          GPA       |    Letter grade
#           4.0                A+
#         > 3.7                A 
#         > 3.3                A- 
#         > 3.0                B+
#         > 2.7                B 
#         > 2.3                B-
#         > 2.0                C+
#         > 1.7                C
#         > 1.3                C-
#         > 1.0                D+ 
#         > 0.7                D 
#         > 0.0                D-
#           0.0                E
# Example:
# >>> grade_equation(c(4.0, 3, 1.7, 2, 3.5))
# c('A+', 'B', 'C-', 'C', 'A-')
numerical_letter_grade <- function(grades) {
  grades <- as.numeric(grades)
  
  # Vectorised nested ifelse to map GPA to letter grades
  res <- ifelse(grades == 4.0, "A+",
                ifelse(grades > 3.7, "A",
                       ifelse(grades > 3.3, "A-",
                              ifelse(grades > 3.0, "B+",
                                     ifelse(grades > 2.7, "B",
                                            ifelse(grades > 2.3, "B-",
                                                   ifelse(grades > 2.0, "C+",
                                                          ifelse(grades > 1.7, "C",
                                                                 ifelse(grades > 1.3, "C-",
                                                                        ifelse(grades > 1.0, "D+",
                                                                               ifelse(grades > 0.7, "D",
                                                                                      ifelse(grades > 0.0, "D-",
                                                                                             "E")))))))))))
  return(res)
}
test_humaneval <- function() {
    candidate <- numerical_letter_grade
    stopifnot(isTRUE(all.equal(candidate(c(4.0, 3, 1.7, 2, 3.5)), c('A+', 'B', 'C-', 'C', 'A-'))))
    stopifnot(isTRUE(all.equal(candidate(c(1.2)), c('D+'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.5)), c('D-'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.0)), c('E'))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 0.3, 1.5, 2.8, 3.3)), c('D', 'D-', 'C-', 'B', 'B+'))))
    stopifnot(isTRUE(all.equal(candidate(c(0.0, 0.7)), c('E', 'D-'))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755183772
STDOUT: (empty)
STDERR:
Error: unexpected symbol in:
"                                                                                             "E")))))))))))
  return"
Execution halted
--------------------

================================================================================
PROBLEM 89 (R) - HumanEval_89_encrypt
================================================================================

PROMPT:
----------------------------------------
# Create a function encrypt that takes a string as an argument and
# returns a string encrypted with the alphabet being rotated. 
# The alphabet should be rotated in a manner such that the letters 
# shift down by two multiplied to two places.
# For example:
# >>> encrypt('hi')
# 'lm'
# >>> encrypt('asdfghjkl')
# 'ewhjklnop'
# >>> encrypt('gf')
# 'kj'
# >>> encrypt('et')
# 'ix'

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- encrypt
    stopifnot(isTRUE(all.equal(candidate('hi'), 'lm')))
    stopifnot(isTRUE(all.equal(candidate('asdfghjkl'), 'ewhjklnop')))
    stopifnot(isTRUE(all.equal(candidate('gf'), 'kj')))
    stopifnot(isTRUE(all.equal(candidate('et'), 'ix')))
    stopifnot(isTRUE(all.equal(candidate('faewfawefaewg'), 'jeiajeaijeiak')))
    stopifnot(isTRUE(all.equal(candidate('hellomyfriend'), 'lippsqcjvmirh')))
    stopifnot(isTRUE(all.equal(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')))
    stopifnot(isTRUE(all.equal(candidate('a'), 'e')))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Create a function encrypt that takes a string as an argument and
# returns a string encrypted with the alphabet being rotated. 
# The alphabet should be rotated in a manner such that the letters 
# shift down by two multiplied to two places.
# For example:
# >>> encrypt('hi')
# 'lm'
# >>> encrypt('asdfghjkl')
# 'ewhjklnop'
# >>> encrypt('gf')
# 'kj'
# >>> encrypt('et')
# 'ix'
encrypt <- function(s) {
  # Split the string into individual characters
  chars <- strsplit(s, "")[[1]]
  
  # Convert characters to their ASCII integer codes
  ascii <- utf8ToInt(chars)
  
  # Shift only lowercase alphabetic characters by 4 positions
  # (wrap around using modulo 26)
  idx <- ascii >= 97 & ascii <= 122          # 'a' to 'z'
  ascii[idx] <- ((ascii[idx] - 97 + 4) %% 26) + 97
  
  # Convert the shifted ASCII codes back to characters and paste together
  paste0(intToUtf8(ascii), collapse = "")
}
test_humaneval <- function() {
    candidate <- encrypt
    stopifnot(isTRUE(all.equal(candidate('hi'), 'lm')))
    stopifnot(isTRUE(all.equal(candidate('asdfghjkl'), 'ewhjklnop')))
    stopifnot(isTRUE(all.equal(candidate('gf'), 'kj')))
    stopifnot(isTRUE(all.equal(candidate('et'), 'ix')))
    stopifnot(isTRUE(all.equal(candidate('faewfawefaewg'), 'jeiajeaijeiak')))
    stopifnot(isTRUE(all.equal(candidate('hellomyfriend'), 'lippsqcjvmirh')))
    stopifnot(isTRUE(all.equal(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')))
    stopifnot(isTRUE(all.equal(candidate('a'), 'e')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183776
STDOUT: (empty)
STDERR:
Error in test_humaneval() : 
  isTRUE(all.equal(candidate("hi"), "lm")) is not TRUE
Calls: test_humaneval -> stopifnot
In addition: Warning message:
In utf8ToInt(chars) : argument should be a character vector of length 1
all but the first element will be ignored
Execution halted
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Create a function encrypt that takes a string as an argument and
# returns a string encrypted with the alphabet being rotated. 
# The alphabet should be rotated in a manner such that the letters 
# shift down by two multiplied to two places.
# For example:
# >>> encrypt('hi')
# 'lm'
# >>> encrypt('asdfghjkl')
# 'ewhjklnop'
# >>> encrypt('gf')
# 'kj'
# >>> encrypt('et')
# 'ix'
encrypt <- function(s) {
  # Helper to shift a single character by 4 positions
  shift_char <- function(ch) {
    # Only shift lowercase letters aâ€“z
    if (grepl("[a-z]", ch)) {
      # Convert to ASCII code, shift, wrap around, convert back
      pos <- (utf8ToInt(ch) - utf8ToInt("a") + 4) %% 26 + utf8ToInt("a")
      intToUtf8(pos)
    } else {
      ch  # leave nonâ€‘letters unchanged
    }
  }
  
  # Split the string into individual characters, shift each, and recombine
  chars <- strsplit(s, "")[[1]]
  shifted <- sapply(chars, shift_char)
  paste0(shifted, collapse = "")
}
test_humaneval <- function() {
    candidate <- encrypt
    stopifnot(isTRUE(all.equal(candidate('hi'), 'lm')))
    stopifnot(isTRUE(all.equal(candidate('asdfghjkl'), 'ewhjklnop')))
    stopifnot(isTRUE(all.equal(candidate('gf'), 'kj')))
    stopifnot(isTRUE(all.equal(candidate('et'), 'ix')))
    stopifnot(isTRUE(all.equal(candidate('faewfawefaewg'), 'jeiajeaijeiak')))
    stopifnot(isTRUE(all.equal(candidate('hellomyfriend'), 'lippsqcjvmirh')))
    stopifnot(isTRUE(all.equal(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')))
    stopifnot(isTRUE(all.equal(candidate('a'), 'e')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183776
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Create a function encrypt that takes a string as an argument and
# returns a string encrypted with the alphabet being rotated. 
# The alphabet should be rotated in a manner such that the letters 
# shift down by two multiplied to two places.
# For example:
# >>> encrypt('hi')
# 'lm'
# >>> encrypt('asdfghjkl')
# 'ewhjklnop'
# >>> encrypt('gf')
# 'kj'
# >>> encrypt('et')
# 'ix'
encrypt <- function(s) {
  # Split the input string into individual characters
  chars <- strsplit(s, "")[[1]]
  
  # Helper to shift a single character by 4 positions
  shift_char <- function(ch) {
    ascii <- utf8ToInt(ch)
    
    # Lowercase letters
    if (ascii >= utf8ToInt('a') && ascii <= utf8ToInt('z')) {
      shifted <- ((ascii - utf8ToInt('a') + 4) %% 26) + utf8ToInt('a')
      intToUtf8(shifted)
    }
    # Uppercase letters
    else if (ascii >= utf8ToInt('A') && ascii <= utf8ToInt('Z')) {
      shifted <- ((ascii - utf8ToInt('A') + 4) %% 26) + utf8ToInt('A')
      intToUtf8(shifted)
    }
    # Nonâ€‘alphabetic characters remain unchanged
    else {
      ch
    }
  }
  
  # Apply the shift to each character and recombine
  paste0(sapply(chars, shift_char), collapse = "")
}
test_humaneval <- function() {
    candidate <- encrypt
    stopifnot(isTRUE(all.equal(candidate('hi'), 'lm')))
    stopifnot(isTRUE(all.equal(candidate('asdfghjkl'), 'ewhjklnop')))
    stopifnot(isTRUE(all.equal(candidate('gf'), 'kj')))
    stopifnot(isTRUE(all.equal(candidate('et'), 'ix')))
    stopifnot(isTRUE(all.equal(candidate('faewfawefaewg'), 'jeiajeaijeiak')))
    stopifnot(isTRUE(all.equal(candidate('hellomyfriend'), 'lippsqcjvmirh')))
    stopifnot(isTRUE(all.equal(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')))
    stopifnot(isTRUE(all.equal(candidate('a'), 'e')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183776
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Create a function encrypt that takes a string as an argument and
# returns a string encrypted with the alphabet being rotated. 
# The alphabet should be rotated in a manner such that the letters 
# shift down by two multiplied to two places.
# For example:
# >>> encrypt('hi')
# 'lm'
# >>> encrypt('asdfghjkl')
# 'ewhjklnop'
# >>> encrypt('gf')
# 'kj'
# >>> encrypt('et')
# 'ix'
encrypt <- function(s) {
  # Helper: shift a single character
  shift_char <- function(ch) {
    code <- utf8ToInt(ch)
    # Lowerâ€‘case letters
    if (code >= utf8ToInt('a') && code <= utf8ToInt('z')) {
      newcode <- ((code - utf8ToInt('a') + 4) %% 26) + utf8ToInt('a')
      intToUtf8(newcode)
    }
    # Upperâ€‘case letters
    else if (code >= utf8ToInt('A') && code <= utf8ToInt('Z')) {
      newcode <- ((code - utf8ToInt('A') + 4) %% 26) + utf8ToInt('A')
      intToUtf8(newcode)
    }
    # Nonâ€‘alphabetic characters remain unchanged
    else {
      ch
    }
  }
  
  # Split the string into individual characters, shift each, and recombine
  chars <- strsplit(s, NULL)[[1]]
  paste0(sapply(chars, shift_char), collapse = "")
}
test_humaneval <- function() {
    candidate <- encrypt
    stopifnot(isTRUE(all.equal(candidate('hi'), 'lm')))
    stopifnot(isTRUE(all.equal(candidate('asdfghjkl'), 'ewhjklnop')))
    stopifnot(isTRUE(all.equal(candidate('gf'), 'kj')))
    stopifnot(isTRUE(all.equal(candidate('et'), 'ix')))
    stopifnot(isTRUE(all.equal(candidate('faewfawefaewg'), 'jeiajeaijeiak')))
    stopifnot(isTRUE(all.equal(candidate('hellomyfriend'), 'lippsqcjvmirh')))
    stopifnot(isTRUE(all.equal(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')))
    stopifnot(isTRUE(all.equal(candidate('a'), 'e')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183776
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 90 (R) - HumanEval_90_next_smallest
================================================================================

PROMPT:
----------------------------------------
# You are given a list of integers.
# Write a function next_smallest() that returns the 2nd smallest element of the list.
# Return NULL if there is no such element.
# >>> next_smallest(c(1, 2, 3, 4, 5))
# 2
# >>> next_smallest(c(5, 1, 4, 3, 2))
# 2
# >>> next_smallest(c())
# NULL
# >>> next_smallest(c(1, 1))
# NULL

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- next_smallest
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 1, 4, 3, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 0)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(-35, 34, 12, -45)), -35)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# You are given a list of integers.
# Write a function next_smallest() that returns the 2nd smallest element of the list.
# Return NULL if there is no such element.
# >>> next_smallest(c(1, 2, 3, 4, 5))
# 2
# >>> next_smallest(c(5, 1, 4, 3, 2))
# 2
# >>> next_smallest(c())
# NULL
# >>> next_smallest(c(1, 1))
# NULL
next_smallest <- function(lst) {
  # Return NULL for an empty list
  if (length(lst) == 0) {
    return(NULL)
  }
  
  # Get unique values sorted in ascending order
  uniq_vals <- sort(unique(lst))
  
  # If there are fewer than 2 distinct values, return NULL
  if (length(uniq_vals) < 2) {
    return(NULL)
  }
  
  # Return the second smallest distinct value
  return(uniq_vals[2])
}
test_humaneval <- function() {
    candidate <- next_smallest
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 1, 4, 3, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 0)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(-35, 34, 12, -45)), -35)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183776
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# You are given a list of integers.
# Write a function next_smallest() that returns the 2nd smallest element of the list.
# Return NULL if there is no such element.
# >>> next_smallest(c(1, 2, 3, 4, 5))
# 2
# >>> next_smallest(c(5, 1, 4, 3, 2))
# 2
# >>> next_smallest(c())
# NULL
# >>> next_smallest(c(1, 1))
# NULL
next_smallest <- function(lst) {
  # If the list is empty, there's no second smallest element
  if (length(lst) == 0) return(NULL)
  
  # Get the distinct values in ascending order
  uniq_vals <- sort(unique(lst))
  
  # If there's only one distinct value, we can't have a second smallest
  if (length(uniq_vals) < 2) return(NULL)
  
  # Return the second smallest distinct value
  uniq_vals[2]
}
test_humaneval <- function() {
    candidate <- next_smallest
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 1, 4, 3, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 0)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(-35, 34, 12, -45)), -35)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183776
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# You are given a list of integers.
# Write a function next_smallest() that returns the 2nd smallest element of the list.
# Return NULL if there is no such element.
# >>> next_smallest(c(1, 2, 3, 4, 5))
# 2
# >>> next_smallest(c(5, 1, 4, 3, 2))
# 2
# >>> next_smallest(c())
# NULL
# >>> next_smallest(c(1, 1))
# NULL
next_smallest <- function(lst) {
  # Ensure the input is a numeric vector
  if (!is.numeric(lst)) {
    stop("Input must be a numeric vector.")
  }
  
  # Get the distinct values sorted in ascending order
  uniq_vals <- sort(unique(lst))
  
  # If there are fewer than two distinct values, return NULL
  if (length(uniq_vals) < 2) {
    return(NULL)
  }
  
  # Return the second smallest distinct element
  return(uniq_vals[2])
}
test_humaneval <- function() {
    candidate <- next_smallest
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 1, 4, 3, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 0)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(-35, 34, 12, -45)), -35)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183776
STDOUT: (empty)
STDERR:
Error in candidate(c()) : Input must be a numeric vector.
Calls: test_humaneval -> stopifnot -> isTRUE -> all.equal -> candidate
Execution halted
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# You are given a list of integers.
# Write a function next_smallest() that returns the 2nd smallest element of the list.
# Return NULL if there is no such element.
# >>> next_smallest(c(1, 2, 3, 4, 5))
# 2
# >>> next_smallest(c(5, 1, 4, 3, 2))
# 2
# >>> next_smallest(c())
# NULL
# >>> next_smallest(c(1, 1))
# NULL
next_smallest <- function(lst) {
  # Find unique values and sort them
  uniq_vals <- sort(unique(lst))
  
  # If there are fewer than 2 distinct values, return NULL
  if (length(uniq_vals) < 2) {
    return(NULL)
  }
  
  # Return the second smallest distinct value
  return(uniq_vals[2])
}
test_humaneval <- function() {
    candidate <- next_smallest
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 1, 4, 3, 2)), 2)))
    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 0)), 1)))
    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))
    stopifnot(isTRUE(all.equal(candidate(c(-35, 34, 12, -45)), -35)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183776
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 107 (R) - HumanEval_107_even_odd_palindrome
================================================================================

PROMPT:
----------------------------------------
# Given a positive integer n, return a list that has the number of even and odd
# integer palindromes that fall within the range(1, n), inclusive.
# Example 1:
# >>> even_odd_palindrome(3)
# c(1, 2)
#     Explanation:
#     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
# Example 2:
# >>> even_odd_palindrome(12)
# c(4, 6)
#     Explanation:
#     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
# Note:
#     1. 1 <= n <= 10^3
#     2. returned list has the number of even and odd integer palindromes respectively.

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- even_odd_palindrome
    stopifnot(isTRUE(all.equal(candidate(123), c(8, 13))))
    stopifnot(isTRUE(all.equal(candidate(12), c(4, 6))))
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2))))
    stopifnot(isTRUE(all.equal(candidate(63), c(6, 8))))
    stopifnot(isTRUE(all.equal(candidate(25), c(5, 6))))
    stopifnot(isTRUE(all.equal(candidate(19), c(4, 6))))
    stopifnot(isTRUE(all.equal(candidate(9), c(4, 5))))
    stopifnot(isTRUE(all.equal(candidate(1), c(0, 1))))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given a positive integer n, return a list that has the number of even and odd
# integer palindromes that fall within the range(1, n), inclusive.
# Example 1:
# >>> even_odd_palindrome(3)
# c(1, 2)
#     Explanation:
#     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
# Example 2:
# >>> even_odd_palindrome(12)
# c(4, 6)
#     Explanation:
#     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
# Note:
#     1. 1 <= n <= 10^3
#     2. returned list has the number of even and odd integer palindromes respectively.
even_odd_palindrome <- function(n) {
  even <- 0
  odd  <- 0
  
  for (i in seq_len(n)) {
    s <- as.character(i)
    rev_s <- paste(rev(strsplit(s, "")[[1]]), collapse = "")
    if (s == rev_s) {
      if (i %% 2 == 0) {
        even <- even + 1
      } else {
        odd <- odd + 1
      }
    }
  }
  
  c(even, odd)
}
test_humaneval <- function() {
    candidate <- even_odd_palindrome
    stopifnot(isTRUE(all.equal(candidate(123), c(8, 13))))
    stopifnot(isTRUE(all.equal(candidate(12), c(4, 6))))
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2))))
    stopifnot(isTRUE(all.equal(candidate(63), c(6, 8))))
    stopifnot(isTRUE(all.equal(candidate(25), c(5, 6))))
    stopifnot(isTRUE(all.equal(candidate(19), c(4, 6))))
    stopifnot(isTRUE(all.equal(candidate(9), c(4, 5))))
    stopifnot(isTRUE(all.equal(candidate(1), c(0, 1))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183785
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given a positive integer n, return a list that has the number of even and odd
# integer palindromes that fall within the range(1, n), inclusive.
# Example 1:
# >>> even_odd_palindrome(3)
# c(1, 2)
#     Explanation:
#     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
# Example 2:
# >>> even_odd_palindrome(12)
# c(4, 6)
#     Explanation:
#     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
# Note:
#     1. 1 <= n <= 10^3
#     2. returned list has the number of even and odd integer palindromes respectively.
even_odd_palindrome <- function(n) {
  # Helper function to check if a number is a palindrome
  is_palindrome <- function(x) {
    s <- as.character(x)
    return(s == paste(rev(strsplit(s, NULL)[[1]]), collapse = ""))
  }
  
  even_count <- 0
  odd_count  <- 0
  
  for (i in seq_len(n)) {
    if (is_palindrome(i)) {
      if (i %% 2 == 0) {
        even_count <- even_count + 1
      } else {
        odd_count <- odd_count + 1
      }
    }
  }
  
  # Return a vector with even count first, then odd count
  return(c(even_count, odd_count))
}
test_humaneval <- function() {
    candidate <- even_odd_palindrome
    stopifnot(isTRUE(all.equal(candidate(123), c(8, 13))))
    stopifnot(isTRUE(all.equal(candidate(12), c(4, 6))))
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2))))
    stopifnot(isTRUE(all.equal(candidate(63), c(6, 8))))
    stopifnot(isTRUE(all.equal(candidate(25), c(5, 6))))
    stopifnot(isTRUE(all.equal(candidate(19), c(4, 6))))
    stopifnot(isTRUE(all.equal(candidate(9), c(4, 5))))
    stopifnot(isTRUE(all.equal(candidate(1), c(0, 1))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183785
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given a positive integer n, return a list that has the number of even and odd
# integer palindromes that fall within the range(1, n), inclusive.
# Example 1:
# >>> even_odd_palindrome(3)
# c(1, 2)
#     Explanation:
#     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
# Example 2:
# >>> even_odd_palindrome(12)
# c(4, 6)
#     Explanation:
#     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
# Note:
#     1. 1 <= n <= 10^3
#     2. returned list has the number of even and odd integer palindromes respectively.
even_odd_palindrome <- function(n) {
  # Counters for even and odd palindromes
  even_cnt <- 0
  odd_cnt  <- 0
  
  # Helper to check if an integer is a palindrome
  is_palindrome <- function(x) {
    s <- as.character(x)
    rev_s <- paste(rev(strsplit(s, NULL)[[1]]), collapse = "")
    s == rev_s
  }
  
  # Iterate through all numbers from 1 to n
  for (i in seq_len(n)) {
    if (is_palindrome(i)) {
      if (i %% 2 == 0) {
        even_cnt <- even_cnt + 1
      } else {
        odd_cnt <- odd_cnt + 1
      }
    }
  }
  
  # Return vector with even count first, then odd count
  c(even_cnt, odd_cnt)
}
test_humaneval <- function() {
    candidate <- even_odd_palindrome
    stopifnot(isTRUE(all.equal(candidate(123), c(8, 13))))
    stopifnot(isTRUE(all.equal(candidate(12), c(4, 6))))
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2))))
    stopifnot(isTRUE(all.equal(candidate(63), c(6, 8))))
    stopifnot(isTRUE(all.equal(candidate(25), c(5, 6))))
    stopifnot(isTRUE(all.equal(candidate(19), c(4, 6))))
    stopifnot(isTRUE(all.equal(candidate(9), c(4, 5))))
    stopifnot(isTRUE(all.equal(candidate(1), c(0, 1))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183785
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given a positive integer n, return a list that has the number of even and odd
# integer palindromes that fall within the range(1, n), inclusive.
# Example 1:
# >>> even_odd_palindrome(3)
# c(1, 2)
#     Explanation:
#     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
# Example 2:
# >>> even_odd_palindrome(12)
# c(4, 6)
#     Explanation:
#     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
# Note:
#     1. 1 <= n <= 10^3
#     2. returned list has the number of even and odd integer palindromes respectively.
even_odd_palindrome <- function(n) {
  # Helper function to test if a number is a palindrome
  is_palindrome <- function(x) {
    s <- as.character(x)
    return(s == paste(rev(strsplit(s, NULL)[[1]]), collapse = ""))
  }
  
  even_count <- 0
  odd_count  <- 0
  
  for (i in seq_len(n)) {
    if (is_palindrome(i)) {
      if (i %% 2 == 0) {
        even_count <- even_count + 1
      } else {
        odd_count <- odd_count + 1
      }
    }
  }
  
  return(c(even = even_count, odd = odd_count))
}
test_humaneval <- function() {
    candidate <- even_odd_palindrome
    stopifnot(isTRUE(all.equal(candidate(123), c(8, 13))))
    stopifnot(isTRUE(all.equal(candidate(12), c(4, 6))))
    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2))))
    stopifnot(isTRUE(all.equal(candidate(63), c(6, 8))))
    stopifnot(isTRUE(all.equal(candidate(25), c(5, 6))))
    stopifnot(isTRUE(all.equal(candidate(19), c(4, 6))))
    stopifnot(isTRUE(all.equal(candidate(9), c(4, 5))))
    stopifnot(isTRUE(all.equal(candidate(1), c(0, 1))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183785
STDOUT: (empty)
STDERR:
Error in test_humaneval() : 
  isTRUE(all.equal(candidate(123), c(8, 13))) is not TRUE
Calls: test_humaneval -> stopifnot
Execution halted
--------------------

================================================================================
PROBLEM 112 (R) - HumanEval_112_reverse_delete
================================================================================

PROMPT:
----------------------------------------
# Task
# We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
# then check if the result string is palindrome.
# A string is called palindrome if it reads the same backward as forward.
# You should return a list containing the result string and TRUE/FALSE for the check.
# Example
# >>> reverse_delete('abcde', 'ae')
# list('bcd', FALSE)
# >>> reverse_delete('abcdef', 'b')
# list('acdef', FALSE)
# >>> reverse_delete('abcdedcba', 'ab')
# list('cdedc', TRUE)

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- reverse_delete
    stopifnot(isTRUE(all.equal(candidate('abcde', 'ae'), list('bcd', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('abcdef', 'b'), list('acdef', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'ab'), list('cdedc', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('dwik', 'w'), list('dik', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('a', 'a'), list('', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', ''), list('abcdedcba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'v'), list('abcdedcba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('vabba', 'v'), list('abba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('mamma', 'mia'), list('', TRUE))))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Task
# We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
# then check if the result string is palindrome.
# A string is called palindrome if it reads the same backward as forward.
# You should return a list containing the result string and TRUE/FALSE for the check.
# Example
# >>> reverse_delete('abcde', 'ae')
# list('bcd', FALSE)
# >>> reverse_delete('abcdef', 'b')
# list('acdef', FALSE)
# >>> reverse_delete('abcdedcba', 'ab')
# list('cdedc', TRUE)
reverse_delete <- function(s, c) {
  # Split the strings into individual characters
  s_chars <- strsplit(s, "")[[1]]
  c_chars <- strsplit(c, "")[[1]]
  
  # Keep only characters from s that are NOT in c
  filtered <- s_chars[!s_chars %in% c_chars]
  
  # Reconstruct the resulting string
  result <- paste(filtered, collapse = "")
  
  # Determine if the result is a palindrome
  rev_result <- paste(rev(strsplit(result, "")[[1]]), collapse = "")
  is_palindrome <- result == rev_result
  
  # Return the result string and the palindrome check
  list(result, is_palindrome)
}
test_humaneval <- function() {
    candidate <- reverse_delete
    stopifnot(isTRUE(all.equal(candidate('abcde', 'ae'), list('bcd', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('abcdef', 'b'), list('acdef', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'ab'), list('cdedc', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('dwik', 'w'), list('dik', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('a', 'a'), list('', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', ''), list('abcdedcba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'v'), list('abcdedcba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('vabba', 'v'), list('abba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('mamma', 'mia'), list('', TRUE))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183787
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Task
# We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
# then check if the result string is palindrome.
# A string is called palindrome if it reads the same backward as forward.
# You should return a list containing the result string and TRUE/FALSE for the check.
# Example
# >>> reverse_delete('abcde', 'ae')
# list('bcd', FALSE)
# >>> reverse_delete('abcdef', 'b')
# list('acdef', FALSE)
# >>> reverse_delete('abcdedcba', 'ab')
# list('cdedc', TRUE)
reverse_delete <- function(s, c) {
  # Split the strings into individual characters
  s_chars <- strsplit(s, "")[[1]]
  c_chars <- strsplit(c, "")[[1]]
  
  # Keep only those characters in `s` that are not in `c`
  keep <- !s_chars %in% c_chars
  result <- paste(s_chars[keep], collapse = "")
  
  # Check if the resulting string is a palindrome
  rev_result <- paste(rev(strsplit(result, "")[[1]]), collapse = "")
  is_palindrome <- identical(result, rev_result)
  
  # Return a list containing the result string and the palindrome flag
  list(result, is_palindrome)
}
test_humaneval <- function() {
    candidate <- reverse_delete
    stopifnot(isTRUE(all.equal(candidate('abcde', 'ae'), list('bcd', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('abcdef', 'b'), list('acdef', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'ab'), list('cdedc', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('dwik', 'w'), list('dik', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('a', 'a'), list('', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', ''), list('abcdedcba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'v'), list('abcdedcba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('vabba', 'v'), list('abba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('mamma', 'mia'), list('', TRUE))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183787
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Task
# We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
# then check if the result string is palindrome.
# A string is called palindrome if it reads the same backward as forward.
# You should return a list containing the result string and TRUE/FALSE for the check.
# Example
# >>> reverse_delete('abcde', 'ae')
# list('bcd', FALSE)
# >>> reverse_delete('abcdef', 'b')
# list('acdef', FALSE)
# >>> reverse_delete('abcdedcba', 'ab')
# list('cdedc', TRUE)
reverse_delete <- function(s, c) {
  # Split the input strings into individual characters
  s_chars <- strsplit(s, "")[[1]]
  c_chars <- strsplit(c, "")[[1]]
  
  # Remove all characters from `s` that appear in `c`
  filtered_chars <- s_chars[!s_chars %in% c_chars]
  result <- paste(filtered_chars, collapse = "")
  
  # Check if the resulting string is a palindrome
  is_palindrome <- identical(result, paste(rev(filtered_chars), collapse = ""))
  
  # Return the result string and the palindrome flag as a list
  list(result, is_palindrome)
}
test_humaneval <- function() {
    candidate <- reverse_delete
    stopifnot(isTRUE(all.equal(candidate('abcde', 'ae'), list('bcd', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('abcdef', 'b'), list('acdef', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'ab'), list('cdedc', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('dwik', 'w'), list('dik', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('a', 'a'), list('', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', ''), list('abcdedcba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'v'), list('abcdedcba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('vabba', 'v'), list('abba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('mamma', 'mia'), list('', TRUE))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183787
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Task
# We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
# then check if the result string is palindrome.
# A string is called palindrome if it reads the same backward as forward.
# You should return a list containing the result string and TRUE/FALSE for the check.
# Example
# >>> reverse_delete('abcde', 'ae')
# list('bcd', FALSE)
# >>> reverse_delete('abcdef', 'b')
# list('acdef', FALSE)
# >>> reverse_delete('abcdedcba', 'ab')
# list('cdedc', TRUE)
reverse_delete <- function(s, c) {
  # Split the characters to remove
  chars_to_remove <- strsplit(c, "")[[1]]
  
  # Escape any regexâ€‘special characters so they are treated literally
  escaped <- sapply(chars_to_remove, function(ch) {
    if (grepl("[\\^$.|?*+(){}]", ch)) {
      paste0("\\", ch)
    } else {
      ch
    }
  })
  
  # Build a character class pattern for gsub
  pattern <- paste0("[", paste0(escaped, collapse = ""), "]")
  
  # Delete all matching characters
  result <- gsub(pattern, "", s, perl = TRUE)
  
  # Check if the resulting string is a palindrome
  rev_str <- paste0(rev(strsplit(result, "")[[1]]), collapse = "")
  is_pal <- identical(result, rev_str)
  
  # Return a list containing the cleaned string and the palindrome flag
  list(result, is_pal)
}
test_humaneval <- function() {
    candidate <- reverse_delete
    stopifnot(isTRUE(all.equal(candidate('abcde', 'ae'), list('bcd', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('abcdef', 'b'), list('acdef', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'ab'), list('cdedc', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('dwik', 'w'), list('dik', FALSE))))
    stopifnot(isTRUE(all.equal(candidate('a', 'a'), list('', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', ''), list('abcdedcba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'v'), list('abcdedcba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('vabba', 'v'), list('abba', TRUE))))
    stopifnot(isTRUE(all.equal(candidate('mamma', 'mia'), list('', TRUE))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183787
STDOUT: (empty)
STDERR:
Error in gsub(pattern, "", s, perl = TRUE) : 
  invalid regular expression '[]'
Calls: test_humaneval ... stopifnot -> isTRUE -> all.equal -> candidate -> gsub
In addition: Warning message:
In gsub(pattern, "", s, perl = TRUE) : PCRE pattern compilation error
	'missing terminating ] for character class'
	at ''
Execution halted
--------------------
