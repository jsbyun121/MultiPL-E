As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 77 (RKT) - HumanEval_77_iscube
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Write a function that takes an integer a and returns #t 
;; if this ingeger is a cube of some integer number.
;; Note: you may assume the input is always valid.
;; Examples:
;; >>> (iscube 1)
;; #t
;; >>> (iscube 2)
;; #f
;; >>> (iscube -1)
;; #t
;; >>> (iscube 64)
;; #t
;; >>> (iscube 0)
;; #t
;; >>> (iscube 180)
;; #f

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate iscube))
    (check-within (candidate 1) #t 0.001)
    (check-within (candidate 2) #f 0.001)
    (check-within (candidate -1) #t 0.001)
    (check-within (candidate 64) #t 0.001)
    (check-within (candidate 180) #f 0.001)
    (check-within (candidate 1000) #t 0.001)
    (check-within (candidate 0) #t 0.001)
    (check-within (candidate 1729) #f 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Write a function that takes an integer a and returns #t 
;; if this ingeger is a cube of some integer number.
;; Note: you may assume the input is always valid.
;; Examples:
;; >>> (iscube 1)
;; #t
;; >>> (iscube 2)
;; #f
;; >>> (iscube -1)
;; #t
;; >>> (iscube 64)
;; #t
;; >>> (iscube 0)
;; #t
;; >>> (iscube 180)
;; #f

;; Write a function that takes an integer a and returns #t 
;; if this integer is a cube of some integer number.
;; Note: you may assume the input is always valid.
;; Examples:
;; >>> (iscube 1)
;; #t
;; >>> (iscube 2)
;; #f
;; >>> (iscube -1)
;; #t
;; >>> (iscube 64)
;; #t
;; >>> (iscube 0)
;; #t
;; >>> (iscube 180)
;; #f

(define (iscube a)
  ;; Compute the integer cube root (rounded) of |a|
  (let* ((c (round (expt (abs a) 1/3)))
         (c3 (expt c 3)))
    (if (negative? a)
        (= (* -1 c3) a)   ; negative cubes
        (= c3 a))))        ; non‑negative cubes
(require rackunit)

(define (test-humaneval) 

  (let (( candidate iscube))
    (check-within (candidate 1) #t 0.001)
    (check-within (candidate 2) #f 0.001)
    (check-within (candidate -1) #t 0.001)
    (check-within (candidate 64) #t 0.001)
    (check-within (candidate 180) #f 0.001)
    (check-within (candidate 1000) #t 0.001)
    (check-within (candidate 0) #t 0.001)
    (check-within (candidate 1729) #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183911
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Write a function that takes an integer a and returns #t 
;; if this ingeger is a cube of some integer number.
;; Note: you may assume the input is always valid.
;; Examples:
;; >>> (iscube 1)
;; #t
;; >>> (iscube 2)
;; #f
;; >>> (iscube -1)
;; #t
;; >>> (iscube 64)
;; #t
;; >>> (iscube 0)
;; #t
;; >>> (iscube 180)
;; #f
(define (iscube a)
  (let ((c (round (expt a 1/3))))
    (= (expt c 3) a)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate iscube))
    (check-within (candidate 1) #t 0.001)
    (check-within (candidate 2) #f 0.001)
    (check-within (candidate -1) #t 0.001)
    (check-within (candidate 64) #t 0.001)
    (check-within (candidate 180) #f 0.001)
    (check-within (candidate 1000) #t 0.001)
    (check-within (candidate 0) #t 0.001)
    (check-within (candidate 1729) #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: Exception
Timestamp: 1755183911
STDOUT: (empty)
STDERR:
--------------------
ERROR
name:       check-within
location:   /tmp/tmp1lyhr8vr.rkt:29:4

round: contract violation
  expected: real?
  given: 0.5000000000000001+0.8660254037844386i
--------------------
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Write a function that takes an integer a and returns #t 
;; if this ingeger is a cube of some integer number.
;; Note: you may assume the input is always valid.
;; Examples:
;; >>> (iscube 1)
;; #t
;; >>> (iscube 2)
;; #f
;; >>> (iscube -1)
;; #t
;; >>> (iscube 64)
;; #t
;; >>> (iscube 0)
;; #t
;; >>> (iscube 180)
;; #f

;; Write a function that takes an integer a and returns #t 
;; if this ingeger is a cube of some integer number.
;; Note: you may assume the input is always valid.
;; Examples:
;; >>> (iscube 1)
;; #t
;; >>> (iscube 2)
;; #f
;; >>> (iscube -1)
;; #t
;; >>> (iscube 64)
;; #t
;; >>> (iscube 0)
;; #t
;; >>> (iscube 180)
;; #f

(define (iscube a)
  ;; Compute the integer cube root of |a| and then restore the sign.
  (let* ([abs-a (abs a)]
         [cbrt (round (expt abs-a 1/3))]   ; approximate cube root
         [n    (if (< a 0) (- cbrt) cbrt)]) ; restore sign
    ;; Check whether n^3 equals the original number.
    (= (expt n 3) a)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate iscube))
    (check-within (candidate 1) #t 0.001)
    (check-within (candidate 2) #f 0.001)
    (check-within (candidate -1) #t 0.001)
    (check-within (candidate 64) #t 0.001)
    (check-within (candidate 180) #f 0.001)
    (check-within (candidate 1000) #t 0.001)
    (check-within (candidate 0) #t 0.001)
    (check-within (candidate 1729) #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183911
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Write a function that takes an integer a and returns #t 
;; if this ingeger is a cube of some integer number.
;; Note: you may assume the input is always valid.
;; Examples:
;; >>> (iscube 1)
;; #t
;; >>> (iscube 2)
;; #f
;; >>> (iscube -1)
;; #t
;; >>> (iscube 64)
;; #t
;; >>> (iscube 0)
;; #t
;; >>> (iscube 180)
;; #f

;; Write a function that takes an integer a and returns #t 
;; if this ingeger is a cube of some integer number.
;; Note: you may assume the input is always valid.
;; Examples:
;; >>> (iscube 1)
;; #t
;; >>> (iscube 2)
;; #f
;; >>> (iscube -1)
;; #t
;; >>> (iscube 64)
;; #t
;; >>> (iscube 0)
;; #t
;; >>> (iscube 180)
;; #f

(define (iscube a)
  (let* ((abs-val (abs a))
         (c (round (expt abs-val 1/3))))
    (= (expt c 3) abs-val)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate iscube))
    (check-within (candidate 1) #t 0.001)
    (check-within (candidate 2) #f 0.001)
    (check-within (candidate -1) #t 0.001)
    (check-within (candidate 64) #t 0.001)
    (check-within (candidate 180) #f 0.001)
    (check-within (candidate 1000) #t 0.001)
    (check-within (candidate 0) #t 0.001)
    (check-within (candidate 1729) #f 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183911
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 79 (RKT) - HumanEval_79_decimal_to_binary
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; You will be given a number in decimal form and your task is to convert it to
;; binary format. The function should return a string, with each character representing a binary
;; number. Each character in the string will be '0' or '1'.
;; There will be an extra couple of characters 'db' at the beginning and at the end of the string.
;; The extra characters are there to help with the format.
;; Examples:
;; >>> (decimal_to_binary 15)
;; "db1111db"
;; >>> (decimal_to_binary 32)
;; "db100000db"

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate decimal_to_binary))
    (check-within (candidate 0) "db0db" 0.001)
    (check-within (candidate 32) "db100000db" 0.001)
    (check-within (candidate 103) "db1100111db" 0.001)
    (check-within (candidate 15) "db1111db" 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; You will be given a number in decimal form and your task is to convert it to
;; binary format. The function should return a string, with each character representing a binary
;; number. Each character in the string will be '0' or '1'.
;; There will be an extra couple of characters 'db' at the beginning and at the end of the string.
;; The extra characters are there to help with the format.
;; Examples:
;; >>> (decimal_to_binary 15)
;; "db1111db"
;; >>> (decimal_to_binary 32)
;; "db100000db"

;; Convert a decimal number to a binary string surrounded by "db".
(define (decimal_to_binary decimal)
  (string-append "db" (number->string decimal 2) "db"))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate decimal_to_binary))
    (check-within (candidate 0) "db0db" 0.001)
    (check-within (candidate 32) "db100000db" 0.001)
    (check-within (candidate 103) "db1100111db" 0.001)
    (check-within (candidate 15) "db1111db" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183913
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; You will be given a number in decimal form and your task is to convert it to
;; binary format. The function should return a string, with each character representing a binary
;; number. Each character in the string will be '0' or '1'.
;; There will be an extra couple of characters 'db' at the beginning and at the end of the string.
;; The extra characters are there to help with the format.
;; Examples:
;; >>> (decimal_to_binary 15)
;; "db1111db"
;; >>> (decimal_to_binary 32)
;; "db100000db"

;; Convert a decimal number to a binary string wrapped with "db".
(define (decimal_to_binary decimal)
  (string-append "db"
                 (number->string decimal 2)
                 "db"))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate decimal_to_binary))
    (check-within (candidate 0) "db0db" 0.001)
    (check-within (candidate 32) "db100000db" 0.001)
    (check-within (candidate 103) "db1100111db" 0.001)
    (check-within (candidate 15) "db1111db" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183913
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; You will be given a number in decimal form and your task is to convert it to
;; binary format. The function should return a string, with each character representing a binary
;; number. Each character in the string will be '0' or '1'.
;; There will be an extra couple of characters 'db' at the beginning and at the end of the string.
;; The extra characters are there to help with the format.
;; Examples:
;; >>> (decimal_to_binary 15)
;; "db1111db"
;; >>> (decimal_to_binary 32)
;; "db100000db"

;; Convert a decimal integer to a binary string surrounded by "db".
;; Example:
;;   (decimal_to_binary 15)  ; => "db1111db"
;;   (decimal_to_binary 32)  ; => "db100000db"

(define (decimal_to_binary decimal)
  (string-append "db" (number->string decimal 2) "db"))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate decimal_to_binary))
    (check-within (candidate 0) "db0db" 0.001)
    (check-within (candidate 32) "db100000db" 0.001)
    (check-within (candidate 103) "db1100111db" 0.001)
    (check-within (candidate 15) "db1111db" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183913
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; You will be given a number in decimal form and your task is to convert it to
;; binary format. The function should return a string, with each character representing a binary
;; number. Each character in the string will be '0' or '1'.
;; There will be an extra couple of characters 'db' at the beginning and at the end of the string.
;; The extra characters are there to help with the format.
;; Examples:
;; >>> (decimal_to_binary 15)
;; "db1111db"
;; >>> (decimal_to_binary 32)
;; "db100000db"

;; Convert a decimal number to a binary string, wrapped with "db" markers.
(define (decimal_to_binary decimal)
  (string-append "db"
                 (integer->string decimal 2)
                 "db"))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate decimal_to_binary))
    (check-within (candidate 0) "db0db" 0.001)
    (check-within (candidate 32) "db100000db" 0.001)
    (check-within (candidate 103) "db1100111db" 0.001)
    (check-within (candidate 15) "db1111db" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183913
STDOUT: (empty)
STDERR:
/tmp/tmpi6aipxv4.rkt:17:18: integer->string: unbound identifier
  in: integer->string
  location...:
   /tmp/tmpi6aipxv4.rkt:17:18
--------------------

================================================================================
PROBLEM 83 (RKT) - HumanEval_83_starts_one_ends
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given a positive integer n, return the count of the numbers of n-digit
;; positive integers that start or end with 1.

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate starts_one_ends))
    (check-within (candidate 1) 1 0.001)
    (check-within (candidate 2) 18 0.001)
    (check-within (candidate 3) 180 0.001)
    (check-within (candidate 4) 1800 0.001)
    (check-within (candidate 5) 18000 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer n, return the count of the numbers of n-digit
;; positive integers that start or end with 1.

;; Given a positive integer n, return the count of the numbers of n-digit
;; positive integers that start or end with 1.
(define (starts_one_ends n)
  (cond
    [(= n 1) 1]                                 ; only the number 1
    [else (* 18 (expt 10 (- n 2)))]))           ; 18 * 10^(n-2) for n ≥ 2
(require rackunit)

(define (test-humaneval) 

  (let (( candidate starts_one_ends))
    (check-within (candidate 1) 1 0.001)
    (check-within (candidate 2) 18 0.001)
    (check-within (candidate 3) 180 0.001)
    (check-within (candidate 4) 1800 0.001)
    (check-within (candidate 5) 18000 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183917
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer n, return the count of the numbers of n-digit
;; positive integers that start or end with 1.

;; Given a positive integer n, return the count of the numbers of n-digit
;; positive integers that start or end with 1.
(define (starts_one_ends n)
  (cond
    [(= n 1) 1]                                   ; only the number 1
    [else
     (+ (expt 10 (- n 1))                        ; start with 1
        (* 8 (expt 10 (- n 2))))])               ; end with 1, subtract overlap
(require rackunit)

(define (test-humaneval) 

  (let (( candidate starts_one_ends))
    (check-within (candidate 1) 1 0.001)
    (check-within (candidate 2) 18 0.001)
    (check-within (candidate 3) 180 0.001)
    (check-within (candidate 4) 1800 0.001)
    (check-within (candidate 5) 18000 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755183916
STDOUT: (empty)
STDERR:
/tmp/tmp2rvedhcn.rkt:8:0: read-syntax: expected a `)` to close `(`
  possible cause: indentation suggests a missing `)` before line 14
  context...:
   /usr/share/racket/collects/syntax/module-reader.rkt:186:17: body
   /usr/share/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /usr/share/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer n, return the count of the numbers of n-digit
;; positive integers that start or end with 1.

;; Given a positive integer n, return the count of the numbers of n-digit
;; positive integers that start or end with 1.
(define (starts_one_ends n)
  (cond
    [(= n 1) 1]                              ; only the number 1
    [else (* 18 (expt 10 (- n 2)))]))       ; 18·10^(n‑2) for n ≥ 2
(require rackunit)

(define (test-humaneval) 

  (let (( candidate starts_one_ends))
    (check-within (candidate 1) 1 0.001)
    (check-within (candidate 2) 18 0.001)
    (check-within (candidate 3) 180 0.001)
    (check-within (candidate 4) 1800 0.001)
    (check-within (candidate 5) 18000 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183917
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given a positive integer n, return the count of the numbers of n-digit
;; positive integers that start or end with 1.

;; Given a positive integer n, return the count of the numbers of n-digit
;; positive integers that start or end with 1.
(define (starts_one_ends n)
  (cond
    [(= n 1) 1] ; only the number 1
    [else (* 18 (expt 10 (- n 2)))])) ; 18 * 10^(n-2) for n ≥ 2
(require rackunit)

(define (test-humaneval) 

  (let (( candidate starts_one_ends))
    (check-within (candidate 1) 1 0.001)
    (check-within (candidate 2) 18 0.001)
    (check-within (candidate 3) 180 0.001)
    (check-within (candidate 4) 1800 0.001)
    (check-within (candidate 5) 18000 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183917
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 85 (RKT) - HumanEval_85_add
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Given a non-empty list of integers lst. add the even elements that are at odd indices..
;; Examples:
;; >>> (add (list 4 2 6 7))
;; 2

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-within (candidate (list 4 88)) 88 0.001)
    (check-within (candidate (list 4 5 6 7 2 122)) 122 0.001)
    (check-within (candidate (list 4 0 6 7)) 0 0.001)
    (check-within (candidate (list 4 4 6 8)) 12 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Given a non-empty list of integers lst. add the even elements that are at odd indices..
;; Examples:
;; >>> (add (list 4 2 6 7))
;; 2

;; Given a non-empty list of integers `lst`, add the even elements that are
;; located at odd indices (0‑based indexing).  
;; Example:
;;   (add (list 4 2 6 7))  ; => 2
(define (add lst)
  ;; Enumerate the list to get pairs (index . element).  
  ;; Accumulate the sum of elements that satisfy:
  ;;   - index is odd
  ;;   - element is even
  (for/fold ([sum 0])          ; initial accumulator
            ([p (in-list (enumerate lst))])  ; each pair (index . element)
    (match-define (cons i x) p)             ; destructure pair
    (if (and (odd? i) (even? x))
        (+ sum x)   ; add element to sum
        sum)))      ; otherwise keep accumulator unchanged
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-within (candidate (list 4 88)) 88 0.001)
    (check-within (candidate (list 4 5 6 7 2 122)) 122 0.001)
    (check-within (candidate (list 4 0 6 7)) 0 0.001)
    (check-within (candidate (list 4 4 6 8)) 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183918
STDOUT: (empty)
STDERR:
/tmp/tmpluizf6q0.rkt:18:26: enumerate: unbound identifier
  in: enumerate
  location...:
   /tmp/tmpluizf6q0.rkt:18:26
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Given a non-empty list of integers lst. add the even elements that are at odd indices..
;; Examples:
;; >>> (add (list 4 2 6 7))
;; 2

;; Given a non-empty list of integers lst. add the even elements that are at odd indices..
;; Examples:
;; >>> (add (list 4 2 6 7))
;; 2
(define (add lst)
  (define (add-helper lst idx sum)
    (if (null? lst)
        sum
        (let ((x (car lst)))
          (if (and (odd? idx) (even? x))
              (add-helper (cdr lst) (+ idx 1) (+ sum x))
              (add-helper (cdr lst) (+ idx 1) sum)))))
  (add-helper lst 0 0))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-within (candidate (list 4 88)) 88 0.001)
    (check-within (candidate (list 4 5 6 7 2 122)) 122 0.001)
    (check-within (candidate (list 4 0 6 7)) 0 0.001)
    (check-within (candidate (list 4 4 6 8)) 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183918
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Given a non-empty list of integers lst. add the even elements that are at odd indices..
;; Examples:
;; >>> (add (list 4 2 6 7))
;; 2

;; add : (listof Integer) -> Integer
;; Given a non‑empty list of integers `lst`, return the sum of the
;; even elements that are located at odd indices (0‑based).
;;
;; Example:
;;   (add (list 4 2 6 7))  ; => 2
(define (add lst)
  ;; Helper that carries the current index and the running sum.
  (define (helper remaining idx acc)
    (cond
      [(empty? remaining) acc]                     ; finished
      [else
       (let ([elem (first remaining)])
         (if (and (odd? idx) (even? elem))
             (helper (rest remaining) (+ idx 1) (+ acc elem)) ; include
             (helper (rest remaining) (+ idx 1) acc)))]))     ; skip
  (helper lst 0 0))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-within (candidate (list 4 88)) 88 0.001)
    (check-within (candidate (list 4 5 6 7 2 122)) 122 0.001)
    (check-within (candidate (list 4 0 6 7)) 0 0.001)
    (check-within (candidate (list 4 4 6 8)) 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183918
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Given a non-empty list of integers lst. add the even elements that are at odd indices..
;; Examples:
;; >>> (add (list 4 2 6 7))
;; 2

;; add : (Listof Integer) -> Integer
;; Given a non‑empty list of integers `lst`, add the even elements that
;; are at odd indices (0‑based indexing).
;;
;; Examples:
;;   (add (list 4 2 6 7))  ; => 2
;;
(define (add lst)
  (let loop ((l lst) (idx 0) (sum 0))
    (cond
      [(empty? l) sum]
      [else
       (let ((x (first l)))
         (if (and (odd? idx) (even? x))
             (loop (rest l) (+ idx 1) (+ sum x))
             (loop (rest l) (+ idx 1) sum)))])))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-within (candidate (list 4 88)) 88 0.001)
    (check-within (candidate (list 4 5 6 7 2 122)) 122 0.001)
    (check-within (candidate (list 4 0 6 7)) 0 0.001)
    (check-within (candidate (list 4 4 6 8)) 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183918
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 90 (RKT) - HumanEval_90_next_smallest
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-within (candidate (list 1 2 3 4 5)) 2 0.001)
    (check-within (candidate (list 5 1 4 3 2)) 2 0.001)
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list 1 1)) #f 0.001)
    (check-within (candidate (list 1 1 1 1 0)) 1 0.001)
    (check-within (candidate (list 1 1)) #f 0.001)
    (check-within (candidate (list -35 34 12 -45)) -35 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f

(define (next_smallest lst)
  (let loop ((lst lst) (min1 #f) (min2 #f))
    (cond
      [(null? lst) min2]  ; finished scanning
      [else
       (let ((x (car lst)))
         (cond
           ;; Found a new smallest value
           [(or (eq? min1 #f) (< x min1))
            (loop (cdr lst) x min1)]
           ;; Found a new second‑smallest distinct value
           [(and (not (eq? min1 #f))
                 (not (= x min1))
                 (or (eq? min2 #f) (< x min2)))
            (loop (cdr lst) min1 x)]
           ;; Otherwise keep the current pair
           [else
            (loop (cdr lst) min1 min2)]))])))

;; Test cases
(displayln (next_smallest (list 1 2 3 4 5)))   ; => 2
(displayln (next_smallest (list 5 1 4 3 2)))   ; => 2
(displayln (next_smallest (list)))            ; => #f
(displayln (next_smallest (list 1 1)))        ; => #f
(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-within (candidate (list 1 2 3 4 5)) 2 0.001)
    (check-within (candidate (list 5 1 4 3 2)) 2 0.001)
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list 1 1)) #f 0.001)
    (check-within (candidate (list 1 1 1 1 0)) 1 0.001)
    (check-within (candidate (list 1 1)) #f 0.001)
    (check-within (candidate (list -35 34 12 -45)) -35 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183937
STDOUT:
2
2
#f
#f
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  ;; Keep track of the smallest (min1) and the second smallest distinct value (min2).
  (define min1 #f)
  (define min2 #f)

  ;; Iterate over each element in the list.
  (for ([x lst])
    (cond
      ;; If we have no smallest yet, or x is smaller than the current smallest,
      ;; update both min1 and min2 accordingly.
      [(or (not min1) (< x min1))
       (set! min2 min1)
       (set! min1 x)]
      ;; If x is distinct from the current smallest and smaller than the current
      ;; second smallest (or we don't have one yet), update min2.
      [(and (not (eq? x min1))
            (or (not min2) (< x min2)))
       (set! min2 x)]))

  ;; Return the second smallest value, or #f if it doesn't exist.
  min2)
(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-within (candidate (list 1 2 3 4 5)) 2 0.001)
    (check-within (candidate (list 5 1 4 3 2)) 2 0.001)
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list 1 1)) #f 0.001)
    (check-within (candidate (list 1 1 1 1 0)) 1 0.001)
    (check-within (candidate (list 1 1)) #f 0.001)
    (check-within (candidate (list -35 34 12 -45)) -35 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183937
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(null? lst) #f]                     ; empty list
    [else
     (let* ([min1 (apply min lst)]      ; smallest element
            [rest (filter (lambda (x) (not (= x min1))) lst)]) ; remove all min1
       (if (null? rest)
           #f                           ; no second distinct element
           (apply min rest)))]))        ; second smallest
(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-within (candidate (list 1 2 3 4 5)) 2 0.001)
    (check-within (candidate (list 5 1 4 3 2)) 2 0.001)
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list 1 1)) #f 0.001)
    (check-within (candidate (list 1 1 1 1 0)) 1 0.001)
    (check-within (candidate (list 1 1)) #f 0.001)
    (check-within (candidate (list -35 34 12 -45)) -35 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183937
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f

;; Find the second smallest distinct element in a list.
;; Return #f if there is no such element.
(define (next_smallest lst)
  (cond
    [(null? lst) #f]                     ; Empty list → no second smallest
    [else
     (let loop ((srt (sort lst <)))     ; Sort the list ascending
       (cond
         [(null? srt) #f]                ; Should not happen, but safe
         [(null? (cdr srt)) #f]          ; Only one element → no second smallest
         [else
          (let ((first (car srt))
                (rest  (cdr srt)))
            (if (= first (car rest))     ; Skip duplicates of the smallest
                (loop rest)               ; Continue searching
                (car rest)))]))])          ; Found the second smallest
(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-within (candidate (list 1 2 3 4 5)) 2 0.001)
    (check-within (candidate (list 5 1 4 3 2)) 2 0.001)
    (check-within (candidate (list )) #f 0.001)
    (check-within (candidate (list 1 1)) #f 0.001)
    (check-within (candidate (list 1 1 1 1 0)) 1 0.001)
    (check-within (candidate (list 1 1)) #f 0.001)
    (check-within (candidate (list -35 34 12 -45)) -35 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755183936
STDOUT: (empty)
STDERR:
/tmp/tmpu7zhu1jy.rkt:17:0: read-syntax: expected a `)` to close `(`
  possible cause: indentation suggests a missing `)` before line 31
  context...:
   /usr/share/racket/collects/syntax/module-reader.rkt:186:17: body
   /usr/share/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /usr/share/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper
--------------------

================================================================================
PROBLEM 94 (RKT) - HumanEval_94_skjkasdkd
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-within (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10 0.001)
    (check-within (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25 0.001)
    (check-within (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13 0.001)
    (check-within (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11 0.001)
    (check-within (candidate (list 0 81 12 3 1 21)) 3 0.001)
    (check-within (candidate (list 0 8 1 2 1 7)) 7 0.001)
    (check-within (candidate (list 8191)) 19 0.001)
    (check-within (candidate (list 8191 123456 127 7)) 19 0.001)
    (check-within (candidate (list 127 97 8192)) 10 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7

;; Helper: test if an integer is prime
(define (prime? n)
  (and (> n 1)
       (not (for/or ([i (in-range 2 (add1 (integer-sqrt n)))])
              (= (modulo n i) 0)))))

;; Helper: sum of digits of a non‑negative integer
(define (digit-sum n)
  (if (< n 10)
      n
      (+ (modulo n 10)
         (digit-sum (quotient n 10)))))

;; Main function
(define (skjkasdkd lst)
  ;; Find the largest prime in the list
  (define largest-prime
    (apply max (filter prime? lst)))
  ;; Return the sum of its digits
  (digit-sum largest-prime))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-within (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10 0.001)
    (check-within (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25 0.001)
    (check-within (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13 0.001)
    (check-within (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11 0.001)
    (check-within (candidate (list 0 81 12 3 1 21)) 3 0.001)
    (check-within (candidate (list 0 8 1 2 1 7)) 7 0.001)
    (check-within (candidate (list 8191)) 19 0.001)
    (check-within (candidate (list 8191 123456 127 7)) 19 0.001)
    (check-within (candidate (list 127 97 8192)) 10 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183941
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7

;; ------------------------------------------------------------------
;; Helper: test whether an integer is prime
;; ------------------------------------------------------------------
(define (prime? n)
  (cond
    [(< n 2) #f]
    [(or (= n 2) (= n 3)) #t]
    [(even? n) #f]
    [else
     (define (divides? d)
       (zero? (modulo n d)))
     (let loop ([d 3])
       (cond
         [(> (* d d) n) #t]
         [(divides? d) #f]
         [else (loop (+ d 2))]))]))

;; ------------------------------------------------------------------
;; Helper: sum of digits of an integer
;; ------------------------------------------------------------------
(define (sum-digits n)
  (define digits
    (map (lambda (c) (- (char->integer c) (char->integer #\0)))
         (string->list (number->string (abs n)))))
  (apply + digits))

;; ------------------------------------------------------------------
;; Main function
;; ------------------------------------------------------------------
(define (skjkasdkd lst)
  (define primes (filter prime? lst))
  (if (null? primes)
      0                               ; no prime found → return 0
      (sum-digits (apply max primes))))

;; ------------------------------------------------------------------
;; Examples
;; ------------------------------------------------------------------
(printf "~a\n" (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)))   ; 10
(printf "~a\n" (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)))           ; 25
(printf "~a\n" (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)))   ; 13
(printf "~a\n" (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)))                 ; 11
(printf "~a\n" (skjkasdkd (list 0 81 12 3 1 21)))                                      ; 3
(printf "~a\n" (skjkasdkd (list 0 8 1 2 1 7)))                                         ; 7
(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-within (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10 0.001)
    (check-within (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25 0.001)
    (check-within (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13 0.001)
    (check-within (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11 0.001)
    (check-within (candidate (list 0 81 12 3 1 21)) 3 0.001)
    (check-within (candidate (list 0 8 1 2 1 7)) 7 0.001)
    (check-within (candidate (list 8191)) 19 0.001)
    (check-within (candidate (list 8191 123456 127 7)) 19 0.001)
    (check-within (candidate (list 127 97 8192)) 10 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183941
STDOUT:
10
25
13
11
3
7
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7

;; Find the largest prime in a list and return the sum of its digits.
(define (skjkasdkd lst)
  ;; Helper to test primality.
  (define (prime? n)
    (cond
      [(< n 2) #f]                     ; 0 and 1 are not prime
      [(= n 2) #t]                     ; 2 is prime
      [(even? n) #f]                   ; even numbers > 2 are not prime
      [else
       (define (check d)
         (cond
           [(> (* d d) n) #t]           ; no divisor found
           [(zero? (modulo n d)) #f]    ; divisor found
           [else (check (+ d 2))]))     ; test next odd divisor
       (check 3)]))

  ;; Filter the list to keep only primes.
  (define primes (filter prime? lst))

  ;; If there are no primes, return 0 (you can change this if needed).
  (if (null? primes)
      0
      (let* ([maxp (apply max primes)]
             ;; Convert the number to a string, split into characters,
             ;; convert each character back to a number, and sum them.
             [sum-digits
              (foldl (lambda (c acc)
                       (+ acc (string->number (string c))))
                     0
                     (string->list (number->string maxp)))])
        sum-digits)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-within (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10 0.001)
    (check-within (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25 0.001)
    (check-within (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13 0.001)
    (check-within (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11 0.001)
    (check-within (candidate (list 0 81 12 3 1 21)) 3 0.001)
    (check-within (candidate (list 0 8 1 2 1 7)) 7 0.001)
    (check-within (candidate (list 8191)) 19 0.001)
    (check-within (candidate (list 8191 123456 127 7)) 19 0.001)
    (check-within (candidate (list 127 97 8192)) 10 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183941
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7

;; Helper: test whether n is a prime number.
(define (prime? n)
  (and (>= n 2)
       (let loop ((d 2))
         (cond
           [(>= d (floor (sqrt n))) #t]
           [(zero? (modulo n d)) #f]
           [else (loop (+ d 1))]))))

;; Helper: sum the decimal digits of an integer.
(define (sum-digits n)
  (if (< n 10)
      n
      (+ (modulo n 10)
         (sum-digits (quotient n 10)))))

;; Main function: find the largest prime in the list and return
;; the sum of its digits.
(define (skjkasdkd lst)
  (define primes (filter prime? lst))
  (if (null? primes)
      0
      (sum-digits (apply max primes))))

;; Example usage:
;; (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; => 10
(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-within (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10 0.001)
    (check-within (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25 0.001)
    (check-within (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13 0.001)
    (check-within (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11 0.001)
    (check-within (candidate (list 0 81 12 3 1 21)) 3 0.001)
    (check-within (candidate (list 0 8 1 2 1 7)) 7 0.001)
    (check-within (candidate (list 8191)) 19 0.001)
    (check-within (candidate (list 8191 123456 127 7)) 19 0.001)
    (check-within (candidate (list 127 97 8192)) 10 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: Exception
Timestamp: 1755183941
STDOUT: (empty)
STDERR:
--------------------
FAILURE
name:       check-within
location:   /tmp/tmpt2znv_e0.rkt:56:4
actual:     8
expected:   7
--------------------
--------------------

================================================================================
PROBLEM 96 (RKT) - HumanEval_96_count_up_to
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-within (candidate 5) (list 2 3) 0.001)
    (check-within (candidate 6) (list 2 3 5) 0.001)
    (check-within (candidate 7) (list 2 3 5) 0.001)
    (check-within (candidate 10) (list 2 3 5 7) 0.001)
    (check-within (candidate 0) (list ) 0.001)
    (check-within (candidate 22) (list 2 3 5 7 11 13 17 19) 0.001)
    (check-within (candidate 1) (list ) 0.001)
    (check-within (candidate 18) (list 2 3 5 7 11 13 17) 0.001)
    (check-within (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43) 0.001)
    (check-within (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)

;; Return a list of all prime numbers less than `n`.
(define (count_up_to n)
  (define (prime? m)
    (and (> m 1)
         (not (for/or ([d (in-range 2 (add1 (floor (sqrt m))))])
                (= (modulo m d) 0)))))
  (filter prime? (range 2 n)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-within (candidate 5) (list 2 3) 0.001)
    (check-within (candidate 6) (list 2 3 5) 0.001)
    (check-within (candidate 7) (list 2 3 5) 0.001)
    (check-within (candidate 10) (list 2 3 5 7) 0.001)
    (check-within (candidate 0) (list ) 0.001)
    (check-within (candidate 22) (list 2 3 5 7 11 13 17 19) 0.001)
    (check-within (candidate 1) (list ) 0.001)
    (check-within (candidate 18) (list 2 3 5 7 11 13 17) 0.001)
    (check-within (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43) 0.001)
    (check-within (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183942
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)

;; Helper function: check if a number is prime
(define (prime? x)
  (cond
    [(< x 2) #f]
    [(= x 2) #t]
    [else
     (define (divisible? d)
       (= (remainder x d) 0))
     (not (ormap divisible? (in-range 2 (add1 (floor (sqrt x))))))]))

;; Main function: list all primes less than n
(define (count_up_to n)
  (for/list ([i (in-range 2 n)])
    (when (prime? i) i)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-within (candidate 5) (list 2 3) 0.001)
    (check-within (candidate 6) (list 2 3 5) 0.001)
    (check-within (candidate 7) (list 2 3 5) 0.001)
    (check-within (candidate 10) (list 2 3 5 7) 0.001)
    (check-within (candidate 0) (list ) 0.001)
    (check-within (candidate 22) (list 2 3 5 7 11 13 17 19) 0.001)
    (check-within (candidate 1) (list ) 0.001)
    (check-within (candidate 18) (list 2 3 5 7 11 13 17) 0.001)
    (check-within (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43) 0.001)
    (check-within (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: Exception
Timestamp: 1755183942
STDOUT: (empty)
STDERR:
--------------------
ERROR
name:       check-within
location:   /tmp/tmpd2josh58.rkt:38:4

ormap: contract violation
  expected: list?
  given: #<stream>
--------------------
--------------------
ERROR
name:       check-within
location:   /tmp/tmpd2josh58.rkt:39:4

ormap: contract violation
  expected: list?
  given: #<stream>
--------------------
--------------------
ERROR
name:       check-within
location:   /tmp/tmpd2josh58.rkt:40:4

ormap: contract violation
  expected: list?
  given: #<stream>
--------------------
--------------------
ERROR
name:       check-within
location:   /tmp/tmpd2josh58.rkt:41:4

ormap: contract violation
  expected: list?
  given: #<stream>
--------------------
--------------------
ERROR
name:       check-within
location:   /tmp/tmpd2josh58.rkt:43:4

ormap: contract violation
  expected: list?
  given: #<stream>
--------------------
--------------------
ERROR
name:       check-within
location:   /tmp/tmpd2josh58.rkt:45:4

ormap: contract violation
  expected: list?
  given: #<str
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)

;; Helper: test whether an integer n > 1 is prime
(define (prime? n)
  (and (> n 1)
       (not (ormap (lambda (d) (= 0 (modulo n d)))
                   (range 2 (add1 (integer-sqrt n)))))))

;; Return a list of all primes less than n
(define (count_up_to n)
  (filter prime? (range 2 n)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-within (candidate 5) (list 2 3) 0.001)
    (check-within (candidate 6) (list 2 3 5) 0.001)
    (check-within (candidate 7) (list 2 3 5) 0.001)
    (check-within (candidate 10) (list 2 3 5 7) 0.001)
    (check-within (candidate 0) (list ) 0.001)
    (check-within (candidate 22) (list 2 3 5 7 11 13 17 19) 0.001)
    (check-within (candidate 1) (list ) 0.001)
    (check-within (candidate 18) (list 2 3 5 7 11 13 17) 0.001)
    (check-within (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43) 0.001)
    (check-within (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183942
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)

;; Helper predicate: true if `x` is a prime number.
(define (prime? x)
  (cond
    [(< x 2) #f]                     ; 0 and 1 are not prime
    [(= x 2) #t]                     ; 2 is prime
    [(even? x) #f]                   ; even numbers > 2 are not prime
    [else
     (let* ([limit (inexact->exact (floor (sqrt x)))]
            [divisors (in-range 3 (add1 limit) 2)]) ; only odd divisors
       (not (for/or ([d divisors]) (= (modulo x d) 0))))]))

;; Main function: list of all primes less than `n`.
(define (count_up_to n)
  (for/list ([i (in-range 2 n)]
             #:when (prime? i))
    i))

;; Example usage:
;; (count_up_to 5)   => (list 2 3)
;; (count_up_to 11)  => (list 2 3 5 7)
;; (count_up_to 0)   => (list)
;; (count_up_to 20)  => (list 2 3 5 7 11 13 17 19)
;; (count_up_to 1)   => (list)
;; (count_up_to 18)  => (list 2 3 5 7 11 13 17)
(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-within (candidate 5) (list 2 3) 0.001)
    (check-within (candidate 6) (list 2 3 5) 0.001)
    (check-within (candidate 7) (list 2 3 5) 0.001)
    (check-within (candidate 10) (list 2 3 5 7) 0.001)
    (check-within (candidate 0) (list ) 0.001)
    (check-within (candidate 22) (list 2 3 5 7 11 13 17 19) 0.001)
    (check-within (candidate 1) (list ) 0.001)
    (check-within (candidate 18) (list 2 3 5 7 11 13 17) 0.001)
    (check-within (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43) 0.001)
    (check-within (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183942
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 97 (RKT) - HumanEval_97_multiply
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate multiply))
    (check-within (candidate 148 412) 16 0.001)
    (check-within (candidate 19 28) 72 0.001)
    (check-within (candidate 2020 1851) 0 0.001)
    (check-within (candidate 14 -15) 20 0.001)
    (check-within (candidate 76 67) 42 0.001)
    (check-within (candidate 17 27) 49 0.001)
    (check-within (candidate 0 1) 0 0.001)
    (check-within (candidate 0 0) 0 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20
(define (multiply a b)
  (* (modulo a 10) (modulo b 10)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate multiply))
    (check-within (candidate 148 412) 16 0.001)
    (check-within (candidate 19 28) 72 0.001)
    (check-within (candidate 2020 1851) 0 0.001)
    (check-within (candidate 14 -15) 20 0.001)
    (check-within (candidate 76 67) 42 0.001)
    (check-within (candidate 17 27) 49 0.001)
    (check-within (candidate 0 1) 0 0.001)
    (check-within (candidate 0 0) 0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183943
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20
(define (multiply a b)
  (* (modulo (abs a) 10)
     (modulo (abs b) 10)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate multiply))
    (check-within (candidate 148 412) 16 0.001)
    (check-within (candidate 19 28) 72 0.001)
    (check-within (candidate 2020 1851) 0 0.001)
    (check-within (candidate 14 -15) 20 0.001)
    (check-within (candidate 76 67) 42 0.001)
    (check-within (candidate 17 27) 49 0.001)
    (check-within (candidate 0 1) 0 0.001)
    (check-within (candidate 0 0) 0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183943
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20
(define (multiply a b)
  (* (mod (abs a) 10)
     (mod (abs b) 10)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate multiply))
    (check-within (candidate 148 412) 16 0.001)
    (check-within (candidate 19 28) 72 0.001)
    (check-within (candidate 2020 1851) 0 0.001)
    (check-within (candidate 14 -15) 20 0.001)
    (check-within (candidate 76 67) 42 0.001)
    (check-within (candidate 17 27) 49 0.001)
    (check-within (candidate 0 1) 0 0.001)
    (check-within (candidate 0 0) 0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183943
STDOUT: (empty)
STDERR:
/tmp/tmp1m903ef0.rkt:29:6: mod: unbound identifier
  in: mod
  location...:
   /tmp/tmp1m903ef0.rkt:29:6
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20
(define (multiply a b)
  (* (modulo (abs a) 10)
     (modulo (abs b) 10)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate multiply))
    (check-within (candidate 148 412) 16 0.001)
    (check-within (candidate 19 28) 72 0.001)
    (check-within (candidate 2020 1851) 0 0.001)
    (check-within (candidate 14 -15) 20 0.001)
    (check-within (candidate 76 67) 42 0.001)
    (check-within (candidate 17 27) 49 0.001)
    (check-within (candidate 0 1) 0 0.001)
    (check-within (candidate 0 0) 0 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183943
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 101 (RKT) - HumanEval_101_words_string
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; You will be given a string of words separated by commas or spaces. Your task is
;; to split the string into words and return a list of the words.
;; For example:
;; >>> (words_string "Hi, my name is John")
;; (list "Hi" "my" "name" "is" "John")
;; >>> (words_string "One, two, three, four, five, six")
;; (list "One" "two" "three" "four" "five" "six")

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_string))
    (check-within (candidate "Hi, my name is John") (list "Hi" "my" "name" "is" "John") 0.001)
    (check-within (candidate "One, two, three, four, five, six") (list "One" "two" "three" "four" "five" "six") 0.001)
    (check-within (candidate "Hi, my name") (list "Hi" "my" "name") 0.001)
    (check-within (candidate "One,, two, three, four, five, six,") (list "One" "two" "three" "four" "five" "six") 0.001)
    (check-within (candidate "") (list ) 0.001)
    (check-within (candidate "ahmed     , gamal") (list "ahmed" "gamal") 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; You will be given a string of words separated by commas or spaces. Your task is
;; to split the string into words and return a list of the words.
;; For example:
;; >>> (words_string "Hi, my name is John")
;; (list "Hi" "my" "name" "is" "John")
;; >>> (words_string "One, two, three, four, five, six")
;; (list "One" "two" "three" "four" "five" "six")

;; Split a string into words separated by commas or spaces.
(define (words_string s)
  ;; The regex `[ ,]+` matches any run of commas or spaces.
  (string-split s #rx"[ ,]+"))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_string))
    (check-within (candidate "Hi, my name is John") (list "Hi" "my" "name" "is" "John") 0.001)
    (check-within (candidate "One, two, three, four, five, six") (list "One" "two" "three" "four" "five" "six") 0.001)
    (check-within (candidate "Hi, my name") (list "Hi" "my" "name") 0.001)
    (check-within (candidate "One,, two, three, four, five, six,") (list "One" "two" "three" "four" "five" "six") 0.001)
    (check-within (candidate "") (list ) 0.001)
    (check-within (candidate "ahmed     , gamal") (list "ahmed" "gamal") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183947
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; You will be given a string of words separated by commas or spaces. Your task is
;; to split the string into words and return a list of the words.
;; For example:
;; >>> (words_string "Hi, my name is John")
;; (list "Hi" "my" "name" "is" "John")
;; >>> (words_string "One, two, three, four, five, six")
;; (list "One" "two" "three" "four" "five" "six")

;; Split a string into words separated by commas or spaces.
(define (words_string s)
  ;; Use a regular expression that matches one or more commas or spaces.
  (regexp-split #px"[ ,]+" s))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_string))
    (check-within (candidate "Hi, my name is John") (list "Hi" "my" "name" "is" "John") 0.001)
    (check-within (candidate "One, two, three, four, five, six") (list "One" "two" "three" "four" "five" "six") 0.001)
    (check-within (candidate "Hi, my name") (list "Hi" "my" "name") 0.001)
    (check-within (candidate "One,, two, three, four, five, six,") (list "One" "two" "three" "four" "five" "six") 0.001)
    (check-within (candidate "") (list ) 0.001)
    (check-within (candidate "ahmed     , gamal") (list "ahmed" "gamal") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: Exception
Timestamp: 1755183947
STDOUT: (empty)
STDERR:
--------------------
FAILURE
name:       check-within
location:   /tmp/tmp5is6_m_6.rkt:23:4
actual:     '("One" "two" "three" "four" "five" "six" "")
expected:   '("One" "two" "three" "four" "five" "six")
--------------------
--------------------
FAILURE
name:       check-within
location:   /tmp/tmp5is6_m_6.rkt:24:4
actual:     '("")
expected:   '()
--------------------
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; You will be given a string of words separated by commas or spaces. Your task is
;; to split the string into words and return a list of the words.
;; For example:
;; >>> (words_string "Hi, my name is John")
;; (list "Hi" "my" "name" "is" "John")
;; >>> (words_string "One, two, three, four, five, six")
;; (list "One" "two" "three" "four" "five" "six")
(require racket/string)

;; Split a string into words separated by commas or spaces.
(define (words_string s)
  ;; Use a regex that matches one or more commas or spaces.
  (filter (lambda (w) (not (string=? w "")))
          (string-split s #rx"[ ,]+")))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_string))
    (check-within (candidate "Hi, my name is John") (list "Hi" "my" "name" "is" "John") 0.001)
    (check-within (candidate "One, two, three, four, five, six") (list "One" "two" "three" "four" "five" "six") 0.001)
    (check-within (candidate "Hi, my name") (list "Hi" "my" "name") 0.001)
    (check-within (candidate "One,, two, three, four, five, six,") (list "One" "two" "three" "four" "five" "six") 0.001)
    (check-within (candidate "") (list ) 0.001)
    (check-within (candidate "ahmed     , gamal") (list "ahmed" "gamal") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183947
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; You will be given a string of words separated by commas or spaces. Your task is
;; to split the string into words and return a list of the words.
;; For example:
;; >>> (words_string "Hi, my name is John")
;; (list "Hi" "my" "name" "is" "John")
;; >>> (words_string "One, two, three, four, five, six")
;; (list "One" "two" "three" "four" "five" "six")

(require racket/string)

;; Split a string into words separated by commas or spaces.
(define (words_string s)
  ;; Use a regex that matches one or more commas or spaces.
  (filter (lambda (w) (not (string=? w "")))
          (string-split s #rx"[ ,]+")))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_string))
    (check-within (candidate "Hi, my name is John") (list "Hi" "my" "name" "is" "John") 0.001)
    (check-within (candidate "One, two, three, four, five, six") (list "One" "two" "three" "four" "five" "six") 0.001)
    (check-within (candidate "Hi, my name") (list "Hi" "my" "name") 0.001)
    (check-within (candidate "One,, two, three, four, five, six,") (list "One" "two" "three" "four" "five" "six") 0.001)
    (check-within (candidate "") (list ) 0.001)
    (check-within (candidate "ahmed     , gamal") (list "ahmed" "gamal") 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183947
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 103 (RKT) - HumanEval_103_rounded_avg
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-within (candidate 1 5) "0b11" 0.001)
    (check-within (candidate 7 13) "0b1010" 0.001)
    (check-within (candidate 964 977) "0b1111001010" 0.001)
    (check-within (candidate 996 997) "0b1111100100" 0.001)
    (check-within (candidate 560 851) "0b1011000010" 0.001)
    (check-within (candidate 185 546) "0b101101110" 0.001)
    (check-within (candidate 362 496) "0b110101101" 0.001)
    (check-within (candidate 350 902) "0b1001110010" 0.001)
    (check-within (candidate 197 233) "0b11010111" 0.001)
    (check-within (candidate 7 5) -1 0.001)
    (check-within (candidate 5 1) -1 0.001)
    (check-within (candidate 5 5) "0b101" 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"

(define (rounded_avg n m)
  (if (> n m)
      -1
      (let* ((avg (round (/ (+ n m) 2)))          ; average of arithmetic sequence
             (bin (string-append "0b" (number->string avg 2))))
        bin)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-within (candidate 1 5) "0b11" 0.001)
    (check-within (candidate 7 13) "0b1010" 0.001)
    (check-within (candidate 964 977) "0b1111001010" 0.001)
    (check-within (candidate 996 997) "0b1111100100" 0.001)
    (check-within (candidate 560 851) "0b1011000010" 0.001)
    (check-within (candidate 185 546) "0b101101110" 0.001)
    (check-within (candidate 362 496) "0b110101101" 0.001)
    (check-within (candidate 350 902) "0b1001110010" 0.001)
    (check-within (candidate 197 233) "0b11010111" 0.001)
    (check-within (candidate 7 5) -1 0.001)
    (check-within (candidate 5 1) -1 0.001)
    (check-within (candidate 5 5) "0b101" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183949
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"

;; Compute the rounded average of all integers from n to m (inclusive).
;; If n > m, return -1.  Otherwise return the average rounded to the
;; nearest integer, converted to a binary string prefixed with "0b".
(define (rounded_avg n m)
  (if (> n m)
      -1
      (let* ([avg    (/ (+ n m) 2)]          ; average of arithmetic series
             [rounded (round avg)])          ; round to nearest integer
        (string-append "0b" (number->string rounded 2)))))

;; Examples
(displayln (rounded_avg 1 5))   ; => "0b11"
(displayln (rounded_avg 7 5))   ; => -1
(displayln (rounded_avg 10 20)) ; => "0b1111"
(displayln (rounded_avg 20 33)) ; => "0b11010"
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-within (candidate 1 5) "0b11" 0.001)
    (check-within (candidate 7 13) "0b1010" 0.001)
    (check-within (candidate 964 977) "0b1111001010" 0.001)
    (check-within (candidate 996 997) "0b1111100100" 0.001)
    (check-within (candidate 560 851) "0b1011000010" 0.001)
    (check-within (candidate 185 546) "0b101101110" 0.001)
    (check-within (candidate 362 496) "0b110101101" 0.001)
    (check-within (candidate 350 902) "0b1001110010" 0.001)
    (check-within (candidate 197 233) "0b11010111" 0.001)
    (check-within (candidate 7 5) -1 0.001)
    (check-within (candidate 5 1) -1 0.001)
    (check-within (candidate 5 5) "0b101" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183949
STDOUT:
0b11
-1
0b1111
0b11010
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"

;; Computes the average of the integers from n through m (inclusive),
;; rounds it down to the nearest integer, and returns its binary
;; representation prefixed with "0b".  If n > m, returns -1.
(define (rounded_avg n m)
  (if (> n m)
      -1
      (let ((avg (quotient (+ n m) 2)))  ; floor((n+m)/2)
        (string-append "0b" (number->string avg 2)))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-within (candidate 1 5) "0b11" 0.001)
    (check-within (candidate 7 13) "0b1010" 0.001)
    (check-within (candidate 964 977) "0b1111001010" 0.001)
    (check-within (candidate 996 997) "0b1111100100" 0.001)
    (check-within (candidate 560 851) "0b1011000010" 0.001)
    (check-within (candidate 185 546) "0b101101110" 0.001)
    (check-within (candidate 362 496) "0b110101101" 0.001)
    (check-within (candidate 350 902) "0b1001110010" 0.001)
    (check-within (candidate 197 233) "0b11010111" 0.001)
    (check-within (candidate 7 5) -1 0.001)
    (check-within (candidate 5 1) -1 0.001)
    (check-within (candidate 5 5) "0b101" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: Exception
Timestamp: 1755183949
STDOUT: (empty)
STDERR:
--------------------
FAILURE
name:       check-within
location:   /tmp/tmpfvev2grm.rkt:34:4
actual:     "0b1011000001"
expected:   "0b1011000010"
--------------------
--------------------
FAILURE
name:       check-within
location:   /tmp/tmpfvev2grm.rkt:35:4
actual:     "0b101101101"
expected:   "0b101101110"
--------------------
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"

;; Compute the average of all integers from n through m inclusive,
;; round it to the nearest integer, and return the result as a binary
;; string prefixed with "0b".  If n is greater than m, return -1.
(define (rounded_avg n m)
  (if (> n m)
      -1
      (let* ((count (+ 1 (- m n)))                    ; number of terms
             (sum   (* (+ n m) count 1/2))             ; arithmetic‑series sum
             (avg   (/ sum count))                    ; exact rational average
             (rounded (round avg)))                   ; nearest integer
        (format "0b~a" (number->string rounded 2))))) ; binary string
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-within (candidate 1 5) "0b11" 0.001)
    (check-within (candidate 7 13) "0b1010" 0.001)
    (check-within (candidate 964 977) "0b1111001010" 0.001)
    (check-within (candidate 996 997) "0b1111100100" 0.001)
    (check-within (candidate 560 851) "0b1011000010" 0.001)
    (check-within (candidate 185 546) "0b101101110" 0.001)
    (check-within (candidate 362 496) "0b110101101" 0.001)
    (check-within (candidate 350 902) "0b1001110010" 0.001)
    (check-within (candidate 197 233) "0b11010111" 0.001)
    (check-within (candidate 7 5) -1 0.001)
    (check-within (candidate 5 1) -1 0.001)
    (check-within (candidate 5 5) "0b101" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183949
STDOUT: (empty)
STDERR: (empty)
--------------------
