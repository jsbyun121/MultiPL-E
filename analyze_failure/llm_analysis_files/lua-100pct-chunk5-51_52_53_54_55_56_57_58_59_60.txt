As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3â€“7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 51 (LUA) - HumanEval_51_remove_vowels
================================================================================

PROMPT:
----------------------------------------
-- remove_vowels is a function that takes string and returns string without vowels.
-- >>> remove_vowels('')
-- ''
-- >>> remove_vowels('abcdef')
-- 'bcdf'
-- >>> remove_vowels('aaaaa')
-- ''
-- >>> remove_vowels('aaBAA')
-- 'B'
-- >>> remove_vowels('zbcd')
-- 'zbcd'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = remove_vowels
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('abcdef\nghijklm'), 'bcdf\nghjklm')
    lu.assertEquals(candidate('fedcba'), 'fdcb')
    lu.assertEquals(candidate('eeeee'), '')
    lu.assertEquals(candidate('acBAA'), 'cB')
    lu.assertEquals(candidate('EcBOO'), 'cB')
    lu.assertEquals(candidate('ybcd'), 'ybcd')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- remove_vowels is a function that takes string and returns string without vowels.
-- >>> remove_vowels('')
-- ''
-- >>> remove_vowels('abcdef')
-- 'bcdf'
-- >>> remove_vowels('aaaaa')
-- ''
-- >>> remove_vowels('aaBAA')
-- 'B'
-- >>> remove_vowels('zbcd')
-- 'zbcd'
-- remove_vowels is a function that takes a string and returns the string
-- with all vowels removed (both lowercase and uppercase).
--
-- >>> remove_vowels('')
-- ''
-- >>> remove_vowels('abcdef')
-- 'bcdf'
-- >>> remove_vowels('aaaaa')
-- ''
-- >>> remove_vowels('aaBAA')
-- 'B'
-- >>> remove_vowels('zbcd')
-- 'zbcd'
local function remove_vowels(text)
    -- Replace any occurrence of a vowel with an empty string.
    return (text:gsub("[aeiouAEIOU]", ""))
end
lu = require('luaunit')

function test_humaneval()
local candidate = remove_vowels
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('abcdef\nghijklm'), 'bcdf\nghjklm')
    lu.assertEquals(candidate('fedcba'), 'fdcb')
    lu.assertEquals(candidate('eeeee'), '')
    lu.assertEquals(candidate('acBAA'), 'cB')
    lu.assertEquals(candidate('EcBOO'), 'cB')
    lu.assertEquals(candidate('ybcd'), 'ybcd')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- remove_vowels is a function that takes string and returns string without vowels.
-- >>> remove_vowels('')
-- ''
-- >>> remove_vowels('abcdef')
-- 'bcdf'
-- >>> remove_vowels('aaaaa')
-- ''
-- >>> remove_vowels('aaBAA')
-- 'B'
-- >>> remove_vowels('zbcd')
-- 'zbcd'
local function remove_vowels(text)
  -- Remove all vowels (a, e, i, o, u) regardless of case
  return text:gsub("[aeiouAEIOU]", "")
end
lu = require('luaunit')

function test_humaneval()
local candidate = remove_vowels
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('abcdef\nghijklm'), 'bcdf\nghjklm')
    lu.assertEquals(candidate('fedcba'), 'fdcb')
    lu.assertEquals(candidate('eeeee'), '')
    lu.assertEquals(candidate('acBAA'), 'cB')
    lu.assertEquals(candidate('EcBOO'), 'cB')
    lu.assertEquals(candidate('ybcd'), 'ybcd')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- remove_vowels is a function that takes string and returns string without vowels.
-- >>> remove_vowels('')
-- ''
-- >>> remove_vowels('abcdef')
-- 'bcdf'
-- >>> remove_vowels('aaaaa')
-- ''
-- >>> remove_vowels('aaBAA')
-- 'B'
-- >>> remove_vowels('zbcd')
-- 'zbcd'
-- Remove all vowels (both lowercase and uppercase) from the input string.
-- Uses pattern matching to replace any vowel with an empty string.
local function remove_vowels(text)
    -- If text is nil or not a string, just return an empty string.
    if type(text) ~= "string" then
        return ""
    end
    return text:gsub("[aeiouAEIOU]", "")
end
lu = require('luaunit')

function test_humaneval()
local candidate = remove_vowels
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('abcdef\nghijklm'), 'bcdf\nghjklm')
    lu.assertEquals(candidate('fedcba'), 'fdcb')
    lu.assertEquals(candidate('eeeee'), '')
    lu.assertEquals(candidate('acBAA'), 'cB')
    lu.assertEquals(candidate('EcBOO'), 'cB')
    lu.assertEquals(candidate('ybcd'), 'ybcd')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- remove_vowels is a function that takes string and returns string without vowels.
-- >>> remove_vowels('')
-- ''
-- >>> remove_vowels('abcdef')
-- 'bcdf'
-- >>> remove_vowels('aaaaa')
-- ''
-- >>> remove_vowels('aaBAA')
-- 'B'
-- >>> remove_vowels('zbcd')
-- 'zbcd'
local function remove_vowels(text)
    -- Replace any vowel (a, e, i, o, u) in either case with an empty string
    return text:gsub("[aeiouAEIOU]", "")
end
lu = require('luaunit')

function test_humaneval()
local candidate = remove_vowels
    lu.assertEquals(candidate(''), '')
    lu.assertEquals(candidate('abcdef\nghijklm'), 'bcdf\nghjklm')
    lu.assertEquals(candidate('fedcba'), 'fdcb')
    lu.assertEquals(candidate('eeeee'), '')
    lu.assertEquals(candidate('acBAA'), 'cB')
    lu.assertEquals(candidate('EcBOO'), 'cB')
    lu.assertEquals(candidate('ybcd'), 'ybcd')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 52 (LUA) - HumanEval_52_below_threshold
================================================================================

PROMPT:
----------------------------------------
-- Return true if all numbers in the table l are below threshold t.
-- >>> below_threshold({1, 2, 4, 10}, 100)
-- true
-- >>> below_threshold({1, 20, 4, 10}, 5)
-- false

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = below_threshold
    lu.assertEquals(candidate({1, 2, 4, 10}, 100), true)
    lu.assertEquals(candidate({1, 20, 4, 10}, 5), false)
    lu.assertEquals(candidate({1, 20, 4, 10}, 21), true)
    lu.assertEquals(candidate({1, 20, 4, 10}, 22), true)
    lu.assertEquals(candidate({1, 8, 4, 10}, 11), true)
    lu.assertEquals(candidate({1, 8, 4, 10}, 10), false)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Return true if all numbers in the table l are below threshold t.
-- >>> below_threshold({1, 2, 4, 10}, 100)
-- true
-- >>> below_threshold({1, 20, 4, 10}, 5)
-- false
local function below_threshold(l, t)
    for _, v in ipairs(l) do
        if v >= t then
            return false
        end
    end
    return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = below_threshold
    lu.assertEquals(candidate({1, 2, 4, 10}, 100), true)
    lu.assertEquals(candidate({1, 20, 4, 10}, 5), false)
    lu.assertEquals(candidate({1, 20, 4, 10}, 21), true)
    lu.assertEquals(candidate({1, 20, 4, 10}, 22), true)
    lu.assertEquals(candidate({1, 8, 4, 10}, 11), true)
    lu.assertEquals(candidate({1, 8, 4, 10}, 10), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Return true if all numbers in the table l are below threshold t.
-- >>> below_threshold({1, 2, 4, 10}, 100)
-- true
-- >>> below_threshold({1, 20, 4, 10}, 5)
-- false
local function below_threshold(l, t)
    for _, v in ipairs(l) do
        if v >= t then
            return false
        end
    end
    return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = below_threshold
    lu.assertEquals(candidate({1, 2, 4, 10}, 100), true)
    lu.assertEquals(candidate({1, 20, 4, 10}, 5), false)
    lu.assertEquals(candidate({1, 20, 4, 10}, 21), true)
    lu.assertEquals(candidate({1, 20, 4, 10}, 22), true)
    lu.assertEquals(candidate({1, 8, 4, 10}, 11), true)
    lu.assertEquals(candidate({1, 8, 4, 10}, 10), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Return true if all numbers in the table l are below threshold t.
-- >>> below_threshold({1, 2, 4, 10}, 100)
-- true
-- >>> below_threshold({1, 20, 4, 10}, 5)
-- false
local function below_threshold(l, t)
    for _, v in ipairs(l) do
        if v >= t then
            return false
        end
    end
    return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = below_threshold
    lu.assertEquals(candidate({1, 2, 4, 10}, 100), true)
    lu.assertEquals(candidate({1, 20, 4, 10}, 5), false)
    lu.assertEquals(candidate({1, 20, 4, 10}, 21), true)
    lu.assertEquals(candidate({1, 20, 4, 10}, 22), true)
    lu.assertEquals(candidate({1, 8, 4, 10}, 11), true)
    lu.assertEquals(candidate({1, 8, 4, 10}, 10), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Return true if all numbers in the table l are below threshold t.
-- >>> below_threshold({1, 2, 4, 10}, 100)
-- true
-- >>> below_threshold({1, 20, 4, 10}, 5)
-- false
-- Return true if all numbers in the table l are below threshold t.
-- >>> below_threshold({1, 2, 4, 10}, 100)
-- true
-- >>> below_threshold({1, 20, 4, 10}, 5)
-- false
local function below_threshold(l, t)
  for _, v in ipairs(l) do
    if v >= t then
      return false
    end
  end
  return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = below_threshold
    lu.assertEquals(candidate({1, 2, 4, 10}, 100), true)
    lu.assertEquals(candidate({1, 20, 4, 10}, 5), false)
    lu.assertEquals(candidate({1, 20, 4, 10}, 21), true)
    lu.assertEquals(candidate({1, 20, 4, 10}, 22), true)
    lu.assertEquals(candidate({1, 8, 4, 10}, 11), true)
    lu.assertEquals(candidate({1, 8, 4, 10}, 10), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 53 (LUA) - HumanEval_53_add
================================================================================

PROMPT:
----------------------------------------
-- Add two numbers x and y
-- >>> add(2, 3)
-- 5
-- >>> add(5, 7)
-- 12

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = add
    lu.assertEquals(candidate(0, 1), 1)
    lu.assertEquals(candidate(1, 0), 1)
    lu.assertEquals(candidate(2, 3), 5)
    lu.assertEquals(candidate(5, 7), 12)
    lu.assertEquals(candidate(7, 5), 12)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Add two numbers x and y
-- >>> add(2, 3)
-- 5
-- >>> add(5, 7)
-- 12
local function add(x, y)
  return x + y
end
lu = require('luaunit')

function test_humaneval()
local candidate = add
    lu.assertEquals(candidate(0, 1), 1)
    lu.assertEquals(candidate(1, 0), 1)
    lu.assertEquals(candidate(2, 3), 5)
    lu.assertEquals(candidate(5, 7), 12)
    lu.assertEquals(candidate(7, 5), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Add two numbers x and y
-- >>> add(2, 3)
-- 5
-- >>> add(5, 7)
-- 12
local function add(x, y)
    return x + y
end
lu = require('luaunit')

function test_humaneval()
local candidate = add
    lu.assertEquals(candidate(0, 1), 1)
    lu.assertEquals(candidate(1, 0), 1)
    lu.assertEquals(candidate(2, 3), 5)
    lu.assertEquals(candidate(5, 7), 12)
    lu.assertEquals(candidate(7, 5), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Add two numbers x and y
-- >>> add(2, 3)
-- 5
-- >>> add(5, 7)
-- 12
local function add(x, y)
  return x + y
end
lu = require('luaunit')

function test_humaneval()
local candidate = add
    lu.assertEquals(candidate(0, 1), 1)
    lu.assertEquals(candidate(1, 0), 1)
    lu.assertEquals(candidate(2, 3), 5)
    lu.assertEquals(candidate(5, 7), 12)
    lu.assertEquals(candidate(7, 5), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Add two numbers x and y
-- >>> add(2, 3)
-- 5
-- >>> add(5, 7)
-- 12
local function add(x, y)
    return x + y
end
lu = require('luaunit')

function test_humaneval()
local candidate = add
    lu.assertEquals(candidate(0, 1), 1)
    lu.assertEquals(candidate(1, 0), 1)
    lu.assertEquals(candidate(2, 3), 5)
    lu.assertEquals(candidate(5, 7), 12)
    lu.assertEquals(candidate(7, 5), 12)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 54 (LUA) - HumanEval_54_same_chars
================================================================================

PROMPT:
----------------------------------------
-- Check if two words have the same characters.
-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
-- true
-- >>> same_chars('abcd', 'dddddddabc')
-- true
-- >>> same_chars('dddddddabc', 'abcd')
-- true
-- >>> same_chars('eabcd', 'dddddddabc')
-- false
-- >>> same_chars('abcd', 'dddddddabce')
-- false
-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
-- false

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = same_chars
    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), true)
    lu.assertEquals(candidate('abcd', 'dddddddabc'), true)
    lu.assertEquals(candidate('dddddddabc', 'abcd'), true)
    lu.assertEquals(candidate('eabcd', 'dddddddabc'), false)
    lu.assertEquals(candidate('abcd', 'dddddddabcf'), false)
    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), false)
    lu.assertEquals(candidate('aabb', 'aaccc'), false)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Check if two words have the same characters.
-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
-- true
-- >>> same_chars('abcd', 'dddddddabc')
-- true
-- >>> same_chars('dddddddabc', 'abcd')
-- true
-- >>> same_chars('eabcd', 'dddddddabc')
-- false
-- >>> same_chars('abcd', 'dddddddabce')
-- false
-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
-- false
local function same_chars(s0, s1)
  -- Build a set of characters for each string
  local set0 = {}
  for i = 1, #s0 do
    set0[s0:sub(i, i)] = true
  end

  local set1 = {}
  for i = 1, #s1 do
    set1[s1:sub(i, i)] = true
  end

  -- Check that every character in set0 appears in set1
  for k, _ in pairs(set0) do
    if not set1[k] then
      return false
    end
  end

  -- Check that every character in set1 appears in set0
  for k, _ in pairs(set1) do
    if not set0[k] then
      return false
    end
  end

  return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = same_chars
    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), true)
    lu.assertEquals(candidate('abcd', 'dddddddabc'), true)
    lu.assertEquals(candidate('dddddddabc', 'abcd'), true)
    lu.assertEquals(candidate('eabcd', 'dddddddabc'), false)
    lu.assertEquals(candidate('abcd', 'dddddddabcf'), false)
    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), false)
    lu.assertEquals(candidate('aabb', 'aaccc'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Check if two words have the same characters.
-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
-- true
-- >>> same_chars('abcd', 'dddddddabc')
-- true
-- >>> same_chars('dddddddabc', 'abcd')
-- true
-- >>> same_chars('eabcd', 'dddddddabc')
-- false
-- >>> same_chars('abcd', 'dddddddabce')
-- false
-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
-- false
-- Check if two words have the same characters (ignoring order and repetitions).
-- Returns true if the set of unique characters in s0 equals that in s1.
local function same_chars(s0, s1)
  local set0 = {}
  for c in s0:gmatch"." do
    set0[c] = true
  end

  local set1 = {}
  for c in s1:gmatch"." do
    set1[c] = true
  end

  -- Check that every character in set0 appears in set1
  for c, _ in pairs(set0) do
    if not set1[c] then
      return false
    end
  end

  -- Check that every character in set1 appears in set0
  for c, _ in pairs(set1) do
    if not set0[c] then
      return false
    end
  end

  return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = same_chars
    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), true)
    lu.assertEquals(candidate('abcd', 'dddddddabc'), true)
    lu.assertEquals(candidate('dddddddabc', 'abcd'), true)
    lu.assertEquals(candidate('eabcd', 'dddddddabc'), false)
    lu.assertEquals(candidate('abcd', 'dddddddabcf'), false)
    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), false)
    lu.assertEquals(candidate('aabb', 'aaccc'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Check if two words have the same characters.
-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
-- true
-- >>> same_chars('abcd', 'dddddddabc')
-- true
-- >>> same_chars('dddddddabc', 'abcd')
-- true
-- >>> same_chars('eabcd', 'dddddddabc')
-- false
-- >>> same_chars('abcd', 'dddddddabce')
-- false
-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
-- false
-- Check if two words have the same characters (ignoring order and frequency).
-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
-- true
-- >>> same_chars('abcd', 'dddddddabc')
-- true
-- >>> same_chars('dddddddabc', 'abcd')
-- true
-- >>> same_chars('eabcd', 'dddddddabc')
-- false
-- >>> same_chars('abcd', 'dddddddabce')
-- false
-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
-- false
local function same_chars(s0, s1)
    -- Helper to build a set of characters from a string
    local function build_set(str)
        local set = {}
        for ch in str:gmatch(".") do
            set[ch] = true
        end
        return set
    end

    local set0 = build_set(s0)
    local set1 = build_set(s1)

    -- Compare the two sets for equality
    for ch in pairs(set0) do
        if not set1[ch] then
            return false
        end
    end
    for ch in pairs(set1) do
        if not set0[ch] then
            return false
        end
    end
    return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = same_chars
    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), true)
    lu.assertEquals(candidate('abcd', 'dddddddabc'), true)
    lu.assertEquals(candidate('dddddddabc', 'abcd'), true)
    lu.assertEquals(candidate('eabcd', 'dddddddabc'), false)
    lu.assertEquals(candidate('abcd', 'dddddddabcf'), false)
    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), false)
    lu.assertEquals(candidate('aabb', 'aaccc'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Check if two words have the same characters.
-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
-- true
-- >>> same_chars('abcd', 'dddddddabc')
-- true
-- >>> same_chars('dddddddabc', 'abcd')
-- true
-- >>> same_chars('eabcd', 'dddddddabc')
-- false
-- >>> same_chars('abcd', 'dddddddabce')
-- false
-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
-- false
-- Check if two words have the same characters.
-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
-- true
-- >>> same_chars('abcd', 'dddddddabc')
-- true
-- >>> same_chars('dddddddabc', 'abcd')
-- true
-- >>> same_chars('eabcd', 'dddddddabc')
-- false
-- >>> same_chars('abcd', 'dddddddabce')
-- false
-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
-- false
local function same_chars(s0, s1)
  -- Build a set of characters for each string
  local set0 = {}
  local set1 = {}

  for c in s0:gmatch(".") do
    set0[c] = true
  end

  for c in s1:gmatch(".") do
    set1[c] = true
  end

  -- If the number of unique characters differs, they can't be the same set
  local len0, len1 = 0, 0
  for _ in pairs(set0) do len0 = len0 + 1 end
  for _ in pairs(set1) do len1 = len1 + 1 end
  if len0 ~= len1 then
    return false
  end

  -- Ensure every character in set0 appears in set1 and vice versa
  for k in pairs(set0) do
    if not set1[k] then
      return false
    end
  end
  for k in pairs(set1) do
    if not set0[k] then
      return false
    end
  end

  return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = same_chars
    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), true)
    lu.assertEquals(candidate('abcd', 'dddddddabc'), true)
    lu.assertEquals(candidate('dddddddabc', 'abcd'), true)
    lu.assertEquals(candidate('eabcd', 'dddddddabc'), false)
    lu.assertEquals(candidate('abcd', 'dddddddabcf'), false)
    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), false)
    lu.assertEquals(candidate('aabb', 'aaccc'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 55 (LUA) - HumanEval_55_fib
================================================================================

PROMPT:
----------------------------------------
-- Return n-th Fibonacci number.
-- >>> fib(10)
-- 55
-- >>> fib(1)
-- 1
-- >>> fib(8)
-- 21

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = fib
    lu.assertEquals(candidate(10), 55)
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(8), 21)
    lu.assertEquals(candidate(11), 89)
    lu.assertEquals(candidate(12), 144)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Return n-th Fibonacci number.
-- >>> fib(10)
-- 55
-- >>> fib(1)
-- 1
-- >>> fib(8)
-- 21
-- Return n-th Fibonacci number.
-- >>> fib(10)
-- 55
-- >>> fib(1)
-- 1
-- >>> fib(8)
-- 21
local function fib(n)
    if n <= 0 then
        return 0
    end

    local a, b = 0, 1
    for i = 2, n do
        a, b = b, a + b
    end

    return b
end
lu = require('luaunit')

function test_humaneval()
local candidate = fib
    lu.assertEquals(candidate(10), 55)
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(8), 21)
    lu.assertEquals(candidate(11), 89)
    lu.assertEquals(candidate(12), 144)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Return n-th Fibonacci number.
-- >>> fib(10)
-- 55
-- >>> fib(1)
-- 1
-- >>> fib(8)
-- 21
-- Return n-th Fibonacci number.
-- >>> fib(10)
-- 55
-- >>> fib(1)
-- 1
-- >>> fib(8)
-- 21
local function fib(n)
    if n <= 0 then
        error("n must be a positive integer")
    elseif n == 1 or n == 2 then
        return 1
    else
        local a, b = 1, 1
        for i = 3, n do
            a, b = b, a + b
        end
        return b
    end
end
lu = require('luaunit')

function test_humaneval()
local candidate = fib
    lu.assertEquals(candidate(10), 55)
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(8), 21)
    lu.assertEquals(candidate(11), 89)
    lu.assertEquals(candidate(12), 144)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Return n-th Fibonacci number.
-- >>> fib(10)
-- 55
-- >>> fib(1)
-- 1
-- >>> fib(8)
-- 21
-- Return n-th Fibonacci number (1-indexed: fib(1)=1, fib(2)=1, fib(3)=2, â€¦).
local function fib(n)
    if n <= 0 then
        error("n must be a positive integer")
    end

    -- Base cases
    if n == 1 or n == 2 then
        return 1
    end

    -- Iteratively compute Fibonacci numbers
    local a, b = 1, 1  -- a = F(n-2), b = F(n-1)
    for i = 3, n do
        a, b = b, a + b
    end

    return b
end
lu = require('luaunit')

function test_humaneval()
local candidate = fib
    lu.assertEquals(candidate(10), 55)
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(8), 21)
    lu.assertEquals(candidate(11), 89)
    lu.assertEquals(candidate(12), 144)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Return n-th Fibonacci number.
-- >>> fib(10)
-- 55
-- >>> fib(1)
-- 1
-- >>> fib(8)
-- 21
-- Return n-th Fibonacci number.
-- >>> fib(10)
-- 55
-- >>> fib(1)
-- 1
-- >>> fib(8)
-- 21
local function fib(n)
    if n <= 0 then
        error("n must be a positive integer")
    end
    if n == 1 or n == 2 then
        return 1
    end
    local a, b = 1, 1
    for i = 3, n do
        a, b = b, a + b
    end
    return b
end
lu = require('luaunit')

function test_humaneval()
local candidate = fib
    lu.assertEquals(candidate(10), 55)
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(8), 21)
    lu.assertEquals(candidate(11), 89)
    lu.assertEquals(candidate(12), 144)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 56 (LUA) - HumanEval_56_correct_bracketing
================================================================================

PROMPT:
----------------------------------------
-- brackets is a string of "<" and ">".
-- return true if every opening bracket has a corresponding closing bracket.
-- >>> correct_bracketing('<')
-- false
-- >>> correct_bracketing('<>')
-- true
-- >>> correct_bracketing('<<><>>')
-- true
-- >>> correct_bracketing('><<>')
-- false

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = correct_bracketing
    lu.assertEquals(candidate('<>'), true)
    lu.assertEquals(candidate('<<><>>'), true)
    lu.assertEquals(candidate('<><><<><>><>'), true)
    lu.assertEquals(candidate('<><><<<><><>><>><<><><<>>>'), true)
    lu.assertEquals(candidate('<<<><>>>>'), false)
    lu.assertEquals(candidate('><<>'), false)
    lu.assertEquals(candidate('<'), false)
    lu.assertEquals(candidate('<<<<'), false)
    lu.assertEquals(candidate('>'), false)
    lu.assertEquals(candidate('<<>'), false)
    lu.assertEquals(candidate('<><><<><>><>><<>'), false)
    lu.assertEquals(candidate('<><><<><>><>>><>'), false)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- brackets is a string of "<" and ">".
-- return true if every opening bracket has a corresponding closing bracket.
-- >>> correct_bracketing('<')
-- false
-- >>> correct_bracketing('<>')
-- true
-- >>> correct_bracketing('<<><>>')
-- true
-- >>> correct_bracketing('><<>')
-- false
-- Check that a string of '<' and '>' is correctly bracketed
local function correct_bracketing(brackets)
    -- The counter represents the current depth of nested brackets
    local depth = 0

    for i = 1, #brackets do
        local c = brackets:sub(i, i)
        if c == '<' then
            depth = depth + 1          -- opening bracket increases depth
        elseif c == '>' then
            depth = depth - 1          -- closing bracket decreases depth
            if depth < 0 then          -- more closings than openings
                return false
            end
        else
            -- If the string contains any other character, it's invalid
            return false
        end
    end

    -- All brackets must be closed, so depth should be zero
    return depth == 0
end
lu = require('luaunit')

function test_humaneval()
local candidate = correct_bracketing
    lu.assertEquals(candidate('<>'), true)
    lu.assertEquals(candidate('<<><>>'), true)
    lu.assertEquals(candidate('<><><<><>><>'), true)
    lu.assertEquals(candidate('<><><<<><><>><>><<><><<>>>'), true)
    lu.assertEquals(candidate('<<<><>>>>'), false)
    lu.assertEquals(candidate('><<>'), false)
    lu.assertEquals(candidate('<'), false)
    lu.assertEquals(candidate('<<<<'), false)
    lu.assertEquals(candidate('>'), false)
    lu.assertEquals(candidate('<<>'), false)
    lu.assertEquals(candidate('<><><<><>><>><<>'), false)
    lu.assertEquals(candidate('<><><<><>><>>><>'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- brackets is a string of "<" and ">".
-- return true if every opening bracket has a corresponding closing bracket.
-- >>> correct_bracketing('<')
-- false
-- >>> correct_bracketing('<>')
-- true
-- >>> correct_bracketing('<<><>>')
-- true
-- >>> correct_bracketing('><<>')
-- false
local function correct_bracketing(brackets)
    -- Use a counter as a simple stack
    local count = 0

    for i = 1, #brackets do
        local c = brackets:sub(i, i)
        if c == '<' then
            count = count + 1
        elseif c == '>' then
            if count == 0 then
                return false          -- closing without matching opening
            end
            count = count - 1
        else
            -- ignore any other characters (or you could treat them as errors)
        end
    end

    return count == 0   -- true if all openings have been closed
end
lu = require('luaunit')

function test_humaneval()
local candidate = correct_bracketing
    lu.assertEquals(candidate('<>'), true)
    lu.assertEquals(candidate('<<><>>'), true)
    lu.assertEquals(candidate('<><><<><>><>'), true)
    lu.assertEquals(candidate('<><><<<><><>><>><<><><<>>>'), true)
    lu.assertEquals(candidate('<<<><>>>>'), false)
    lu.assertEquals(candidate('><<>'), false)
    lu.assertEquals(candidate('<'), false)
    lu.assertEquals(candidate('<<<<'), false)
    lu.assertEquals(candidate('>'), false)
    lu.assertEquals(candidate('<<>'), false)
    lu.assertEquals(candidate('<><><<><>><>><<>'), false)
    lu.assertEquals(candidate('<><><<><>><>>><>'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- brackets is a string of "<" and ">".
-- return true if every opening bracket has a corresponding closing bracket.
-- >>> correct_bracketing('<')
-- false
-- >>> correct_bracketing('<>')
-- true
-- >>> correct_bracketing('<<><>>')
-- true
-- >>> correct_bracketing('><<>')
-- false
-- Check that every opening '<' has a matching closing '>'
-- and that the brackets are properly nested.
local function correct_bracketing(brackets)
    local depth = 0
    for i = 1, #brackets do
        local c = brackets:sub(i,i)
        if c == '<' then
            depth = depth + 1
        elseif c == '>' then
            depth = depth - 1
            if depth < 0 then
                return false          -- a closing bracket appeared too early
            end
        else
            -- If other characters are possible, ignore or handle here.
        end
    end
    return depth == 0
end
lu = require('luaunit')

function test_humaneval()
local candidate = correct_bracketing
    lu.assertEquals(candidate('<>'), true)
    lu.assertEquals(candidate('<<><>>'), true)
    lu.assertEquals(candidate('<><><<><>><>'), true)
    lu.assertEquals(candidate('<><><<<><><>><>><<><><<>>>'), true)
    lu.assertEquals(candidate('<<<><>>>>'), false)
    lu.assertEquals(candidate('><<>'), false)
    lu.assertEquals(candidate('<'), false)
    lu.assertEquals(candidate('<<<<'), false)
    lu.assertEquals(candidate('>'), false)
    lu.assertEquals(candidate('<<>'), false)
    lu.assertEquals(candidate('<><><<><>><>><<>'), false)
    lu.assertEquals(candidate('<><><<><>><>>><>'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- brackets is a string of "<" and ">".
-- return true if every opening bracket has a corresponding closing bracket.
-- >>> correct_bracketing('<')
-- false
-- >>> correct_bracketing('<>')
-- true
-- >>> correct_bracketing('<<><>>')
-- true
-- >>> correct_bracketing('><<>')
-- false
local function correct_bracketing(brackets)
    local balance = 0
    for i = 1, #brackets do
        local ch = brackets:sub(i, i)
        if ch == '<' then
            balance = balance + 1
        elseif ch == '>' then
            balance = balance - 1
            if balance < 0 then
                return false
            end
        end
    end
    return balance == 0
end
lu = require('luaunit')

function test_humaneval()
local candidate = correct_bracketing
    lu.assertEquals(candidate('<>'), true)
    lu.assertEquals(candidate('<<><>>'), true)
    lu.assertEquals(candidate('<><><<><>><>'), true)
    lu.assertEquals(candidate('<><><<<><><>><>><<><><<>>>'), true)
    lu.assertEquals(candidate('<<<><>>>>'), false)
    lu.assertEquals(candidate('><<>'), false)
    lu.assertEquals(candidate('<'), false)
    lu.assertEquals(candidate('<<<<'), false)
    lu.assertEquals(candidate('>'), false)
    lu.assertEquals(candidate('<<>'), false)
    lu.assertEquals(candidate('<><><<><>><>><<>'), false)
    lu.assertEquals(candidate('<><><<><>><>>><>'), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 57 (LUA) - HumanEval_57_monotonic
================================================================================

PROMPT:
----------------------------------------
-- Return true is table elements are monotonically increasing or decreasing.
-- >>> monotonic({1, 2, 4, 20})
-- true
-- >>> monotonic({1, 20, 4, 10})
-- false
-- >>> monotonic({4, 1, 0, -10})
-- true

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = monotonic
    lu.assertEquals(candidate({1, 2, 4, 10}), true)
    lu.assertEquals(candidate({1, 2, 4, 20}), true)
    lu.assertEquals(candidate({1, 20, 4, 10}), false)
    lu.assertEquals(candidate({4, 1, 0, -10}), true)
    lu.assertEquals(candidate({4, 1, 1, 0}), true)
    lu.assertEquals(candidate({1, 2, 3, 2, 5, 60}), false)
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 60}), true)
    lu.assertEquals(candidate({9, 9, 9, 9}), true)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Return true is table elements are monotonically increasing or decreasing.
-- >>> monotonic({1, 2, 4, 20})
-- true
-- >>> monotonic({1, 20, 4, 10})
-- false
-- >>> monotonic({4, 1, 0, -10})
-- true
-- Return true if table elements are monotonically increasing or decreasing.
-- >>> monotonic({1, 2, 4, 20})
-- true
-- >>> monotonic({1, 20, 4, 10})
-- false
-- >>> monotonic({4, 1, 0, -10})
-- true
local function monotonic(l)
  if #l <= 1 then
    return true
  end

  local inc, dec = false, false

  for i = 2, #l do
    local diff = l[i] - l[i - 1]
    if diff > 0 then inc = true end
    if diff < 0 then dec = true end
  end

  -- If both increasing and decreasing patterns are present, it's not monotonic.
  return not (inc and dec)
end
lu = require('luaunit')

function test_humaneval()
local candidate = monotonic
    lu.assertEquals(candidate({1, 2, 4, 10}), true)
    lu.assertEquals(candidate({1, 2, 4, 20}), true)
    lu.assertEquals(candidate({1, 20, 4, 10}), false)
    lu.assertEquals(candidate({4, 1, 0, -10}), true)
    lu.assertEquals(candidate({4, 1, 1, 0}), true)
    lu.assertEquals(candidate({1, 2, 3, 2, 5, 60}), false)
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 60}), true)
    lu.assertEquals(candidate({9, 9, 9, 9}), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Return true is table elements are monotonically increasing or decreasing.
-- >>> monotonic({1, 2, 4, 20})
-- true
-- >>> monotonic({1, 20, 4, 10})
-- false
-- >>> monotonic({4, 1, 0, -10})
-- true
-- Return true if table elements are monotonically increasing or decreasing.
-- >>> monotonic({1, 2, 4, 20})
-- true
-- >>> monotonic({1, 20, 4, 10})
-- false
-- >>> monotonic({4, 1, 0, -10})
-- true
local function monotonic(l)
    if #l <= 1 then
        return true
    end

    local inc, dec = false, false

    for i = 2, #l do
        local diff = l[i] - l[i - 1]
        if diff > 0 then
            inc = true
        elseif diff < 0 then
            dec = true
        end
        if inc and dec then
            return false
        end
    end

    return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = monotonic
    lu.assertEquals(candidate({1, 2, 4, 10}), true)
    lu.assertEquals(candidate({1, 2, 4, 20}), true)
    lu.assertEquals(candidate({1, 20, 4, 10}), false)
    lu.assertEquals(candidate({4, 1, 0, -10}), true)
    lu.assertEquals(candidate({4, 1, 1, 0}), true)
    lu.assertEquals(candidate({1, 2, 3, 2, 5, 60}), false)
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 60}), true)
    lu.assertEquals(candidate({9, 9, 9, 9}), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Return true is table elements are monotonically increasing or decreasing.
-- >>> monotonic({1, 2, 4, 20})
-- true
-- >>> monotonic({1, 20, 4, 10})
-- false
-- >>> monotonic({4, 1, 0, -10})
-- true
-- Return true if table elements are monotonically increasing or decreasing
-- >>> monotonic({1, 2, 4, 20})
-- true
-- >>> monotonic({1, 20, 4, 10})
-- false
-- >>> monotonic({4, 1, 0, -10})
-- true
local function monotonic(l)
    local n = #l
    if n <= 1 then return true end

    -- Find first pair of distinct elements to determine direction
    local i = 2
    while i <= n and l[i] == l[i-1] do
        i = i + 1
    end

    -- All elements are equal
    if i > n then return true end

    local increasing = l[i] > l[i-1]

    for j = i + 1, n do
        if increasing then
            if l[j] < l[j-1] then return false end
        else
            if l[j] > l[j-1] then return false end
        end
    end

    return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = monotonic
    lu.assertEquals(candidate({1, 2, 4, 10}), true)
    lu.assertEquals(candidate({1, 2, 4, 20}), true)
    lu.assertEquals(candidate({1, 20, 4, 10}), false)
    lu.assertEquals(candidate({4, 1, 0, -10}), true)
    lu.assertEquals(candidate({4, 1, 1, 0}), true)
    lu.assertEquals(candidate({1, 2, 3, 2, 5, 60}), false)
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 60}), true)
    lu.assertEquals(candidate({9, 9, 9, 9}), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Return true is table elements are monotonically increasing or decreasing.
-- >>> monotonic({1, 2, 4, 20})
-- true
-- >>> monotonic({1, 20, 4, 10})
-- false
-- >>> monotonic({4, 1, 0, -10})
-- true
-- Return true if the table elements are monotonically increasing or decreasing.
-- >>> monotonic({1, 2, 4, 20})
-- true
-- >>> monotonic({1, 20, 4, 10})
-- false
-- >>> monotonic({4, 1, 0, -10})
-- true
local function monotonic(l)
  local n = #l
  if n <= 1 then return true end

  -- Find the first nonâ€‘zero difference to determine the direction.
  local direction = 0  -- 1 for increasing, -1 for decreasing, 0 for all equal so far
  for i = 2, n do
    local diff = l[i] - l[i-1]
    if diff ~= 0 then
      direction = diff > 0 and 1 or -1
      break
    end
  end

  -- If all elements are equal, it's monotonic.
  if direction == 0 then return true end

  -- Verify that every subsequent difference follows the same direction.
  for i = 2, n do
    local diff = l[i] - l[i-1]
    if diff ~= 0 then
      local dir = diff > 0 and 1 or -1
      if dir ~= direction then
        return false
      end
    end
  end

  return true
end
lu = require('luaunit')

function test_humaneval()
local candidate = monotonic
    lu.assertEquals(candidate({1, 2, 4, 10}), true)
    lu.assertEquals(candidate({1, 2, 4, 20}), true)
    lu.assertEquals(candidate({1, 20, 4, 10}), false)
    lu.assertEquals(candidate({4, 1, 0, -10}), true)
    lu.assertEquals(candidate({4, 1, 1, 0}), true)
    lu.assertEquals(candidate({1, 2, 3, 2, 5, 60}), false)
    lu.assertEquals(candidate({1, 2, 3, 4, 5, 60}), true)
    lu.assertEquals(candidate({9, 9, 9, 9}), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 58 (LUA) - HumanEval_58_common
================================================================================

PROMPT:
----------------------------------------
-- Return sorted unique common elements for two tables.
-- >>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})
-- {1, 5, 653}
-- >>> common({5, 3, 2, 8}, {3, 2})
-- {2, 3}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = common
    lu.assertEquals(candidate({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}), {1, 5, 653})
    lu.assertEquals(candidate({5, 3, 2, 8}, {3, 2}), {2, 3})
    lu.assertEquals(candidate({4, 3, 2, 8}, {3, 2, 4}), {2, 3, 4})
    lu.assertEquals(candidate({4, 3, 2, 8}, {}), {})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Return sorted unique common elements for two tables.
-- >>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})
-- {1, 5, 653}
-- >>> common({5, 3, 2, 8}, {3, 2})
-- {2, 3}
-- Return sorted unique common elements for two tables.
-- >>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})
-- {1, 5, 653}
-- >>> common({5, 3, 2, 8}, {3, 2})
-- {2, 3}
local function common(l1, l2)
    -- Build a set from the first table
    local set1 = {}
    for _, v in pairs(l1) do
        set1[v] = true
    end

    -- Find common elements and store them in a set to avoid duplicates
    local common_set = {}
    for _, v in pairs(l2) do
        if set1[v] then
            common_set[v] = true
        end
    end

    -- Convert the set to a list
    local result = {}
    for v, _ in pairs(common_set) do
        table.insert(result, v)
    end

    -- Sort the result
    table.sort(result)

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = common
    lu.assertEquals(candidate({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}), {1, 5, 653})
    lu.assertEquals(candidate({5, 3, 2, 8}, {3, 2}), {2, 3})
    lu.assertEquals(candidate({4, 3, 2, 8}, {3, 2, 4}), {2, 3, 4})
    lu.assertEquals(candidate({4, 3, 2, 8}, {}), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Return sorted unique common elements for two tables.
-- >>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})
-- {1, 5, 653}
-- >>> common({5, 3, 2, 8}, {3, 2})
-- {2, 3}
-- Return sorted unique common elements for two tables.
-- >>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})
-- {1, 5, 653}
-- >>> common({5, 3, 2, 8}, {3, 2})
-- {2, 3}
local function common(l1, l2)
  -- Build a set from the first list
  local set1 = {}
  for _, v in ipairs(l1) do
    set1[v] = true
  end

  -- Find common elements and store them in a set
  local common_set = {}
  for _, v in ipairs(l2) do
    if set1[v] then
      common_set[v] = true
    end
  end

  -- Convert the set to an array
  local result = {}
  for v, _ in pairs(common_set) do
    table.insert(result, v)
  end

  -- Sort numerically
  table.sort(result)

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = common
    lu.assertEquals(candidate({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}), {1, 5, 653})
    lu.assertEquals(candidate({5, 3, 2, 8}, {3, 2}), {2, 3})
    lu.assertEquals(candidate({4, 3, 2, 8}, {3, 2, 4}), {2, 3, 4})
    lu.assertEquals(candidate({4, 3, 2, 8}, {}), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Return sorted unique common elements for two tables.
-- >>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})
-- {1, 5, 653}
-- >>> common({5, 3, 2, 8}, {3, 2})
-- {2, 3}
-- Return sorted unique common elements for two tables.
-- >>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})
-- {1, 5, 653}
-- >>> common({5, 3, 2, 8}, {3, 2})
-- {2, 3}
local function common(l1, l2)
  -- Build a set from the first table
  local set1 = {}
  for _, v in ipairs(l1) do
    set1[v] = true
  end

  -- Find common elements and store them in a set
  local commonSet = {}
  for _, v in ipairs(l2) do
    if set1[v] then
      commonSet[v] = true
    end
  end

  -- Convert the set to a sorted array
  local result = {}
  for v, _ in pairs(commonSet) do
    table.insert(result, v)
  end
  table.sort(result)

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = common
    lu.assertEquals(candidate({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}), {1, 5, 653})
    lu.assertEquals(candidate({5, 3, 2, 8}, {3, 2}), {2, 3})
    lu.assertEquals(candidate({4, 3, 2, 8}, {3, 2, 4}), {2, 3, 4})
    lu.assertEquals(candidate({4, 3, 2, 8}, {}), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Return sorted unique common elements for two tables.
-- >>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})
-- {1, 5, 653}
-- >>> common({5, 3, 2, 8}, {3, 2})
-- {2, 3}
local function common(l1, l2)
    -- Build a set from the second list for O(1) lookâ€‘ups
    local set2 = {}
    for _, v in ipairs(l2) do
        set2[v] = true
    end

    -- Collect unique common elements
    local result = {}
    local seen = {}
    for _, v in ipairs(l1) do
        if set2[v] and not seen[v] then
            table.insert(result, v)
            seen[v] = true
        end
    end

    -- Sort the result in ascending order
    table.sort(result)
    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = common
    lu.assertEquals(candidate({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}), {1, 5, 653})
    lu.assertEquals(candidate({5, 3, 2, 8}, {3, 2}), {2, 3})
    lu.assertEquals(candidate({4, 3, 2, 8}, {3, 2, 4}), {2, 3, 4})
    lu.assertEquals(candidate({4, 3, 2, 8}, {}), {})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 59 (LUA) - HumanEval_59_largest_prime_factor
================================================================================

PROMPT:
----------------------------------------
-- Return the largest prime factor of n. Assume n > 1 and is not a prime.
-- >>> largest_prime_factor(13195)
-- 29
-- >>> largest_prime_factor(2048)
-- 2

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = largest_prime_factor
    lu.assertEquals(candidate(15), 5)
    lu.assertEquals(candidate(27), 3)
    lu.assertEquals(candidate(63), 7)
    lu.assertEquals(candidate(330), 11)
    lu.assertEquals(candidate(13195), 29)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Return the largest prime factor of n. Assume n > 1 and is not a prime.
-- >>> largest_prime_factor(13195)
-- 29
-- >>> largest_prime_factor(2048)
-- 2
local function largest_prime_factor(n)
    local largest = nil

    -- Remove all factors of 2 first
    while n % 2 == 0 do
        largest = 2
        n = n / 2
    end

    -- Now check odd factors up to sqrt(n)
    local i = 3
    while i * i <= n do
        while n % i == 0 do
            largest = i
            n = n / i
        end
        i = i + 2
    end

    -- If n is still greater than 1, it is a prime factor
    if n > 1 then
        largest = n
    end

    return largest
end
lu = require('luaunit')

function test_humaneval()
local candidate = largest_prime_factor
    lu.assertEquals(candidate(15), 5)
    lu.assertEquals(candidate(27), 3)
    lu.assertEquals(candidate(63), 7)
    lu.assertEquals(candidate(330), 11)
    lu.assertEquals(candidate(13195), 29)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Return the largest prime factor of n. Assume n > 1 and is not a prime.
-- >>> largest_prime_factor(13195)
-- 29
-- >>> largest_prime_factor(2048)
-- 2
-- Return the largest prime factor of n. Assume n > 1 and is not a prime.
-- >>> largest_prime_factor(13195)
-- 29
-- >>> largest_prime_factor(2048)
-- 2
local function largest_prime_factor(n)
    local max_factor = nil
    local d = 2
    while d * d <= n do
        if n % d == 0 then
            max_factor = d
            repeat
                n = n / d
            until n % d ~= 0
        end
        d = d + 1
    end
    if n > 1 then
        max_factor = n
    end
    return max_factor
end
lu = require('luaunit')

function test_humaneval()
local candidate = largest_prime_factor
    lu.assertEquals(candidate(15), 5)
    lu.assertEquals(candidate(27), 3)
    lu.assertEquals(candidate(63), 7)
    lu.assertEquals(candidate(330), 11)
    lu.assertEquals(candidate(13195), 29)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Return the largest prime factor of n. Assume n > 1 and is not a prime.
-- >>> largest_prime_factor(13195)
-- 29
-- >>> largest_prime_factor(2048)
-- 2
local function largest_prime_factor(n)
  local largest = nil
  local d = 2
  while d * d <= n do
    while n % d == 0 do
      largest = d
      n = n / d
    end
    d = d + 1
  end
  if n > 1 then
    largest = n
  end
  return largest
end
lu = require('luaunit')

function test_humaneval()
local candidate = largest_prime_factor
    lu.assertEquals(candidate(15), 5)
    lu.assertEquals(candidate(27), 3)
    lu.assertEquals(candidate(63), 7)
    lu.assertEquals(candidate(330), 11)
    lu.assertEquals(candidate(13195), 29)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Return the largest prime factor of n. Assume n > 1 and is not a prime.
-- >>> largest_prime_factor(13195)
-- 29
-- >>> largest_prime_factor(2048)
-- 2
-- Return the largest prime factor of n. Assume n > 1 and is not a prime.
-- >>> largest_prime_factor(13195)
-- 29
-- >>> largest_prime_factor(2048)
-- 2
local function largest_prime_factor(n)
    local largest = nil

    -- Handle factor 2 separately
    while n % 2 == 0 do
        largest = 2
        n = n / 2
    end

    -- Now n is odd. Test odd divisors only.
    local d = 3
    while d * d <= n do
        while n % d == 0 do
            largest = d
            n = n / d
        end
        d = d + 2
    end

    -- If n is now greater than 1, it itself is a prime factor
    if n > 1 then
        largest = n
    end

    return largest
end
lu = require('luaunit')

function test_humaneval()
local candidate = largest_prime_factor
    lu.assertEquals(candidate(15), 5)
    lu.assertEquals(candidate(27), 3)
    lu.assertEquals(candidate(63), 7)
    lu.assertEquals(candidate(330), 11)
    lu.assertEquals(candidate(13195), 29)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154470
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 60 (LUA) - HumanEval_60_sum_to_n
================================================================================

PROMPT:
----------------------------------------
-- sum_to_n is a function that sums numbers from 1 to n.
-- >>> sum_to_n(30)
-- 465
-- >>> sum_to_n(100)
-- 5050
-- >>> sum_to_n(5)
-- 15
-- >>> sum_to_n(10)
-- 55
-- >>> sum_to_n(1)
-- 1

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = sum_to_n
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(6), 21)
    lu.assertEquals(candidate(11), 66)
    lu.assertEquals(candidate(30), 465)
    lu.assertEquals(candidate(100), 5050)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- sum_to_n is a function that sums numbers from 1 to n.
-- >>> sum_to_n(30)
-- 465
-- >>> sum_to_n(100)
-- 5050
-- >>> sum_to_n(5)
-- 15
-- >>> sum_to_n(10)
-- 55
-- >>> sum_to_n(1)
-- 1
-- sum_to_n is a function that sums numbers from 1 to n.
-- >>> sum_to_n(30)
-- 465
-- >>> sum_to_n(100)
-- 5050
-- >>> sum_to_n(5)
-- 15
-- >>> sum_to_n(10)
-- 55
-- >>> sum_to_n(1)
-- 1
local function sum_to_n(n)
    -- Using the arithmetic series formula: n * (n + 1) / 2
    -- Lua 5.3+ supports integer division with //, which guarantees an integer result.
    return (n * (n + 1)) // 2
end
lu = require('luaunit')

function test_humaneval()
local candidate = sum_to_n
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(6), 21)
    lu.assertEquals(candidate(11), 66)
    lu.assertEquals(candidate(30), 465)
    lu.assertEquals(candidate(100), 5050)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- sum_to_n is a function that sums numbers from 1 to n.
-- >>> sum_to_n(30)
-- 465
-- >>> sum_to_n(100)
-- 5050
-- >>> sum_to_n(5)
-- 15
-- >>> sum_to_n(10)
-- 55
-- >>> sum_to_n(1)
-- 1
-- Sum numbers from 1 to n
local function sum_to_n(n)
  -- Using integer division to keep the result an integer
  return n * (n + 1) // 2
end
lu = require('luaunit')

function test_humaneval()
local candidate = sum_to_n
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(6), 21)
    lu.assertEquals(candidate(11), 66)
    lu.assertEquals(candidate(30), 465)
    lu.assertEquals(candidate(100), 5050)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- sum_to_n is a function that sums numbers from 1 to n.
-- >>> sum_to_n(30)
-- 465
-- >>> sum_to_n(100)
-- 5050
-- >>> sum_to_n(5)
-- 15
-- >>> sum_to_n(10)
-- 55
-- >>> sum_to_n(1)
-- 1
local function sum_to_n(n)
    -- Using the arithmetic series formula for efficiency
    return n * (n + 1) // 2
end
lu = require('luaunit')

function test_humaneval()
local candidate = sum_to_n
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(6), 21)
    lu.assertEquals(candidate(11), 66)
    lu.assertEquals(candidate(30), 465)
    lu.assertEquals(candidate(100), 5050)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- sum_to_n is a function that sums numbers from 1 to n.
-- >>> sum_to_n(30)
-- 465
-- >>> sum_to_n(100)
-- 5050
-- >>> sum_to_n(5)
-- 15
-- >>> sum_to_n(10)
-- 55
-- >>> sum_to_n(1)
-- 1
-- sum_to_n is a function that sums numbers from 1 to n.
-- >>> sum_to_n(30)
-- 465
-- >>> sum_to_n(100)
-- 5050
-- >>> sum_to_n(5)
-- 15
-- >>> sum_to_n(10)
-- 55
-- >>> sum_to_n(1)
-- 1
local function sum_to_n(n)
    return n * (n + 1) / 2
end
lu = require('luaunit')

function test_humaneval()
local candidate = sum_to_n
    lu.assertEquals(candidate(1), 1)
    lu.assertEquals(candidate(6), 21)
    lu.assertEquals(candidate(11), 66)
    lu.assertEquals(candidate(30), 465)
    lu.assertEquals(candidate(100), 5050)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154471
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------
