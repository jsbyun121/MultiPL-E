As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 16 (R) - HumanEval_16_count_distinct_characters
================================================================================

PROMPT:
----------------------------------------
# Given a string, find out how many distinct characters (regardless of case) does it consist of
# >>> count_distinct_characters('xyzXYZ')
# 3
# >>> count_distinct_characters('Jerry')
# 4

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- count_distinct_characters
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('abcde'), 5)))
    stopifnot(isTRUE(all.equal(candidate('abcdecadeCADE'), 5)))
    stopifnot(isTRUE(all.equal(candidate('aaaaAAAAaaaa'), 1)))
    stopifnot(isTRUE(all.equal(candidate('Jerry jERRY JeRRRY'), 5)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given a string, find out how many distinct characters (regardless of case) does it consist of
# >>> count_distinct_characters('xyzXYZ')
# 3
# >>> count_distinct_characters('Jerry')
# 4
count_distinct_characters <- function(string) {
  # Convert to lower case to ignore case differences
  lower_str <- tolower(string)
  
  # Split the string into individual characters
  chars <- strsplit(lower_str, split = "")[[1]]
  
  # Handle the case of an empty string
  if (length(chars) == 0) {
    return(0L)
  }
  
  # Count unique characters
  return(length(unique(chars)))
}
test_humaneval <- function() {
    candidate <- count_distinct_characters
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('abcde'), 5)))
    stopifnot(isTRUE(all.equal(candidate('abcdecadeCADE'), 5)))
    stopifnot(isTRUE(all.equal(candidate('aaaaAAAAaaaa'), 1)))
    stopifnot(isTRUE(all.equal(candidate('Jerry jERRY JeRRRY'), 5)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183740
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given a string, find out how many distinct characters (regardless of case) does it consist of
# >>> count_distinct_characters('xyzXYZ')
# 3
# >>> count_distinct_characters('Jerry')
# 4
count_distinct_characters <- function(string) {
  # Convert to lower case to ignore case differences
  lowered <- tolower(string)
  # Split the string into individual characters
  chars <- unlist(strsplit(lowered, split = ""))
  # Remove any empty strings that may result from an empty input
  chars <- chars[chars != ""]
  # Count unique characters
  length(unique(chars))
}
test_humaneval <- function() {
    candidate <- count_distinct_characters
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('abcde'), 5)))
    stopifnot(isTRUE(all.equal(candidate('abcdecadeCADE'), 5)))
    stopifnot(isTRUE(all.equal(candidate('aaaaAAAAaaaa'), 1)))
    stopifnot(isTRUE(all.equal(candidate('Jerry jERRY JeRRRY'), 5)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183740
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given a string, find out how many distinct characters (regardless of case) does it consist of
# >>> count_distinct_characters('xyzXYZ')
# 3
# >>> count_distinct_characters('Jerry')
# 4
count_distinct_characters <- function(string) {
  # Convert the string to lower case so the count is case‑insensitive
  lower_string <- tolower(string)
  
  # Split the string into individual characters
  chars <- unlist(strsplit(lower_string, split = ""))
  
  # Return the number of unique characters
  length(unique(chars))
}
test_humaneval <- function() {
    candidate <- count_distinct_characters
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('abcde'), 5)))
    stopifnot(isTRUE(all.equal(candidate('abcdecadeCADE'), 5)))
    stopifnot(isTRUE(all.equal(candidate('aaaaAAAAaaaa'), 1)))
    stopifnot(isTRUE(all.equal(candidate('Jerry jERRY JeRRRY'), 5)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183740
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given a string, find out how many distinct characters (regardless of case) does it consist of
# >>> count_distinct_characters('xyzXYZ')
# 3
# >>> count_distinct_characters('Jerry')
# 4
count_distinct_characters <- function(string) {
  # Handle NULL or non‑character inputs
  if (is.null(string) || !is.character(string)) {
    stop("Input must be a non‑null character string.")
  }
  
  # Convert to lower case to ignore case differences
  lower_str <- tolower(string)
  
  # Split into individual characters
  chars <- strsplit(lower_str, NULL)[[1]]
  
  # Remove any empty strings that might arise from an empty input
  chars <- chars[chars != ""]
  
  # Count unique characters
  length(unique(chars))
}
test_humaneval <- function() {
    candidate <- count_distinct_characters
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('abcde'), 5)))
    stopifnot(isTRUE(all.equal(candidate('abcdecadeCADE'), 5)))
    stopifnot(isTRUE(all.equal(candidate('aaaaAAAAaaaa'), 1)))
    stopifnot(isTRUE(all.equal(candidate('Jerry jERRY JeRRRY'), 5)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183740
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 18 (R) - HumanEval_18_how_many_times
================================================================================

PROMPT:
----------------------------------------
# Find how many times a given substring can be found in the original string. Count overlaping cases.
# >>> how_many_times('', 'a')
# 0
# >>> how_many_times('aaa', 'a')
# 3
# >>> how_many_times('aaaa', 'aa')
# 3

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- how_many_times
    stopifnot(isTRUE(all.equal(candidate('', 'x'), 0)))
    stopifnot(isTRUE(all.equal(candidate('xyxyxyx', 'x'), 4)))
    stopifnot(isTRUE(all.equal(candidate('cacacacac', 'cac'), 4)))
    stopifnot(isTRUE(all.equal(candidate('john doe', 'john'), 1)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Find how many times a given substring can be found in the original string. Count overlaping cases.
# >>> how_many_times('', 'a')
# 0
# >>> how_many_times('aaa', 'a')
# 3
# >>> how_many_times('aaaa', 'aa')
# 3
# Find how many times a given substring can be found in the original string.
# Count overlapping cases.
# >>> how_many_times('', 'a')
# 0
# >>> how_many_times('aaa', 'a')
# 3
# >>> how_many_times('aaaa', 'aa')
# 3
how_many_times <- function(string, substring) {
  # Return 0 if either the string or the substring is empty
  if (nchar(string) == 0 || nchar(substring) == 0) {
    return(0)
  }

  # Use a look‑ahead regex to find overlapping matches
  pattern <- paste0("(?=", substring, ")")
  matches <- gregexpr(pattern, string, perl = TRUE)[[1]]

  # gregexpr returns -1 when no match is found
  if (matches[1] == -1) {
    return(0)
  }

  return(length(matches))
}
test_humaneval <- function() {
    candidate <- how_many_times
    stopifnot(isTRUE(all.equal(candidate('', 'x'), 0)))
    stopifnot(isTRUE(all.equal(candidate('xyxyxyx', 'x'), 4)))
    stopifnot(isTRUE(all.equal(candidate('cacacacac', 'cac'), 4)))
    stopifnot(isTRUE(all.equal(candidate('john doe', 'john'), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183741
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Find how many times a given substring can be found in the original string. Count overlaping cases.
# >>> how_many_times('', 'a')
# 0
# >>> how_many_times('aaa', 'a')
# 3
# >>> how_many_times('aaaa', 'aa')
# 3
# Find how many times a given substring can be found in the original string.
# Count overlapping cases.
# >>> how_many_times('', 'a')
# 0
# >>> how_many_times('aaa', 'a')
# 3
# >>> how_many_times('aaaa', 'aa')
# 3
how_many_times <- function(string, substring) {
  # Empty string or empty pattern → no matches
  if (string == "" || substring == "") return(0L)

  # Escape regex metacharacters in the substring
  escaped_sub <- gsub("([\\^$.|?*+(){}])", "\\\\\\1", substring)

  # Look‑ahead pattern finds overlapping matches
  pattern <- paste0("(?=", escaped_sub, ")")

  # Find all start positions (length 0 matches)
  pos <- gregexpr(pattern, string, perl = TRUE)[[1]]

  # If no match, gregexpr returns -1
  if (pos[1] == -1) return(0L)

  # Number of matches equals number of positions found
  length(pos)
}
test_humaneval <- function() {
    candidate <- how_many_times
    stopifnot(isTRUE(all.equal(candidate('', 'x'), 0)))
    stopifnot(isTRUE(all.equal(candidate('xyxyxyx', 'x'), 4)))
    stopifnot(isTRUE(all.equal(candidate('cacacacac', 'cac'), 4)))
    stopifnot(isTRUE(all.equal(candidate('john doe', 'john'), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183741
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Find how many times a given substring can be found in the original string. Count overlaping cases.
# >>> how_many_times('', 'a')
# 0
# >>> how_many_times('aaa', 'a')
# 3
# >>> how_many_times('aaaa', 'aa')
# 3
# Find how many times a given substring can be found in the original string.
# Count overlapping cases.
# >>> how_many_times('', 'a')
# 0
# >>> how_many_times('aaa', 'a')
# 3
# >>> how_many_times('aaaa', 'aa')
# 3

how_many_times <- function(string, substring) {
  # Return 0 if either string or substring is empty
  if (nchar(substring) == 0 || nchar(string) == 0) {
    return(0)
  }
  
  sub_len <- nchar(substring)
  str_len <- nchar(string)
  count <- 0
  
  # Slide a window of length sub_len across the string
  for (i in seq_len(str_len - sub_len + 1)) {
    if (substr(string, i, i + sub_len - 1) == substring) {
      count <- count + 1
    }
  }
  
  count
}
test_humaneval <- function() {
    candidate <- how_many_times
    stopifnot(isTRUE(all.equal(candidate('', 'x'), 0)))
    stopifnot(isTRUE(all.equal(candidate('xyxyxyx', 'x'), 4)))
    stopifnot(isTRUE(all.equal(candidate('cacacacac', 'cac'), 4)))
    stopifnot(isTRUE(all.equal(candidate('john doe', 'john'), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183741
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Find how many times a given substring can be found in the original string. Count overlaping cases.
# >>> how_many_times('', 'a')
# 0
# >>> how_many_times('aaa', 'a')
# 3
# >>> how_many_times('aaaa', 'aa')
# 3
# Find how many times a given substring can be found in the original string.
# Count overlapping cases.
# >>> how_many_times('', 'a')
# 0
# >>> how_many_times('aaa', 'a')
# 3
# >>> how_many_times('aaaa', 'aa')
# 3
how_many_times <- function(string, substring) {
  # If the substring is empty, or the string is empty, return 0
  if (nchar(substring) == 0 || nchar(string) == 0) {
    return(0L)
  }
  
  # Lengths of the string and the substring
  n <- nchar(string)
  m <- nchar(substring)
  
  # If the substring is longer than the string, no matches
  if (m > n) {
    return(0L)
  }
  
  # Convert to character vectors for efficient slicing
  # (use substr which is vectorised but we will loop for clarity)
  count <- 0L
  for (i in seq_len(n - m + 1)) {
    if (substr(string, i, i + m - 1) == substring) {
      count <- count + 1L
    }
  }
  return(count)
}
test_humaneval <- function() {
    candidate <- how_many_times
    stopifnot(isTRUE(all.equal(candidate('', 'x'), 0)))
    stopifnot(isTRUE(all.equal(candidate('xyxyxyx', 'x'), 4)))
    stopifnot(isTRUE(all.equal(candidate('cacacacac', 'cac'), 4)))
    stopifnot(isTRUE(all.equal(candidate('john doe', 'john'), 1)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183741
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 19 (R) - HumanEval_19_sort_numbers
================================================================================

PROMPT:
----------------------------------------
# Input is a space-delimited string of numberals from 'zero' to 'nine'.
# Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
# Return the string with numbers sorted from smallest to largest
# >>> sort_numbers('three one five')
# 'one three five'

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- sort_numbers
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('three'), 'three')))
    stopifnot(isTRUE(all.equal(candidate('three five nine'), 'three five nine')))
    stopifnot(isTRUE(all.equal(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')))
    stopifnot(isTRUE(all.equal(candidate('six five four three two one zero'), 'zero one two three four five six')))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Input is a space-delimited string of numberals from 'zero' to 'nine'.
# Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
# Return the string with numbers sorted from smallest to largest
# >>> sort_numbers('three one five')
# 'one three five'
# Input is a space-delimited string of numberals from 'zero' to 'nine'.
# Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
# Return the string with numbers sorted from smallest to largest
# >>> sort_numbers('three one five')
# 'one three five'
sort_numbers <- function(numbers) {
  # Handle empty input
  if (nchar(numbers) == 0) return("")
  
  # Split the input into individual words
  words <- strsplit(numbers, " ")[[1]]
  
  # Mapping from word to its numeric value
  value_map <- c(
    zero = 0, one = 1, two = 2, three = 3, four = 4,
    five = 5, six = 6, seven = 7, eight = 8, nine = 9
  )
  
  # Convert words to numeric values
  numeric_vals <- value_map[words]
  
  # Order the words based on the numeric values
  sorted_words <- words[order(numeric_vals)]
  
  # Reconstruct the sorted string
  paste(sorted_words, collapse = " ")
}
test_humaneval <- function() {
    candidate <- sort_numbers
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('three'), 'three')))
    stopifnot(isTRUE(all.equal(candidate('three five nine'), 'three five nine')))
    stopifnot(isTRUE(all.equal(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')))
    stopifnot(isTRUE(all.equal(candidate('six five four three two one zero'), 'zero one two three four five six')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183741
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Input is a space-delimited string of numberals from 'zero' to 'nine'.
# Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
# Return the string with numbers sorted from smallest to largest
# >>> sort_numbers('three one five')
# 'one three five'
# Sort a space‑delimited string of number words from smallest to largest.
# Example:
#   sort_numbers('three one five')  # returns 'one three five'
sort_numbers <- function(numbers) {
  # Return empty string unchanged
  if (nchar(numbers) == 0) return("")
  
  # Mapping of word to numeric value
  num_map <- c(
    zero   = 0, one   = 1, two   = 2, three = 3,
    four   = 4, five  = 5, six   = 6, seven = 7,
    eight  = 8, nine  = 9
  )
  
  # Split the input string into individual words
  words <- strsplit(numbers, "\\s+")[[1]]
  
  # Convert words to numeric values using the map
  nums <- num_map[words]
  
  # Handle potential missing words (just in case)
  if (any(is.na(nums))) {
    stop("Input contains invalid number words.")
  }
  
  # Order indices by numeric value
  order_idx <- order(nums)
  
  # Reorder words accordingly
  sorted_words <- words[order_idx]
  
  # Join back into a single string
  paste(sorted_words, collapse = " ")
}
test_humaneval <- function() {
    candidate <- sort_numbers
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('three'), 'three')))
    stopifnot(isTRUE(all.equal(candidate('three five nine'), 'three five nine')))
    stopifnot(isTRUE(all.equal(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')))
    stopifnot(isTRUE(all.equal(candidate('six five four three two one zero'), 'zero one two three four five six')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183741
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Input is a space-delimited string of numberals from 'zero' to 'nine'.
# Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
# Return the string with numbers sorted from smallest to largest
# >>> sort_numbers('three one five')
# 'one three five'
# Input is a space-delimited string of numberals from 'zero' to 'nine'.
# Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
# Return the string with numbers sorted from smallest to largest
# >>> sort_numbers('three one five')
# 'one three five'
sort_numbers <- function(numbers) {
  # Ordered list of number words
  word_order <- c('zero', 'one', 'two', 'three', 'four',
                  'five', 'six', 'seven', 'eight', 'nine')
  
  # Handle empty input
  if (nchar(numbers) == 0) return("")
  
  # Split the input string into individual words
  words_in <- strsplit(numbers, " ", fixed = TRUE)[[1]]
  
  # Order the words by their numeric value
  sorted_words <- words_in[order(match(words_in, word_order))]
  
  # Reassemble the sorted words into a single string
  paste(sorted_words, collapse = " ")
}
test_humaneval <- function() {
    candidate <- sort_numbers
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('three'), 'three')))
    stopifnot(isTRUE(all.equal(candidate('three five nine'), 'three five nine')))
    stopifnot(isTRUE(all.equal(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')))
    stopifnot(isTRUE(all.equal(candidate('six five four three two one zero'), 'zero one two three four five six')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183741
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Input is a space-delimited string of numberals from 'zero' to 'nine'.
# Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
# Return the string with numbers sorted from smallest to largest
# >>> sort_numbers('three one five')
# 'one three five'
# Input is a space-delimited string of numberals from 'zero' to 'nine'.
# Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
# Return the string with numbers sorted from smallest to largest
# >>> sort_numbers('three one five')
# 'one three five'
sort_numbers <- function(numbers) {
  # Define mapping from word to numeric value
  word_to_num <- setNames(0:9, c('zero', 'one', 'two', 'three', 'four',
                                 'five', 'six', 'seven', 'eight', 'nine'))
  
  # Trim whitespace and split the input string into individual words
  words <- strsplit(trimws(numbers), "\\s+")[[1]]
  
  # Handle empty input
  if (length(words) == 0 || words[1] == "") {
    return("")
  }
  
  # Convert words to numeric values
  nums <- word_to_num[words]
  
  # Order words by their numeric values
  sorted_words <- words[order(nums)]
  
  # Reconstruct the sorted string
  paste(sorted_words, collapse = " ")
}
test_humaneval <- function() {
    candidate <- sort_numbers
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('three'), 'three')))
    stopifnot(isTRUE(all.equal(candidate('three five nine'), 'three five nine')))
    stopifnot(isTRUE(all.equal(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')))
    stopifnot(isTRUE(all.equal(candidate('six five four three two one zero'), 'zero one two three four five six')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183741
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 20 (R) - HumanEval_20_find_closest_elements
================================================================================

PROMPT:
----------------------------------------
# From a supplied list of numbers (of length at least two) select and return two that are the closest to each
# other and return them in order (smaller number, larger number).
# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))
# c(2.0, 2.2)
# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))
# c(2.0, 2.0)

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- find_closest_elements
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2)), c(3.9, 4.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0)), c(5.0, 5.9))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2)), c(2.0, 2.2))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)), c(2.0, 2.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1)), c(2.2, 3.1))))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# From a supplied list of numbers (of length at least two) select and return two that are the closest to each
# other and return them in order (smaller number, larger number).
# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))
# c(2.0, 2.2)
# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))
# c(2.0, 2.0)
find_closest_elements <- function(numbers) {
  # Ensure the input has at least two elements
  if (length(numbers) < 2) {
    stop("Input vector must contain at least two numbers.")
  }

  # Sort the numbers to make pairwise comparison efficient
  sorted <- sort(numbers)

  # Compute differences between consecutive sorted elements
  diffs <- diff(sorted)

  # Find the index of the smallest difference
  idx <- which.min(diffs)

  # Return the pair in ascending order
  c(sorted[idx], sorted[idx + 1])
}
test_humaneval <- function() {
    candidate <- find_closest_elements
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2)), c(3.9, 4.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0)), c(5.0, 5.9))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2)), c(2.0, 2.2))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)), c(2.0, 2.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1)), c(2.2, 3.1))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183742
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# From a supplied list of numbers (of length at least two) select and return two that are the closest to each
# other and return them in order (smaller number, larger number).
# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))
# c(2.0, 2.2)
# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))
# c(2.0, 2.0)
# Find two numbers that are closest to each other in a numeric vector
# and return them in ascending order.
find_closest_elements <- function(numbers) {
  # Basic input checks
  if (!is.numeric(numbers)) {
    stop("Input must be a numeric vector.")
  }
  if (length(numbers) < 2) {
    stop("Input vector must contain at least two numbers.")
  }
  
  # Sort the numbers to make adjacent pairs the only candidates
  sorted_nums <- sort(numbers)
  
  # Compute absolute differences between consecutive elements
  diffs <- diff(sorted_nums)
  
  # Find the index of the smallest difference
  min_idx <- which.min(diffs)
  
  # Return the pair with the smallest difference, in ascending order
  return(c(sorted_nums[min_idx], sorted_nums[min_idx + 1]))
}
test_humaneval <- function() {
    candidate <- find_closest_elements
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2)), c(3.9, 4.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0)), c(5.0, 5.9))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2)), c(2.0, 2.2))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)), c(2.0, 2.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1)), c(2.2, 3.1))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183742
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# From a supplied list of numbers (of length at least two) select and return two that are the closest to each
# other and return them in order (smaller number, larger number).
# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))
# c(2.0, 2.2)
# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))
# c(2.0, 2.0)
find_closest_elements <- function(numbers) {
  # Ensure there are at least two numbers
  if (length(numbers) < 2) {
    stop("Input vector must contain at least two numbers.")
  }
  
  # Sort the numbers so that the closest pair must be adjacent
  sorted_nums <- sort(numbers)
  
  # Compute differences between consecutive elements
  diffs <- diff(sorted_nums)
  
  # Find the index of the smallest difference
  min_idx <- which.min(diffs)
  
  # Return the two numbers that are closest (already sorted)
  sorted_nums[c(min_idx, min_idx + 1)]
}
test_humaneval <- function() {
    candidate <- find_closest_elements
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2)), c(3.9, 4.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0)), c(5.0, 5.9))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2)), c(2.0, 2.2))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)), c(2.0, 2.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1)), c(2.2, 3.1))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183742
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# From a supplied list of numbers (of length at least two) select and return two that are the closest to each
# other and return them in order (smaller number, larger number).
# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))
# c(2.0, 2.2)
# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))
# c(2.0, 2.0)
find_closest_elements <- function(numbers) {
  if(length(numbers) < 2) {
    stop("At least two numbers are required")
  }
  # Sort the numbers so that the closest pair will be adjacent
  sorted <- sort(numbers)
  # Compute absolute differences between consecutive elements
  diffs <- abs(diff(sorted))
  # Find the index of the smallest difference
  min_idx <- which.min(diffs)
  # Return the pair in ascending order
  c(sorted[min_idx], sorted[min_idx + 1])
}
test_humaneval <- function() {
    candidate <- find_closest_elements
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2)), c(3.9, 4.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0)), c(5.0, 5.9))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2)), c(2.0, 2.2))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)), c(2.0, 2.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1)), c(2.2, 3.1))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183742
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 21 (R) - HumanEval_21_rescale_to_unit
================================================================================

PROMPT:
----------------------------------------
# Given list of numbers (of at least two elements), apply a linear transform to that list,
# such that the smallest number will become 0 and the largest will become 1
# >>> rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))
# c(0.0, 0.25, 0.5, 0.75, 1.0)

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- rescale_to_unit
    stopifnot(isTRUE(all.equal(candidate(c(2.0, 49.9)), c(0.0, 1.0))))
    stopifnot(isTRUE(all.equal(candidate(c(100.0, 49.9)), c(1.0, 0.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), c(0.0, 0.25, 0.5, 0.75, 1.0))))
    stopifnot(isTRUE(all.equal(candidate(c(2.0, 1.0, 5.0, 3.0, 4.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))
    stopifnot(isTRUE(all.equal(candidate(c(12.0, 11.0, 15.0, 13.0, 14.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given list of numbers (of at least two elements), apply a linear transform to that list,
# such that the smallest number will become 0 and the largest will become 1
# >>> rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))
# c(0.0, 0.25, 0.5, 0.75, 1.0)
# Given list of numbers (of at least two elements), apply a linear transform to that list,
# such that the smallest number will become 0 and the largest will become 1
# >>> rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))
# c(0.0, 0.25, 0.5, 0.75, 1.0)
rescale_to_unit <- function(numbers) {
  # Ensure input is numeric
  if (!is.numeric(numbers)) {
    stop("Input must be a numeric vector")
  }
  
  # Find minimum and maximum
  min_val <- min(numbers, na.rm = TRUE)
  max_val <- max(numbers, na.rm = TRUE)
  
  # If all values are identical, avoid division by zero
  if (identical(min_val, max_val)) {
    return(rep(0, length(numbers)))
  }
  
  # Apply linear transformation
  (numbers - min_val) / (max_val - min_val)
}
test_humaneval <- function() {
    candidate <- rescale_to_unit
    stopifnot(isTRUE(all.equal(candidate(c(2.0, 49.9)), c(0.0, 1.0))))
    stopifnot(isTRUE(all.equal(candidate(c(100.0, 49.9)), c(1.0, 0.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), c(0.0, 0.25, 0.5, 0.75, 1.0))))
    stopifnot(isTRUE(all.equal(candidate(c(2.0, 1.0, 5.0, 3.0, 4.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))
    stopifnot(isTRUE(all.equal(candidate(c(12.0, 11.0, 15.0, 13.0, 14.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183742
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given list of numbers (of at least two elements), apply a linear transform to that list,
# such that the smallest number will become 0 and the largest will become 1
# >>> rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))
# c(0.0, 0.25, 0.5, 0.75, 1.0)
rescale_to_unit <- function(numbers) {
  min_val <- min(numbers)
  max_val <- max(numbers)
  
  # Avoid division by zero when all numbers are equal
  if (max_val == min_val) {
    return(rep(0, length(numbers)))
  }
  
  (numbers - min_val) / (max_val - min_val)
}
test_humaneval <- function() {
    candidate <- rescale_to_unit
    stopifnot(isTRUE(all.equal(candidate(c(2.0, 49.9)), c(0.0, 1.0))))
    stopifnot(isTRUE(all.equal(candidate(c(100.0, 49.9)), c(1.0, 0.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), c(0.0, 0.25, 0.5, 0.75, 1.0))))
    stopifnot(isTRUE(all.equal(candidate(c(2.0, 1.0, 5.0, 3.0, 4.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))
    stopifnot(isTRUE(all.equal(candidate(c(12.0, 11.0, 15.0, 13.0, 14.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183742
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given list of numbers (of at least two elements), apply a linear transform to that list,
# such that the smallest number will become 0 and the largest will become 1
# >>> rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))
# c(0.0, 0.25, 0.5, 0.75, 1.0)
rescale_to_unit <- function(numbers) {
  # Ensure the input is numeric
  if (!is.numeric(numbers)) {
    stop("Input must be a numeric vector.")
  }
  
  min_val <- min(numbers)
  max_val <- max(numbers)
  range   <- max_val - min_val
  
  # If all numbers are identical, avoid division by zero
  if (range == 0) {
    return(rep(0, length(numbers)))
  }
  
  # Apply the linear transformation
  (numbers - min_val) / range
}
test_humaneval <- function() {
    candidate <- rescale_to_unit
    stopifnot(isTRUE(all.equal(candidate(c(2.0, 49.9)), c(0.0, 1.0))))
    stopifnot(isTRUE(all.equal(candidate(c(100.0, 49.9)), c(1.0, 0.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), c(0.0, 0.25, 0.5, 0.75, 1.0))))
    stopifnot(isTRUE(all.equal(candidate(c(2.0, 1.0, 5.0, 3.0, 4.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))
    stopifnot(isTRUE(all.equal(candidate(c(12.0, 11.0, 15.0, 13.0, 14.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183742
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given list of numbers (of at least two elements), apply a linear transform to that list,
# such that the smallest number will become 0 and the largest will become 1
# >>> rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))
# c(0.0, 0.25, 0.5, 0.75, 1.0)
rescale_to_unit <- function(numbers) {
  # Ensure the input is a numeric vector
  if (!is.numeric(numbers)) {
    stop("Input must be a numeric vector.")
  }

  # Compute the minimum and maximum values
  min_val <- min(numbers)
  max_val <- max(numbers)

  # If all values are identical, return a vector of zeros
  if (min_val == max_val) {
    return(rep(0, length(numbers)))
  }

  # Apply the linear transformation
  scaled <- (numbers - min_val) / (max_val - min_val)

  return(scaled)
}
test_humaneval <- function() {
    candidate <- rescale_to_unit
    stopifnot(isTRUE(all.equal(candidate(c(2.0, 49.9)), c(0.0, 1.0))))
    stopifnot(isTRUE(all.equal(candidate(c(100.0, 49.9)), c(1.0, 0.0))))
    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), c(0.0, 0.25, 0.5, 0.75, 1.0))))
    stopifnot(isTRUE(all.equal(candidate(c(2.0, 1.0, 5.0, 3.0, 4.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))
    stopifnot(isTRUE(all.equal(candidate(c(12.0, 11.0, 15.0, 13.0, 14.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183742
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 23 (R) - HumanEval_23_strlen
================================================================================

PROMPT:
----------------------------------------
# Return length of given string
# >>> strlen('')
# 0
# >>> strlen('abc')
# 3

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- strlen
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('x'), 1)))
    stopifnot(isTRUE(all.equal(candidate('asdasnakj'), 9)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Return length of given string
# >>> strlen('')
# 0
# >>> strlen('abc')
# 3
# Return length of given string
# >>> strlen('')
# 0
# >>> strlen('abc')
# 3
strlen <- function(string) {
  # Use nchar to compute the number of characters in the string
  nchar(string)
}
test_humaneval <- function() {
    candidate <- strlen
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('x'), 1)))
    stopifnot(isTRUE(all.equal(candidate('asdasnakj'), 9)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183744
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Return length of given string
# >>> strlen('')
# 0
# >>> strlen('abc')
# 3
# Return length of given string
# >>> strlen('')
# 0
# >>> strlen('abc')
# 3
strlen <- function(string) {
  nchar(string)
}
test_humaneval <- function() {
    candidate <- strlen
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('x'), 1)))
    stopifnot(isTRUE(all.equal(candidate('asdasnakj'), 9)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183744
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Return length of given string
# >>> strlen('')
# 0
# >>> strlen('abc')
# 3
# Return length of given string
# >>> strlen('')
# 0
# >>> strlen('abc')
# 3
strlen <- function(string) {
  # Use nchar to compute the number of characters in the string
  nchar(string)
}
test_humaneval <- function() {
    candidate <- strlen
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('x'), 1)))
    stopifnot(isTRUE(all.equal(candidate('asdasnakj'), 9)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183744
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Return length of given string
# >>> strlen('')
# 0
# >>> strlen('abc')
# 3
# Return length of given string
# >>> strlen('')
# 0
# >>> strlen('abc')
# 3
strlen <- function(string) {
  # nchar returns the number of characters in a string
  nchar(string)
}
test_humaneval <- function() {
    candidate <- strlen
    stopifnot(isTRUE(all.equal(candidate(''), 0)))
    stopifnot(isTRUE(all.equal(candidate('x'), 1)))
    stopifnot(isTRUE(all.equal(candidate('asdasnakj'), 9)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183744
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 24 (R) - HumanEval_24_largest_divisor
================================================================================

PROMPT:
----------------------------------------
# For a given number n, find the largest number that divides n evenly, smaller than n
# >>> largest_divisor(15)
# 5

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- largest_divisor
    stopifnot(isTRUE(all.equal(candidate(3), 1)))
    stopifnot(isTRUE(all.equal(candidate(7), 1)))
    stopifnot(isTRUE(all.equal(candidate(10), 5)))
    stopifnot(isTRUE(all.equal(candidate(100), 50)))
    stopifnot(isTRUE(all.equal(candidate(49), 7)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# For a given number n, find the largest number that divides n evenly, smaller than n
# >>> largest_divisor(15)
# 5
# For a given number n, find the largest number that divides n evenly, smaller than n
# >>> largest_divisor(15)
# [1] 5
largest_divisor <- function(n) {
  # Edge cases: n <= 1 has no proper divisor
  if (n <= 1) {
    return(NA)
  }
  
  # Start checking from the largest possible proper divisor (floor(n/2))
  for (i in seq(floor(n / 2), 1, by = -1)) {
    if (n %% i == 0) {
      return(i)
    }
  }
  
  # Fallback: 1 is always a divisor for n > 1
  return(1)
}
test_humaneval <- function() {
    candidate <- largest_divisor
    stopifnot(isTRUE(all.equal(candidate(3), 1)))
    stopifnot(isTRUE(all.equal(candidate(7), 1)))
    stopifnot(isTRUE(all.equal(candidate(10), 5)))
    stopifnot(isTRUE(all.equal(candidate(100), 50)))
    stopifnot(isTRUE(all.equal(candidate(49), 7)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183744
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# For a given number n, find the largest number that divides n evenly, smaller than n
# >>> largest_divisor(15)
# 5
# For a given number n, find the largest number that divides n evenly, smaller than n
# >>> largest_divisor(15)
# 5
largest_divisor <- function(n) {
  # Handle edge cases: if n is less than or equal to 1, there is no proper divisor
  if (n <= 1) {
    return(NA_integer_)
  }
  
  # Start from the largest possible divisor smaller than n
  # which is floor(n/2), and go downwards
  for (i in seq(floor(n / 2), 1, by = -1)) {
    if (n %% i == 0) {
      return(i)
    }
  }
  
  # If no divisor found (shouldn't happen for n > 1), return NA
  return(NA_integer_)
}
test_humaneval <- function() {
    candidate <- largest_divisor
    stopifnot(isTRUE(all.equal(candidate(3), 1)))
    stopifnot(isTRUE(all.equal(candidate(7), 1)))
    stopifnot(isTRUE(all.equal(candidate(10), 5)))
    stopifnot(isTRUE(all.equal(candidate(100), 50)))
    stopifnot(isTRUE(all.equal(candidate(49), 7)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183744
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# For a given number n, find the largest number that divides n evenly, smaller than n
# >>> largest_divisor(15)
# 5
# For a given number n, find the largest number that divides n evenly, smaller than n
# >>> largest_divisor(15)
# 5
largest_divisor <- function(n) {
  # Basic input checks
  if (!is.numeric(n) || length(n) != 1) {
    stop("n must be a single numeric value")
  }
  if (n <= 1) {
    return(NA)   # No proper divisor exists for n <= 1
  }
  
  # Search from the largest possible divisor downwards
  for (i in floor(n / 2):1) {
    if (n %% i == 0) {
      return(i)
    }
  }
  
  # Should never reach here for n > 1, but return NA just in case
  return(NA)
}
test_humaneval <- function() {
    candidate <- largest_divisor
    stopifnot(isTRUE(all.equal(candidate(3), 1)))
    stopifnot(isTRUE(all.equal(candidate(7), 1)))
    stopifnot(isTRUE(all.equal(candidate(10), 5)))
    stopifnot(isTRUE(all.equal(candidate(100), 50)))
    stopifnot(isTRUE(all.equal(candidate(49), 7)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183744
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# For a given number n, find the largest number that divides n evenly, smaller than n
# >>> largest_divisor(15)
# 5
# For a given number n, find the largest number that divides n evenly, smaller than n
# >>> largest_divisor(15)
# 5
largest_divisor <- function(n) {
  # Basic input validation
  if (!is.numeric(n) || length(n) != 1 || floor(n) != n || n <= 1) {
    stop("n must be a positive integer greater than 1")
  }

  # Scan from floor(n/2) down to 1
  for (i in floor(n/2):1) {
    if (n %% i == 0) {
      return(i)
    }
  }

  # In theory we should never reach here because 1 always divides n,
  # but return NA for completeness.
  return(NA)
}
test_humaneval <- function() {
    candidate <- largest_divisor
    stopifnot(isTRUE(all.equal(candidate(3), 1)))
    stopifnot(isTRUE(all.equal(candidate(7), 1)))
    stopifnot(isTRUE(all.equal(candidate(10), 5)))
    stopifnot(isTRUE(all.equal(candidate(100), 50)))
    stopifnot(isTRUE(all.equal(candidate(49), 7)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183744
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 25 (R) - HumanEval_25_factorize
================================================================================

PROMPT:
----------------------------------------
# Return list of prime factors of given integer in the order from smallest to largest.
# Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
# Input number should be equal to the product of all factors
# >>> factorize(8)
# c(2, 2, 2)
# >>> factorize(25)
# c(5, 5)
# >>> factorize(70)
# c(2, 5, 7)

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- factorize
    stopifnot(isTRUE(all.equal(candidate(2), c(2))))
    stopifnot(isTRUE(all.equal(candidate(4), c(2, 2))))
    stopifnot(isTRUE(all.equal(candidate(8), c(2, 2, 2))))
    stopifnot(isTRUE(all.equal(candidate(57), c(3, 19))))
    stopifnot(isTRUE(all.equal(candidate(3249), c(3, 3, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(185193), c(3, 3, 3, 19, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(20577), c(3, 19, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 3))))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Return list of prime factors of given integer in the order from smallest to largest.
# Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
# Input number should be equal to the product of all factors
# >>> factorize(8)
# c(2, 2, 2)
# >>> factorize(25)
# c(5, 5)
# >>> factorize(70)
# c(2, 5, 7)
# Return list of prime factors of given integer in the order from smallest to largest.
# Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
# Input number should be equal to the product of all factors
# >>> factorize(8)
# c(2, 2, 2)
# >>> factorize(25)
# c(5, 5)
# >>> factorize(70)
# c(2, 5, 7)
factorize <- function(n) {
  # Basic sanity checks
  if (!is.numeric(n) || length(n) != 1 || n <= 0 || floor(n) != n) {
    stop("`n` must be a single positive integer")
  }

  factors <- integer(0)   # vector to collect prime factors
  i <- 2L                 # start checking from the smallest prime

  while (i * i <= n) {
    while (n %% i == 0) {
      factors <- c(factors, i)
      n <- n / i
    }
    i <- i + 1L
  }

  # If n is still greater than 1, it is a prime factor itself
  if (n > 1) {
    factors <- c(factors, n)
  }

  return(factors)
}
test_humaneval <- function() {
    candidate <- factorize
    stopifnot(isTRUE(all.equal(candidate(2), c(2))))
    stopifnot(isTRUE(all.equal(candidate(4), c(2, 2))))
    stopifnot(isTRUE(all.equal(candidate(8), c(2, 2, 2))))
    stopifnot(isTRUE(all.equal(candidate(57), c(3, 19))))
    stopifnot(isTRUE(all.equal(candidate(3249), c(3, 3, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(185193), c(3, 3, 3, 19, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(20577), c(3, 19, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 3))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183745
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Return list of prime factors of given integer in the order from smallest to largest.
# Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
# Input number should be equal to the product of all factors
# >>> factorize(8)
# c(2, 2, 2)
# >>> factorize(25)
# c(5, 5)
# >>> factorize(70)
# c(2, 5, 7)
# Return list of prime factors of given integer in the order from smallest to largest.
# Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
# Input number should be equal to the product of all factors
# >>> factorize(8)
# c(2, 2, 2)
# >>> factorize(25)
# c(5, 5)
# >>> factorize(70)
# c(2, 5, 7)
factorize <- function(n) {
  # Handle trivial cases
  if (n <= 1) {
    return(numeric(0))
  }
  
  factors <- numeric()
  i <- 2
  # Trial division up to sqrt(n)
  while (i * i <= n) {
    while (n %% i == 0) {
      factors <- c(factors, i)
      n <- n / i
    }
    i <- i + 1
  }
  # If n is now > 1, it is a prime factor larger than sqrt(original n)
  if (n > 1) {
    factors <- c(factors, n)
  }
  return(factors)
}
test_humaneval <- function() {
    candidate <- factorize
    stopifnot(isTRUE(all.equal(candidate(2), c(2))))
    stopifnot(isTRUE(all.equal(candidate(4), c(2, 2))))
    stopifnot(isTRUE(all.equal(candidate(8), c(2, 2, 2))))
    stopifnot(isTRUE(all.equal(candidate(57), c(3, 19))))
    stopifnot(isTRUE(all.equal(candidate(3249), c(3, 3, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(185193), c(3, 3, 3, 19, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(20577), c(3, 19, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 3))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183745
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Return list of prime factors of given integer in the order from smallest to largest.
# Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
# Input number should be equal to the product of all factors
# >>> factorize(8)
# c(2, 2, 2)
# >>> factorize(25)
# c(5, 5)
# >>> factorize(70)
# c(2, 5, 7)
# Return list of prime factors of given integer in the order from smallest to largest.
# Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
# Input number should be equal to the product of all factors
# >>> factorize(8)
# c(2, 2, 2)
# >>> factorize(25)
# c(5, 5)
# >>> factorize(70)
# c(2, 5, 7)
factorize <- function(n) {
  # Basic checks
  if (!is.numeric(n) || length(n) != 1 || n < 2 || n != as.integer(n)) {
    stop("n must be an integer greater than or equal to 2")
  }
  n <- as.integer(n)
  factors <- integer(0)

  # Extract factor 2
  while (n %% 2 == 0) {
    factors <- c(factors, 2)
    n <- n %/% 2
  }

  # Extract odd factors
  i <- 3
  while (i * i <= n) {
    while (n %% i == 0) {
      factors <- c(factors, i)
      n <- n %/% i
    }
    i <- i + 2
  }

  # If remaining n is a prime > 2
  if (n > 1) {
    factors <- c(factors, n)
  }

  return(factors)
}
test_humaneval <- function() {
    candidate <- factorize
    stopifnot(isTRUE(all.equal(candidate(2), c(2))))
    stopifnot(isTRUE(all.equal(candidate(4), c(2, 2))))
    stopifnot(isTRUE(all.equal(candidate(8), c(2, 2, 2))))
    stopifnot(isTRUE(all.equal(candidate(57), c(3, 19))))
    stopifnot(isTRUE(all.equal(candidate(3249), c(3, 3, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(185193), c(3, 3, 3, 19, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(20577), c(3, 19, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 3))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183745
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Return list of prime factors of given integer in the order from smallest to largest.
# Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
# Input number should be equal to the product of all factors
# >>> factorize(8)
# c(2, 2, 2)
# >>> factorize(25)
# c(5, 5)
# >>> factorize(70)
# c(2, 5, 7)
# Return list of prime factors of given integer in the order from smallest to largest.
# Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
# Input number should be equal to the product of all factors
# >>> factorize(8)
# c(2, 2, 2)
# >>> factorize(25)
# c(5, 5)
# >>> factorize(70)
# c(2, 5, 7)
factorize <- function(n) {
  # Handle non‑positive inputs
  if (!is.numeric(n) || length(n) != 1 || n <= 0) {
    stop("Input must be a positive integer.")
  }
  n <- as.integer(n)
  
  # Special case: 1 has no prime factors
  if (n == 1) {
    return(numeric(0))
  }
  
  factors <- integer(0)
  divisor <- 2
  # Factor out all 2s first for speed
  while (n %% divisor == 0) {
    factors <- c(factors, divisor)
    n <- n / divisor
  }
  # Now test odd divisors up to sqrt(n)
  divisor <- 3
  while (divisor * divisor <= n) {
    while (n %% divisor == 0) {
      factors <- c(factors, divisor)
      n <- n / divisor
    }
    divisor <- divisor + 2
  }
  # If n > 1, it is a prime factor itself
  if (n > 1) {
    factors <- c(factors, n)
  }
  return(factors)
}
test_humaneval <- function() {
    candidate <- factorize
    stopifnot(isTRUE(all.equal(candidate(2), c(2))))
    stopifnot(isTRUE(all.equal(candidate(4), c(2, 2))))
    stopifnot(isTRUE(all.equal(candidate(8), c(2, 2, 2))))
    stopifnot(isTRUE(all.equal(candidate(57), c(3, 19))))
    stopifnot(isTRUE(all.equal(candidate(3249), c(3, 3, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(185193), c(3, 3, 3, 19, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(20577), c(3, 19, 19, 19))))
    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 3))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183745
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 26 (R) - HumanEval_26_remove_duplicates
================================================================================

PROMPT:
----------------------------------------
# From a list of integers, remove all elements that occur more than once.
# Keep order of elements left the same as in the input.
# >>> remove_duplicates(c(1, 2, 3, 2, 4))
# c(1, 3, 4)

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- remove_duplicates
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 4, 3, 5)), c(1, 4, 5))))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# From a list of integers, remove all elements that occur more than once.
# Keep order of elements left the same as in the input.
# >>> remove_duplicates(c(1, 2, 3, 2, 4))
# c(1, 3, 4)
# From a list of integers, remove all elements that occur more than once.
# Keep order of elements left the same as in the input.
# >>> remove_duplicates(c(1, 2, 3, 2, 4))
# c(1, 3, 4)
remove_duplicates <- function(numbers) {
  # Count how many times each value appears
  freq <- table(numbers)
  
  # Keep only those values that appear exactly once
  uniq_vals <- as.numeric(names(freq[freq == 1]))
  
  # Preserve the original order by subsetting with the unique values
  numbers[numbers %in% uniq_vals]
}
test_humaneval <- function() {
    candidate <- remove_duplicates
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 4, 3, 5)), c(1, 4, 5))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183745
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# From a list of integers, remove all elements that occur more than once.
# Keep order of elements left the same as in the input.
# >>> remove_duplicates(c(1, 2, 3, 2, 4))
# c(1, 3, 4)
# From a list of integers, remove all elements that occur more than once.
# Keep order of elements left the same as in the input.
# >>> remove_duplicates(c(1, 2, 3, 2, 4))
# c(1, 3, 4)
remove_duplicates <- function(numbers) {
  # Return the vector containing only elements that appear exactly once.
  # We use duplicated() twice: once from the left and once from the right.
  # An element is kept only if it is not duplicated in either direction.
  numbers[!duplicated(numbers) & !duplicated(numbers, fromLast = TRUE)]
}
test_humaneval <- function() {
    candidate <- remove_duplicates
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 4, 3, 5)), c(1, 4, 5))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183745
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# From a list of integers, remove all elements that occur more than once.
# Keep order of elements left the same as in the input.
# >>> remove_duplicates(c(1, 2, 3, 2, 4))
# c(1, 3, 4)
# From a list of integers, remove all elements that occur more than once.
# Keep order of elements left the same as in the input.
# >>> remove_duplicates(c(1, 2, 3, 2, 4))
# c(1, 3, 4)
remove_duplicates <- function(numbers) {
  # Keep only those elements that are not duplicated in either direction
  numbers[!duplicated(numbers) & !duplicated(numbers, fromLast = TRUE)]
}
test_humaneval <- function() {
    candidate <- remove_duplicates
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 4, 3, 5)), c(1, 4, 5))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183745
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# From a list of integers, remove all elements that occur more than once.
# Keep order of elements left the same as in the input.
# >>> remove_duplicates(c(1, 2, 3, 2, 4))
# c(1, 3, 4)
# From a list of integers, remove all elements that occur more than once.
# Keep order of elements left the same as in the input.
# >>> remove_duplicates(c(1, 2, 3, 2, 4))
# c(1, 3, 4)
remove_duplicates <- function(numbers) {
  # Count how many times each number appears
  counts <- table(numbers)
  
  # Identify the values that occur exactly once
  unique_vals <- as.numeric(names(counts[counts == 1]))
  
  # Return only those numbers, keeping original order
  numbers[numbers %in% unique_vals]
}
test_humaneval <- function() {
    candidate <- remove_duplicates
    stopifnot(isTRUE(all.equal(candidate(c()), c())))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))
    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 4, 3, 5)), c(1, 4, 5))))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183745
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 27 (R) - HumanEval_27_flip_case
================================================================================

PROMPT:
----------------------------------------
# For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
# >>> flip_case('Hello')
# 'hELLO'

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- flip_case
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('Hello!'), 'hELLO!')))
    stopifnot(isTRUE(all.equal(candidate('These violent delights have violent ends'), 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS')))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
# >>> flip_case('Hello')
# 'hELLO'
# For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
# >>> flip_case('Hello')
# 'hELLO'
flip_case <- function(string) {
  # Use chartr to swap case for all alphabetic characters
  # The first argument lists all lowercase letters followed by all uppercase letters
  # The second argument lists the corresponding uppercase letters followed by lowercase letters
  chartr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
         string)
}
test_humaneval <- function() {
    candidate <- flip_case
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('Hello!'), 'hELLO!')))
    stopifnot(isTRUE(all.equal(candidate('These violent delights have violent ends'), 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183746
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
# >>> flip_case('Hello')
# 'hELLO'
# For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
# >>> flip_case('Hello')
# 'hELLO'
flip_case <- function(string) {
  # Use chartr to swap all lower‑case letters with upper‑case letters
  # and vice versa in one go.
  chartr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
         string)
}
test_humaneval <- function() {
    candidate <- flip_case
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('Hello!'), 'hELLO!')))
    stopifnot(isTRUE(all.equal(candidate('These violent delights have violent ends'), 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183746
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
# >>> flip_case('Hello')
# 'hELLO'
# For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
# >>> flip_case('Hello')
# 'hELLO'
flip_case <- function(string) {
  # Ensure we have a single character string
  if (!is.character(string) || length(string) != 1) {
    stop("Input must be a single string.")
  }
  
  # Use chartr to swap the case of each alphabetic character
  chartr(
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    string
  )
}
test_humaneval <- function() {
    candidate <- flip_case
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('Hello!'), 'hELLO!')))
    stopifnot(isTRUE(all.equal(candidate('These violent delights have violent ends'), 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183746
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
# >>> flip_case('Hello')
# 'hELLO'
flip_case <- function(string) {
  # Flip the case of every alphabetic character in the string.
  # Non‑alphabetic characters are left unchanged.
  chartr("a-zA-Z", "A-Za-z", string)
}
test_humaneval <- function() {
    candidate <- flip_case
    stopifnot(isTRUE(all.equal(candidate(''), '')))
    stopifnot(isTRUE(all.equal(candidate('Hello!'), 'hELLO!')))
    stopifnot(isTRUE(all.equal(candidate('These violent delights have violent ends'), 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183746
STDOUT: (empty)
STDERR: (empty)
--------------------
