As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 9 (RKT) - HumanEval_9_rolling_max
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; From a given list of integers, generate a list of rolling maximum element found until given moment
;; in the sequence.
;; >>> (rolling_max (list 1 2 3 2 3 4 2))
;; (list 1 2 3 3 3 4 4)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rolling_max))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)
    (check-within (candidate (list 4 3 2 1)) (list 4 4 4 4) 0.001)
    (check-within (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; From a given list of integers, generate a list of rolling maximum element found until given moment
;; in the sequence.
;; >>> (rolling_max (list 1 2 3 2 3 4 2))
;; (list 1 2 3 3 3 4 4)

;; From a given list of integers, generate a list of rolling maximum element found until given moment
;; in the sequence.
;; >>> (rolling_max (list 1 2 3 2 3 4 2))
;; (list 1 2 3 3 3 4 4)
(define (rolling_max numbers)
  (if (null? numbers)
      '()
      ;; Helper that walks the list keeping the current maximum.
      (let loop ((rest (cdr numbers))
                 (curr (car numbers)))
        (if (null? rest)
            '()
            (cons curr (loop (cdr rest) (max curr (car rest))))))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rolling_max))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)
    (check-within (candidate (list 4 3 2 1)) (list 4 4 4 4) 0.001)
    (check-within (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: Exception
Timestamp: 1755183823
STDOUT: (empty)
STDERR:
--------------------
FAILURE
name:       check-within
location:   /tmp/tmpnhd667pp.rkt:27:4
actual:     '(1 2 3)
expected:   '(1 2 3 4)
--------------------
--------------------
FAILURE
name:       check-within
location:   /tmp/tmpnhd667pp.rkt:28:4
actual:     '(4 4 4)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-within
location:   /tmp/tmpnhd667pp.rkt:29:4
actual:     '(3 3 3 100)
expected:   '(3 3 3 100 100)
--------------------
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; From a given list of integers, generate a list of rolling maximum element found until given moment
;; in the sequence.
;; >>> (rolling_max (list 1 2 3 2 3 4 2))
;; (list 1 2 3 3 3 4 4)

;; From a given list of integers, generate a list of rolling maximum element found until given moment
;; in the sequence.
;; >>> (rolling_max (list 1 2 3 2 3 4 2))
;; (list 1 2 3 3 3 4 4)

(define (rolling_max numbers)
  ;; Helper that walks through the list, keeping the current maximum
  ;; and accumulating the running‑maximum list in reverse order.
  (define (iter lst current-max acc)
    (if (null? lst)
        (reverse acc)                     ; finished – reverse the accumulator
        (let* ([x (car lst)]
               [new-max (if (> x current-max) x current-max)])
          (iter (cdr lst) new-max (cons new-max acc)))))

  ;; Handle the empty list case first
  (if (null? numbers)
      '()
      (iter (cdr numbers)          ; start from the second element
            (car numbers)          ; first element is the initial max
            (list (car numbers))))) ; accumulator starts with the first max
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rolling_max))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)
    (check-within (candidate (list 4 3 2 1)) (list 4 4 4 4) 0.001)
    (check-within (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183823
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; From a given list of integers, generate a list of rolling maximum element found until given moment
;; in the sequence.
;; >>> (rolling_max (list 1 2 3 2 3 4 2))
;; (list 1 2 3 3 3 4 4)

;; From a given list of integers, generate a list of rolling maximum element found until given moment
;; in the sequence.
;; >>> (rolling_max (list 1 2 3 2 3 4 2))
;; (list 1 2 3 3 3 4 4)
(define (rolling_max numbers)
  (if (null? numbers)
      '()
      (let loop ((rest (cdr numbers))
                 (current-max (car numbers))
                 (acc (list (car numbers))))
        (if (null? rest)
            (reverse acc)
            (let* ((x (car rest))
                   (new-max (max current-max x)))
              (loop (cdr rest) new-max (cons new-max acc)))))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rolling_max))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)
    (check-within (candidate (list 4 3 2 1)) (list 4 4 4 4) 0.001)
    (check-within (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183823
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; From a given list of integers, generate a list of rolling maximum element found until given moment
;; in the sequence.
;; >>> (rolling_max (list 1 2 3 2 3 4 2))
;; (list 1 2 3 3 3 4 4)

;; From a given list of integers, generate a list of rolling maximum element found until given moment
;; in the sequence.
;; >>> (rolling_max (list 1 2 3 2 3 4 2))
;; (list 1 2 3 3 3 4 4)
(define (rolling_max numbers)
  ;; Helper that walks through the list, keeping the current maximum
  ;; and accumulating the result in reverse order.
  (define (helper lst current-max acc)
    (if (null? lst)
        (reverse acc)                     ; finished – reverse to restore order
        (let* ([next (car lst)]
               [new-max (if (> next current-max) next current-max)])
          (helper (cdr lst) new-max (cons new-max acc)))))
  ;; Handle the empty list separately.
  (if (null? numbers)
      '()
      (helper (cdr numbers) (car numbers) (list (car numbers)))))   ; start with first element
(require rackunit)

(define (test-humaneval) 

  (let (( candidate rolling_max))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)
    (check-within (candidate (list 4 3 2 1)) (list 4 4 4 4) 0.001)
    (check-within (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183823
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 11 (RKT) - HumanEval_11_string_xor
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-within (candidate "111000" "101010") "010010" 0.001)
    (check-within (candidate "1" "1") "0" 0.001)
    (check-within (candidate "0101" "0000") "0101" 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"

(define (string_xor a b)
  ;; Ensure both strings have the same length
  (unless (= (string-length a) (string-length b))
    (error 'string_xor "Input strings must be of equal length"))
  (define n (string-length a))
  (define res (make-string n))
  (for ([i (in-range n)])
    (define ca (string-ref a i))
    (define cb (string-ref b i))
    (string-set! res i (if (char=? ca cb) #\0 #\1)))
  res)
(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-within (candidate "111000" "101010") "010010" 0.001)
    (check-within (candidate "1" "1") "0" 0.001)
    (check-within (candidate "0101" "0000") "0101" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183825
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (define len (string-length a))
  (define (xor-char i)
    (if (char=? (string-ref a i) (string-ref b i))
        #\0
        #\1))
  (list->string (for/list ([i (in-range len)])
                  (xor-char i))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-within (candidate "111000" "101010") "010010" 0.001)
    (check-within (candidate "1" "1") "0" 0.001)
    (check-within (candidate "0101" "0000") "0101" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183825
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (let ([len (string-length a)])
    (build-string len
      (lambda (i)
        (let ([ca (string-ref a i)]
              [cb (string-ref b i)])
          (if (char=? ca cb) #\0 #\1))))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-within (candidate "111000" "101010") "010010" 0.001)
    (check-within (candidate "1" "1") "0" 0.001)
    (check-within (candidate "0101" "0000") "0101" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183825
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  ;; string-map can take multiple strings; the lambda receives a char
  ;; from each string.  If the chars are equal we output #\0, otherwise #\1.
  (string-map (lambda (c1 c2)
                (if (char=? c1 c2) #\0 #\1))
              a b))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-within (candidate "111000" "101010") "010010" 0.001)
    (check-within (candidate "1" "1") "0" 0.001)
    (check-within (candidate "0101" "0000") "0101" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183825
STDOUT: (empty)
STDERR:
/tmp/tmpu8b02aiz.rkt:15:3: string-map: unbound identifier
  in: string-map
  location...:
   /tmp/tmpu8b02aiz.rkt:15:3
--------------------

================================================================================
PROBLEM 13 (RKT) - HumanEval_13_greatest_common_divisor
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Return a greatest common divisor of two integers a and b
;; >>> (greatest_common_divisor 3 5)
;; 1
;; >>> (greatest_common_divisor 25 15)
;; 5

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate greatest_common_divisor))
    (check-within (candidate 3 7) 1 0.001)
    (check-within (candidate 10 15) 5 0.001)
    (check-within (candidate 49 14) 7 0.001)
    (check-within (candidate 144 60) 12 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Return a greatest common divisor of two integers a and b
;; >>> (greatest_common_divisor 3 5)
;; 1
;; >>> (greatest_common_divisor 25 15)
;; 5

;; Return a greatest common divisor of two integers a and b
;; >>> (greatest_common_divisor 3 5)
;; 1
;; >>> (greatest_common_divisor 25 15)
;; 5
(define (greatest_common_divisor a b)
  (define (gcd-aux x y)
    (if (= y 0)
        (abs x)               ; ensure a positive result
        (gcd-aux y (modulo x y))))
  (gcd-aux a b))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate greatest_common_divisor))
    (check-within (candidate 3 7) 1 0.001)
    (check-within (candidate 10 15) 5 0.001)
    (check-within (candidate 49 14) 7 0.001)
    (check-within (candidate 144 60) 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183827
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Return a greatest common divisor of two integers a and b
;; >>> (greatest_common_divisor 3 5)
;; 1
;; >>> (greatest_common_divisor 25 15)
;; 5
(define (greatest_common_divisor a b)
  ;; Euclidean algorithm: gcd(a, b) = gcd(b, a mod b)
  (if (= b 0)
      (abs a)          ; return the absolute value of a as the GCD
      (greatest_common_divisor b (mod a b))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate greatest_common_divisor))
    (check-within (candidate 3 7) 1 0.001)
    (check-within (candidate 10 15) 5 0.001)
    (check-within (candidate 49 14) 7 0.001)
    (check-within (candidate 144 60) 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183826
STDOUT: (empty)
STDERR:
/tmp/tmpinj3yb51.rkt:12:34: mod: unbound identifier
  in: mod
  location...:
   /tmp/tmpinj3yb51.rkt:12:34
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Return a greatest common divisor of two integers a and b
;; >>> (greatest_common_divisor 3 5)
;; 1
;; >>> (greatest_common_divisor 25 15)
;; 5

;; Return a greatest common divisor of two integers a and b
;; >>> (greatest_common_divisor 3 5)
;; 1
;; >>> (greatest_common_divisor 25 15)
;; 5
(define (greatest_common_divisor a b)
  ;; Ensure we work with non‑negative numbers
  (define (abs-val x) (if (< x 0) (- x) x))
  (let loop ((x (abs-val a)) (y (abs-val b)))
    (if (= y 0)
        x
        (loop y (modulo x y)))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate greatest_common_divisor))
    (check-within (candidate 3 7) 1 0.001)
    (check-within (candidate 10 15) 5 0.001)
    (check-within (candidate 49 14) 7 0.001)
    (check-within (candidate 144 60) 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183827
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Return a greatest common divisor of two integers a and b
;; >>> (greatest_common_divisor 3 5)
;; 1
;; >>> (greatest_common_divisor 25 15)
;; 5

;; Return a greatest common divisor of two integers a and b
;; >>> (greatest_common_divisor 3 5)
;; 1
;; >>> (greatest_common_divisor 25 15)
;; 5
(define (greatest_common_divisor a b)
  ;; Ensure we work with non‑negative values
  (let ([a (abs a)]
        [b (abs b)])
    (cond
      [(zero? b) a]            ; base case: gcd(a,0) = a
      [else (greatest_common_divisor b (modulo a b))])))

;; Example usage
(displayln (greatest_common_divisor 3 5))   ; → 1
(displayln (greatest_common_divisor 25 15)) ; → 5
(require rackunit)

(define (test-humaneval) 

  (let (( candidate greatest_common_divisor))
    (check-within (candidate 3 7) 1 0.001)
    (check-within (candidate 10 15) 5 0.001)
    (check-within (candidate 49 14) 7 0.001)
    (check-within (candidate 144 60) 12 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183827
STDOUT:
1
5
STDERR: (empty)
--------------------

================================================================================
PROBLEM 15 (RKT) - HumanEval_15_string_sequence
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Return a string containing space-delimited numbers starting from 0 upto n inclusive.
;; >>> (string_sequence 0)
;; "0"
;; >>> (string_sequence 5)
;; "0 1 2 3 4 5"

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_sequence))
    (check-within (candidate 0) "0" 0.001)
    (check-within (candidate 3) "0 1 2 3" 0.001)
    (check-within (candidate 10) "0 1 2 3 4 5 6 7 8 9 10" 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Return a string containing space-delimited numbers starting from 0 upto n inclusive.
;; >>> (string_sequence 0)
;; "0"
;; >>> (string_sequence 5)
;; "0 1 2 3 4 5"

;; Return a string containing space-delimited numbers starting from 0 upto n inclusive.
;; >>> (string_sequence 0)
;; "0"
;; >>> (string_sequence 5)
;; "0 1 2 3 4 5"
(define (string_sequence n)
  (string-join
   (map number->string (iota (add1 n)))  ; generate list 0 .. n
   " "))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_sequence))
    (check-within (candidate 0) "0" 0.001)
    (check-within (candidate 3) "0 1 2 3" 0.001)
    (check-within (candidate 10) "0 1 2 3 4 5 6 7 8 9 10" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183828
STDOUT: (empty)
STDERR:
/tmp/tmpb02vhfps.rkt:16:24: iota: unbound identifier
  in: iota
  location...:
   /tmp/tmpb02vhfps.rkt:16:24
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Return a string containing space-delimited numbers starting from 0 upto n inclusive.
;; >>> (string_sequence 0)
;; "0"
;; >>> (string_sequence 5)
;; "0 1 2 3 4 5"

;; Return a string containing space-delimited numbers starting from 0 up to n inclusive.
;; >>> (string_sequence 0)
;; "0"
;; >>> (string_sequence 5)
;; "0 1 2 3 4 5"
(define (string_sequence n)
  (string-join
   (map number->string (range 0 (+ n 1)))
   " "))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_sequence))
    (check-within (candidate 0) "0" 0.001)
    (check-within (candidate 3) "0 1 2 3" 0.001)
    (check-within (candidate 10) "0 1 2 3 4 5 6 7 8 9 10" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183828
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Return a string containing space-delimited numbers starting from 0 upto n inclusive.
;; >>> (string_sequence 0)
;; "0"
;; >>> (string_sequence 5)
;; "0 1 2 3 4 5"

;; Return a string containing space-delimited numbers starting from 0 upto n inclusive.
;; >>> (string_sequence 0)
;; "0"
;; >>> (string_sequence 5)
;; "0 1 2 3 4 5"
(define (string_sequence n)
  (string-join
   (map number->string (range 0 (add1 n)))
   " "))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_sequence))
    (check-within (candidate 0) "0" 0.001)
    (check-within (candidate 3) "0 1 2 3" 0.001)
    (check-within (candidate 10) "0 1 2 3 4 5 6 7 8 9 10" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183828
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Return a string containing space-delimited numbers starting from 0 upto n inclusive.
;; >>> (string_sequence 0)
;; "0"
;; >>> (string_sequence 5)
;; "0 1 2 3 4 5"

;; Return a string containing space-delimited numbers starting from 0 upto n inclusive.
;; >>> (string_sequence 0)
;; "0"
;; >>> (string_sequence 5)
;; "0 1 2 3 4 5"
(define (string_sequence n)
  (string-join
   (map number->string (range 0 (add1 n)))
   " "))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_sequence))
    (check-within (candidate 0) "0" 0.001)
    (check-within (candidate 3) "0 1 2 3" 0.001)
    (check-within (candidate 10) "0 1 2 3 4 5 6 7 8 9 10" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183828
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 19 (RKT) - HumanEval_19_sort_numbers
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Input is a space-delimited string of numberals from 'zero' to 'nine'.
;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
;; Return the string with numbers sorted from smallest to largest
;; >>> (sort_numbers "three one five")
;; "one three five"

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_numbers))
    (check-within (candidate "") "" 0.001)
    (check-within (candidate "three") "three" 0.001)
    (check-within (candidate "three five nine") "three five nine" 0.001)
    (check-within (candidate "five zero four seven nine eight") "zero four five seven eight nine" 0.001)
    (check-within (candidate "six five four three two one zero") "zero one two three four five six" 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Input is a space-delimited string of numberals from 'zero' to 'nine'.
;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
;; Return the string with numbers sorted from smallest to largest
;; >>> (sort_numbers "three one five")
;; "one three five"

(require racket/string racket/list)

;; Input is a space-delimited string of numberals from 'zero' to 'nine'.
;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six',
;; 'seven', 'eight' and 'nine'.
;; Return the string with numbers sorted from smallest to largest
;; >>> (sort_numbers "three one five")
;; "one three five"
(define (sort_numbers numbers)
  ;; Split the input string into a list of words
  (define words (string-split numbers))

  ;; Mapping from word → numeric value
  (define word->num
    (hash
     "zero"   0
     "one"    1
     "two"    2
     "three"  3
     "four"   4
     "five"   5
     "six"    6
     "seven"  7
     "eight"  8
     "nine"   9))

  ;; Mapping from numeric value → word
  (define num->word
    (vector "zero" "one" "two" "three" "four" "five"
            "six" "seven" "eight" "nine"))

  ;; Convert words to numbers
  (define nums
    (map (lambda (w) (hash-ref word->num w))
         words))

  ;; Sort the numeric list
  (define sorted-nums (sort nums <))

  ;; Convert back to words
  (define sorted-words
    (map (lambda (n) (vector-ref num->word n))
         sorted-nums))

  ;; Join back into a string
  (string-join sorted-words " "))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_numbers))
    (check-within (candidate "") "" 0.001)
    (check-within (candidate "three") "three" 0.001)
    (check-within (candidate "three five nine") "three five nine" 0.001)
    (check-within (candidate "five zero four seven nine eight") "zero four five seven eight nine" 0.001)
    (check-within (candidate "six five four three two one zero") "zero one two three four five six" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183832
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Input is a space-delimited string of numberals from 'zero' to 'nine'.
;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
;; Return the string with numbers sorted from smallest to largest
;; >>> (sort_numbers "three one five")
;; "one three five"

;; Mapping from number words to their numeric values
(define number->value
  (hash "zero" 0
        "one" 1
        "two" 2
        "three" 3
        "four" 4
        "five" 5
        "six" 6
        "seven" 7
        "eight" 8
        "nine" 9))

;; Input is a space‑delimited string of numberals from 'zero' to 'nine'.
;; Return the string with numbers sorted from smallest to largest
;; >>> (sort_numbers "three one five")
;; "one three five"
(define (sort_numbers numbers)
  (define words (string-split numbers))
  (define sorted-words
    (sort words
          (lambda (a b)
            (< (hash-ref number->value a)
               (hash-ref number->value b)))))
  (string-join sorted-words " "))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_numbers))
    (check-within (candidate "") "" 0.001)
    (check-within (candidate "three") "three" 0.001)
    (check-within (candidate "three five nine") "three five nine" 0.001)
    (check-within (candidate "five zero four seven nine eight") "zero four five seven eight nine" 0.001)
    (check-within (candidate "six five four three two one zero") "zero one two three four five six" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183832
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Input is a space-delimited string of numberals from 'zero' to 'nine'.
;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
;; Return the string with numbers sorted from smallest to largest
;; >>> (sort_numbers "three one five")
;; "one three five"

(require racket/string)

(define word-list
  '("zero" "one" "two" "three" "four" "five" "six" "seven" "eight" "nine"))

(define (word->int w)
  (let loop ((idx 0) (lst word-list))
    (cond [(null? lst) #f]
          [(string=? w (car lst)) idx]
          [else (loop (+ idx 1) (cdr lst))])))

(define (int->word i)
  (list-ref word-list i))

(define (sort_numbers numbers)
  (let* ((words (string-split numbers))
         (int-words (map word->int words))
         (sorted-ints (sort int-words <))
         (sorted-words (map int->word sorted-ints)))
    (string-join sorted-words)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_numbers))
    (check-within (candidate "") "" 0.001)
    (check-within (candidate "three") "three" 0.001)
    (check-within (candidate "three five nine") "three five nine" 0.001)
    (check-within (candidate "five zero four seven nine eight") "zero four five seven eight nine" 0.001)
    (check-within (candidate "six five four three two one zero") "zero one two three four five six" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183832
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Input is a space-delimited string of numberals from 'zero' to 'nine'.
;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
;; Return the string with numbers sorted from smallest to largest
;; >>> (sort_numbers "three one five")
;; "one three five"

;; Input is a space-delimited string of numberals from 'zero' to 'nine'.
;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
;; Return the string with numbers sorted from smallest to largest
;; >>> (sort_numbers "three one five")
;; "one three five"

(define (sort_numbers numbers)
  ;; List of number words in ascending order
  (define word-order
    '("zero" "one" "two" "three" "four" "five" "six" "seven" "eight" "nine"))

  ;; Convert a word to its numeric rank
  (define (word->rank w)
    (or (list-index word-order w)
        (error "Invalid number word:" w)))

  ;; Split the input string into a list of words
  (define words (string-split numbers))

  ;; Sort the words by their numeric rank
  (define sorted-words
    (sort words
          (lambda (a b)
            (< (word->rank a) (word->rank b)))))

  ;; Join the sorted words back into a single string
  (string-join sorted-words " "))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_numbers))
    (check-within (candidate "") "" 0.001)
    (check-within (candidate "three") "three" 0.001)
    (check-within (candidate "three five nine") "three five nine" 0.001)
    (check-within (candidate "five zero four seven nine eight") "zero four five seven eight nine" 0.001)
    (check-within (candidate "six five four three two one zero") "zero one two three four five six" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183832
STDOUT: (empty)
STDERR:
/tmp/tmppd1do4o2.rkt:22:9: list-index: unbound identifier
  in: list-index
  location...:
   /tmp/tmppd1do4o2.rkt:22:9
--------------------

================================================================================
PROBLEM 20 (RKT) - HumanEval_20_find_closest_elements
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0) 0.001)
    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0) 0.001)
    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)

(define (find_closest_elements numbers)
  (let* ((sorted (sort numbers <))
         (len    (length sorted)))
    (unless (>= len 2)
      (error "find_closest_elements: list must contain at least two numbers"))
    ;; Initialize with the first pair
    (define min-diff (abs (- (list-ref sorted 1) (list-ref sorted 0))))
    (define min-pair (list (list-ref sorted 0) (list-ref sorted 1)))
    ;; Scan through the sorted list to find the smallest difference
    (for ([i (in-range 2 len)])
      (define curr (list-ref sorted i))
      (define prev (list-ref sorted (- i 1)))
      (define diff (abs (- curr prev)))
      (when (< diff min-diff)
        (set! min-diff diff)
        (set! min-pair (list prev curr))))
    min-pair))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0) 0.001)
    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0) 0.001)
    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183833
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)

(define (find_closest_elements numbers)
  ;; Sort the list to guarantee that consecutive elements are the closest candidates
  (define sorted (sort numbers <))
  ;; Iterate over consecutive pairs, keeping track of the smallest difference seen so far
  (define-values (best-diff best-pair)
    (for/fold ([best-diff +inf.0] [best-pair null])
              ([i (in-range (- (length sorted) 1))])
      (define a (list-ref sorted i))
      (define b (list-ref sorted (+ i 1)))
      (define diff (abs (- a b)))
      (if (< diff best-diff)
          (values diff (list a b))
          (values best-diff best-pair))))
  ;; Return the pair of numbers that are closest
  best-pair)
(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0) 0.001)
    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0) 0.001)
    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183833
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)

(define (find_closest_elements numbers)
  ;; Sort the numbers to make the closest pair adjacent.
  (define sorted (sort numbers <))

  ;; Helper that walks the sorted list, keeping track of the best pair found so far.
  (define (loop lst best-diff best-pair)
    (if (null? (cdr lst))          ; no more adjacent pairs to examine
        best-pair
        (let* ((a (car lst))
               (b (cadr lst))
               (diff (abs (- b a))))
          (if (< diff best-diff)
              (loop (cdr lst) diff (list a b))   ; new best pair
              (loop (cdr lst) best-diff best-pair)))))

  ;; Start with an infinitely large difference and the first pair as a placeholder.
  (loop sorted +inf.0 (list (car sorted) (cadr sorted))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0) 0.001)
    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0) 0.001)
    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183833
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)

(define (find_closest_elements numbers)
  ;; Sort the numbers first so that the closest pair will be adjacent.
  (let* ([sorted (sort numbers <)]
         [len (length sorted)])
    (cond
      [(= len 2) sorted]          ; only one possible pair
      [else
       ;; Scan the sorted list for the pair with the smallest difference.
       (let loop ([i 0]
                  [best-pair (list (list-ref sorted 0) (list-ref sorted 1))])
         (if (= i (- len 2))
             best-pair
             (let* ([a (list-ref sorted i)]
                    [b (list-ref sorted (+ i 1))]
                    [diff (- b a)]
                    [best-diff (- (second best-pair) (first best-pair))]
                    [new-pair (if (< diff best-diff) (list a b) best-pair)])
               (loop (+ i 1) new-pair)))))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0) 0.001)
    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2) 0.001)
    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0) 0.001)
    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755183832
STDOUT: (empty)
STDERR:
/tmp/tmpzrchdtz5.rkt:34:41: read-syntax: missing `]` to close `[` on line 23, found instead `)`
  possible cause: indentation suggests a missing `]` before line 25
  context...:
   /usr/share/racket/collects/syntax/module-reader.rkt:186:17: body
   /usr/share/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /usr/share/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper
--------------------

================================================================================
PROBLEM 24 (RKT) - HumanEval_24_largest_divisor
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-within (candidate 3) 1 0.001)
    (check-within (candidate 7) 1 0.001)
    (check-within (candidate 10) 5 0.001)
    (check-within (candidate 100) 50 0.001)
    (check-within (candidate 49) 7 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5

;; For a given number n, find the largest number that divides n evenly,
;; smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (cond
    [(<= n 1) 1]   ; no proper divisor for 0 or 1
    [else
     (let loop ([d (- n 1)])
       (cond
         [(zero? (modulo n d)) d]   ; d divides n
         [else (loop (- d 1))])])]) ; keep searching
(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-within (candidate 3) 1 0.001)
    (check-within (candidate 7) 1 0.001)
    (check-within (candidate 10) 5 0.001)
    (check-within (candidate 100) 50 0.001)
    (check-within (candidate 49) 7 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 1
Status: SyntaxError
Timestamp: 1755183836
STDOUT: (empty)
STDERR:
/tmp/tmp3kjulybw.rkt:18:31: read-syntax: missing `)` to close `(` on line 15, found instead `]`
  context...:
   /usr/share/racket/collects/syntax/module-reader.rkt:186:17: body
   /usr/share/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /usr/share/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5

;; For a given number n, find the largest number that divides n evenly,
;; smaller than n.
;;
;; Example:
;;   (largest_divisor 15)  ; => 5
(define (largest_divisor n)
  (cond
    [(<= n 1) n]          ; trivial case: 0 or 1 return themselves
    [else
     ;; Start searching from the largest possible proper divisor: floor(n/2)
     (define (search i)
       (cond
         [(= i 1) 1]       ; if we reach 1, it's the only divisor left
         [(zero? (modulo n i)) i]  ; found a divisor
         [else (search (- i 1))])) ; continue searching
     (search (floor (/ n 2)))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-within (candidate 3) 1 0.001)
    (check-within (candidate 7) 1 0.001)
    (check-within (candidate 10) 5 0.001)
    (check-within (candidate 100) 50 0.001)
    (check-within (candidate 49) 7 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183837
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5

;; For a given number n, find the largest number that divides n evenly,
;; smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  ;; Handle the trivial case first
  (if (<= n 1)
      1
      ;; Search downward from n‑1 until a divisor is found
      (let loop ([i (sub1 n)])
        (cond
          [(zero? (modulo n i)) i]   ; i divides n
          [else (loop (sub1 i))]))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-within (candidate 3) 1 0.001)
    (check-within (candidate 7) 1 0.001)
    (check-within (candidate 10) 5 0.001)
    (check-within (candidate 100) 50 0.001)
    (check-within (candidate 49) 7 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183837
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5

;; For a given number n, find the largest number that divides n evenly,
;; smaller than n.
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (search d)
    (cond
      [(= (remainder n d) 0) d]          ; d divides n
      [else (search (- d 1))]))          ; try next smaller number
  (search (- n 1)))                      ; start from n‑1
(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-within (candidate 3) 1 0.001)
    (check-within (candidate 7) 1 0.001)
    (check-within (candidate 10) 5 0.001)
    (check-within (candidate 100) 50 0.001)
    (check-within (candidate 49) 7 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183837
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 25 (RKT) - HumanEval_25_factorize
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Return list of prime factors of given integer in the order from smallest to largest.
;; Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
;; Input number should be equal to the product of all factors
;; >>> (factorize 8)
;; (list 2 2 2)
;; >>> (factorize 25)
;; (list 5 5)
;; >>> (factorize 70)
;; (list 2 5 7)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate factorize))
    (check-within (candidate 2) (list 2) 0.001)
    (check-within (candidate 4) (list 2 2) 0.001)
    (check-within (candidate 8) (list 2 2 2) 0.001)
    (check-within (candidate 57) (list 3 19) 0.001)
    (check-within (candidate 3249) (list 3 3 19 19) 0.001)
    (check-within (candidate 185193) (list 3 3 3 19 19 19) 0.001)
    (check-within (candidate 20577) (list 3 19 19 19) 0.001)
    (check-within (candidate 18) (list 2 3 3) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Return list of prime factors of given integer in the order from smallest to largest.
;; Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
;; Input number should be equal to the product of all factors
;; >>> (factorize 8)
;; (list 2 2 2)
;; >>> (factorize 25)
;; (list 5 5)
;; >>> (factorize 70)
;; (list 2 5 7)

;; Return list of prime factors of given integer in the order from smallest to largest.
;; Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
;; Input number should be equal to the product of all factors
;; >>> (factorize 8)
;; (list 2 2 2)
;; >>> (factorize 25)
;; (list 5 5)
;; >>> (factorize 70)
;; (list 2 5 7)
(define (factorize n)
  ;; Helper that finds the smallest divisor of m (starting at d).
  (define (find-divisor m d)
    (cond
      [(> (* d d) m) m]                     ; m is prime
      [(zero? (modulo m d)) d]              ; d divides m
      [else (find-divisor m (+ d 1))]))
  (if (<= n 1)
      empty                                 ; no factors for 0 or 1
      (let ([d (find-divisor n 2)])
        (cons d (factorize (quotient n d)))))) ; recurse on the quotient
(require rackunit)

(define (test-humaneval) 

  (let (( candidate factorize))
    (check-within (candidate 2) (list 2) 0.001)
    (check-within (candidate 4) (list 2 2) 0.001)
    (check-within (candidate 8) (list 2 2 2) 0.001)
    (check-within (candidate 57) (list 3 19) 0.001)
    (check-within (candidate 3249) (list 3 3 19 19) 0.001)
    (check-within (candidate 185193) (list 3 3 3 19 19 19) 0.001)
    (check-within (candidate 20577) (list 3 19 19 19) 0.001)
    (check-within (candidate 18) (list 2 3 3) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183838
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Return list of prime factors of given integer in the order from smallest to largest.
;; Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
;; Input number should be equal to the product of all factors
;; >>> (factorize 8)
;; (list 2 2 2)
;; >>> (factorize 25)
;; (list 5 5)
;; >>> (factorize 70)
;; (list 2 5 7)

;; Return list of prime factors of given integer in the order from smallest to largest.
;; Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
;; Input number should be equal to the product of all factors
;; >>> (factorize 8)
;; (list 2 2 2)
;; >>> (factorize 25)
;; (list 5 5)
;; >>> (factorize 70)
;; (list 2 5 7)

(define (factorize n)
  ;; Helper to find the smallest divisor of n (or n itself if prime)
  (define (smallest-divisor n)
    (define (iter d)
      (cond [(> (* d d) n) n]                     ; no divisor found, n is prime
            [(zero? (modulo n d)) d]              ; d divides n
            [else (iter (+ d 1))]))              ; try next d
    (iter 2))
  
  (cond [(= n 1) (list)]                          ; base case: 1 has no prime factors
        [else
         (let ([d (smallest-divisor n)])
           (if (= d n)                      ; n itself is prime
               (list n)
               (cons d (factorize (/ n d)))))]))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate factorize))
    (check-within (candidate 2) (list 2) 0.001)
    (check-within (candidate 4) (list 2 2) 0.001)
    (check-within (candidate 8) (list 2 2 2) 0.001)
    (check-within (candidate 57) (list 3 19) 0.001)
    (check-within (candidate 3249) (list 3 3 19 19) 0.001)
    (check-within (candidate 185193) (list 3 3 3 19 19 19) 0.001)
    (check-within (candidate 20577) (list 3 19 19 19) 0.001)
    (check-within (candidate 18) (list 2 3 3) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183838
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Return list of prime factors of given integer in the order from smallest to largest.
;; Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
;; Input number should be equal to the product of all factors
;; >>> (factorize 8)
;; (list 2 2 2)
;; >>> (factorize 25)
;; (list 5 5)
;; >>> (factorize 70)
;; (list 2 5 7)

;; Return list of prime factors of given integer in the order from smallest to largest.
;; Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
;; Input number should be equal to the product of all factors
;; >>> (factorize 8)
;; (list 2 2 2)
;; >>> (factorize 25)
;; (list 5 5)
;; >>> (factorize 70)
;; (list 2 5 7)
(define (factorize n)
  ;; Helper that takes the current number and the current divisor to try.
  (define (factorize-helper n d)
    (cond
      [(< n 2) '()]                                 ; n is 0 or 1 → no factors
      [(= (modulo n d) 0)                           ; d divides n
       (cons d (factorize-helper (/ n d) d))]       ; keep dividing by d
      [(> (* d d) n)                                 ; n is prime
       (list n)]
      [else                                          ; try next divisor
       (factorize-helper n (+ d 1))]))
  (factorize-helper n 2))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate factorize))
    (check-within (candidate 2) (list 2) 0.001)
    (check-within (candidate 4) (list 2 2) 0.001)
    (check-within (candidate 8) (list 2 2 2) 0.001)
    (check-within (candidate 57) (list 3 19) 0.001)
    (check-within (candidate 3249) (list 3 3 19 19) 0.001)
    (check-within (candidate 185193) (list 3 3 3 19 19 19) 0.001)
    (check-within (candidate 20577) (list 3 19 19 19) 0.001)
    (check-within (candidate 18) (list 2 3 3) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183838
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Return list of prime factors of given integer in the order from smallest to largest.
;; Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
;; Input number should be equal to the product of all factors
;; >>> (factorize 8)
;; (list 2 2 2)
;; >>> (factorize 25)
;; (list 5 5)
;; >>> (factorize 70)
;; (list 2 5 7)

;; Return list of prime factors of given integer in the order from smallest to largest.
;; Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
;; Input number should be equal to the product of all factors
;; >>> (factorize 8)
;; (list 2 2 2)
;; >>> (factorize 25)
;; (list 5 5)
;; >>> (factorize 70)
;; (list 2 5 7)

(define (factorize n)
  ;; Recursive helper that builds the list in reverse order
  (define (factorize-aux n acc)
    (cond
      [(= n 1) (reverse acc)]                     ; finished
      [(zero? (modulo n 2))                       ; 2 is a factor
       (factorize-aux (quotient n 2) (cons 2 acc))]
      [else
       (let loop ((i 3))                           ; try odd divisors
         (cond
           [(> (* i i) n)                          ; n is prime
            (factorize-aux n (cons n acc))]
           [(zero? (modulo n i))                   ; found a factor
            (factorize-aux (quotient n i) (cons i acc))]
           [else
            (loop (+ i 2))]))]))                   ; next odd candidate
  (factorize-aux n '()))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate factorize))
    (check-within (candidate 2) (list 2) 0.001)
    (check-within (candidate 4) (list 2 2) 0.001)
    (check-within (candidate 8) (list 2 2 2) 0.001)
    (check-within (candidate 57) (list 3 19) 0.001)
    (check-within (candidate 3249) (list 3 3 19 19) 0.001)
    (check-within (candidate 185193) (list 3 3 3 19 19 19) 0.001)
    (check-within (candidate 20577) (list 3 19 19 19) 0.001)
    (check-within (candidate 18) (list 2 3 3) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: -1
Status: Exception
Timestamp: 1755183852
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 26 (RKT) - HumanEval_26_remove_duplicates
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate remove_duplicates))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)
    (check-within (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5) 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)

(define (remove_duplicates numbers)
  (define (freq x)
    (count (lambda (y) (= x y)) numbers))
  (filter (lambda (x) (= (freq x) 1)) numbers))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate remove_duplicates))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)
    (check-within (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183853
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)

(define (remove_duplicates numbers)
  ;; First count how many times each number appears.
  (define counts (make-hash))
  (for ([n numbers])
    (hash-update! counts n (lambda (c) (+ c 1)) 0))

  ;; Keep only those numbers that appear exactly once.
  (filter (lambda (n) (= (hash-ref counts n 0) 1)) numbers))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate remove_duplicates))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)
    (check-within (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183853
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)
(define (remove_duplicates numbers)
  ;; First build a hash table that counts occurrences of each number.
  (define freq
    (foldl (lambda (n acc)
             (hash-set acc n (+ 1 (hash-ref acc n 0))))
           (make-hash)
           numbers))
  ;; Keep only those numbers whose count is exactly 1.
  (filter (lambda (n) (= (hash-ref freq n) 1)) numbers))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate remove_duplicates))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)
    (check-within (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: Exception
Timestamp: 1755183853
STDOUT: (empty)
STDERR:
--------------------
ERROR
name:       check-within
location:   /tmp/tmpyygzdu95.rkt:27:4

hash-set: contract violation
  expected: (and/c hash? immutable?)
  given: '#hash()
  argument position: 1st
  other arguments...:
   1
   1
--------------------
--------------------
ERROR
name:       check-within
location:   /tmp/tmpyygzdu95.rkt:28:4

hash-set: contract violation
  expected: (and/c hash? immutable?)
  given: '#hash()
  argument position: 1st
  other arguments...:
   1
   1
--------------------
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)

(require racket/list)

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)

(define (remove_duplicates numbers)
  (filter
   (lambda (x)
     (= (count (lambda (y) (= y x)) numbers) 1))
   numbers))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate remove_duplicates))
    (check-within (candidate (list )) (list ) 0.001)
    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)
    (check-within (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5) 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183853
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 28 (RKT) - HumanEval_28_concatenate
================================================================================

PROMPT:
----------------------------------------
#lang racket

;; Concatenate list of strings into a single string
;; >>> (concatenate (list ))
;; ""
;; >>> (concatenate (list "a" "b" "c"))
;; "abc"

----------------------------------------

TEST CASES:
----------------------------------------
(require rackunit)

(define (test-humaneval) 

  (let (( candidate concatenate))
    (check-within (candidate (list )) "" 0.001)
    (check-within (candidate (list "x" "y" "z")) "xyz" 0.001)
    (check-within (candidate (list "x" "y" "z" "w" "k")) "xyzwk" 0.001)
))

(test-humaneval)
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
#lang racket

;; Concatenate list of strings into a single string
;; >>> (concatenate (list ))
;; ""
;; >>> (concatenate (list "a" "b" "c"))
;; "abc"

;; Concatenate list of strings into a single string
;; >>> (concatenate (list ))
;; ""
;; >>> (concatenate (list "a" "b" "c"))
;; "abc"
(define (concatenate strings)
  (apply string-append strings))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate concatenate))
    (check-within (candidate (list )) "" 0.001)
    (check-within (candidate (list "x" "y" "z")) "xyz" 0.001)
    (check-within (candidate (list "x" "y" "z" "w" "k")) "xyzwk" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183854
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
#lang racket

;; Concatenate list of strings into a single string
;; >>> (concatenate (list ))
;; ""
;; >>> (concatenate (list "a" "b" "c"))
;; "abc"

;; Concatenate list of strings into a single string
;; >>> (concatenate (list ))
;; ""
;; >>> (concatenate (list "a" "b" "c"))
;; "abc"
(define (concatenate strings)
  (foldl string-append "" strings))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate concatenate))
    (check-within (candidate (list )) "" 0.001)
    (check-within (candidate (list "x" "y" "z")) "xyz" 0.001)
    (check-within (candidate (list "x" "y" "z" "w" "k")) "xyzwk" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: Exception
Timestamp: 1755183854
STDOUT: (empty)
STDERR:
--------------------
FAILURE
name:       check-within
location:   /tmp/tmp301zye_u.rkt:22:4
actual:     "zyx"
expected:   "xyz"
--------------------
--------------------
FAILURE
name:       check-within
location:   /tmp/tmp301zye_u.rkt:23:4
actual:     "kwzyx"
expected:   "xyzwk"
--------------------
--------------------

COMPLETION 3:
--------------------
PROGRAM:
#lang racket

;; Concatenate list of strings into a single string
;; >>> (concatenate (list ))
;; ""
;; >>> (concatenate (list "a" "b" "c"))
;; "abc"

;; Concatenate list of strings into a single string
;; >>> (concatenate (list ))
;; ""
;; >>> (concatenate (list "a" "b" "c"))
;; "abc"
(define (concatenate strings)
  (apply string-append strings))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate concatenate))
    (check-within (candidate (list )) "" 0.001)
    (check-within (candidate (list "x" "y" "z")) "xyz" 0.001)
    (check-within (candidate (list "x" "y" "z" "w" "k")) "xyzwk" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183854
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
#lang racket

;; Concatenate list of strings into a single string
;; >>> (concatenate (list ))
;; ""
;; >>> (concatenate (list "a" "b" "c"))
;; "abc"

;; Concatenate list of strings into a single string
;; >>> (concatenate (list ))
;; ""
;; >>> (concatenate (list "a" "b" "c"))
;; "abc"
(define (concatenate strings)
  (apply string-append strings))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate concatenate))
    (check-within (candidate (list )) "" 0.001)
    (check-within (candidate (list "x" "y" "z")) "xyz" 0.001)
    (check-within (candidate (list "x" "y" "z" "w" "k")) "xyzwk" 0.001)
))

(test-humaneval)

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183854
STDOUT: (empty)
STDERR: (empty)
--------------------
