As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 115 (R) - HumanEval_115_max_fill
================================================================================

PROMPT:
----------------------------------------
# You are given a rectangular grid of wells. Each row represents a single well,
# and each 1 in a row represents a single unit of water.
# Each well has a corresponding bucket that can be used to extract water from it, 
# and all buckets have the same capacity.
# Your task is to use the buckets to empty the wells.
# Output the number of times you need to lower the buckets.
# Example 1:
# >>> max_fill(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1)
# 6
# Example 2:
# >>> max_fill(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2)
# 5
# Example 3:
# >>> max_fill(list(c(0, 0, 0), c(0, 0, 0)), 5)
# 0
# Constraints:
#     * all wells have the same length
#     * 1 <= grid.length <= 10^2
#     * 1 <= grid[:,1].length <= 10^2
#     * grid[i][j] -> 0 | 1
#     * 1 <= capacity <= 10

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- max_fill
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1), 6)))
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2), 5)))
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 0), c(0, 0, 0)), 5), 0)))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 2), 4)))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 9), 2)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# You are given a rectangular grid of wells. Each row represents a single well,
# and each 1 in a row represents a single unit of water.
# Each well has a corresponding bucket that can be used to extract water from it, 
# and all buckets have the same capacity.
# Your task is to use the buckets to empty the wells.
# Output the number of times you need to lower the buckets.
# Example 1:
# >>> max_fill(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1)
# 6
# Example 2:
# >>> max_fill(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2)
# 5
# Example 3:
# >>> max_fill(list(c(0, 0, 0), c(0, 0, 0)), 5)
# 0
# Constraints:
#     * all wells have the same length
#     * 1 <= grid.length <= 10^2
#     * 1 <= grid[:,1].length <= 10^2
#     * grid[i][j] -> 0 | 1
#     * 1 <= capacity <= 10
max_fill <- function(grid, capacity) {
  # Count the number of water units in each well (row)
  row_sums <- sapply(grid, sum)
  
  # For each well, compute the number of bucket submerges needed:
  #   ceil(number_of_units / capacity)
  submerges_per_well <- ceiling(row_sums / capacity)
  
  # Total number of bucket submerges is the sum over all wells
  total_submerges <- sum(submerges_per_well)
  
  return(total_submerges)
}
test_humaneval <- function() {
    candidate <- max_fill
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1), 6)))
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2), 5)))
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 0), c(0, 0, 0)), 5), 0)))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 2), 4)))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 9), 2)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183789
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# You are given a rectangular grid of wells. Each row represents a single well,
# and each 1 in a row represents a single unit of water.
# Each well has a corresponding bucket that can be used to extract water from it, 
# and all buckets have the same capacity.
# Your task is to use the buckets to empty the wells.
# Output the number of times you need to lower the buckets.
# Example 1:
# >>> max_fill(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1)
# 6
# Example 2:
# >>> max_fill(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2)
# 5
# Example 3:
# >>> max_fill(list(c(0, 0, 0), c(0, 0, 0)), 5)
# 0
# Constraints:
#     * all wells have the same length
#     * 1 <= grid.length <= 10^2
#     * 1 <= grid[:,1].length <= 10^2
#     * grid[i][j] -> 0 | 1
#     * 1 <= capacity <= 10
max_fill <- function(grid, capacity) {
  # Validate input
  if (!is.list(grid) || length(grid) == 0) {
    stop("grid must be a non‑empty list of numeric vectors")
  }
  if (!is.numeric(capacity) || length(capacity) != 1 || capacity <= 0) {
    stop("capacity must be a positive numeric value")
  }

  # Sum the water units in each well (each row of the grid)
  row_sums <- sapply(grid, sum)

  # Number of bucket lowers needed for each well
  lowers_per_well <- ceiling(row_sums / capacity)

  # Total number of lowers
  total_lowers <- sum(lowers_per_well)

  return(total_lowers)
}
test_humaneval <- function() {
    candidate <- max_fill
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1), 6)))
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2), 5)))
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 0), c(0, 0, 0)), 5), 0)))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 2), 4)))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 9), 2)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183789
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# You are given a rectangular grid of wells. Each row represents a single well,
# and each 1 in a row represents a single unit of water.
# Each well has a corresponding bucket that can be used to extract water from it, 
# and all buckets have the same capacity.
# Your task is to use the buckets to empty the wells.
# Output the number of times you need to lower the buckets.
# Example 1:
# >>> max_fill(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1)
# 6
# Example 2:
# >>> max_fill(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2)
# 5
# Example 3:
# >>> max_fill(list(c(0, 0, 0), c(0, 0, 0)), 5)
# 0
# Constraints:
#     * all wells have the same length
#     * 1 <= grid.length <= 10^2
#     * 1 <= grid[:,1].length <= 10^2
#     * grid[i][j] -> 0 | 1
#     * 1 <= capacity <= 10
max_fill <- function(grid, capacity) {
  # Guard against an empty grid
  if (length(grid) == 0) return(0L)
  
  # Total units of water in each well
  units_per_well <- sapply(grid, sum)
  
  # Number of times the bucket must be lowered for each well
  lowers_per_well <- ceiling(units_per_well / capacity)
  
  # Total lowers across all wells
  total_lowers <- sum(lowers_per_well)
  
  # Return as an integer
  as.integer(total_lowers)
}
test_humaneval <- function() {
    candidate <- max_fill
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1), 6)))
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2), 5)))
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 0), c(0, 0, 0)), 5), 0)))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 2), 4)))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 9), 2)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183789
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# You are given a rectangular grid of wells. Each row represents a single well,
# and each 1 in a row represents a single unit of water.
# Each well has a corresponding bucket that can be used to extract water from it, 
# and all buckets have the same capacity.
# Your task is to use the buckets to empty the wells.
# Output the number of times you need to lower the buckets.
# Example 1:
# >>> max_fill(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1)
# 6
# Example 2:
# >>> max_fill(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2)
# 5
# Example 3:
# >>> max_fill(list(c(0, 0, 0), c(0, 0, 0)), 5)
# 0
# Constraints:
#     * all wells have the same length
#     * 1 <= grid.length <= 10^2
#     * 1 <= grid[:,1].length <= 10^2
#     * grid[i][j] -> 0 | 1
#     * 1 <= capacity <= 10
max_fill <- function(grid, capacity) {
  # Validate capacity
  if (!is.numeric(capacity) || length(capacity) != 1 || capacity <= 0) {
    stop("capacity must be a positive numeric value")
  }
  
  # Convert the input to a matrix for easier row operations
  mat <- as.matrix(grid)
  
  # Count the number of 1s in each row (each well)
  row_counts <- rowSums(mat)
  
  # Compute the number of bucket dips needed for each well
  # ceil(n / capacity) can be calculated as (n + capacity - 1) %/% capacity
  dips_per_well <- (row_counts + capacity - 1) %/% capacity
  
  # Total number of bucket lowers required
  total_dips <- sum(dips_per_well)
  
  return(total_dips)
}
test_humaneval <- function() {
    candidate <- max_fill
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1), 6)))
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2), 5)))
    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 0), c(0, 0, 0)), 5), 0)))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 2), 4)))
    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 9), 2)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183789
STDOUT: (empty)
STDERR:
Error in rowSums(mat) : 'x' must be numeric
Calls: test_humaneval ... stopifnot -> isTRUE -> all.equal -> candidate -> rowSums
Execution halted
--------------------

================================================================================
PROBLEM 119 (R) - HumanEval_119_match_parens
================================================================================

PROMPT:
----------------------------------------
# You are given a list of two strings, both strings consist of open
# parentheses '(' or close parentheses ')' only.
# Your job is to check if it is possible to concatenate the two strings in
# some order, that the resulting string will be good.
# A string S is considered to be good if and only if all parentheses in S
# are balanced. For example: the string '(())()' is good, while the string
# '())' is not.
# Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
# Examples:
# >>> match_parens(c('()(', ')'))
# 'Yes'
# >>> match_parens(c(')', ')'))
# 'No'

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- match_parens
    stopifnot(isTRUE(all.equal(candidate(c('()(', ')')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c(')', ')')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(()(())', '())())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')())', '(()()(')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('(())))', '(()())((')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('()', '())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(()(', '()))()')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('((((', '((())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')(()', '(()(')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')(', ')(')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(', ')')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c(')', '(')), 'Yes')))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# You are given a list of two strings, both strings consist of open
# parentheses '(' or close parentheses ')' only.
# Your job is to check if it is possible to concatenate the two strings in
# some order, that the resulting string will be good.
# A string S is considered to be good if and only if all parentheses in S
# are balanced. For example: the string '(())()' is good, while the string
# '())' is not.
# Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
# Examples:
# >>> match_parens(c('()(', ')'))
# 'Yes'
# >>> match_parens(c(')', ')'))
# 'No'
# Check if a string of parentheses is balanced
is_balanced <- function(s) {
  bal <- 0
  chars <- strsplit(s, "")[[1]]
  for (ch in chars) {
    if (ch == "(") {
      bal <- bal + 1
    } else {          # ch == ")"
      bal <- bal - 1
    }
    if (bal < 0) return(FALSE)   # more ')' than '(' at some point
  }
  return(bal == 0)                # finally all '(' matched
}

# Main function
match_parens <- function(lst) {
  # Expect a list of two strings
  s1 <- lst[[1]]
  s2 <- lst[[2]]
  
  # Test both possible concatenations
  if (is_balanced(paste0(s1, s2)) || is_balanced(paste0(s2, s1))) {
    return("Yes")
  } else {
    return("No")
  }
}
test_humaneval <- function() {
    candidate <- match_parens
    stopifnot(isTRUE(all.equal(candidate(c('()(', ')')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c(')', ')')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(()(())', '())())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')())', '(()()(')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('(())))', '(()())((')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('()', '())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(()(', '()))()')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('((((', '((())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')(()', '(()(')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')(', ')(')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(', ')')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c(')', '(')), 'Yes')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183791
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# You are given a list of two strings, both strings consist of open
# parentheses '(' or close parentheses ')' only.
# Your job is to check if it is possible to concatenate the two strings in
# some order, that the resulting string will be good.
# A string S is considered to be good if and only if all parentheses in S
# are balanced. For example: the string '(())()' is good, while the string
# '())' is not.
# Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
# Examples:
# >>> match_parens(c('()(', ')'))
# 'Yes'
# >>> match_parens(c(')', ')'))
# 'No'
match_parens <- function(lst) {
  # Ensure we have exactly two strings
  if (length(lst) != 2) stop("Input must be a character vector of length 2")
  
  s1 <- lst[1]
  s2 <- lst[2]
  
  # Helper to test if a single string is balanced
  is_balanced <- function(s) {
    bal <- 0
    for (ch in strsplit(s, "")[[1]]) {
      if (ch == "(") {
        bal <- bal + 1
      } else if (ch == ")") {
        bal <- bal - 1
      } else {
        # ignore any other characters (shouldn't happen per problem statement)
        next
      }
      if (bal < 0) return(FALSE)   # more ')' than '(' seen so far
    }
    return(bal == 0)   # all '(' matched by ')'
  }
  
  # Check both concatenation orders
  if (is_balanced(paste0(s1, s2)) || is_balanced(paste0(s2, s1))) {
    return("Yes")
  } else {
    return("No")
  }
}
test_humaneval <- function() {
    candidate <- match_parens
    stopifnot(isTRUE(all.equal(candidate(c('()(', ')')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c(')', ')')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(()(())', '())())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')())', '(()()(')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('(())))', '(()())((')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('()', '())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(()(', '()))()')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('((((', '((())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')(()', '(()(')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')(', ')(')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(', ')')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c(')', '(')), 'Yes')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183791
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# You are given a list of two strings, both strings consist of open
# parentheses '(' or close parentheses ')' only.
# Your job is to check if it is possible to concatenate the two strings in
# some order, that the resulting string will be good.
# A string S is considered to be good if and only if all parentheses in S
# are balanced. For example: the string '(())()' is good, while the string
# '())' is not.
# Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
# Examples:
# >>> match_parens(c('()(', ')'))
# 'Yes'
# >>> match_parens(c(')', ')'))
# 'No'
match_parens <- function(lst) {
  # Helper to check if a single string is balanced
  is_balanced <- function(s) {
    bal <- 0
    # Split the string into individual characters
    chars <- strsplit(s, "")[[1]]
    for (ch in chars) {
      if (ch == "(") {
        bal <- bal + 1
      } else if (ch == ")") {
        bal <- bal - 1
      } else {
        # If any other character appears, consider it invalid
        return(FALSE)
      }
      if (bal < 0) return(FALSE)  # More closing than opening at some prefix
    }
    return(bal == 0)
  }
  
  # Extract the two strings
  if (length(lst) != 2) stop("Input must contain exactly two strings.")
  s1 <- lst[[1]]
  s2 <- lst[[2]]
  
  # Check both possible concatenations
  if (is_balanced(paste0(s1, s2)) || is_balanced(paste0(s2, s1))) {
    return("Yes")
  } else {
    return("No")
  }
}
test_humaneval <- function() {
    candidate <- match_parens
    stopifnot(isTRUE(all.equal(candidate(c('()(', ')')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c(')', ')')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(()(())', '())())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')())', '(()()(')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('(())))', '(()())((')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('()', '())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(()(', '()))()')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('((((', '((())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')(()', '(()(')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')(', ')(')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(', ')')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c(')', '(')), 'Yes')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183791
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# You are given a list of two strings, both strings consist of open
# parentheses '(' or close parentheses ')' only.
# Your job is to check if it is possible to concatenate the two strings in
# some order, that the resulting string will be good.
# A string S is considered to be good if and only if all parentheses in S
# are balanced. For example: the string '(())()' is good, while the string
# '())' is not.
# Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
# Examples:
# >>> match_parens(c('()(', ')'))
# 'Yes'
# >>> match_parens(c(')', ')'))
# 'No'
match_parens <- function(lst) {
  # Helper to check if a single string is balanced
  is_balanced <- function(s) {
    bal <- 0
    for (ch in strsplit(s, "")[[1]]) {
      if (ch == "(") {
        bal <- bal + 1
      } else if (ch == ")") {
        bal <- bal - 1
      }
      if (bal < 0) return(FALSE)  # more ')' than '(' seen so far
    }
    return(bal == 0)
  }
  
  if (!is.list(lst) || length(lst) != 2) {
    stop("Input must be a list of two strings")
  }
  
  a <- lst[[1]]
  b <- lst[[2]]
  
  # Check both possible concatenations
  if (is_balanced(paste0(a, b)) || is_balanced(paste0(b, a))) {
    return("Yes")
  } else {
    return("No")
  }
}
test_humaneval <- function() {
    candidate <- match_parens
    stopifnot(isTRUE(all.equal(candidate(c('()(', ')')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c(')', ')')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(()(())', '())())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')())', '(()()(')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('(())))', '(()())((')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('()', '())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(()(', '()))()')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c('((((', '((())')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')(()', '(()(')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c(')(', ')(')), 'No')))
    stopifnot(isTRUE(all.equal(candidate(c('(', ')')), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate(c(')', '(')), 'Yes')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183791
STDOUT: (empty)
STDERR:
Error in candidate(c("()(", ")")) : Input must be a list of two strings
Calls: test_humaneval -> stopifnot -> isTRUE -> all.equal -> candidate
Execution halted
--------------------

================================================================================
PROBLEM 121 (R) - HumanEval_121_solution
================================================================================

PROMPT:
----------------------------------------
# Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
# Examples
# >>> solution(c(5, 8, 7, 1))
# 12
# >>> solution(c(3, 3, 3, 3, 3))
# 9
# >>> solution(c(30, 13, 24, 321))
# 0

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- solution
    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 7, 1)), 12)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 3, 3, 3, 3)), 9)))
    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 24, 321)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 9)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 23, 32)), 23)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 13, 2, 9)), 3)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
# Examples
# >>> solution(c(5, 8, 7, 1))
# 12
# >>> solution(c(3, 3, 3, 3, 3))
# 9
# >>> solution(c(30, 13, 24, 321))
# 0
solution <- function(lst) {
  # Even positions in 0‑based indexing correspond to odd indices in R
  even_idx <- seq(1, length(lst), by = 2)
  # Extract those elements
  even_elements <- lst[even_idx]
  # Keep only the odd elements
  odd_evens <- even_elements[even_elements %% 2 != 0]
  # Sum (returns 0 if none)
  sum(odd_evens)
}
test_humaneval <- function() {
    candidate <- solution
    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 7, 1)), 12)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 3, 3, 3, 3)), 9)))
    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 24, 321)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 9)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 23, 32)), 23)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 13, 2, 9)), 3)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183792
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
# Examples
# >>> solution(c(5, 8, 7, 1))
# 12
# >>> solution(c(3, 3, 3, 3, 3))
# 9
# >>> solution(c(30, 13, 24, 321))
# 0
solution <- function(lst) {
  # Indices that correspond to even positions in 0‑based indexing are the
  # odd indices in R (1, 3, 5, …).
  even_pos_indices <- seq(1, length(lst), by = 2)
  # Select the elements at those positions
  selected_elements <- lst[even_pos_indices]
  # Keep only the odd elements
  odd_elements <- selected_elements[selected_elements %% 2 != 0]
  # Return their sum (sum of an empty vector is 0)
  sum(odd_elements)
}
test_humaneval <- function() {
    candidate <- solution
    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 7, 1)), 12)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 3, 3, 3, 3)), 9)))
    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 24, 321)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 9)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 23, 32)), 23)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 13, 2, 9)), 3)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183792
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
# Examples
# >>> solution(c(5, 8, 7, 1))
# 12
# >>> solution(c(3, 3, 3, 3, 3))
# 9
# >>> solution(c(30, 13, 24, 321))
# 0
solution <- function(lst) {
  # Extract elements at 1-based odd indices (0‑based even positions)
  odd_pos_elements <- lst[seq(1, length(lst), by = 2)]
  # Keep only those that are odd
  odd_elements <- odd_pos_elements[odd_pos_elements %% 2 != 0]
  # Return their sum
  sum(odd_elements)
}
test_humaneval <- function() {
    candidate <- solution
    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 7, 1)), 12)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 3, 3, 3, 3)), 9)))
    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 24, 321)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 9)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 23, 32)), 23)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 13, 2, 9)), 3)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183792
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
# Examples
# >>> solution(c(5, 8, 7, 1))
# 12
# >>> solution(c(3, 3, 3, 3, 3))
# 9
# >>> solution(c(30, 13, 24, 321))
# 0
solution <- function(lst) {
  # Even positions in R are 2, 4, 6, ...
  even_pos <- seq(2, length(lst), by = 2)
  # Select elements at even positions that are odd
  odd_at_even <- lst[even_pos][lst[even_pos] %% 2 != 0]
  # Return their sum (0 if none)
  sum(odd_at_even)
}
test_humaneval <- function() {
    candidate <- solution
    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 7, 1)), 12)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 3, 3, 3, 3)), 9)))
    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 24, 321)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(5, 9)), 5)))
    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8)), 0)))
    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 23, 32)), 23)))
    stopifnot(isTRUE(all.equal(candidate(c(3, 13, 2, 9)), 3)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183792
STDOUT: (empty)
STDERR:
Error in test_humaneval() : 
  isTRUE(all.equal(candidate(c(5, 8, 7, 1)), 12)) is not TRUE
Calls: test_humaneval -> stopifnot
Execution halted
--------------------

================================================================================
PROBLEM 132 (R) - HumanEval_132_is_nested
================================================================================

PROMPT:
----------------------------------------
# Create a function that takes a string as input which contains only square brackets.
# The function should return TRUE if and only if there is a valid subsequence of brackets 
# where at least one bracket in the subsequence is nested.
# >>> is_nested('[[]]')
# TRUE
# >>> is_nested('[]]]]]]][[[[[]')
# FALSE
# >>> is_nested('[][]')
# FALSE
# >>> is_nested('[]')
# FALSE
# >>> is_nested('[[][]]')
# TRUE
# >>> is_nested('[[]][[')
# TRUE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- is_nested
    stopifnot(isTRUE(all.equal(candidate('[[]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[]]]]]]][[[[[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[][]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[[[]]]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[]]]]]]]]]]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[][][[]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[]]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[]][['), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[[][]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[[[[[[['), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(']]]]]]]]'), FALSE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Create a function that takes a string as input which contains only square brackets.
# The function should return TRUE if and only if there is a valid subsequence of brackets 
# where at least one bracket in the subsequence is nested.
# >>> is_nested('[[]]')
# TRUE
# >>> is_nested('[]]]]]]][[[[[]')
# FALSE
# >>> is_nested('[][]')
# FALSE
# >>> is_nested('[]')
# FALSE
# >>> is_nested('[[][]]')
# TRUE
# >>> is_nested('[[]][[')
# TRUE
# Create a function that takes a string as input which contains only square brackets.
# The function should return TRUE if and only if there is a valid subsequence of brackets 
# where at least one bracket in the subsequence is nested.
# >>> is_nested('[[]]')
# TRUE
# >>> is_nested('[]]]]]]][[[[[]')
# FALSE
# >>> is_nested('[][]')
# FALSE
# >>> is_nested('[]')
# FALSE
# >>> is_nested('[[][]]')
# TRUE
# >>> is_nested('[[]][[')
# TRUE
is_nested <- function(string) {
  # Split the string into individual characters
  chars <- strsplit(string, "")[[1]]
  n <- length(chars)
  
  # Stack to keep indices of unmatched '['
  stack <- integer(0)
  # List to store matched pairs (open_index, close_index)
  pairs <- list()
  
  for (i in seq_len(n)) {
    if (chars[i] == "[") {
      stack <- c(stack, i)
    } else if (chars[i] == "]") {
      # If there is a matching '['
      if (length(stack) > 0) {
        open_idx <- tail(stack, 1)
        stack <- head(stack, -1)
        pairs[[length(pairs) + 1]] <- c(open_idx, i)
      }
    }
  }
  
  # If less than two matched pairs, nesting is impossible
  if (length(pairs) < 2) return(FALSE)
  
  # Check whether any pair contains another pair inside it
  for (p1 in pairs) {
    for (p2 in pairs) {
      if (p1[1] < p2[1] && p2[2] < p1[2]) {
        return(TRUE)
      }
    }
  }
  
  FALSE
}
test_humaneval <- function() {
    candidate <- is_nested
    stopifnot(isTRUE(all.equal(candidate('[[]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[]]]]]]][[[[[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[][]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[[[]]]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[]]]]]]]]]]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[][][[]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[]]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[]][['), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[[][]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[[[[[[['), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(']]]]]]]]'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183798
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Create a function that takes a string as input which contains only square brackets.
# The function should return TRUE if and only if there is a valid subsequence of brackets 
# where at least one bracket in the subsequence is nested.
# >>> is_nested('[[]]')
# TRUE
# >>> is_nested('[]]]]]]][[[[[]')
# FALSE
# >>> is_nested('[][]')
# FALSE
# >>> is_nested('[]')
# FALSE
# >>> is_nested('[[][]]')
# TRUE
# >>> is_nested('[[]][[')
# TRUE

test_humaneval <- function() {
    candidate <- is_nested
    stopifnot(isTRUE(all.equal(candidate('[[]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[]]]]]]][[[[[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[][]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[[[]]]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[]]]]]]]]]]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[][][[]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[]]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[]][['), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[[][]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[[[[[[['), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(']]]]]]]]'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183797
STDOUT: (empty)
STDERR:
Error in test_humaneval() : object 'is_nested' not found
Execution halted
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Create a function that takes a string as input which contains only square brackets.
# The function should return TRUE if and only if there is a valid subsequence of brackets 
# where at least one bracket in the subsequence is nested.
# >>> is_nested('[[]]')
# TRUE
# >>> is_nested('[]]]]]]][[[[[]')
# FALSE
# >>> is_nested('[][]')
# FALSE
# >>> is_nested('[]')
# FALSE
# >>> is_nested('[[][]]')
# TRUE
# >>> is_nested('[[]][[')
# TRUE
#' Check if a string of brackets contains a nested subsequence
#'
#' @param string A character string consisting only of '[' and ']'.
#' @return `TRUE` if there exists a subsequence that is a valid
#'   bracket sequence with at least one level of nesting, otherwise `FALSE`.
#' @examples
#' is_nested("[[]]")     # TRUE
#' is_nested("[]]]]]]][[[[[]")  # FALSE
#' is_nested("[][]")     # FALSE
#' is_nested("[]")       # FALSE
#' is_nested("[[][]]")   # TRUE
#' is_nested("[[]][[")   # TRUE
is_nested <- function(string) {
  n <- nchar(string)
  if (n < 4) return(FALSE)

  # Find first '['
  pos1 <- regexpr("\\[", string)
  if (pos1 == -1) return(FALSE)

  # Find second '[' after the first
  pos2_sub <- substring(string, pos1 + 1)
  pos2_rel <- regexpr("\\[", pos2_sub)
  if (pos2_rel == -1) return(FALSE)
  pos2 <- pos1 + pos2_rel

  # Find first ']' after the second '['
  pos3_sub <- substring(string, pos2 + 1)
  pos3_rel <- regexpr("\\]", pos3_sub)
  if (pos3_rel == -1) return(FALSE)
  pos3 <- pos2 + pos3_rel

  # Find second ']' after the first closing bracket
  pos4_sub <- substring(string, pos3 + 1)
  pos4_rel <- regexpr("\\]", pos4_sub)
  if (pos4_rel == -1) return(FALSE)

  TRUE
}
test_humaneval <- function() {
    candidate <- is_nested
    stopifnot(isTRUE(all.equal(candidate('[[]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[]]]]]]][[[[[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[][]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[[[]]]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[]]]]]]]]]]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[][][[]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[]]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[]][['), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[[][]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[[[[[[['), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(']]]]]]]]'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183798
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Create a function that takes a string as input which contains only square brackets.
# The function should return TRUE if and only if there is a valid subsequence of brackets 
# where at least one bracket in the subsequence is nested.
# >>> is_nested('[[]]')
# TRUE
# >>> is_nested('[]]]]]]][[[[[]')
# FALSE
# >>> is_nested('[][]')
# FALSE
# >>> is_nested('[]')
# FALSE
# >>> is_nested('[[][]]')
# TRUE
# >>> is_nested('[[]][[')
# TRUE
is_nested <- function(string) {
  # Split the string into individual characters
  chars <- strsplit(string, "")[[1]]
  n <- length(chars)

  # If fewer than 4 brackets, nesting is impossible
  if (n < 4) return(FALSE)

  # Prefix counts of '[' (before each position)
  pref <- integer(n + 1)
  for (i in seq_len(n)) {
    pref[i + 1] <- pref[i] + (chars[i] == '[')
  }

  # Suffix counts of ']' (after each position)
  suff <- integer(n + 2)
  for (i in rev(seq_len(n))) {
    suff[i] <- suff[i + 1] + (chars[i] == ']')
  }

  # Check for a nested pattern: an inner '[' (position j)
  # with at least one '[' before it and at least two ']' after it
  for (j in seq_len(n)) {
    if (chars[j] == '[' && pref[j] >= 1 && suff[j + 1] >= 2) {
      return(TRUE)
    }
  }

  return(FALSE)
}
test_humaneval <- function() {
    candidate <- is_nested
    stopifnot(isTRUE(all.equal(candidate('[[]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[]]]]]]][[[[[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[][]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[[[]]]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[]]]]]]]]]]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[][][[]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[[]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[]]'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[]][['), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('[[][]]'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('[[[[[[[['), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(']]]]]]]]'), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183798
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 134 (R) - HumanEval_134_check_if_last_char_is_a_letter
================================================================================

PROMPT:
----------------------------------------
# Create a function that returns TRUE if the last character
# of a given string is an alphabetical character and is not
# a part of a word, and FALSE otherwise.
# Note: "word" is a group of characters separated by space.
# Examples:
# >>> check_if_last_char_is_a_letter('apple pie')
# FALSE
# >>> check_if_last_char_is_a_letter('apple pi e')
# TRUE
# >>> check_if_last_char_is_a_letter('apple pi e ')
# FALSE
# >>> check_if_last_char_is_a_letter('')
# FALSE

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- check_if_last_char_is_a_letter
    stopifnot(isTRUE(all.equal(candidate('apple'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pi e'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('eeeee'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('A'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie '), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie 1'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('eeeee e '), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pie'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pi e '), FALSE)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Create a function that returns TRUE if the last character
# of a given string is an alphabetical character and is not
# a part of a word, and FALSE otherwise.
# Note: "word" is a group of characters separated by space.
# Examples:
# >>> check_if_last_char_is_a_letter('apple pie')
# FALSE
# >>> check_if_last_char_is_a_letter('apple pi e')
# TRUE
# >>> check_if_last_char_is_a_letter('apple pi e ')
# FALSE
# >>> check_if_last_char_is_a_letter('')
# FALSE
check_if_last_char_is_a_letter <- function(txt) {
  # Return FALSE for an empty string
  if (nchar(txt) == 0) {
    return(FALSE)
  }

  # Get the last character
  last_char <- substr(txt, nchar(txt), nchar(txt))

  # Must be an alphabetical letter
  if (!grepl("[A-Za-z]", last_char)) {
    return(FALSE)
  }

  # If the string is only one character long, it's a single‑letter word
  if (nchar(txt) == 1) {
    return(TRUE)
  }

  # The preceding character must be a space (i.e., the letter is a
  # single‑character word at the end of the string)
  prev_char <- substr(txt, nchar(txt) - 1, nchar(txt) - 1)
  return(prev_char == " ")
}
test_humaneval <- function() {
    candidate <- check_if_last_char_is_a_letter
    stopifnot(isTRUE(all.equal(candidate('apple'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pi e'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('eeeee'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('A'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie '), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie 1'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('eeeee e '), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pie'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pi e '), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183799
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Create a function that returns TRUE if the last character
# of a given string is an alphabetical character and is not
# a part of a word, and FALSE otherwise.
# Note: "word" is a group of characters separated by space.
# Examples:
# >>> check_if_last_char_is_a_letter('apple pie')
# FALSE
# >>> check_if_last_char_is_a_letter('apple pi e')
# TRUE
# >>> check_if_last_char_is_a_letter('apple pi e ')
# FALSE
# >>> check_if_last_char_is_a_letter('')
# FALSE
check_if_last_char_is_a_letter <- function(txt) {
  # Empty string → FALSE
  if (nchar(txt) == 0) return(FALSE)
  
  # Grab the last character
  last_char <- substr(txt, nchar(txt), nchar(txt))
  
  # Must be an alphabetical character
  if (!grepl("[A-Za-z]", last_char)) return(FALSE)
  
  # If the string has only one character, it is a single‑letter word
  if (nchar(txt) == 1) return(TRUE)
  
  # Check the character before the last one
  prev_char <- substr(txt, nchar(txt) - 1, nchar(txt) - 1)
  
  # It must be a space (i.e., the letter is a separate word)
  return(prev_char == " ")
}
test_humaneval <- function() {
    candidate <- check_if_last_char_is_a_letter
    stopifnot(isTRUE(all.equal(candidate('apple'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pi e'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('eeeee'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('A'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie '), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie 1'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('eeeee e '), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pie'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pi e '), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183799
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Create a function that returns TRUE if the last character
# of a given string is an alphabetical character and is not
# a part of a word, and FALSE otherwise.
# Note: "word" is a group of characters separated by space.
# Examples:
# >>> check_if_last_char_is_a_letter('apple pie')
# FALSE
# >>> check_if_last_char_is_a_letter('apple pi e')
# TRUE
# >>> check_if_last_char_is_a_letter('apple pi e ')
# FALSE
# >>> check_if_last_char_is_a_letter('')
# FALSE
check_if_last_char_is_a_letter <- function(txt) {
  # Empty string → FALSE
  if (nchar(txt) == 0) {
    return(FALSE)
  }
  
  # Last character of the string
  last_char <- substr(txt, nchar(txt), nchar(txt))
  
  # Is the last character an alphabetical letter?
  if (!grepl("[A-Za-z]", last_char)) {
    return(FALSE)
  }
  
  # Character immediately before the last one
  if (nchar(txt) == 1) {
    # Only one character → it's a single‑letter word
    return(TRUE)
  } else {
    prev_char <- substr(txt, nchar(txt) - 1, nchar(txt) - 1)
    # If the previous character is a space (or the string ends with the letter),
    # the letter is not part of a larger word
    return(prev_char == " ")
  }
}
test_humaneval <- function() {
    candidate <- check_if_last_char_is_a_letter
    stopifnot(isTRUE(all.equal(candidate('apple'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pi e'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('eeeee'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('A'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie '), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie 1'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('eeeee e '), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pie'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pi e '), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183799
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Create a function that returns TRUE if the last character
# of a given string is an alphabetical character and is not
# a part of a word, and FALSE otherwise.
# Note: "word" is a group of characters separated by space.
# Examples:
# >>> check_if_last_char_is_a_letter('apple pie')
# FALSE
# >>> check_if_last_char_is_a_letter('apple pi e')
# TRUE
# >>> check_if_last_char_is_a_letter('apple pi e ')
# FALSE
# >>> check_if_last_char_is_a_letter('')
# FALSE
check_if_last_char_is_a_letter <- function(txt) {
  # Return FALSE for empty or whitespace‑only strings
  if (!nzchar(txt)) return(FALSE)
  
  # Remove any trailing spaces so we examine the true last character
  txt <- trimws(txt, which = "right")
  if (nchar(txt) == 0) return(FALSE)
  
  # Extract the last character
  last_char <- substr(txt, nchar(txt), nchar(txt))
  
  # Must be an alphabetical character
  if (!grepl("[A-Za-z]", last_char)) return(FALSE)
  
  # If the string is a single character, it is a single‑letter word
  if (nchar(txt) == 1) return(TRUE)
  
  # The character before the last one must be a space (i.e., the last
  # character is a separate word)
  prev_char <- substr(txt, nchar(txt) - 1, nchar(txt) - 1)
  return(prev_char == " ")
}
test_humaneval <- function() {
    candidate <- check_if_last_char_is_a_letter
    stopifnot(isTRUE(all.equal(candidate('apple'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pi e'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('eeeee'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('A'), TRUE)))
    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie '), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie 1'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('eeeee e '), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pie'), FALSE)))
    stopifnot(isTRUE(all.equal(candidate('apple pi e '), FALSE)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183799
STDOUT: (empty)
STDERR:
Error in test_humaneval() : 
  isTRUE(all.equal(candidate("eeeee e "), FALSE)) is not TRUE
Calls: test_humaneval -> stopifnot
Execution halted
--------------------

================================================================================
PROBLEM 141 (R) - HumanEval_141_file_name_check
================================================================================

PROMPT:
----------------------------------------
# Create a function which takes a string representing a file's name, and returns
# 'Yes' if the the file's name is valid, and returns 'No' otherwise.
# A file's name is considered to be valid if and only if all the following conditions 
# are met:
# - There should not be more than three digits ('0'-'9') in the file's name.
# - The file's name contains exactly one dot '.'
# - The substring before the dot should not be empty, and it starts with a letter from 
# the latin alphapet ('a'-'z' and 'A'-'Z').
# - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
# Examples:
# >>> file_name_check('example.txt')
# 'Yes'
# >>> file_name_check('1example.dll')
# 'No'

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- file_name_check
    stopifnot(isTRUE(all.equal(candidate('example.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('1example.dll'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('s1sdf3.asd'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('K.dll'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('MY16FILE3.exe'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('His12FILE94.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('_Y.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('?aREYA.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('/this_is_valid.dll'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.wow'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txtexe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('#this2_i4s_5valid.ten'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('@this1_is6_valid.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_12valid.6exe4.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('all.exe.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('I563_No.exe'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('Is3youfault.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('no_one#knows.dll'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('1I563_Yes3.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('I563_Yes3.txtt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('final..txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('final132'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('_f4indsartal132.'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('s.'), 'No')))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# Create a function which takes a string representing a file's name, and returns
# 'Yes' if the the file's name is valid, and returns 'No' otherwise.
# A file's name is considered to be valid if and only if all the following conditions 
# are met:
# - There should not be more than three digits ('0'-'9') in the file's name.
# - The file's name contains exactly one dot '.'
# - The substring before the dot should not be empty, and it starts with a letter from 
# the latin alphapet ('a'-'z' and 'A'-'Z').
# - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
# Examples:
# >>> file_name_check('example.txt')
# 'Yes'
# >>> file_name_check('1example.dll')
# 'No'
file_name_check <- function(file_name) {
  # Split the name by the dot character
  parts <- strsplit(file_name, ".", fixed = TRUE)[[1]]
  
  # Must contain exactly one dot
  if (length(parts) != 2) {
    return('No')
  }
  
  prefix <- parts[1]
  suffix <- parts[2]
  
  # Prefix must not be empty and must start with a Latin letter
  if (prefix == "" || !grepl("^[A-Za-z]", prefix)) {
    return('No')
  }
  
  # Suffix must be one of the allowed extensions
  if (!suffix %in% c('txt', 'exe', 'dll')) {
    return('No')
  }
  
  # Count digits in the entire file name (including the extension)
  digits_count <- sum(grepl("\\d", strsplit(file_name, "")[[1]]))
  if (digits_count > 3) {
    return('No')
  }
  
  return('Yes')
}
test_humaneval <- function() {
    candidate <- file_name_check
    stopifnot(isTRUE(all.equal(candidate('example.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('1example.dll'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('s1sdf3.asd'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('K.dll'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('MY16FILE3.exe'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('His12FILE94.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('_Y.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('?aREYA.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('/this_is_valid.dll'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.wow'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txtexe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('#this2_i4s_5valid.ten'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('@this1_is6_valid.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_12valid.6exe4.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('all.exe.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('I563_No.exe'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('Is3youfault.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('no_one#knows.dll'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('1I563_Yes3.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('I563_Yes3.txtt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('final..txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('final132'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('_f4indsartal132.'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('s.'), 'No')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183802
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# Create a function which takes a string representing a file's name, and returns
# 'Yes' if the the file's name is valid, and returns 'No' otherwise.
# A file's name is considered to be valid if and only if all the following conditions 
# are met:
# - There should not be more than three digits ('0'-'9') in the file's name.
# - The file's name contains exactly one dot '.'
# - The substring before the dot should not be empty, and it starts with a letter from 
# the latin alphapet ('a'-'z' and 'A'-'Z').
# - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
# Examples:
# >>> file_name_check('example.txt')
# 'Yes'
# >>> file_name_check('1example.dll')
# 'No'
file_name_check <- function(file_name) {
  # 1. Exactly one dot
  dot_parts <- strsplit(file_name, ".", fixed = TRUE)[[1]]
  if (length(dot_parts) != 2) return('No')
  
  # 2. Substring before the dot
  name_part <- dot_parts[1]
  if (nchar(name_part) == 0) return('No')
  if (!grepl('^[A-Za-z]', name_part)) return('No')
  
  # 3. Substring after the dot
  ext_part <- dot_parts[2]
  if (!ext_part %in% c('txt', 'exe', 'dll')) return('No')
  
  # 4. No more than three digits in the entire file name
  digit_count <- sum(grepl('[0-9]', strsplit(file_name, NULL)[[1]]))
  if (digit_count > 3) return('No')
  
  # All checks passed
  'Yes'
}
test_humaneval <- function() {
    candidate <- file_name_check
    stopifnot(isTRUE(all.equal(candidate('example.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('1example.dll'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('s1sdf3.asd'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('K.dll'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('MY16FILE3.exe'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('His12FILE94.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('_Y.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('?aREYA.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('/this_is_valid.dll'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.wow'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txtexe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('#this2_i4s_5valid.ten'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('@this1_is6_valid.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_12valid.6exe4.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('all.exe.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('I563_No.exe'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('Is3youfault.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('no_one#knows.dll'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('1I563_Yes3.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('I563_Yes3.txtt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('final..txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('final132'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('_f4indsartal132.'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('s.'), 'No')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183802
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# Create a function which takes a string representing a file's name, and returns
# 'Yes' if the the file's name is valid, and returns 'No' otherwise.
# A file's name is considered to be valid if and only if all the following conditions 
# are met:
# - There should not be more than three digits ('0'-'9') in the file's name.
# - The file's name contains exactly one dot '.'
# - The substring before the dot should not be empty, and it starts with a letter from 
# the latin alphapet ('a'-'z' and 'A'-'Z').
# - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
# Examples:
# >>> file_name_check('example.txt')
# 'Yes'
# >>> file_name_check('1example.dll')
# 'No'
file_name_check <- function(file_name) {
  # Regular expression that enforces:
  # 1. At most 3 digits in the whole string.
  # 2. Exactly one dot.
  # 3. Non‑empty prefix that starts with a letter.
  # 4. Suffix must be one of txt, exe, dll.
  #
  # The look‑ahead `(?=(?:.*\d){0,3}$)` guarantees the digit count.
  #
  # Example of the pattern:
  # ^(?=(?:.*\d){0,3}$)[A-Za-z][A-Za-z0-9]*\.(txt|exe|dll)$
  #
  pattern <- "^(?=(?:.*\\d){0,3}$)[A-Za-z][A-Za-z0-9]*\\.(txt|exe|dll)$"
  
  if (grepl(pattern, file_name, perl = TRUE)) {
    return("Yes")
  } else {
    return("No")
  }
}
test_humaneval <- function() {
    candidate <- file_name_check
    stopifnot(isTRUE(all.equal(candidate('example.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('1example.dll'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('s1sdf3.asd'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('K.dll'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('MY16FILE3.exe'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('His12FILE94.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('_Y.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('?aREYA.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('/this_is_valid.dll'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.wow'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txtexe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('#this2_i4s_5valid.ten'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('@this1_is6_valid.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_12valid.6exe4.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('all.exe.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('I563_No.exe'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('Is3youfault.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('no_one#knows.dll'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('1I563_Yes3.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('I563_Yes3.txtt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('final..txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('final132'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('_f4indsartal132.'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('s.'), 'No')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183802
STDOUT: (empty)
STDERR:
Error in test_humaneval() : 
  isTRUE(all.equal(candidate("example.txt"), "Yes")) is not TRUE
Calls: test_humaneval -> stopifnot
Execution halted
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# Create a function which takes a string representing a file's name, and returns
# 'Yes' if the the file's name is valid, and returns 'No' otherwise.
# A file's name is considered to be valid if and only if all the following conditions 
# are met:
# - There should not be more than three digits ('0'-'9') in the file's name.
# - The file's name contains exactly one dot '.'
# - The substring before the dot should not be empty, and it starts with a letter from 
# the latin alphapet ('a'-'z' and 'A'-'Z').
# - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
# Examples:
# >>> file_name_check('example.txt')
# 'Yes'
# >>> file_name_check('1example.dll')
# 'No'
file_name_check <- function(file_name) {
  # Split the name by dot. There must be exactly one dot.
  parts <- strsplit(file_name, ".", fixed = TRUE)[[1]]
  if (length(parts) != 2) return("No")
  
  name_part <- parts[1]
  ext_part  <- parts[2]
  
  # Count digits in the whole file name – must not exceed 3.
  digit_positions <- gregexpr("[0-9]", file_name)[[1]]
  digit_count <- if (digit_positions[1] == -1) 0 else length(digit_positions)
  if (digit_count > 3) return("No")
  
  # The part before the dot must not be empty and must start with a latin letter.
  if (nchar(name_part) == 0) return("No")
  if (!grepl("^[A-Za-z]", name_part)) return("No")
  
  # The part after the dot must be one of the allowed extensions.
  if (!(ext_part %in% c("txt", "exe", "dll"))) return("No")
  
  # All checks passed
  return("Yes")
}
test_humaneval <- function() {
    candidate <- file_name_check
    stopifnot(isTRUE(all.equal(candidate('example.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('1example.dll'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('s1sdf3.asd'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('K.dll'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('MY16FILE3.exe'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('His12FILE94.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('_Y.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('?aREYA.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('/this_is_valid.dll'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.wow'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txtexe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('#this2_i4s_5valid.ten'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('@this1_is6_valid.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('this_is_12valid.6exe4.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('all.exe.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('I563_No.exe'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('Is3youfault.txt'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('no_one#knows.dll'), 'Yes')))
    stopifnot(isTRUE(all.equal(candidate('1I563_Yes3.exe'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('I563_Yes3.txtt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('final..txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('final132'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('_f4indsartal132.'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('.txt'), 'No')))
    stopifnot(isTRUE(all.equal(candidate('s.'), 'No')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183802
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 147 (R) - HumanEval_147_get_max_triples
================================================================================

PROMPT:
----------------------------------------
# You are given a positive integer n. You have to create an integer vector a of length n.
# For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
# Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
#     and a[i] + a[j] + a[k] is a multiple of 3.
#     Example :
#     >>> get_max_triples(5)
#     1
# Explanation: 
# a = [1, 3, 7, 13, 21]
# The only valid triple is (1, 7, 13).

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- get_max_triples
    stopifnot(isTRUE(all.equal(candidate(5), 1)))
    stopifnot(isTRUE(all.equal(candidate(6), 4)))
    stopifnot(isTRUE(all.equal(candidate(10), 36)))
    stopifnot(isTRUE(all.equal(candidate(100), 53361)))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# You are given a positive integer n. You have to create an integer vector a of length n.
# For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
# Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
#     and a[i] + a[j] + a[k] is a multiple of 3.
#     Example :
#     >>> get_max_triples(5)
#     1
# Explanation: 
# a = [1, 3, 7, 13, 21]
# The only valid triple is (1, 7, 13).
get_max_triples <- function(n) {
  # Count indices with i mod 3 == 2 (residue 0)
  cnt0 <- floor((n + 1) / 3)
  # Remaining indices have residue 1
  cnt1 <- n - cnt0
  
  # Helper to compute combinations C(x,3)
  comb3 <- function(x) {
    if (x < 3) return(0L)
    as.integer(x * (x - 1) * (x - 2) / 6)
  }
  
  # Total triples with sum divisible by 3
  comb3(cnt0) + comb3(cnt1)
}
test_humaneval <- function() {
    candidate <- get_max_triples
    stopifnot(isTRUE(all.equal(candidate(5), 1)))
    stopifnot(isTRUE(all.equal(candidate(6), 4)))
    stopifnot(isTRUE(all.equal(candidate(10), 36)))
    stopifnot(isTRUE(all.equal(candidate(100), 53361)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183805
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# You are given a positive integer n. You have to create an integer vector a of length n.
# For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
# Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
#     and a[i] + a[j] + a[k] is a multiple of 3.
#     Example :
#     >>> get_max_triples(5)
#     1
# Explanation: 
# a = [1, 3, 7, 13, 21]
# The only valid triple is (1, 7, 13).
get_max_triples <- function(n) {
  # No triples possible if fewer than 3 elements
  if (n < 3) return(0L)
  
  # Count indices i with i ≡ 2 (mod 3)  →  a[i] ≡ 0 (mod 3)
  c0 <- floor((n + 1) / 3)          # number of 0‑mod‑3 elements
  
  # Remaining indices have a[i] ≡ 1 (mod 3)
  c1 <- n - c0
  
  # Helper to compute n choose 3 without overflow
  comb3 <- function(x) {
    if (x < 3) return(0L)
    as.integer(x * (x - 1) * (x - 2) / 6)
  }
  
  # Triples all from the 0‑mod‑3 group + triples all from the 1‑mod‑3 group
  result <- comb3(c0) + comb3(c1)
  return(result)
}
test_humaneval <- function() {
    candidate <- get_max_triples
    stopifnot(isTRUE(all.equal(candidate(5), 1)))
    stopifnot(isTRUE(all.equal(candidate(6), 4)))
    stopifnot(isTRUE(all.equal(candidate(10), 36)))
    stopifnot(isTRUE(all.equal(candidate(100), 53361)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183805
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# You are given a positive integer n. You have to create an integer vector a of length n.
# For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
# Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
#     and a[i] + a[j] + a[k] is a multiple of 3.
#     Example :
#     >>> get_max_triples(5)
#     1
# Explanation: 
# a = [1, 3, 7, 13, 21]
# The only valid triple is (1, 7, 13).
get_max_triples <- function(n) {
  # Count indices with remainder 2 (mod 3) – these give a[i] ≡ 0 (mod 3)
  count0 <- (n + 1) %/% 3
  
  # The remaining indices give a[i] ≡ 1 (mod 3)
  count1 <- n - count0
  
  # Helper to compute C(k,3) safely
  choose3 <- function(k) {
    if (k < 3) return(0L)
    return(k * (k - 1) * (k - 2) %/% 6)
  }
  
  # Triples are valid if all three indices are in the same residue class
  result <- choose3(count0) + choose3(count1)
  return(result)
}
test_humaneval <- function() {
    candidate <- get_max_triples
    stopifnot(isTRUE(all.equal(candidate(5), 1)))
    stopifnot(isTRUE(all.equal(candidate(6), 4)))
    stopifnot(isTRUE(all.equal(candidate(10), 36)))
    stopifnot(isTRUE(all.equal(candidate(100), 53361)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183805
STDOUT: (empty)
STDERR:
Error in test_humaneval() : 
  isTRUE(all.equal(candidate(5), 1)) is not TRUE
Calls: test_humaneval -> stopifnot
Execution halted
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# You are given a positive integer n. You have to create an integer vector a of length n.
# For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
# Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
#     and a[i] + a[j] + a[k] is a multiple of 3.
#     Example :
#     >>> get_max_triples(5)
#     1
# Explanation: 
# a = [1, 3, 7, 13, 21]
# The only valid triple is (1, 7, 13).
#' Count triples of a[i] = i^2 - i + 1 with sum divisible by 3
#'
#' @param n positive integer
#' @return integer number of triples (i < j < k) such that
#'   a[i] + a[j] + a[k] is a multiple of 3
#' @examples
#' get_max_triples(5)   # returns 1
#' get_max_triples(10)  # returns 8
#' @export
get_max_triples <- function(n) {
  if (!is.numeric(n) || length(n) != 1 || n <= 0 || floor(n) != n) {
    stop("n must be a positive integer")
  }

  # Count of indices with i ≡ 2 (mod 3) → residue 0
  c0 <- floor((n + 1) / 3)

  # Remaining indices give residue 1
  c1 <- n - c0

  # Helper to compute binomial coefficient choose(k,3)
  choose3 <- function(k) {
    if (k < 3) return(0L)
    # Use integer arithmetic to avoid overflow
    as.integer(k * (k - 1) * (k - 2) / 6)
  }

  result <- choose3(c0) + choose3(c1)
  return(result)
}
test_humaneval <- function() {
    candidate <- get_max_triples
    stopifnot(isTRUE(all.equal(candidate(5), 1)))
    stopifnot(isTRUE(all.equal(candidate(6), 4)))
    stopifnot(isTRUE(all.equal(candidate(10), 36)))
    stopifnot(isTRUE(all.equal(candidate(100), 53361)))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183805
STDOUT: (empty)
STDERR: (empty)
--------------------

================================================================================
PROBLEM 153 (R) - HumanEval_153_Strongest_Extension
================================================================================

PROMPT:
----------------------------------------
# You will be given the name of a class (a string) and a list of extensions.
# The extensions are to be used to load additional classes to the class. The
# strength of the extension is as follows: Let CAP be the number of the uppercase
# letters in the extension's name, and let SM be the number of lowercase letters 
# in the extension's name, the strength is given by the fraction CAP - SM. 
# You should find the strongest extension and return a string in this 
# format: ClassName.StrongestExtensionName.
# If there are two or more extensions with the same strength, you should
# choose the one that comes first in the list.
# For example, if you are given "Slices" as the class and a list of the
# extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
# return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
# (its strength is -1).
# Example:
# >>> Strongest_Extension('my_class', c('AA', 'Be', 'CC'))
# 'my_class.AA'

----------------------------------------

TEST CASES:
----------------------------------------
test_humaneval <- function() {
    candidate <- Strongest_Extension
    stopifnot(isTRUE(all.equal(candidate('Watashi', c('tEN', 'niNE', 'eIGHt8OKe')), 'Watashi.eIGHt8OKe')))
    stopifnot(isTRUE(all.equal(candidate('Boku123', c('nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg')), 'Boku123.YEs.WeCaNe')))
    stopifnot(isTRUE(all.equal(candidate('__YESIMHERE', c('t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321')), '__YESIMHERE.NuLl__')))
    stopifnot(isTRUE(all.equal(candidate('K', c('Ta', 'TAR', 't234An', 'cosSo')), 'K.TAR')))
    stopifnot(isTRUE(all.equal(candidate('__HAHA', c('Tab', '123', '781345', '-_-')), '__HAHA.123')))
    stopifnot(isTRUE(all.equal(candidate('YameRore', c('HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-')), 'YameRore.okIWILL123')))
    stopifnot(isTRUE(all.equal(candidate('finNNalLLly', c('Die', 'NowW', 'Wow', 'WoW')), 'finNNalLLly.WoW')))
    stopifnot(isTRUE(all.equal(candidate('_', c('Bb', '91245')), '_.Bb')))
    stopifnot(isTRUE(all.equal(candidate('Sp', c('671235', 'Bb')), 'Sp.671235')))
}
test_humaneval()
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
# You will be given the name of a class (a string) and a list of extensions.
# The extensions are to be used to load additional classes to the class. The
# strength of the extension is as follows: Let CAP be the number of the uppercase
# letters in the extension's name, and let SM be the number of lowercase letters 
# in the extension's name, the strength is given by the fraction CAP - SM. 
# You should find the strongest extension and return a string in this 
# format: ClassName.StrongestExtensionName.
# If there are two or more extensions with the same strength, you should
# choose the one that comes first in the list.
# For example, if you are given "Slices" as the class and a list of the
# extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
# return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
# (its strength is -1).
# Example:
# >>> Strongest_Extension('my_class', c('AA', 'Be', 'CC'))
# 'my_class.AA'
Strongest_Extension <- function(class_name, extensions) {
  # Compute strength for each extension
  strengths <- sapply(extensions, function(ext) {
    chars <- strsplit(ext, "")[[1]]
    caps   <- sum(grepl("[A-Z]", chars))
    lowers <- sum(grepl("[a-z]", chars))
    caps - lowers
  })
  
  # Find the index of the strongest extension (first in case of ties)
  best_idx <- which.max(strengths)
  
  # Return the combined string
  paste0(class_name, ".", extensions[best_idx])
}
test_humaneval <- function() {
    candidate <- Strongest_Extension
    stopifnot(isTRUE(all.equal(candidate('Watashi', c('tEN', 'niNE', 'eIGHt8OKe')), 'Watashi.eIGHt8OKe')))
    stopifnot(isTRUE(all.equal(candidate('Boku123', c('nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg')), 'Boku123.YEs.WeCaNe')))
    stopifnot(isTRUE(all.equal(candidate('__YESIMHERE', c('t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321')), '__YESIMHERE.NuLl__')))
    stopifnot(isTRUE(all.equal(candidate('K', c('Ta', 'TAR', 't234An', 'cosSo')), 'K.TAR')))
    stopifnot(isTRUE(all.equal(candidate('__HAHA', c('Tab', '123', '781345', '-_-')), '__HAHA.123')))
    stopifnot(isTRUE(all.equal(candidate('YameRore', c('HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-')), 'YameRore.okIWILL123')))
    stopifnot(isTRUE(all.equal(candidate('finNNalLLly', c('Die', 'NowW', 'Wow', 'WoW')), 'finNNalLLly.WoW')))
    stopifnot(isTRUE(all.equal(candidate('_', c('Bb', '91245')), '_.Bb')))
    stopifnot(isTRUE(all.equal(candidate('Sp', c('671235', 'Bb')), 'Sp.671235')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183808
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
# You will be given the name of a class (a string) and a list of extensions.
# The extensions are to be used to load additional classes to the class. The
# strength of the extension is as follows: Let CAP be the number of the uppercase
# letters in the extension's name, and let SM be the number of lowercase letters 
# in the extension's name, the strength is given by the fraction CAP - SM. 
# You should find the strongest extension and return a string in this 
# format: ClassName.StrongestExtensionName.
# If there are two or more extensions with the same strength, you should
# choose the one that comes first in the list.
# For example, if you are given "Slices" as the class and a list of the
# extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
# return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
# (its strength is -1).
# Example:
# >>> Strongest_Extension('my_class', c('AA', 'Be', 'CC'))
# 'my_class.AA'
Strongest_Extension <- function(class_name, extensions) {
  # Calculate the strength for each extension
  strengths <- sapply(extensions, function(ext) {
    # Split the string into individual characters
    chars <- strsplit(ext, "")[[1]]
    # Count uppercase and lowercase letters
    caps   <- sum(chars %in% LETTERS)
    lowers <- sum(chars %in% letters)
    # Strength is the difference CAP - SM
    caps - lowers
  })
  
  # Find the index of the strongest extension (first in case of ties)
  best_index <- which.max(strengths)
  
  # Return the combined string
  paste(class_name, extensions[best_index], sep = ".")
}
test_humaneval <- function() {
    candidate <- Strongest_Extension
    stopifnot(isTRUE(all.equal(candidate('Watashi', c('tEN', 'niNE', 'eIGHt8OKe')), 'Watashi.eIGHt8OKe')))
    stopifnot(isTRUE(all.equal(candidate('Boku123', c('nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg')), 'Boku123.YEs.WeCaNe')))
    stopifnot(isTRUE(all.equal(candidate('__YESIMHERE', c('t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321')), '__YESIMHERE.NuLl__')))
    stopifnot(isTRUE(all.equal(candidate('K', c('Ta', 'TAR', 't234An', 'cosSo')), 'K.TAR')))
    stopifnot(isTRUE(all.equal(candidate('__HAHA', c('Tab', '123', '781345', '-_-')), '__HAHA.123')))
    stopifnot(isTRUE(all.equal(candidate('YameRore', c('HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-')), 'YameRore.okIWILL123')))
    stopifnot(isTRUE(all.equal(candidate('finNNalLLly', c('Die', 'NowW', 'Wow', 'WoW')), 'finNNalLLly.WoW')))
    stopifnot(isTRUE(all.equal(candidate('_', c('Bb', '91245')), '_.Bb')))
    stopifnot(isTRUE(all.equal(candidate('Sp', c('671235', 'Bb')), 'Sp.671235')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183808
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
# You will be given the name of a class (a string) and a list of extensions.
# The extensions are to be used to load additional classes to the class. The
# strength of the extension is as follows: Let CAP be the number of the uppercase
# letters in the extension's name, and let SM be the number of lowercase letters 
# in the extension's name, the strength is given by the fraction CAP - SM. 
# You should find the strongest extension and return a string in this 
# format: ClassName.StrongestExtensionName.
# If there are two or more extensions with the same strength, you should
# choose the one that comes first in the list.
# For example, if you are given "Slices" as the class and a list of the
# extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
# return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
# (its strength is -1).
# Example:
# >>> Strongest_Extension('my_class', c('AA', 'Be', 'CC'))
# 'my_class.AA'
Strongest_Extension <- function(class_name, extensions) {
  # Compute strength for each extension: (#uppercase) - (#lowercase)
  strengths <- sapply(extensions, function(ext) {
    cap <- nchar(gsub("[^A-Z]", "", ext))
    sm  <- nchar(gsub("[^a-z]", "", ext))
    cap - sm
  })
  
  # Find index of the first maximum strength
  best_idx <- which.max(strengths)
  
  # Construct and return the result string
  paste(class_name, extensions[best_idx], sep = ".")
}
test_humaneval <- function() {
    candidate <- Strongest_Extension
    stopifnot(isTRUE(all.equal(candidate('Watashi', c('tEN', 'niNE', 'eIGHt8OKe')), 'Watashi.eIGHt8OKe')))
    stopifnot(isTRUE(all.equal(candidate('Boku123', c('nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg')), 'Boku123.YEs.WeCaNe')))
    stopifnot(isTRUE(all.equal(candidate('__YESIMHERE', c('t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321')), '__YESIMHERE.NuLl__')))
    stopifnot(isTRUE(all.equal(candidate('K', c('Ta', 'TAR', 't234An', 'cosSo')), 'K.TAR')))
    stopifnot(isTRUE(all.equal(candidate('__HAHA', c('Tab', '123', '781345', '-_-')), '__HAHA.123')))
    stopifnot(isTRUE(all.equal(candidate('YameRore', c('HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-')), 'YameRore.okIWILL123')))
    stopifnot(isTRUE(all.equal(candidate('finNNalLLly', c('Die', 'NowW', 'Wow', 'WoW')), 'finNNalLLly.WoW')))
    stopifnot(isTRUE(all.equal(candidate('_', c('Bb', '91245')), '_.Bb')))
    stopifnot(isTRUE(all.equal(candidate('Sp', c('671235', 'Bb')), 'Sp.671235')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755183808
STDOUT: (empty)
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
# You will be given the name of a class (a string) and a list of extensions.
# The extensions are to be used to load additional classes to the class. The
# strength of the extension is as follows: Let CAP be the number of the uppercase
# letters in the extension's name, and let SM be the number of lowercase letters 
# in the extension's name, the strength is given by the fraction CAP - SM. 
# You should find the strongest extension and return a string in this 
# format: ClassName.StrongestExtensionName.
# If there are two or more extensions with the same strength, you should
# choose the one that comes first in the list.
# For example, if you are given "Slices" as the class and a list of the
# extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
# return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
# (its strength is -1).
# Example:
# >>> Strongest_Extension('my_class', c('AA', 'Be', 'CC'))
# 'my_class.AA'
Strongest_Extension <- function(class_name, extensions) {
  # Compute strength for each extension: (# uppercase) - (# lowercase)
  strengths <- sapply(extensions, function(ext) {
    cap  <- sum(grepl("[A-Z]", ext))
    sm   <- sum(grepl("[a-z]", ext))
    cap - sm
  })
  
  # Find the index of the first extension with maximum strength
  max_strength <- max(strengths)
  idx <- which(strengths == max_strength)[1]
  
  # Return the formatted string
  paste(class_name, extensions[idx], sep = ".")
}
test_humaneval <- function() {
    candidate <- Strongest_Extension
    stopifnot(isTRUE(all.equal(candidate('Watashi', c('tEN', 'niNE', 'eIGHt8OKe')), 'Watashi.eIGHt8OKe')))
    stopifnot(isTRUE(all.equal(candidate('Boku123', c('nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg')), 'Boku123.YEs.WeCaNe')))
    stopifnot(isTRUE(all.equal(candidate('__YESIMHERE', c('t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321')), '__YESIMHERE.NuLl__')))
    stopifnot(isTRUE(all.equal(candidate('K', c('Ta', 'TAR', 't234An', 'cosSo')), 'K.TAR')))
    stopifnot(isTRUE(all.equal(candidate('__HAHA', c('Tab', '123', '781345', '-_-')), '__HAHA.123')))
    stopifnot(isTRUE(all.equal(candidate('YameRore', c('HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-')), 'YameRore.okIWILL123')))
    stopifnot(isTRUE(all.equal(candidate('finNNalLLly', c('Die', 'NowW', 'Wow', 'WoW')), 'finNNalLLly.WoW')))
    stopifnot(isTRUE(all.equal(candidate('_', c('Bb', '91245')), '_.Bb')))
    stopifnot(isTRUE(all.equal(candidate('Sp', c('671235', 'Bb')), 'Sp.671235')))
}
test_humaneval()

EXECUTION RESULTS:
Exit Code: 1
Status: Exception
Timestamp: 1755183808
STDOUT: (empty)
STDERR:
Error in test_humaneval() : 
  isTRUE(all.equal(candidate("Watashi", c("tEN", "niNE", "eIGHt8OKe")),  .... is not TRUE
Calls: test_humaneval -> stopifnot
Execution halted
--------------------
