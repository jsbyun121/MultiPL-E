As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3–7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 154 (LUA) - HumanEval_154_cycpattern_check
================================================================================

PROMPT:
----------------------------------------
-- You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word
-- >>> cycpattern_check('abcd', 'abd')
-- false
-- >>> cycpattern_check('hello', 'ell')
-- true
-- >>> cycpattern_check('whassup', 'psus')
-- false
-- >>> cycpattern_check('abab', 'baa')
-- true
-- >>> cycpattern_check('efef', 'eeff')
-- false
-- >>> cycpattern_check('himenss', 'simen')
-- true

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = cycpattern_check
    lu.assertEquals(candidate('xyzw', 'xyw'), false)
    lu.assertEquals(candidate('yello', 'ell'), true)
    lu.assertEquals(candidate('whattup', 'ptut'), false)
    lu.assertEquals(candidate('efef', 'fee'), true)
    lu.assertEquals(candidate('abab', 'aabb'), false)
    lu.assertEquals(candidate('winemtt', 'tinem'), true)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word
-- >>> cycpattern_check('abcd', 'abd')
-- false
-- >>> cycpattern_check('hello', 'ell')
-- true
-- >>> cycpattern_check('whassup', 'psus')
-- false
-- >>> cycpattern_check('abab', 'baa')
-- true
-- >>> cycpattern_check('efef', 'eeff')
-- false
-- >>> cycpattern_check('himenss', 'simen')
-- true
-- Check if the second word or any of its rotations appears as a substring in the first word
local function cycpattern_check(a, b)
    local la, lb = #a, #b

    -- If the pattern is longer than the text, it can never match
    if lb > la then return false end

    -- Generate all rotations of b
    for i = 0, lb - 1 do
        -- Rotation: take substring from i+1 to end, then prepend the prefix of length i
        local rotation = b:sub(i + 1, lb) .. b:sub(1, i)
        -- Check if this rotation is a substring of a
        if a:find(rotation, 1, true) then
            return true
        end
    end

    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = cycpattern_check
    lu.assertEquals(candidate('xyzw', 'xyw'), false)
    lu.assertEquals(candidate('yello', 'ell'), true)
    lu.assertEquals(candidate('whattup', 'ptut'), false)
    lu.assertEquals(candidate('efef', 'fee'), true)
    lu.assertEquals(candidate('abab', 'aabb'), false)
    lu.assertEquals(candidate('winemtt', 'tinem'), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word
-- >>> cycpattern_check('abcd', 'abd')
-- false
-- >>> cycpattern_check('hello', 'ell')
-- true
-- >>> cycpattern_check('whassup', 'psus')
-- false
-- >>> cycpattern_check('abab', 'baa')
-- true
-- >>> cycpattern_check('efef', 'eeff')
-- false
-- >>> cycpattern_check('himenss', 'simen')
-- true
-- Returns true if `b` or any of its rotations is a substring of `a`
local function cycpattern_check(a, b)
    -- Quick edge‑case checks
    if not a or not b then return false end
    local n = #b
    if n == 0 then return true end  -- empty pattern matches trivially

    for i = 1, n do
        -- Build rotation: start at position i and wrap around
        local rot = string.sub(b, i) .. string.sub(b, 1, i - 1)
        if a:find(rot, 1, true) then  -- plain substring search
            return true
        end
    end
    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = cycpattern_check
    lu.assertEquals(candidate('xyzw', 'xyw'), false)
    lu.assertEquals(candidate('yello', 'ell'), true)
    lu.assertEquals(candidate('whattup', 'ptut'), false)
    lu.assertEquals(candidate('efef', 'fee'), true)
    lu.assertEquals(candidate('abab', 'aabb'), false)
    lu.assertEquals(candidate('winemtt', 'tinem'), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word
-- >>> cycpattern_check('abcd', 'abd')
-- false
-- >>> cycpattern_check('hello', 'ell')
-- true
-- >>> cycpattern_check('whassup', 'psus')
-- false
-- >>> cycpattern_check('abab', 'baa')
-- true
-- >>> cycpattern_check('efef', 'eeff')
-- false
-- >>> cycpattern_check('himenss', 'simen')
-- true
-- Cyclic pattern check: true if any rotation of `b` is a substring of `a`
local function cycpattern_check(a, b)
    local n = #b
    if n == 0 then
        -- An empty string is always a substring
        return true
    end

    for i = 1, n do
        -- Build the i‑th rotation of b
        local rotation = b:sub(i) .. b:sub(1, i - 1)
        -- Check for a plain substring match
        if a:find(rotation, 1, true) then
            return true
        end
    end
    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = cycpattern_check
    lu.assertEquals(candidate('xyzw', 'xyw'), false)
    lu.assertEquals(candidate('yello', 'ell'), true)
    lu.assertEquals(candidate('whattup', 'ptut'), false)
    lu.assertEquals(candidate('efef', 'fee'), true)
    lu.assertEquals(candidate('abab', 'aabb'), false)
    lu.assertEquals(candidate('winemtt', 'tinem'), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word
-- >>> cycpattern_check('abcd', 'abd')
-- false
-- >>> cycpattern_check('hello', 'ell')
-- true
-- >>> cycpattern_check('whassup', 'psus')
-- false
-- >>> cycpattern_check('abab', 'baa')
-- true
-- >>> cycpattern_check('efef', 'eeff')
-- false
-- >>> cycpattern_check('himenss', 'simen')
-- true
-- Function to check if any rotation of string `b` is a substring of string `a`
local function cycpattern_check(a, b)
    local len_b = #b
    -- If `b` is longer than `a`, no rotation can be a substring
    if len_b > #a then
        return false
    end

    -- Generate all rotations of `b` and check each against `a`
    for i = 0, len_b - 1 do
        -- Rotation: take suffix starting at i+1 and prepend prefix of length i
        local rotation = string.sub(b, i + 1) .. string.sub(b, 1, i)
        if string.find(a, rotation, 1, true) then
            return true
        end
    end

    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = cycpattern_check
    lu.assertEquals(candidate('xyzw', 'xyw'), false)
    lu.assertEquals(candidate('yello', 'ell'), true)
    lu.assertEquals(candidate('whattup', 'ptut'), false)
    lu.assertEquals(candidate('efef', 'fee'), true)
    lu.assertEquals(candidate('abab', 'aabb'), false)
    lu.assertEquals(candidate('winemtt', 'tinem'), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 155 (LUA) - HumanEval_155_even_odd_count
================================================================================

PROMPT:
----------------------------------------
-- Given an integer. return a table that has the number of even and odd digits respectively.
-- Example:
--     >>> even_odd_count(-12)
--     {1, 1}
--     >>> even_odd_count(123)
--     {1, 2}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = even_odd_count
    lu.assertEquals(candidate(7), {0, 1})
    lu.assertEquals(candidate(-78), {1, 1})
    lu.assertEquals(candidate(3452), {2, 2})
    lu.assertEquals(candidate(346211), {3, 3})
    lu.assertEquals(candidate(-345821), {3, 3})
    lu.assertEquals(candidate(-2), {1, 0})
    lu.assertEquals(candidate(-45347), {2, 3})
    lu.assertEquals(candidate(0), {1, 0})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given an integer. return a table that has the number of even and odd digits respectively.
-- Example:
--     >>> even_odd_count(-12)
--     {1, 1}
--     >>> even_odd_count(123)
--     {1, 2}
-- Return a table with the number of even and odd digits in the given integer.
-- The first element is the count of even digits, the second is the count of odd digits.
local function even_odd_count(num)
    local even, odd = 0, 0
    -- Work with the absolute value to ignore the sign.
    local s = tostring(math.abs(num))
    for i = 1, #s do
        local d = tonumber(s:sub(i, i))
        if d then
            if d % 2 == 0 then
                even = even + 1
            else
                odd = odd + 1
            end
        end
    end
    return {even, odd}
end
lu = require('luaunit')

function test_humaneval()
local candidate = even_odd_count
    lu.assertEquals(candidate(7), {0, 1})
    lu.assertEquals(candidate(-78), {1, 1})
    lu.assertEquals(candidate(3452), {2, 2})
    lu.assertEquals(candidate(346211), {3, 3})
    lu.assertEquals(candidate(-345821), {3, 3})
    lu.assertEquals(candidate(-2), {1, 0})
    lu.assertEquals(candidate(-45347), {2, 3})
    lu.assertEquals(candidate(0), {1, 0})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given an integer. return a table that has the number of even and odd digits respectively.
-- Example:
--     >>> even_odd_count(-12)
--     {1, 1}
--     >>> even_odd_count(123)
--     {1, 2}
local function even_odd_count(num)
    local n = math.abs(num)          -- ignore the sign
    local even, odd = 0, 0

    if n == 0 then
        -- special case: 0 is an even digit
        even = 1
    else
        while n > 0 do
            local digit = n % 10
            if digit % 2 == 0 then
                even = even + 1
            else
                odd = odd + 1
            end
            n = math.floor(n / 10)
        end
    end

    return {even, odd}
end
lu = require('luaunit')

function test_humaneval()
local candidate = even_odd_count
    lu.assertEquals(candidate(7), {0, 1})
    lu.assertEquals(candidate(-78), {1, 1})
    lu.assertEquals(candidate(3452), {2, 2})
    lu.assertEquals(candidate(346211), {3, 3})
    lu.assertEquals(candidate(-345821), {3, 3})
    lu.assertEquals(candidate(-2), {1, 0})
    lu.assertEquals(candidate(-45347), {2, 3})
    lu.assertEquals(candidate(0), {1, 0})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given an integer. return a table that has the number of even and odd digits respectively.
-- Example:
--     >>> even_odd_count(-12)
--     {1, 1}
--     >>> even_odd_count(123)
--     {1, 2}
-- Return a table `{even_count, odd_count}` for the digits of an integer.
-- Negative numbers are treated the same as their absolute value.
local function even_odd_count(num)
    -- Special case: 0 has one even digit.
    if num == 0 then
        return {1, 0}
    end

    local abs = math.abs(num)
    local even = 0
    local odd  = 0

    while abs > 0 do
        local digit = abs % 10
        if digit % 2 == 0 then
            even = even + 1
        else
            odd = odd + 1
        end
        abs = math.floor(abs / 10)
    end

    return {even, odd}
end
lu = require('luaunit')

function test_humaneval()
local candidate = even_odd_count
    lu.assertEquals(candidate(7), {0, 1})
    lu.assertEquals(candidate(-78), {1, 1})
    lu.assertEquals(candidate(3452), {2, 2})
    lu.assertEquals(candidate(346211), {3, 3})
    lu.assertEquals(candidate(-345821), {3, 3})
    lu.assertEquals(candidate(-2), {1, 0})
    lu.assertEquals(candidate(-45347), {2, 3})
    lu.assertEquals(candidate(0), {1, 0})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given an integer. return a table that has the number of even and odd digits respectively.
-- Example:
--     >>> even_odd_count(-12)
--     {1, 1}
--     >>> even_odd_count(123)
--     {1, 2}
-- Return a table with the count of even and odd digits in the given integer.
-- The first element of the table is the count of even digits,
-- the second element is the count of odd digits.
--
-- Examples:
--   even_odd_count(-12)  --> {1, 1}
--   even_odd_count(123)  --> {1, 2}
local function even_odd_count(num)
    -- Convert to string and remove any leading sign
    local str = tostring(num)
    if str:sub(1, 1) == '-' then
        str = str:sub(2)
    end

    local even = 0
    local odd  = 0

    for i = 1, #str do
        local ch = str:sub(i, i)
        local digit = tonumber(ch)
        if digit then
            if digit % 2 == 0 then
                even = even + 1
            else
                odd = odd + 1
            end
        end
    end

    return {even, odd}
end
lu = require('luaunit')

function test_humaneval()
local candidate = even_odd_count
    lu.assertEquals(candidate(7), {0, 1})
    lu.assertEquals(candidate(-78), {1, 1})
    lu.assertEquals(candidate(3452), {2, 2})
    lu.assertEquals(candidate(346211), {3, 3})
    lu.assertEquals(candidate(-345821), {3, 3})
    lu.assertEquals(candidate(-2), {1, 0})
    lu.assertEquals(candidate(-45347), {2, 3})
    lu.assertEquals(candidate(0), {1, 0})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 156 (LUA) - HumanEval_156_int_to_mini_roman
================================================================================

PROMPT:
----------------------------------------
-- Given a positive integer, obtain its roman numeral equivalent as a string,
-- and return it in lowercase.
-- Restrictions: 1 <= num <= 1000
-- Examples:
-- >>> int_to_mini_roman(19)
-- 'xix'
-- >>> int_to_mini_roman(152)
-- 'clii'
-- >>> int_to_mini_roman(426)
-- 'cdxxvi'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = int_to_mini_roman
    lu.assertEquals(candidate(19), 'xix')
    lu.assertEquals(candidate(152), 'clii')
    lu.assertEquals(candidate(251), 'ccli')
    lu.assertEquals(candidate(426), 'cdxxvi')
    lu.assertEquals(candidate(500), 'd')
    lu.assertEquals(candidate(1), 'i')
    lu.assertEquals(candidate(4), 'iv')
    lu.assertEquals(candidate(43), 'xliii')
    lu.assertEquals(candidate(90), 'xc')
    lu.assertEquals(candidate(94), 'xciv')
    lu.assertEquals(candidate(532), 'dxxxii')
    lu.assertEquals(candidate(900), 'cm')
    lu.assertEquals(candidate(994), 'cmxciv')
    lu.assertEquals(candidate(1000), 'm')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a positive integer, obtain its roman numeral equivalent as a string,
-- and return it in lowercase.
-- Restrictions: 1 <= num <= 1000
-- Examples:
-- >>> int_to_mini_roman(19)
-- 'xix'
-- >>> int_to_mini_roman(152)
-- 'clii'
-- >>> int_to_mini_roman(426)
-- 'cdxxvi'
-- Convert an integer (1 ≤ num ≤ 1000) to its Roman numeral representation in lowercase.
local function int_to_mini_roman(number)
    -- Ordered mapping of decimal values to Roman symbols
    local roman_map = {
        {1000, "M"},
        {900,  "CM"},
        {500,  "D"},
        {400,  "CD"},
        {100,  "C"},
        {90,   "XC"},
        {50,   "L"},
        {40,   "XL"},
        {10,   "X"},
        {9,    "IX"},
        {5,    "V"},
        {4,    "IV"},
        {1,    "I"}
    }

    local parts = {}

    for _, pair in ipairs(roman_map) do
        local value, symbol = pair[1], pair[2]
        while number >= value do
            table.insert(parts, symbol)
            number = number - value
        end
    end

    return string.lower(table.concat(parts))
end
lu = require('luaunit')

function test_humaneval()
local candidate = int_to_mini_roman
    lu.assertEquals(candidate(19), 'xix')
    lu.assertEquals(candidate(152), 'clii')
    lu.assertEquals(candidate(251), 'ccli')
    lu.assertEquals(candidate(426), 'cdxxvi')
    lu.assertEquals(candidate(500), 'd')
    lu.assertEquals(candidate(1), 'i')
    lu.assertEquals(candidate(4), 'iv')
    lu.assertEquals(candidate(43), 'xliii')
    lu.assertEquals(candidate(90), 'xc')
    lu.assertEquals(candidate(94), 'xciv')
    lu.assertEquals(candidate(532), 'dxxxii')
    lu.assertEquals(candidate(900), 'cm')
    lu.assertEquals(candidate(994), 'cmxciv')
    lu.assertEquals(candidate(1000), 'm')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a positive integer, obtain its roman numeral equivalent as a string,
-- and return it in lowercase.
-- Restrictions: 1 <= num <= 1000
-- Examples:
-- >>> int_to_mini_roman(19)
-- 'xix'
-- >>> int_to_mini_roman(152)
-- 'clii'
-- >>> int_to_mini_roman(426)
-- 'cdxxvi'
-- Convert an integer (1 ≤ num ≤ 1000) to its Roman numeral representation in lowercase.
local function int_to_mini_roman(number)
    -- Mapping of Roman numerals to their integer values, in descending order.
    local mapping = {
        {1000, "m"},
        {900,  "cm"},
        {500,  "d"},
        {400,  "cd"},
        {100,  "c"},
        {90,   "xc"},
        {50,   "l"},
        {40,   "xl"},
        {10,   "x"},
        {9,    "ix"},
        {5,    "v"},
        {4,    "iv"},
        {1,    "i"},
    }

    local result = {}

    for _, pair in ipairs(mapping) do
        local value, numeral = pair[1], pair[2]
        while number >= value do
            number = number - value
            table.insert(result, numeral)
        end
    end

    return table.concat(result)
end
lu = require('luaunit')

function test_humaneval()
local candidate = int_to_mini_roman
    lu.assertEquals(candidate(19), 'xix')
    lu.assertEquals(candidate(152), 'clii')
    lu.assertEquals(candidate(251), 'ccli')
    lu.assertEquals(candidate(426), 'cdxxvi')
    lu.assertEquals(candidate(500), 'd')
    lu.assertEquals(candidate(1), 'i')
    lu.assertEquals(candidate(4), 'iv')
    lu.assertEquals(candidate(43), 'xliii')
    lu.assertEquals(candidate(90), 'xc')
    lu.assertEquals(candidate(94), 'xciv')
    lu.assertEquals(candidate(532), 'dxxxii')
    lu.assertEquals(candidate(900), 'cm')
    lu.assertEquals(candidate(994), 'cmxciv')
    lu.assertEquals(candidate(1000), 'm')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a positive integer, obtain its roman numeral equivalent as a string,
-- and return it in lowercase.
-- Restrictions: 1 <= num <= 1000
-- Examples:
-- >>> int_to_mini_roman(19)
-- 'xix'
-- >>> int_to_mini_roman(152)
-- 'clii'
-- >>> int_to_mini_roman(426)
-- 'cdxxvi'
-- Convert a positive integer (1 <= num <= 1000) to a lowercase Roman numeral.
local function int_to_mini_roman(number)
    local numerals = {
        {1000, "m"},
        {900,  "cm"},
        {500,  "d"},
        {400,  "cd"},
        {100,  "c"},
        {90,   "xc"},
        {50,   "l"},
        {40,   "xl"},
        {10,   "x"},
        {9,    "ix"},
        {5,    "v"},
        {4,    "iv"},
        {1,    "i"}
    }

    local result = ""
    for _, pair in ipairs(numerals) do
        local value, symbol = pair[1], pair[2]
        while number >= value do
            result = result .. symbol
            number = number - value
        end
    end
    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = int_to_mini_roman
    lu.assertEquals(candidate(19), 'xix')
    lu.assertEquals(candidate(152), 'clii')
    lu.assertEquals(candidate(251), 'ccli')
    lu.assertEquals(candidate(426), 'cdxxvi')
    lu.assertEquals(candidate(500), 'd')
    lu.assertEquals(candidate(1), 'i')
    lu.assertEquals(candidate(4), 'iv')
    lu.assertEquals(candidate(43), 'xliii')
    lu.assertEquals(candidate(90), 'xc')
    lu.assertEquals(candidate(94), 'xciv')
    lu.assertEquals(candidate(532), 'dxxxii')
    lu.assertEquals(candidate(900), 'cm')
    lu.assertEquals(candidate(994), 'cmxciv')
    lu.assertEquals(candidate(1000), 'm')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a positive integer, obtain its roman numeral equivalent as a string,
-- and return it in lowercase.
-- Restrictions: 1 <= num <= 1000
-- Examples:
-- >>> int_to_mini_roman(19)
-- 'xix'
-- >>> int_to_mini_roman(152)
-- 'clii'
-- >>> int_to_mini_roman(426)
-- 'cdxxvi'
local function int_to_mini_roman(number)
    -- Mapping of integer values to Roman numerals (uppercase)
    local values  = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
    local numerals = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"}

    local result = {}

    for i = 1, #values do
        local count = math.floor(number / values[i])
        if count > 0 then
            for _ = 1, count do
                table.insert(result, numerals[i])
            end
            number = number % values[i]
        end
    end

    -- Join and convert to lowercase
    return table.concat(result):lower()
end
lu = require('luaunit')

function test_humaneval()
local candidate = int_to_mini_roman
    lu.assertEquals(candidate(19), 'xix')
    lu.assertEquals(candidate(152), 'clii')
    lu.assertEquals(candidate(251), 'ccli')
    lu.assertEquals(candidate(426), 'cdxxvi')
    lu.assertEquals(candidate(500), 'd')
    lu.assertEquals(candidate(1), 'i')
    lu.assertEquals(candidate(4), 'iv')
    lu.assertEquals(candidate(43), 'xliii')
    lu.assertEquals(candidate(90), 'xc')
    lu.assertEquals(candidate(94), 'xciv')
    lu.assertEquals(candidate(532), 'dxxxii')
    lu.assertEquals(candidate(900), 'cm')
    lu.assertEquals(candidate(994), 'cmxciv')
    lu.assertEquals(candidate(1000), 'm')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 157 (LUA) - HumanEval_157_right_angle_triangle
================================================================================

PROMPT:
----------------------------------------
-- Given the lengths of the three sides of a triangle. Return true if the three
-- sides form a right-angled triangle, false otherwise.
-- A right-angled triangle is a triangle in which one angle is right angle or 
-- 90 degree.
-- Example:
-- >>> right_angle_triangle(3, 4, 5)
-- true
-- >>> right_angle_triangle(1, 2, 3)
-- false

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = right_angle_triangle
    lu.assertEquals(candidate(3, 4, 5), true)
    lu.assertEquals(candidate(1, 2, 3), false)
    lu.assertEquals(candidate(10, 6, 8), true)
    lu.assertEquals(candidate(2, 2, 2), false)
    lu.assertEquals(candidate(7, 24, 25), true)
    lu.assertEquals(candidate(10, 5, 7), false)
    lu.assertEquals(candidate(5, 12, 13), true)
    lu.assertEquals(candidate(15, 8, 17), true)
    lu.assertEquals(candidate(48, 55, 73), true)
    lu.assertEquals(candidate(1, 1, 1), false)
    lu.assertEquals(candidate(2, 2, 10), false)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given the lengths of the three sides of a triangle. Return true if the three
-- sides form a right-angled triangle, false otherwise.
-- A right-angled triangle is a triangle in which one angle is right angle or 
-- 90 degree.
-- Example:
-- >>> right_angle_triangle(3, 4, 5)
-- true
-- >>> right_angle_triangle(1, 2, 3)
-- false
-- Determine if three side lengths form a right‑angled triangle.
-- The function accepts the side lengths in any order and returns
-- true if the Pythagorean theorem holds (within a small tolerance),
-- otherwise false.
local function right_angle_triangle(a, b, c)
    -- Sort the sides so that the largest side is the hypotenuse candidate.
    local sides = {a, b, c}
    table.sort(sides)

    local x, y, z = sides[1], sides[2], sides[3]  -- x ≤ y ≤ z

    -- Quick check: the sum of the two shorter sides must be greater
    -- than the longest side for a valid triangle.
    if x + y <= z then
        return false
    end

    -- Use a tolerance to account for floating‑point rounding errors.
    local epsilon = 1e-9
    return math.abs(x * x + y * y - z * z) < epsilon
end
lu = require('luaunit')

function test_humaneval()
local candidate = right_angle_triangle
    lu.assertEquals(candidate(3, 4, 5), true)
    lu.assertEquals(candidate(1, 2, 3), false)
    lu.assertEquals(candidate(10, 6, 8), true)
    lu.assertEquals(candidate(2, 2, 2), false)
    lu.assertEquals(candidate(7, 24, 25), true)
    lu.assertEquals(candidate(10, 5, 7), false)
    lu.assertEquals(candidate(5, 12, 13), true)
    lu.assertEquals(candidate(15, 8, 17), true)
    lu.assertEquals(candidate(48, 55, 73), true)
    lu.assertEquals(candidate(1, 1, 1), false)
    lu.assertEquals(candidate(2, 2, 10), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given the lengths of the three sides of a triangle. Return true if the three
-- sides form a right-angled triangle, false otherwise.
-- A right-angled triangle is a triangle in which one angle is right angle or 
-- 90 degree.
-- Example:
-- >>> right_angle_triangle(3, 4, 5)
-- true
-- >>> right_angle_triangle(1, 2, 3)
-- false
local function right_angle_triangle(a, b, c)
    -- Sort the sides so that a <= b <= c
    local sides = {a, b, c}
    table.sort(sides)
    local x, y, z = sides[1], sides[2], sides[3]

    -- Check for a valid triangle first
    if x + y <= z then
        return false
    end

    -- Apply the Pythagorean theorem
    return x * x + y * y == z * z
end
lu = require('luaunit')

function test_humaneval()
local candidate = right_angle_triangle
    lu.assertEquals(candidate(3, 4, 5), true)
    lu.assertEquals(candidate(1, 2, 3), false)
    lu.assertEquals(candidate(10, 6, 8), true)
    lu.assertEquals(candidate(2, 2, 2), false)
    lu.assertEquals(candidate(7, 24, 25), true)
    lu.assertEquals(candidate(10, 5, 7), false)
    lu.assertEquals(candidate(5, 12, 13), true)
    lu.assertEquals(candidate(15, 8, 17), true)
    lu.assertEquals(candidate(48, 55, 73), true)
    lu.assertEquals(candidate(1, 1, 1), false)
    lu.assertEquals(candidate(2, 2, 10), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given the lengths of the three sides of a triangle. Return true if the three
-- sides form a right-angled triangle, false otherwise.
-- A right-angled triangle is a triangle in which one angle is right angle or 
-- 90 degree.
-- Example:
-- >>> right_angle_triangle(3, 4, 5)
-- true
-- >>> right_angle_triangle(1, 2, 3)
-- false
-- Check if the sides can form a triangle first
local function right_angle_triangle(a, b, c)
    -- Triangle inequality
    if not (a + b > c and a + c > b and b + c > a) then
        return false
    end

    -- Compute squares
    local a2, b2, c2 = a * a, b * b, c * c

    -- Check for right‑angle using Pythagoras theorem
    if a2 + b2 == c2 or a2 + c2 == b2 or b2 + c2 == a2 then
        return true
    end

    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = right_angle_triangle
    lu.assertEquals(candidate(3, 4, 5), true)
    lu.assertEquals(candidate(1, 2, 3), false)
    lu.assertEquals(candidate(10, 6, 8), true)
    lu.assertEquals(candidate(2, 2, 2), false)
    lu.assertEquals(candidate(7, 24, 25), true)
    lu.assertEquals(candidate(10, 5, 7), false)
    lu.assertEquals(candidate(5, 12, 13), true)
    lu.assertEquals(candidate(15, 8, 17), true)
    lu.assertEquals(candidate(48, 55, 73), true)
    lu.assertEquals(candidate(1, 1, 1), false)
    lu.assertEquals(candidate(2, 2, 10), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given the lengths of the three sides of a triangle. Return true if the three
-- sides form a right-angled triangle, false otherwise.
-- A right-angled triangle is a triangle in which one angle is right angle or 
-- 90 degree.
-- Example:
-- >>> right_angle_triangle(3, 4, 5)
-- true
-- >>> right_angle_triangle(1, 2, 3)
-- false
-- Returns true if the three sides form a right‑angled triangle, false otherwise.
local function right_angle_triangle(a, b, c)
  -- Ensure all sides are numbers and positive
  if type(a)~="number" or type(b)~="number" or type(c)~="number" then
    return false
  end
  if a <= 0 or b <= 0 or c <= 0 then
    return false
  end

  -- Sort sides so that the largest is last
  local sides = {a, b, c}
  table.sort(sides)

  -- Check the Pythagorean theorem
  return sides[1] * sides[1] + sides[2] * sides[2] == sides[3] * sides[3]
end
lu = require('luaunit')

function test_humaneval()
local candidate = right_angle_triangle
    lu.assertEquals(candidate(3, 4, 5), true)
    lu.assertEquals(candidate(1, 2, 3), false)
    lu.assertEquals(candidate(10, 6, 8), true)
    lu.assertEquals(candidate(2, 2, 2), false)
    lu.assertEquals(candidate(7, 24, 25), true)
    lu.assertEquals(candidate(10, 5, 7), false)
    lu.assertEquals(candidate(5, 12, 13), true)
    lu.assertEquals(candidate(15, 8, 17), true)
    lu.assertEquals(candidate(48, 55, 73), true)
    lu.assertEquals(candidate(1, 1, 1), false)
    lu.assertEquals(candidate(2, 2, 10), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 158 (LUA) - HumanEval_158_find_max
================================================================================

PROMPT:
----------------------------------------
-- Write a function that accepts a table of strings.
-- The table contains different words. Return the word with maximum number
-- of unique characters. If multiple strings have maximum number of unique
-- characters, return the one which comes first in lexicographical order.
-- >>> find_max({'name', 'of', 'string'})
-- 'string'
-- >>> find_max({'name', 'enam', 'game'})
-- 'enam'
-- >>> find_max({'aaaaaaa', 'bb', 'cc'})
-- 'aaaaaaa'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = find_max
    lu.assertEquals(candidate({'name', 'of', 'string'}), 'string')
    lu.assertEquals(candidate({'name', 'enam', 'game'}), 'enam')
    lu.assertEquals(candidate({'aaaaaaa', 'bb', 'cc'}), 'aaaaaaa')
    lu.assertEquals(candidate({'abc', 'cba'}), 'abc')
    lu.assertEquals(candidate({'play', 'this', 'game', 'of', 'footbott'}), 'footbott')
    lu.assertEquals(candidate({'we', 'are', 'gonna', 'rock'}), 'gonna')
    lu.assertEquals(candidate({'we', 'are', 'a', 'mad', 'nation'}), 'nation')
    lu.assertEquals(candidate({'this', 'is', 'a', 'prrk'}), 'this')
    lu.assertEquals(candidate({'b'}), 'b')
    lu.assertEquals(candidate({'play', 'play', 'play'}), 'play')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Write a function that accepts a table of strings.
-- The table contains different words. Return the word with maximum number
-- of unique characters. If multiple strings have maximum number of unique
-- characters, return the one which comes first in lexicographical order.
-- >>> find_max({'name', 'of', 'string'})
-- 'string'
-- >>> find_max({'name', 'enam', 'game'})
-- 'enam'
-- >>> find_max({'aaaaaaa', 'bb', 'cc'})
-- 'aaaaaaa'
-- Find the word with the maximum number of unique characters.
-- If there is a tie, return the lexicographically smallest word.
--
-- @param words table<string>  A table containing the words to evaluate.
-- @return string|nil          The word that satisfies the conditions,
--                             or nil if the table is empty.
local function find_max(words)
    if #words == 0 then
        return nil
    end

    local best_word   -- the current best word
    local best_unique = -1  -- number of unique characters in best_word

    for _, word in ipairs(words) do
        -- Count unique characters in `word`
        local seen = {}
        local unique = 0
        for ch in word:gmatch(".") do
            if not seen[ch] then
                seen[ch] = true
                unique = unique + 1
            end
        end

        -- Update best_word if necessary
        if unique > best_unique then
            best_unique = unique
            best_word = word
        elseif unique == best_unique then
            if word < best_word then
                best_word = word
            end
        end
    end

    return best_word
end
lu = require('luaunit')

function test_humaneval()
local candidate = find_max
    lu.assertEquals(candidate({'name', 'of', 'string'}), 'string')
    lu.assertEquals(candidate({'name', 'enam', 'game'}), 'enam')
    lu.assertEquals(candidate({'aaaaaaa', 'bb', 'cc'}), 'aaaaaaa')
    lu.assertEquals(candidate({'abc', 'cba'}), 'abc')
    lu.assertEquals(candidate({'play', 'this', 'game', 'of', 'footbott'}), 'footbott')
    lu.assertEquals(candidate({'we', 'are', 'gonna', 'rock'}), 'gonna')
    lu.assertEquals(candidate({'we', 'are', 'a', 'mad', 'nation'}), 'nation')
    lu.assertEquals(candidate({'this', 'is', 'a', 'prrk'}), 'this')
    lu.assertEquals(candidate({'b'}), 'b')
    lu.assertEquals(candidate({'play', 'play', 'play'}), 'play')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Write a function that accepts a table of strings.
-- The table contains different words. Return the word with maximum number
-- of unique characters. If multiple strings have maximum number of unique
-- characters, return the one which comes first in lexicographical order.
-- >>> find_max({'name', 'of', 'string'})
-- 'string'
-- >>> find_max({'name', 'enam', 'game'})
-- 'enam'
-- >>> find_max({'aaaaaaa', 'bb', 'cc'})
-- 'aaaaaaa'
-- Find the word with the maximum number of unique characters.
-- In case of a tie, return the lexicographically smallest word.
local function find_max(words)
    if #words == 0 then
        return nil
    end

    local best_word   = nil   -- The current best word
    local best_count  = -1    -- Highest unique‑character count seen so far

    for _, w in ipairs(words) do
        local seen = {}
        local count = 0

        -- Count unique characters in the current word
        for i = 1, #w do
            local ch = w:sub(i, i)
            if not seen[ch] then
                seen[ch] = true
                count = count + 1
            end
        end

        -- Update the best word if necessary
        if count > best_count or
           (count == best_count and (best_word == nil or w < best_word)) then
            best_count = count
            best_word  = w
        end
    end

    return best_word
end
lu = require('luaunit')

function test_humaneval()
local candidate = find_max
    lu.assertEquals(candidate({'name', 'of', 'string'}), 'string')
    lu.assertEquals(candidate({'name', 'enam', 'game'}), 'enam')
    lu.assertEquals(candidate({'aaaaaaa', 'bb', 'cc'}), 'aaaaaaa')
    lu.assertEquals(candidate({'abc', 'cba'}), 'abc')
    lu.assertEquals(candidate({'play', 'this', 'game', 'of', 'footbott'}), 'footbott')
    lu.assertEquals(candidate({'we', 'are', 'gonna', 'rock'}), 'gonna')
    lu.assertEquals(candidate({'we', 'are', 'a', 'mad', 'nation'}), 'nation')
    lu.assertEquals(candidate({'this', 'is', 'a', 'prrk'}), 'this')
    lu.assertEquals(candidate({'b'}), 'b')
    lu.assertEquals(candidate({'play', 'play', 'play'}), 'play')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Write a function that accepts a table of strings.
-- The table contains different words. Return the word with maximum number
-- of unique characters. If multiple strings have maximum number of unique
-- characters, return the one which comes first in lexicographical order.
-- >>> find_max({'name', 'of', 'string'})
-- 'string'
-- >>> find_max({'name', 'enam', 'game'})
-- 'enam'
-- >>> find_max({'aaaaaaa', 'bb', 'cc'})
-- 'aaaaaaa'
local function find_max(words)
    local best_word = nil
    local best_count = -1

    for _, word in ipairs(words) do
        local seen = {}
        local count = 0

        for c in word:gmatch(".") do
            if not seen[c] then
                seen[c] = true
                count = count + 1
            end
        end

        if count > best_count or (count == best_count and (best_word == nil or word < best_word)) then
            best_count = count
            best_word = word
        end
    end

    return best_word
end
lu = require('luaunit')

function test_humaneval()
local candidate = find_max
    lu.assertEquals(candidate({'name', 'of', 'string'}), 'string')
    lu.assertEquals(candidate({'name', 'enam', 'game'}), 'enam')
    lu.assertEquals(candidate({'aaaaaaa', 'bb', 'cc'}), 'aaaaaaa')
    lu.assertEquals(candidate({'abc', 'cba'}), 'abc')
    lu.assertEquals(candidate({'play', 'this', 'game', 'of', 'footbott'}), 'footbott')
    lu.assertEquals(candidate({'we', 'are', 'gonna', 'rock'}), 'gonna')
    lu.assertEquals(candidate({'we', 'are', 'a', 'mad', 'nation'}), 'nation')
    lu.assertEquals(candidate({'this', 'is', 'a', 'prrk'}), 'this')
    lu.assertEquals(candidate({'b'}), 'b')
    lu.assertEquals(candidate({'play', 'play', 'play'}), 'play')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Write a function that accepts a table of strings.
-- The table contains different words. Return the word with maximum number
-- of unique characters. If multiple strings have maximum number of unique
-- characters, return the one which comes first in lexicographical order.
-- >>> find_max({'name', 'of', 'string'})
-- 'string'
-- >>> find_max({'name', 'enam', 'game'})
-- 'enam'
-- >>> find_max({'aaaaaaa', 'bb', 'cc'})
-- 'aaaaaaa'
local function find_max(words)
  local best = nil
  local bestCount = -1

  for _, w in ipairs(words) do
    local seen = {}
    local count = 0

    for i = 1, #w do
      local c = w:sub(i, i)
      if not seen[c] then
        seen[c] = true
        count = count + 1
      end
    end

    if count > bestCount or (count == bestCount and (best == nil or w < best)) then
      best = w
      bestCount = count
    end
  end

  return best
end
lu = require('luaunit')

function test_humaneval()
local candidate = find_max
    lu.assertEquals(candidate({'name', 'of', 'string'}), 'string')
    lu.assertEquals(candidate({'name', 'enam', 'game'}), 'enam')
    lu.assertEquals(candidate({'aaaaaaa', 'bb', 'cc'}), 'aaaaaaa')
    lu.assertEquals(candidate({'abc', 'cba'}), 'abc')
    lu.assertEquals(candidate({'play', 'this', 'game', 'of', 'footbott'}), 'footbott')
    lu.assertEquals(candidate({'we', 'are', 'gonna', 'rock'}), 'gonna')
    lu.assertEquals(candidate({'we', 'are', 'a', 'mad', 'nation'}), 'nation')
    lu.assertEquals(candidate({'this', 'is', 'a', 'prrk'}), 'this')
    lu.assertEquals(candidate({'b'}), 'b')
    lu.assertEquals(candidate({'play', 'play', 'play'}), 'play')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.001 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 159 (LUA) - HumanEval_159_eat
================================================================================

PROMPT:
----------------------------------------
-- You're a hungry rabbit, and you already have eaten a certain number of carrots,
-- but now you need to eat more carrots to complete the day's meals.
-- you should return a table of [ total number of eaten carrots after your meals,
--                                 the number of carrots left after your meals ]
-- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
-- Example:
-- >>> eat(5, 6, 10)
-- {11, 4}
-- >>> eat(4, 8, 9)
-- {12, 1}
-- >>> eat(1, 10, 10)
-- {11, 0}
-- >>> eat(2, 11, 5)
-- {7, 0}
-- Variables:
-- @number : integer
--     the number of carrots that you have eaten.
-- @need : integer
--     the number of carrots that you need to eat.
-- @remaining : integer
--     the number of remaining carrots thet exist in stock
-- Constrain:
-- * 0 <= number <= 1000
-- * 0 <= need <= 1000
-- * 0 <= remaining <= 1000
-- Have fun :)

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = eat
    lu.assertEquals(candidate(5, 6, 10), {11, 4})
    lu.assertEquals(candidate(4, 8, 9), {12, 1})
    lu.assertEquals(candidate(1, 10, 10), {11, 0})
    lu.assertEquals(candidate(2, 11, 5), {7, 0})
    lu.assertEquals(candidate(4, 5, 7), {9, 2})
    lu.assertEquals(candidate(4, 5, 1), {5, 0})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You're a hungry rabbit, and you already have eaten a certain number of carrots,
-- but now you need to eat more carrots to complete the day's meals.
-- you should return a table of [ total number of eaten carrots after your meals,
--                                 the number of carrots left after your meals ]
-- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
-- Example:
-- >>> eat(5, 6, 10)
-- {11, 4}
-- >>> eat(4, 8, 9)
-- {12, 1}
-- >>> eat(1, 10, 10)
-- {11, 0}
-- >>> eat(2, 11, 5)
-- {7, 0}
-- Variables:
-- @number : integer
--     the number of carrots that you have eaten.
-- @need : integer
--     the number of carrots that you need to eat.
-- @remaining : integer
--     the number of remaining carrots thet exist in stock
-- Constrain:
-- * 0 <= number <= 1000
-- * 0 <= need <= 1000
-- * 0 <= remaining <= 1000
-- Have fun :)
-- Return a table containing:
--   1. The total number of carrots eaten after the meal.
--   2. The number of carrots left in stock after the meal.
local function eat(number, need, remaining)
    -- How many carrots can we actually eat this time?
    local eaten_this_time = math.min(need, remaining)

    -- Total carrots eaten so far
    local total_eaten = number + eaten_this_time

    -- Carrots left after eating
    local left = remaining - eaten_this_time

    return { total_eaten, left }
end
lu = require('luaunit')

function test_humaneval()
local candidate = eat
    lu.assertEquals(candidate(5, 6, 10), {11, 4})
    lu.assertEquals(candidate(4, 8, 9), {12, 1})
    lu.assertEquals(candidate(1, 10, 10), {11, 0})
    lu.assertEquals(candidate(2, 11, 5), {7, 0})
    lu.assertEquals(candidate(4, 5, 7), {9, 2})
    lu.assertEquals(candidate(4, 5, 1), {5, 0})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You're a hungry rabbit, and you already have eaten a certain number of carrots,
-- but now you need to eat more carrots to complete the day's meals.
-- you should return a table of [ total number of eaten carrots after your meals,
--                                 the number of carrots left after your meals ]
-- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
-- Example:
-- >>> eat(5, 6, 10)
-- {11, 4}
-- >>> eat(4, 8, 9)
-- {12, 1}
-- >>> eat(1, 10, 10)
-- {11, 0}
-- >>> eat(2, 11, 5)
-- {7, 0}
-- Variables:
-- @number : integer
--     the number of carrots that you have eaten.
-- @need : integer
--     the number of carrots that you need to eat.
-- @remaining : integer
--     the number of remaining carrots thet exist in stock
-- Constrain:
-- * 0 <= number <= 1000
-- * 0 <= need <= 1000
-- * 0 <= remaining <= 1000
-- Have fun :)
-- Returns a table with:
--   1. total number of carrots eaten after the meal
--   2. number of carrots left in stock
local function eat(number, need, remaining)
    -- How many carrots can we actually eat from the remaining stock?
    local eatenFromRemaining = math.min(need, remaining)

    -- Total carrots eaten so far
    local total = number + eatenFromRemaining

    -- Remaining carrots after the meal
    local left = remaining - eatenFromRemaining

    return { total, left }
end
lu = require('luaunit')

function test_humaneval()
local candidate = eat
    lu.assertEquals(candidate(5, 6, 10), {11, 4})
    lu.assertEquals(candidate(4, 8, 9), {12, 1})
    lu.assertEquals(candidate(1, 10, 10), {11, 0})
    lu.assertEquals(candidate(2, 11, 5), {7, 0})
    lu.assertEquals(candidate(4, 5, 7), {9, 2})
    lu.assertEquals(candidate(4, 5, 1), {5, 0})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You're a hungry rabbit, and you already have eaten a certain number of carrots,
-- but now you need to eat more carrots to complete the day's meals.
-- you should return a table of [ total number of eaten carrots after your meals,
--                                 the number of carrots left after your meals ]
-- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
-- Example:
-- >>> eat(5, 6, 10)
-- {11, 4}
-- >>> eat(4, 8, 9)
-- {12, 1}
-- >>> eat(1, 10, 10)
-- {11, 0}
-- >>> eat(2, 11, 5)
-- {7, 0}
-- Variables:
-- @number : integer
--     the number of carrots that you have eaten.
-- @need : integer
--     the number of carrots that you need to eat.
-- @remaining : integer
--     the number of remaining carrots thet exist in stock
-- Constrain:
-- * 0 <= number <= 1000
-- * 0 <= need <= 1000
-- * 0 <= remaining <= 1000
-- Have fun :)
-- You are a hungry rabbit who has already eaten `number` carrots.
-- You need to eat `need` more carrots, but only `remaining` carrots are left in the stock.
-- The function returns a table where:
--   first element = total carrots eaten after the meal
--   second element = carrots left in the stock after the meal
-- If there aren't enough carrots left, you eat all that remain.
--
-- Example:
--   eat(5, 6, 10) --> {11, 4}
--   eat(4, 8, 9)  --> {12, 1}
--   eat(1, 10, 10) --> {11, 0}
--   eat(2, 11, 5) --> {7, 0}
--
-- @number   integer – carrots already eaten (0 ≤ number ≤ 1000)
-- @need     integer – carrots you still need to eat (0 ≤ need ≤ 1000)
-- @remaining integer – carrots available in stock (0 ≤ remaining ≤ 1000)
--
-- @return table {total_eaten, remaining_after}

local function eat(number, need, remaining)
    -- Determine how many carrots you can actually eat
    local eatable = math.min(need, remaining)

    -- Total carrots eaten after the meal
    local total = number + eatable

    -- Carrots left after you eat
    local left = remaining - eatable

    return {total, left}
end

-- Example usage:
-- print(table.concat(eat(5, 6, 10), ", "))  --> "11, 4"
lu = require('luaunit')

function test_humaneval()
local candidate = eat
    lu.assertEquals(candidate(5, 6, 10), {11, 4})
    lu.assertEquals(candidate(4, 8, 9), {12, 1})
    lu.assertEquals(candidate(1, 10, 10), {11, 0})
    lu.assertEquals(candidate(2, 11, 5), {7, 0})
    lu.assertEquals(candidate(4, 5, 7), {9, 2})
    lu.assertEquals(candidate(4, 5, 1), {5, 0})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You're a hungry rabbit, and you already have eaten a certain number of carrots,
-- but now you need to eat more carrots to complete the day's meals.
-- you should return a table of [ total number of eaten carrots after your meals,
--                                 the number of carrots left after your meals ]
-- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
-- Example:
-- >>> eat(5, 6, 10)
-- {11, 4}
-- >>> eat(4, 8, 9)
-- {12, 1}
-- >>> eat(1, 10, 10)
-- {11, 0}
-- >>> eat(2, 11, 5)
-- {7, 0}
-- Variables:
-- @number : integer
--     the number of carrots that you have eaten.
-- @need : integer
--     the number of carrots that you need to eat.
-- @remaining : integer
--     the number of remaining carrots thet exist in stock
-- Constrain:
-- * 0 <= number <= 1000
-- * 0 <= need <= 1000
-- * 0 <= remaining <= 1000
-- Have fun :)
-- Returns a table { total_eaten, remaining_carrots }
local function eat(number, need, remaining)
    -- Calculate how many carrots the rabbit will actually eat
    local eaten = math.min(need, remaining)
    -- Update the totals
    local total_eaten = number + eaten
    local remaining_carrots = remaining - eaten
    return { total_eaten, remaining_carrots }
end
lu = require('luaunit')

function test_humaneval()
local candidate = eat
    lu.assertEquals(candidate(5, 6, 10), {11, 4})
    lu.assertEquals(candidate(4, 8, 9), {12, 1})
    lu.assertEquals(candidate(1, 10, 10), {11, 0})
    lu.assertEquals(candidate(2, 11, 5), {7, 0})
    lu.assertEquals(candidate(4, 5, 7), {9, 2})
    lu.assertEquals(candidate(4, 5, 1), {5, 0})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154482
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 161 (LUA) - HumanEval_161_solve
================================================================================

PROMPT:
----------------------------------------
-- You are given a string s.
-- if s[i] is a letter, reverse its case from lower to upper or vise versa, 
-- otherwise keep it as it is.
-- If the string contains no letters, reverse the string.
-- The function should return the resulted string.
-- Examples
-- >>> solve('1234')
-- '4321'
-- >>> solve('ab')
-- 'AB'
-- >>> solve('#a@C')
-- '#A@c'

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = solve
    lu.assertEquals(candidate('AsDf'), 'aSdF')
    lu.assertEquals(candidate('1234'), '4321')
    lu.assertEquals(candidate('ab'), 'AB')
    lu.assertEquals(candidate('#a@C'), '#A@c')
    lu.assertEquals(candidate('#AsdfW^45'), '#aSDFw^45')
    lu.assertEquals(candidate('#6@2'), '2@6#')
    lu.assertEquals(candidate('#$a^D'), '#$A^d')
    lu.assertEquals(candidate('#ccc'), '#CCC')
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You are given a string s.
-- if s[i] is a letter, reverse its case from lower to upper or vise versa, 
-- otherwise keep it as it is.
-- If the string contains no letters, reverse the string.
-- The function should return the resulted string.
-- Examples
-- >>> solve('1234')
-- '4321'
-- >>> solve('ab')
-- 'AB'
-- >>> solve('#a@C')
-- '#A@c'
-- Function that transforms the input string according to the rules described
local function solve(s)
    -- Check if the string contains at least one letter
    local hasLetter = s:match("[A-Za-z]") ~= nil

    if not hasLetter then
        -- No letters: simply reverse the string
        return s:reverse()
    else
        -- Contains letters: flip the case of each letter
        local result = {}
        for i = 1, #s do
            local ch = s:sub(i, i)
            if ch:match("[A-Z]") then
                table.insert(result, ch:lower())
            elseif ch:match("[a-z]") then
                table.insert(result, ch:upper())
            else
                table.insert(result, ch)
            end
        end
        return table.concat(result)
    end
end

-- Example usage:
-- print(solve('1234'))   --> '4321'
-- print(solve('ab'))     --> 'AB'
-- print(solve('#a@C'))   --> '#A@c'
lu = require('luaunit')

function test_humaneval()
local candidate = solve
    lu.assertEquals(candidate('AsDf'), 'aSdF')
    lu.assertEquals(candidate('1234'), '4321')
    lu.assertEquals(candidate('ab'), 'AB')
    lu.assertEquals(candidate('#a@C'), '#A@c')
    lu.assertEquals(candidate('#AsdfW^45'), '#aSDFw^45')
    lu.assertEquals(candidate('#6@2'), '2@6#')
    lu.assertEquals(candidate('#$a^D'), '#$A^d')
    lu.assertEquals(candidate('#ccc'), '#CCC')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154483
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You are given a string s.
-- if s[i] is a letter, reverse its case from lower to upper or vise versa, 
-- otherwise keep it as it is.
-- If the string contains no letters, reverse the string.
-- The function should return the resulted string.
-- Examples
-- >>> solve('1234')
-- '4321'
-- >>> solve('ab')
-- 'AB'
-- >>> solve('#a@C')
-- '#A@c'
-- | Reverses the case of all letters in the input string.
-- | If the string contains no letters, it simply reverses the string.
-- |
-- | Examples:
-- |   solve('1234')   --> '4321'
-- |   solve('ab')     --> 'AB'
-- |   solve('#a@C')   --> '#A@c'

local function solve(s)
  -- If there are no alphabetic characters, just reverse the string.
  if not s:match("%a") then
    return string.reverse(s)
  end

  local result = {}
  for i = 1, #s do
    local ch = s:sub(i, i)
    local byte = string.byte(ch)

    if byte >= 97 and byte <= 122 then          -- 'a'..'z'
      result[i] = string.char(byte - 32)       -- to uppercase
    elseif byte >= 65 and byte <= 90 then       -- 'A'..'Z'
      result[i] = string.char(byte + 32)       -- to lowercase
    else
      result[i] = ch                            -- keep as is
    end
  end

  return table.concat(result)
end
lu = require('luaunit')

function test_humaneval()
local candidate = solve
    lu.assertEquals(candidate('AsDf'), 'aSdF')
    lu.assertEquals(candidate('1234'), '4321')
    lu.assertEquals(candidate('ab'), 'AB')
    lu.assertEquals(candidate('#a@C'), '#A@c')
    lu.assertEquals(candidate('#AsdfW^45'), '#aSDFw^45')
    lu.assertEquals(candidate('#6@2'), '2@6#')
    lu.assertEquals(candidate('#$a^D'), '#$A^d')
    lu.assertEquals(candidate('#ccc'), '#CCC')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154483
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You are given a string s.
-- if s[i] is a letter, reverse its case from lower to upper or vise versa, 
-- otherwise keep it as it is.
-- If the string contains no letters, reverse the string.
-- The function should return the resulted string.
-- Examples
-- >>> solve('1234')
-- '4321'
-- >>> solve('ab')
-- 'AB'
-- >>> solve('#a@C')
-- '#A@c'
local function solve(s)
  -- Check if the string contains at least one letter
  if s:match("%a") then
    -- Flip case for every letter
    return (s:gsub(".", function(c)
      if c:lower() == c then
        return c:upper()
      elseif c:upper() == c then
        return c:lower()
      else
        return c
      end
    end))
  else
    -- No letters – just reverse the string
    return s:reverse()
  end
end
lu = require('luaunit')

function test_humaneval()
local candidate = solve
    lu.assertEquals(candidate('AsDf'), 'aSdF')
    lu.assertEquals(candidate('1234'), '4321')
    lu.assertEquals(candidate('ab'), 'AB')
    lu.assertEquals(candidate('#a@C'), '#A@c')
    lu.assertEquals(candidate('#AsdfW^45'), '#aSDFw^45')
    lu.assertEquals(candidate('#6@2'), '2@6#')
    lu.assertEquals(candidate('#$a^D'), '#$A^d')
    lu.assertEquals(candidate('#ccc'), '#CCC')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154483
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You are given a string s.
-- if s[i] is a letter, reverse its case from lower to upper or vise versa, 
-- otherwise keep it as it is.
-- If the string contains no letters, reverse the string.
-- The function should return the resulted string.
-- Examples
-- >>> solve('1234')
-- '4321'
-- >>> solve('ab')
-- 'AB'
-- >>> solve('#a@C')
-- '#A@c'
-- Function that transforms the string according to the rules described
local function solve(s)
    -- Table to hold the processed characters
    local chars = {}
    local hasLetter = false

    -- First pass: transform letters and detect if any letter exists
    for i = 1, #s do
        local c   = s:sub(i, i)
        local byte = string.byte(c)

        if byte >= 65 and byte <= 90 then          -- 'A'..'Z'
            hasLetter = true
            chars[i] = string.char(byte + 32)     -- to lowercase
        elseif byte >= 97 and byte <= 122 then     -- 'a'..'z'
            hasLetter = true
            chars[i] = string.char(byte - 32)     -- to uppercase
        else
            chars[i] = c                           -- keep unchanged
        end
    end

    -- If no letters were found, reverse the whole string
    if not hasLetter then
        local n = #chars
        for i = 1, math.floor(n / 2) do
            chars[i], chars[n - i + 1] = chars[n - i + 1], chars[i]
        end
    end

    return table.concat(chars)
end
lu = require('luaunit')

function test_humaneval()
local candidate = solve
    lu.assertEquals(candidate('AsDf'), 'aSdF')
    lu.assertEquals(candidate('1234'), '4321')
    lu.assertEquals(candidate('ab'), 'AB')
    lu.assertEquals(candidate('#a@C'), '#A@c')
    lu.assertEquals(candidate('#AsdfW^45'), '#aSDFw^45')
    lu.assertEquals(candidate('#6@2'), '2@6#')
    lu.assertEquals(candidate('#$a^D'), '#$A^d')
    lu.assertEquals(candidate('#ccc'), '#CCC')
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154483
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------
