As per my standing instructions, analyze each code-execution result provided. For every item, produce a structured report as follows.

1) Status
Status: "OK" (Success) or else (Failure)
Evidence: include exit code, error status, and whether stderr is empty/non-empty (quote the first relevant line).

If Failure (non-zero exit code, error status, or non-empty stderr)
Root Cause Analysis
Explain why it failed, grounded in the logs/trace.
Point to the exact faulty locations (file and line numbers if available). Quote the minimal offending snippets.
Recommended Fix (Minimal Patch)
Provide brief code segments (3â€“7 lines each) that would correct the issue.
If multiple faults exist, list fixes in order of impact.
Final Answer
Classify the ultimate source of failure as one of: faulty problem setting / wrong test case / incorrect code implementation.
State it on a single line: Final Answer: <chosen category>.

If Success (exit code 0 and empty stderr)
Critical Correctness Review
Do not assume success means correctness.
Check if the code's logic truly matches the intended problem requirements, including edge cases and corner conditions.
Identify any silent errors, logical flaws, or incompleteness that would still pass execution but fail semantically.
If the implementation is sound, explain why it is correct. If not, explain the discrepancy clearly.
Final Answer
Explicitly confirm or reject correctness in one line: Final Answer: correct or incorrect (with a one-phrase justification if incorrect).

General rules
Be precise and concise. Don't invent behavior not evidenced by the logs or code.
When line numbers aren't available, reference the closest identifiable code block.
Prefer minimal fixes over refactors; include just enough context to apply the patch.

CONTENT TO ANALYZE:

================================================================================
PROBLEM 0 (LUA) - HumanEval_0_has_close_elements
================================================================================

PROMPT:
----------------------------------------
-- Check if in given table of numbers, are any two numbers closer to each other than
-- given threshold.
-- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)
-- false
-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)
-- true

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = has_close_elements
    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), true)
    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), false)
    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), true)
    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), false)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), true)
    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), true)
    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), false)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Check if in given table of numbers, are any two numbers closer to each other than
-- given threshold.
-- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)
-- false
-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)
-- true
-- Check if in given table of numbers, are any two numbers closer to each other than
-- given threshold.
-- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)
-- false
-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)
-- true
local function has_close_elements(numbers, threshold)
    local n = #numbers
    for i = 1, n - 1 do
        for j = i + 1, n do
            if math.abs(numbers[i] - numbers[j]) < threshold then
                return true
            end
        end
    end
    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = has_close_elements
    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), true)
    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), false)
    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), true)
    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), false)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), true)
    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), true)
    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Check if in given table of numbers, are any two numbers closer to each other than
-- given threshold.
-- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)
-- false
-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)
-- true
-- Check if in given table of numbers, are any two numbers closer to each other than
-- given threshold.
-- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)
-- false
-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)
-- true
local function has_close_elements(numbers, threshold)
    local n = #numbers
    if n < 2 then
        return false
    end

    for i = 1, n - 1 do
        for j = i + 1, n do
            if math.abs(numbers[i] - numbers[j]) < threshold then
                return true
            end
        end
    end

    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = has_close_elements
    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), true)
    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), false)
    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), true)
    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), false)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), true)
    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), true)
    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Check if in given table of numbers, are any two numbers closer to each other than
-- given threshold.
-- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)
-- false
-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)
-- true
-- Check if in given table of numbers, are any two numbers closer to each other than
-- given threshold.
-- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)
-- false
-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)
-- true
local function has_close_elements(numbers, threshold)
    local n = #numbers
    if n < 2 then
        return false
    end

    -- Make a copy so we don't modify the original table
    local arr = {}
    for i = 1, n do
        arr[i] = numbers[i]
    end

    -- Sort the numbers to only need to check adjacent pairs
    table.sort(arr)

    for i = 1, n - 1 do
        if arr[i + 1] - arr[i] < threshold then
            return true
        end
    end

    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = has_close_elements
    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), true)
    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), false)
    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), true)
    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), false)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), true)
    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), true)
    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Check if in given table of numbers, are any two numbers closer to each other than
-- given threshold.
-- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)
-- false
-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)
-- true
-- Check if in given table of numbers, are any two numbers closer to each other than
-- given threshold.
-- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)
-- false
-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)
-- true
local function has_close_elements(numbers, threshold)
  local n = #numbers
  for i = 1, n - 1 do
    for j = i + 1, n do
      if math.abs(numbers[i] - numbers[j]) < threshold then
        return true
      end
    end
  end
  return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = has_close_elements
    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), true)
    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), false)
    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), true)
    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), false)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), true)
    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), true)
    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), false)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 1 (LUA) - HumanEval_1_separate_paren_groups
================================================================================

PROMPT:
----------------------------------------
-- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
-- separate those group into separate strings and return the table of those.
-- Separate groups are balanced (each open brace is properly closed) and not nested within each other
-- Ignore any spaces in the input string.
-- >>> separate_paren_groups('( ) (( )) (( )( ))')
-- {'()', '(())', '(()())'}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = separate_paren_groups
    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {'(()())', '((()))', '()', '((())()())'})
    lu.assertEquals(candidate('() (()) ((())) (((())))'), {'()', '(())', '((()))', '(((())))'})
    lu.assertEquals(candidate('(()(())((())))'), {'(()(())((())))'})
    lu.assertEquals(candidate('( ) (( )) (( )( ))'), {'()', '(())', '(()())'})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
-- separate those group into separate strings and return the table of those.
-- Separate groups are balanced (each open brace is properly closed) and not nested within each other
-- Ignore any spaces in the input string.
-- >>> separate_paren_groups('( ) (( )) (( )( ))')
-- {'()', '(())', '(()())'}
-- Separate balanced parenthesis groups from a string.
-- Ignores spaces and returns a table (array) of the groups.
local function separate_paren_groups(paren_string)
  -- Remove all whitespace characters
  local cleaned = paren_string:gsub("%s+", "")

  local groups = {}
  local depth = 0          -- current nesting depth
  local start_idx = nil    -- index where the current group starts

  for i = 1, #cleaned do
    local c = cleaned:sub(i, i)
    if c == '(' then
      if depth == 0 then
        start_idx = i   -- start of a new group
      end
      depth = depth + 1
    elseif c == ')' then
      depth = depth - 1
      if depth == 0 then
        -- group finished, extract it
        local group = cleaned:sub(start_idx, i)
        table.insert(groups, group)
        start_idx = nil
      end
    end
  end

  return groups
end
lu = require('luaunit')

function test_humaneval()
local candidate = separate_paren_groups
    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {'(()())', '((()))', '()', '((())()())'})
    lu.assertEquals(candidate('() (()) ((())) (((())))'), {'()', '(())', '((()))', '(((())))'})
    lu.assertEquals(candidate('(()(())((())))'), {'(()(())((())))'})
    lu.assertEquals(candidate('( ) (( )) (( )( ))'), {'()', '(())', '(()())'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
-- separate those group into separate strings and return the table of those.
-- Separate groups are balanced (each open brace is properly closed) and not nested within each other
-- Ignore any spaces in the input string.
-- >>> separate_paren_groups('( ) (( )) (( )( ))')
-- {'()', '(())', '(()())'}
-- Separate a string of nested parentheses into individual balanced groups.
-- Spaces are ignored, and groups are not nested within each other.
-- Example:
--   separate_paren_groups('( ) (( )) (( )( ))')
--   --> {'()', '(())', '(()())'}
local function separate_paren_groups(paren_string)
  local result = {}
  local current = {}
  local depth = 0

  for i = 1, #paren_string do
    local c = paren_string:sub(i, i)

    if c == ' ' then
      -- ignore spaces
    elseif c == '(' then
      depth = depth + 1
      table.insert(current, c)
    elseif c == ')' then
      table.insert(current, c)
      depth = depth - 1
      if depth == 0 then
        table.insert(result, table.concat(current))
        current = {}
      end
    end
  end

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = separate_paren_groups
    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {'(()())', '((()))', '()', '((())()())'})
    lu.assertEquals(candidate('() (()) ((())) (((())))'), {'()', '(())', '((()))', '(((())))'})
    lu.assertEquals(candidate('(()(())((())))'), {'(()(())((())))'})
    lu.assertEquals(candidate('( ) (( )) (( )( ))'), {'()', '(())', '(()())'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
-- separate those group into separate strings and return the table of those.
-- Separate groups are balanced (each open brace is properly closed) and not nested within each other
-- Ignore any spaces in the input string.
-- >>> separate_paren_groups('( ) (( )) (( )( ))')
-- {'()', '(())', '(()())'}
-- Separate nested parenthesis groups into a table of strings
-- Ignores any spaces in the input
local function separate_paren_groups(paren_string)
  local groups = {}      -- Result table
  local current = {}     -- Buffer for the current group
  local depth = 0        -- Parenthesis depth counter

  for i = 1, #paren_string do
    local c = paren_string:sub(i, i)

    if c == '(' then
      depth = depth + 1
      table.insert(current, c)

    elseif c == ')' then
      depth = depth - 1
      table.insert(current, c)

      -- When depth reaches zero, we have a complete group
      if depth == 0 then
        table.insert(groups, table.concat(current))
        current = {}
      end

    -- ignore spaces (and any other non-parenthesis characters)
    end
  end

  return groups
end
lu = require('luaunit')

function test_humaneval()
local candidate = separate_paren_groups
    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {'(()())', '((()))', '()', '((())()())'})
    lu.assertEquals(candidate('() (()) ((())) (((())))'), {'()', '(())', '((()))', '(((())))'})
    lu.assertEquals(candidate('(()(())((())))'), {'(()(())((())))'})
    lu.assertEquals(candidate('( ) (( )) (( )( ))'), {'()', '(())', '(()())'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
-- separate those group into separate strings and return the table of those.
-- Separate groups are balanced (each open brace is properly closed) and not nested within each other
-- Ignore any spaces in the input string.
-- >>> separate_paren_groups('( ) (( )) (( )( ))')
-- {'()', '(())', '(()())'}
-- Separate nested parenthesis groups from a string.
-- The input string may contain spaces anywhere; they are ignored.
-- Each group is a balanced set of parentheses that does not overlap
-- with any other group.  The function returns a table containing
-- the groups in the order they appear.
--
-- Example:
--   separate_paren_groups('( ) (( )) (( )( ))')
--   --> {'()', '(())', '(()())'}
local function separate_paren_groups(paren_string)
  local groups = {}
  local depth   = 0          -- current nesting depth
  local current = ''         -- buffer for the current group

  for i = 1, #paren_string do
    local ch = paren_string:sub(i,i)

    if ch == '(' then
      depth = depth + 1
      -- start a new group when we go from depth 0 to 1
      if depth == 1 then
        current = ''
      end
      current = current .. '('

    elseif ch == ')' then
      current = current .. ')'
      depth = depth - 1
      -- close a group when we return to depth 0
      if depth == 0 then
        table.insert(groups, current)
        current = ''
      end

    elseif ch ~= ' ' then
      -- ignore any character that is not a parenthesis or a space
      -- (the problem guarantees only these are present)
    end
  end

  return groups
end
lu = require('luaunit')

function test_humaneval()
local candidate = separate_paren_groups
    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {'(()())', '((()))', '()', '((())()())'})
    lu.assertEquals(candidate('() (()) ((())) (((())))'), {'()', '(())', '((()))', '(((())))'})
    lu.assertEquals(candidate('(()(())((())))'), {'(()(())((())))'})
    lu.assertEquals(candidate('( ) (( )) (( )( ))'), {'()', '(())', '(()())'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 2 (LUA) - HumanEval_2_truncate_number
================================================================================

PROMPT:
----------------------------------------
-- Given a positive floating point number, it can be decomposed into
-- and integer part (largest integer smaller than given number) and decimals
-- (leftover part always smaller than 1).
-- Return the decimal part of the number.
-- >>> truncate_number(3.5)
-- 0.5

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = truncate_number
    lu.assertEquals(candidate(3.5), 0.5)
    lu.assertEquals(candidate(1.25), 0.25)
    lu.assertEquals(candidate(123.0), 0.0)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Given a positive floating point number, it can be decomposed into
-- and integer part (largest integer smaller than given number) and decimals
-- (leftover part always smaller than 1).
-- Return the decimal part of the number.
-- >>> truncate_number(3.5)
-- 0.5
-- Return the decimal (fractional) part of a positive floatingâ€‘point number.
-- Example: 3.5 â†’ 0.5
local function truncate_number(number)
    -- Lua's math.modf returns the integer part and the fractional part.
    local _, frac = math.modf(number)
    return frac
end
lu = require('luaunit')

function test_humaneval()
local candidate = truncate_number
    lu.assertEquals(candidate(3.5), 0.5)
    lu.assertEquals(candidate(1.25), 0.25)
    lu.assertEquals(candidate(123.0), 0.0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Given a positive floating point number, it can be decomposed into
-- and integer part (largest integer smaller than given number) and decimals
-- (leftover part always smaller than 1).
-- Return the decimal part of the number.
-- >>> truncate_number(3.5)
-- 0.5
-- Return the decimal part of the given positive floating point number
local function truncate_number(number)
    -- math.floor gives the largest integer <= number
    return number - math.floor(number)
end
lu = require('luaunit')

function test_humaneval()
local candidate = truncate_number
    lu.assertEquals(candidate(3.5), 0.5)
    lu.assertEquals(candidate(1.25), 0.25)
    lu.assertEquals(candidate(123.0), 0.0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Given a positive floating point number, it can be decomposed into
-- and integer part (largest integer smaller than given number) and decimals
-- (leftover part always smaller than 1).
-- Return the decimal part of the number.
-- >>> truncate_number(3.5)
-- 0.5
-- Returns the fractional part of a positive floating point number.
-- For example, truncate_number(3.5) returns 0.5.
local function truncate_number(number)
    -- math.floor gives the largest integer <= number.
    -- Subtracting it from the original number leaves the decimal part.
    return number - math.floor(number)
end
lu = require('luaunit')

function test_humaneval()
local candidate = truncate_number
    lu.assertEquals(candidate(3.5), 0.5)
    lu.assertEquals(candidate(1.25), 0.25)
    lu.assertEquals(candidate(123.0), 0.0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Given a positive floating point number, it can be decomposed into
-- and integer part (largest integer smaller than given number) and decimals
-- (leftover part always smaller than 1).
-- Return the decimal part of the number.
-- >>> truncate_number(3.5)
-- 0.5
-- Return the decimal part of a positive floating point number.
-- The decimal part is the fractional remainder after removing the integer part.
-- For example: truncate_number(3.5) -> 0.5
local function truncate_number(number)
    -- Ensure we are dealing with a positive number (as per the problem statement)
    if number < 0 then
        error("truncate_number expects a positive number")
    end

    -- Compute the integer part using math.floor
    local integer_part = math.floor(number)

    -- Subtract the integer part to get the decimal (fractional) part
    local decimal_part = number - integer_part

    return decimal_part
end
lu = require('luaunit')

function test_humaneval()
local candidate = truncate_number
    lu.assertEquals(candidate(3.5), 0.5)
    lu.assertEquals(candidate(1.25), 0.25)
    lu.assertEquals(candidate(123.0), 0.0)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 3 (LUA) - HumanEval_3_below_zero
================================================================================

PROMPT:
----------------------------------------
-- You're given a table of deposit and withdrawal operations on a bank account that starts with
-- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
-- at that point function should return true. Otherwise it should return false.
-- >>> below_zero({1, 2, 3})
-- false
-- >>> below_zero({1, 2, -4, 5})
-- true

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = below_zero
    lu.assertEquals(candidate({}), false)
    lu.assertEquals(candidate({1, 2, -3, 1, 2, -3}), false)
    lu.assertEquals(candidate({1, 2, -4, 5, 6}), true)
    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -4}), false)
    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -5}), true)
    lu.assertEquals(candidate({1, -2, 2, -2, 5, -5, 4, -4}), true)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- You're given a table of deposit and withdrawal operations on a bank account that starts with
-- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
-- at that point function should return true. Otherwise it should return false.
-- >>> below_zero({1, 2, 3})
-- false
-- >>> below_zero({1, 2, -4, 5})
-- true
local function below_zero(operations)
  local balance = 0
  for _, op in ipairs(operations) do
    balance = balance + op
    if balance < 0 then
      return true
    end
  end
  return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = below_zero
    lu.assertEquals(candidate({}), false)
    lu.assertEquals(candidate({1, 2, -3, 1, 2, -3}), false)
    lu.assertEquals(candidate({1, 2, -4, 5, 6}), true)
    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -4}), false)
    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -5}), true)
    lu.assertEquals(candidate({1, -2, 2, -2, 5, -5, 4, -4}), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- You're given a table of deposit and withdrawal operations on a bank account that starts with
-- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
-- at that point function should return true. Otherwise it should return false.
-- >>> below_zero({1, 2, 3})
-- false
-- >>> below_zero({1, 2, -4, 5})
-- true
local function below_zero(operations)
    local balance = 0
    for _, op in ipairs(operations) do
        balance = balance + op
        if balance < 0 then
            return true
        end
    end
    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = below_zero
    lu.assertEquals(candidate({}), false)
    lu.assertEquals(candidate({1, 2, -3, 1, 2, -3}), false)
    lu.assertEquals(candidate({1, 2, -4, 5, 6}), true)
    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -4}), false)
    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -5}), true)
    lu.assertEquals(candidate({1, -2, 2, -2, 5, -5, 4, -4}), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- You're given a table of deposit and withdrawal operations on a bank account that starts with
-- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
-- at that point function should return true. Otherwise it should return false.
-- >>> below_zero({1, 2, 3})
-- false
-- >>> below_zero({1, 2, -4, 5})
-- true
-- Detects whether the account balance ever goes below zero
-- @param operations table of integers representing deposits (+) and withdrawals (-)
-- @return boolean true if the balance ever becomes negative, otherwise false
local function below_zero(operations)
    local balance = 0
    for _, op in ipairs(operations) do
        balance = balance + op
        if balance < 0 then
            return true
        end
    end
    return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = below_zero
    lu.assertEquals(candidate({}), false)
    lu.assertEquals(candidate({1, 2, -3, 1, 2, -3}), false)
    lu.assertEquals(candidate({1, 2, -4, 5, 6}), true)
    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -4}), false)
    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -5}), true)
    lu.assertEquals(candidate({1, -2, 2, -2, 5, -5, 4, -4}), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- You're given a table of deposit and withdrawal operations on a bank account that starts with
-- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
-- at that point function should return true. Otherwise it should return false.
-- >>> below_zero({1, 2, 3})
-- false
-- >>> below_zero({1, 2, -4, 5})
-- true
local function below_zero(operations)
  local balance = 0
  for _, op in ipairs(operations) do
    balance = balance + op
    if balance < 0 then
      return true
    end
  end
  return false
end
lu = require('luaunit')

function test_humaneval()
local candidate = below_zero
    lu.assertEquals(candidate({}), false)
    lu.assertEquals(candidate({1, 2, -3, 1, 2, -3}), false)
    lu.assertEquals(candidate({1, 2, -4, 5, 6}), true)
    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -4}), false)
    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -5}), true)
    lu.assertEquals(candidate({1, -2, 2, -2, 5, -5, 4, -4}), true)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 4 (LUA) - HumanEval_4_mean_absolute_deviation
================================================================================

PROMPT:
----------------------------------------
-- For a given table of input numbers, calculate Mean Absolute Deviation
-- around the mean of this dataset.
-- Mean Absolute Deviation is the average absolute difference between each
-- element and a centerpoint (mean in this case):
-- MAD = average | x - x_mean |
-- >>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})
-- 1.0

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = mean_absolute_deviation
    lu.assertEquals(candidate({1.0, 2.0}), 0.5)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0}), 1.0)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}), 1.2)
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- For a given table of input numbers, calculate Mean Absolute Deviation
-- around the mean of this dataset.
-- Mean Absolute Deviation is the average absolute difference between each
-- element and a centerpoint (mean in this case):
-- MAD = average | x - x_mean |
-- >>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})
-- 1.0
-- Calculate Mean Absolute Deviation (MAD) for a table of numbers.
-- The table is expected to contain numeric values and is treated as a list.
-- If the table is empty, the function returns 0.
local function mean_absolute_deviation(numbers)
    local n = #numbers
    if n == 0 then
        return 0
    end

    -- Compute the mean
    local sum = 0
    for _, v in ipairs(numbers) do
        sum = sum + v
    end
    local mean = sum / n

    -- Compute the average absolute deviation
    local mad = 0
    for _, v in ipairs(numbers) do
        mad = mad + math.abs(v - mean)
    end
    return mad / n
end
lu = require('luaunit')

function test_humaneval()
local candidate = mean_absolute_deviation
    lu.assertEquals(candidate({1.0, 2.0}), 0.5)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0}), 1.0)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}), 1.2)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- For a given table of input numbers, calculate Mean Absolute Deviation
-- around the mean of this dataset.
-- Mean Absolute Deviation is the average absolute difference between each
-- element and a centerpoint (mean in this case):
-- MAD = average | x - x_mean |
-- >>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})
-- 1.0
-- Calculate the Mean Absolute Deviation (MAD) of a numeric table.
-- @param numbers A table containing numeric values.
-- @return The MAD of the numbers (average absolute difference from the mean).
local function mean_absolute_deviation(numbers)
    local n = #numbers
    if n == 0 then
        return 0  -- or nil if you prefer to signal an error
    end

    -- Compute the mean
    local sum = 0
    for _, v in ipairs(numbers) do
        sum = sum + v
    end
    local mean = sum / n

    -- Compute the average absolute deviation
    local absSum = 0
    for _, v in ipairs(numbers) do
        absSum = absSum + math.abs(v - mean)
    end

    return absSum / n
end
lu = require('luaunit')

function test_humaneval()
local candidate = mean_absolute_deviation
    lu.assertEquals(candidate({1.0, 2.0}), 0.5)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0}), 1.0)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}), 1.2)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- For a given table of input numbers, calculate Mean Absolute Deviation
-- around the mean of this dataset.
-- Mean Absolute Deviation is the average absolute difference between each
-- element and a centerpoint (mean in this case):
-- MAD = average | x - x_mean |
-- >>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})
-- 1.0
-- Calculate Mean Absolute Deviation (MAD) for a numeric table.
-- MAD = average of |x - mean| for all elements x in the table.
--
-- Example:
--   mean_absolute_deviation({1.0, 2.0, 3.0, 4.0}) --> 1.0
--
local function mean_absolute_deviation(numbers)
    local n = #numbers
    if n == 0 then
        return 0  -- or nil, depending on desired behavior for empty input
    end

    -- Compute the mean
    local sum = 0
    for _, v in ipairs(numbers) do
        sum = sum + v
    end
    local mean = sum / n

    -- Compute the sum of absolute deviations from the mean
    local mad_sum = 0
    for _, v in ipairs(numbers) do
        mad_sum = mad_sum + math.abs(v - mean)
    end

    -- Return the average absolute deviation
    return mad_sum / n
end
lu = require('luaunit')

function test_humaneval()
local candidate = mean_absolute_deviation
    lu.assertEquals(candidate({1.0, 2.0}), 0.5)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0}), 1.0)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}), 1.2)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- For a given table of input numbers, calculate Mean Absolute Deviation
-- around the mean of this dataset.
-- Mean Absolute Deviation is the average absolute difference between each
-- element and a centerpoint (mean in this case):
-- MAD = average | x - x_mean |
-- >>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})
-- 1.0
-- Calculate the Mean Absolute Deviation (MAD) of a numeric table.
-- The MAD is the average of the absolute differences between each
-- element and the arithmetic mean of the dataset.
--
-- Example:
--   mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})  --> 1.0
--
-- Parameters
--   numbers (table): A table containing numeric values.
--
-- Returns
--   number: The MAD of the input numbers. If the table is empty,
--   the function returns 0.
--
local function mean_absolute_deviation(numbers)
    -- Guard against an empty table to avoid division by zero.
    local n = #numbers
    if n == 0 then
        return 0
    end

    -- 1. Compute the mean of the numbers.
    local sum = 0
    for _, value in ipairs(numbers) do
        sum = sum + value
    end
    local mean = sum / n

    -- 2. Compute the sum of absolute deviations from the mean.
    local abs_dev_sum = 0
    for _, value in ipairs(numbers) do
        abs_dev_sum = abs_dev_sum + math.abs(value - mean)
    end

    -- 3. Return the average absolute deviation.
    return abs_dev_sum / n
end
lu = require('luaunit')

function test_humaneval()
local candidate = mean_absolute_deviation
    lu.assertEquals(candidate({1.0, 2.0}), 0.5)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0}), 1.0)
    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}), 1.2)
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 5 (LUA) - HumanEval_5_intersperse
================================================================================

PROMPT:
----------------------------------------
-- Insert a number 'delimeter' between every two consecutive elements of input table `numbers'
-- >>> intersperse({}, 4)
-- {}
-- >>> intersperse({1, 2, 3}, 4)
-- {1, 4, 2, 4, 3}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = intersperse
    lu.assertEquals(candidate({}, 7), {})
    lu.assertEquals(candidate({5, 6, 3, 2}, 8), {5, 8, 6, 8, 3, 8, 2})
    lu.assertEquals(candidate({2, 2, 2}, 2), {2, 2, 2, 2, 2})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Insert a number 'delimeter' between every two consecutive elements of input table `numbers'
-- >>> intersperse({}, 4)
-- {}
-- >>> intersperse({1, 2, 3}, 4)
-- {1, 4, 2, 4, 3}
local function intersperse(numbers, delimeter)
  local result = {}
  local n = #numbers
  for i, v in ipairs(numbers) do
    result[#result + 1] = v
    if i < n then
      result[#result + 1] = delimeter
    end
  end
  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = intersperse
    lu.assertEquals(candidate({}, 7), {})
    lu.assertEquals(candidate({5, 6, 3, 2}, 8), {5, 8, 6, 8, 3, 8, 2})
    lu.assertEquals(candidate({2, 2, 2}, 2), {2, 2, 2, 2, 2})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Insert a number 'delimeter' between every two consecutive elements of input table `numbers'
-- >>> intersperse({}, 4)
-- {}
-- >>> intersperse({1, 2, 3}, 4)
-- {1, 4, 2, 4, 3}
local function intersperse(numbers, delimeter)
  local result = {}
  if not numbers then return result end

  local n = #numbers
  for i = 1, n do
    result[#result + 1] = numbers[i]
    if i < n then
      result[#result + 1] = delimeter
    end
  end

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = intersperse
    lu.assertEquals(candidate({}, 7), {})
    lu.assertEquals(candidate({5, 6, 3, 2}, 8), {5, 8, 6, 8, 3, 8, 2})
    lu.assertEquals(candidate({2, 2, 2}, 2), {2, 2, 2, 2, 2})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Insert a number 'delimeter' between every two consecutive elements of input table `numbers'
-- >>> intersperse({}, 4)
-- {}
-- >>> intersperse({1, 2, 3}, 4)
-- {1, 4, 2, 4, 3}
-- Insert a number 'delimeter' between every two consecutive elements of input table `numbers`
-- >>> intersperse({}, 4)
-- {}
-- >>> intersperse({1, 2, 3}, 4)
-- {1, 4, 2, 4, 3}
local function intersperse(numbers, delimeter)
  local result = {}
  local n = #numbers
  for i, v in ipairs(numbers) do
    result[#result + 1] = v
    if i < n then
      result[#result + 1] = delimeter
    end
  end
  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = intersperse
    lu.assertEquals(candidate({}, 7), {})
    lu.assertEquals(candidate({5, 6, 3, 2}, 8), {5, 8, 6, 8, 3, 8, 2})
    lu.assertEquals(candidate({2, 2, 2}, 2), {2, 2, 2, 2, 2})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Insert a number 'delimeter' between every two consecutive elements of input table `numbers'
-- >>> intersperse({}, 4)
-- {}
-- >>> intersperse({1, 2, 3}, 4)
-- {1, 4, 2, 4, 3}
local function intersperse(numbers, delimeter)
    -- Create a new table to hold the result
    local result = {}
    -- If the input table is empty, just return the empty result
    if #numbers == 0 then
        return result
    end

    -- Iterate over the input table
    for i = 1, #numbers do
        -- Copy the current element
        result[#result + 1] = numbers[i]
        -- Insert the delimiter after every element except the last
        if i < #numbers then
            result[#result + 1] = delimeter
        end
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = intersperse
    lu.assertEquals(candidate({}, 7), {})
    lu.assertEquals(candidate({5, 6, 3, 2}, 8), {5, 8, 6, 8, 3, 8, 2})
    lu.assertEquals(candidate({2, 2, 2}, 2), {2, 2, 2, 2, 2})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154464
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 6 (LUA) - HumanEval_6_parse_nested_parens
================================================================================

PROMPT:
----------------------------------------
-- Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
-- For each of the group, output the deepest level of nesting of parentheses.
-- E.g. (()()) has maximum two levels of nesting while ((())) has three.
-- >>> parse_nested_parens('(()()) ((())) () ((())()())')
-- {2, 3, 1, 3}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = parse_nested_parens
    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {2, 3, 1, 3})
    lu.assertEquals(candidate('() (()) ((())) (((())))'), {1, 2, 3, 4})
    lu.assertEquals(candidate('(()(())((())))'), {4})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
-- For each of the group, output the deepest level of nesting of parentheses.
-- E.g. (()()) has maximum two levels of nesting while ((())) has three.
-- >>> parse_nested_parens('(()()) ((())) () ((())()())')
-- {2, 3, 1, 3}
local function parse_nested_parens(paren_string)
    local depths = {}
    -- Iterate over each group separated by whitespace
    for group in paren_string:gmatch("%S+") do
        local depth = 0
        local max_depth = 0
        -- Scan each character in the group
        for i = 1, #group do
            local char = group:sub(i, i)
            if char == '(' then
                depth = depth + 1
                if depth > max_depth then
                    max_depth = depth
                end
            elseif char == ')' then
                depth = depth - 1
            end
        end
        table.insert(depths, max_depth)
    end
    return depths
end
lu = require('luaunit')

function test_humaneval()
local candidate = parse_nested_parens
    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {2, 3, 1, 3})
    lu.assertEquals(candidate('() (()) ((())) (((())))'), {1, 2, 3, 4})
    lu.assertEquals(candidate('(()(())((())))'), {4})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
-- For each of the group, output the deepest level of nesting of parentheses.
-- E.g. (()()) has maximum two levels of nesting while ((())) has three.
-- >>> parse_nested_parens('(()()) ((())) () ((())()())')
-- {2, 3, 1, 3}
-- | Parse a string containing several groups of nested parentheses
-- | separated by spaces and return a table containing the deepest
-- | level of nesting for each group.
--
-- Example:
-- >>> parse_nested_parens('(()()) ((())) () ((())()())')
-- {2, 3, 1, 3}
--
local function parse_nested_parens(paren_string)
  local result = {}

  -- Split the input string into individual groups (separated by whitespace)
  for group in paren_string:gmatch("%S+") do
    local depth = 0          -- current nesting depth
    local max_depth = 0      -- deepest depth seen in this group

    -- Iterate over each character in the group
    for i = 1, #group do
      local char = group:sub(i, i)

      if char == '(' then
        depth = depth + 1
        if depth > max_depth then
          max_depth = depth
        end
      elseif char == ')' then
        depth = depth - 1
      end
    end

    -- Store the maximum depth for this group
    result[#result + 1] = max_depth
  end

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = parse_nested_parens
    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {2, 3, 1, 3})
    lu.assertEquals(candidate('() (()) ((())) (((())))'), {1, 2, 3, 4})
    lu.assertEquals(candidate('(()(())((())))'), {4})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
-- For each of the group, output the deepest level of nesting of parentheses.
-- E.g. (()()) has maximum two levels of nesting while ((())) has three.
-- >>> parse_nested_parens('(()()) ((())) () ((())()())')
-- {2, 3, 1, 3}
-- Returns a table containing the deepest nesting depth for each group of parentheses
-- separated by spaces in the input string.
local function parse_nested_parens(paren_string)
    local result = {}          -- table that will hold the depths

    -- Iterate over each nonâ€‘empty group separated by whitespace
    for group in string.gmatch(paren_string, "%S+") do
        local depth = 0
        local max_depth = 0

        -- Scan every character in the current group
        for i = 1, #group do
            local c = group:sub(i, i)

            if c == '(' then
                depth = depth + 1
                if depth > max_depth then
                    max_depth = depth
                end
            elseif c == ')' then
                depth = depth - 1
            end
        end

        table.insert(result, max_depth)
    end

    return result
end

-- Example usage:
-- local depths = parse_nested_parens('(()()) ((())) () ((())()())')
-- print(table.concat(depths, ", "))  -- prints: 2, 3, 1, 3
lu = require('luaunit')

function test_humaneval()
local candidate = parse_nested_parens
    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {2, 3, 1, 3})
    lu.assertEquals(candidate('() (()) ((())) (((())))'), {1, 2, 3, 4})
    lu.assertEquals(candidate('(()(())((())))'), {4})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
-- For each of the group, output the deepest level of nesting of parentheses.
-- E.g. (()()) has maximum two levels of nesting while ((())) has three.
-- >>> parse_nested_parens('(()()) ((())) () ((())()())')
-- {2, 3, 1, 3}
-- Parse a string containing several parenthesis groups separated by spaces.
-- For each group, compute the deepest level of nesting.
-- Return a table with the maximum depth for every group.
--
-- Example:
--   parse_nested_parens('(()()) ((())) () ((())()())')
--   --> {2, 3, 1, 3}
--
local function parse_nested_parens(paren_string)
  local result = {}          -- table to hold max depth per group
  local current_depth = 0    -- depth while scanning a group
  local max_depth = 0        -- deepest depth seen so far in the current group

  for i = 1, #paren_string do
    local c = paren_string:sub(i, i)

    if c == '(' then
      current_depth = current_depth + 1
      if current_depth > max_depth then
        max_depth = current_depth
      end

    elseif c == ')' then
      current_depth = current_depth - 1

    elseif c == ' ' then
      -- End of a group: store its depth if it was nonâ€‘empty
      if max_depth > 0 then
        table.insert(result, max_depth)
      end
      -- Reset counters for the next group
      current_depth = 0
      max_depth = 0
    end
  end

  -- Handle the last group (if the string doesnâ€™t end with a space)
  if max_depth > 0 then
    table.insert(result, max_depth)
  end

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = parse_nested_parens
    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {2, 3, 1, 3})
    lu.assertEquals(candidate('() (()) ((())) (((())))'), {1, 2, 3, 4})
    lu.assertEquals(candidate('(()(())((())))'), {4})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 7 (LUA) - HumanEval_7_filter_by_substring
================================================================================

PROMPT:
----------------------------------------
-- Filter an input table of strings only for ones that contain given substring
-- >>> filter_by_substring({}, 'a')
-- {}
-- >>> filter_by_substring({'abc', 'bacd', 'cde', 'array'}, 'a')
-- {'abc', 'bacd', 'array'}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = filter_by_substring
    lu.assertEquals(candidate({}, 'john'), {})
    lu.assertEquals(candidate({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx'), {'xxx', 'xxxAAA', 'xxx'})
    lu.assertEquals(candidate({'xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'}, 'xx'), {'xxx', 'aaaxxy', 'xxxAAA', 'xxx'})
    lu.assertEquals(candidate({'grunt', 'trumpet', 'prune', 'gruesome'}, 'run'), {'grunt', 'prune'})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- Filter an input table of strings only for ones that contain given substring
-- >>> filter_by_substring({}, 'a')
-- {}
-- >>> filter_by_substring({'abc', 'bacd', 'cde', 'array'}, 'a')
-- {'abc', 'bacd', 'array'}
-- Filter an input table of strings only for ones that contain the given substring
-- >>> filter_by_substring({}, 'a')
-- {}
-- >>> filter_by_substring({'abc', 'bacd', 'cde', 'array'}, 'a')
-- {'abc', 'bacd', 'array'}
local function filter_by_substring(strings, substring)
    local result = {}
    -- iterate over the array part of the table
    for _, str in ipairs(strings) do
        -- use plain string search (no pattern matching)
        if string.find(str, substring, 1, true) then
            table.insert(result, str)
        end
    end
    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = filter_by_substring
    lu.assertEquals(candidate({}, 'john'), {})
    lu.assertEquals(candidate({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx'), {'xxx', 'xxxAAA', 'xxx'})
    lu.assertEquals(candidate({'xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'}, 'xx'), {'xxx', 'aaaxxy', 'xxxAAA', 'xxx'})
    lu.assertEquals(candidate({'grunt', 'trumpet', 'prune', 'gruesome'}, 'run'), {'grunt', 'prune'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- Filter an input table of strings only for ones that contain given substring
-- >>> filter_by_substring({}, 'a')
-- {}
-- >>> filter_by_substring({'abc', 'bacd', 'cde', 'array'}, 'a')
-- {'abc', 'bacd', 'array'}
-- Filter an input table of strings only for ones that contain given substring
-- >>> filter_by_substring({}, 'a')
-- {}
-- >>> filter_by_substring({'abc', 'bacd', 'cde', 'array'}, 'a')
-- {'abc', 'bacd', 'array'}
local function filter_by_substring(strings, substring)
    -- Create a new table to hold the filtered results
    local result = {}

    -- Iterate over each string in the input table
    for _, str in ipairs(strings) do
        -- Use string.find with the plain flag (true) to avoid pattern matching
        if string.find(str, substring, 1, true) then
            table.insert(result, str)
        end
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = filter_by_substring
    lu.assertEquals(candidate({}, 'john'), {})
    lu.assertEquals(candidate({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx'), {'xxx', 'xxxAAA', 'xxx'})
    lu.assertEquals(candidate({'xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'}, 'xx'), {'xxx', 'aaaxxy', 'xxxAAA', 'xxx'})
    lu.assertEquals(candidate({'grunt', 'trumpet', 'prune', 'gruesome'}, 'run'), {'grunt', 'prune'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- Filter an input table of strings only for ones that contain given substring
-- >>> filter_by_substring({}, 'a')
-- {}
-- >>> filter_by_substring({'abc', 'bacd', 'cde', 'array'}, 'a')
-- {'abc', 'bacd', 'array'}
local function filter_by_substring(strings, substring)
    local result = {}
    for _, s in ipairs(strings) do
        if string.find(s, substring, nil, true) then
            table.insert(result, s)
        end
    end
    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = filter_by_substring
    lu.assertEquals(candidate({}, 'john'), {})
    lu.assertEquals(candidate({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx'), {'xxx', 'xxxAAA', 'xxx'})
    lu.assertEquals(candidate({'xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'}, 'xx'), {'xxx', 'aaaxxy', 'xxxAAA', 'xxx'})
    lu.assertEquals(candidate({'grunt', 'trumpet', 'prune', 'gruesome'}, 'run'), {'grunt', 'prune'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- Filter an input table of strings only for ones that contain given substring
-- >>> filter_by_substring({}, 'a')
-- {}
-- >>> filter_by_substring({'abc', 'bacd', 'cde', 'array'}, 'a')
-- {'abc', 'bacd', 'array'}
-- Filter an input table of strings only for ones that contain given substring
-- >>> filter_by_substring({}, 'a')
-- {}
-- >>> filter_by_substring({'abc', 'bacd', 'cde', 'array'}, 'a')
-- {'abc', 'bacd', 'array'}
local function filter_by_substring(strings, substring)
  local result = {}
  -- Iterate over the array-like part of the table
  for _, str in ipairs(strings) do
    if type(str) == 'string' and string.find(str, substring, 1, true) then
      table.insert(result, str)
    end
  end
  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = filter_by_substring
    lu.assertEquals(candidate({}, 'john'), {})
    lu.assertEquals(candidate({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx'), {'xxx', 'xxxAAA', 'xxx'})
    lu.assertEquals(candidate({'xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'}, 'xx'), {'xxx', 'aaaxxy', 'xxxAAA', 'xxx'})
    lu.assertEquals(candidate({'grunt', 'trumpet', 'prune', 'gruesome'}, 'run'), {'grunt', 'prune'})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 8 (LUA) - HumanEval_8_sum_product
================================================================================

PROMPT:
----------------------------------------
-- For a given table of integers, return a table consisting of a sum and a product of all the integers in a table.
-- Empty sum should be equal to 0 and empty product should be equal to 1.
-- >>> sum_product({})
-- {0, 1}
-- >>> sum_product({1, 2, 3, 4})
-- {10, 24}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = sum_product
    lu.assertEquals(candidate({}), {0, 1})
    lu.assertEquals(candidate({1, 1, 1}), {3, 1})
    lu.assertEquals(candidate({100, 0}), {100, 0})
    lu.assertEquals(candidate({3, 5, 7}), {15, 105})
    lu.assertEquals(candidate({10}), {10, 10})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- For a given table of integers, return a table consisting of a sum and a product of all the integers in a table.
-- Empty sum should be equal to 0 and empty product should be equal to 1.
-- >>> sum_product({})
-- {0, 1}
-- >>> sum_product({1, 2, 3, 4})
-- {10, 24}
local function sum_product(numbers)
  local sum = 0
  local product = 1
  for _, v in ipairs(numbers) do
    sum = sum + v
    product = product * v
  end
  return {sum, product}
end
lu = require('luaunit')

function test_humaneval()
local candidate = sum_product
    lu.assertEquals(candidate({}), {0, 1})
    lu.assertEquals(candidate({1, 1, 1}), {3, 1})
    lu.assertEquals(candidate({100, 0}), {100, 0})
    lu.assertEquals(candidate({3, 5, 7}), {15, 105})
    lu.assertEquals(candidate({10}), {10, 10})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- For a given table of integers, return a table consisting of a sum and a product of all the integers in a table.
-- Empty sum should be equal to 0 and empty product should be equal to 1.
-- >>> sum_product({})
-- {0, 1}
-- >>> sum_product({1, 2, 3, 4})
-- {10, 24}
local function sum_product(numbers)
  local sum, product = 0, 1
  for _, v in ipairs(numbers) do
    sum = sum + v
    product = product * v
  end
  return {sum, product}
end
lu = require('luaunit')

function test_humaneval()
local candidate = sum_product
    lu.assertEquals(candidate({}), {0, 1})
    lu.assertEquals(candidate({1, 1, 1}), {3, 1})
    lu.assertEquals(candidate({100, 0}), {100, 0})
    lu.assertEquals(candidate({3, 5, 7}), {15, 105})
    lu.assertEquals(candidate({10}), {10, 10})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- For a given table of integers, return a table consisting of a sum and a product of all the integers in a table.
-- Empty sum should be equal to 0 and empty product should be equal to 1.
-- >>> sum_product({})
-- {0, 1}
-- >>> sum_product({1, 2, 3, 4})
-- {10, 24}
local function sum_product(numbers)
  local sum = 0
  local prod = 1

  for _, n in ipairs(numbers) do
    sum = sum + n
    prod = prod * n
  end

  return {sum, prod}
end
lu = require('luaunit')

function test_humaneval()
local candidate = sum_product
    lu.assertEquals(candidate({}), {0, 1})
    lu.assertEquals(candidate({1, 1, 1}), {3, 1})
    lu.assertEquals(candidate({100, 0}), {100, 0})
    lu.assertEquals(candidate({3, 5, 7}), {15, 105})
    lu.assertEquals(candidate({10}), {10, 10})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- For a given table of integers, return a table consisting of a sum and a product of all the integers in a table.
-- Empty sum should be equal to 0 and empty product should be equal to 1.
-- >>> sum_product({})
-- {0, 1}
-- >>> sum_product({1, 2, 3, 4})
-- {10, 24}
local function sum_product(numbers)
  -- Initialize sum and product according to the problem statement
  local sum = 0
  local product = 1

  -- Iterate over the table of numbers (assuming array-like table)
  for _, num in ipairs(numbers) do
    sum = sum + num
    product = product * num
  end

  -- Return a table containing the sum and the product
  return {sum, product}
end
lu = require('luaunit')

function test_humaneval()
local candidate = sum_product
    lu.assertEquals(candidate({}), {0, 1})
    lu.assertEquals(candidate({1, 1, 1}), {3, 1})
    lu.assertEquals(candidate({100, 0}), {100, 0})
    lu.assertEquals(candidate({3, 5, 7}), {15, 105})
    lu.assertEquals(candidate({10}), {10, 10})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

================================================================================
PROBLEM 9 (LUA) - HumanEval_9_rolling_max
================================================================================

PROMPT:
----------------------------------------
-- From a given table of integers, generate a table of rolling maximum element found until given moment
-- in the sequence.
-- >>> rolling_max({1, 2, 3, 2, 3, 4, 2})
-- {1, 2, 3, 3, 3, 4, 4}

----------------------------------------

TEST CASES:
----------------------------------------
lu = require('luaunit')

function test_humaneval()
local candidate = rolling_max
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 2, 3, 4})
    lu.assertEquals(candidate({4, 3, 2, 1}), {4, 4, 4, 4})
    lu.assertEquals(candidate({3, 2, 3, 100, 3}), {3, 3, 3, 100, 100})
end

os.exit(lu.LuaUnit.run())
----------------------------------------

COMPLETION 1:
--------------------
PROGRAM:
-- From a given table of integers, generate a table of rolling maximum element found until given moment
-- in the sequence.
-- >>> rolling_max({1, 2, 3, 2, 3, 4, 2})
-- {1, 2, 3, 3, 3, 4, 4}
local function rolling_max(numbers)
    local result = {}
    local current_max = nil

    for i, v in ipairs(numbers) do
        if current_max == nil or v > current_max then
            current_max = v
        end
        result[i] = current_max
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = rolling_max
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 2, 3, 4})
    lu.assertEquals(candidate({4, 3, 2, 1}), {4, 4, 4, 4})
    lu.assertEquals(candidate({3, 2, 3, 100, 3}), {3, 3, 3, 100, 100})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 2:
--------------------
PROGRAM:
-- From a given table of integers, generate a table of rolling maximum element found until given moment
-- in the sequence.
-- >>> rolling_max({1, 2, 3, 2, 3, 4, 2})
-- {1, 2, 3, 3, 3, 4, 4}
-- Return a table where each element is the maximum of all elements up to that index.
local function rolling_max(numbers)
    local result = {}
    local max = -math.huge  -- start with the smallest possible number

    for i, v in ipairs(numbers) do
        if v > max then
            max = v
        end
        result[i] = max
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = rolling_max
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 2, 3, 4})
    lu.assertEquals(candidate({4, 3, 2, 1}), {4, 4, 4, 4})
    lu.assertEquals(candidate({3, 2, 3, 100, 3}), {3, 3, 3, 100, 100})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 3:
--------------------
PROGRAM:
-- From a given table of integers, generate a table of rolling maximum element found until given moment
-- in the sequence.
-- >>> rolling_max({1, 2, 3, 2, 3, 4, 2})
-- {1, 2, 3, 3, 3, 4, 4}
local function rolling_max(numbers)
  local result = {}
  local current_max

  for i, v in ipairs(numbers) do
    if i == 1 then
      current_max = v
    else
      if v > current_max then
        current_max = v
      end
    end
    result[i] = current_max
  end

  return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = rolling_max
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 2, 3, 4})
    lu.assertEquals(candidate({4, 3, 2, 1}), {4, 4, 4, 4})
    lu.assertEquals(candidate({3, 2, 3, 100, 3}), {3, 3, 3, 100, 100})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------

COMPLETION 4:
--------------------
PROGRAM:
-- From a given table of integers, generate a table of rolling maximum element found until given moment
-- in the sequence.
-- >>> rolling_max({1, 2, 3, 2, 3, 4, 2})
-- {1, 2, 3, 3, 3, 4, 4}
-- From a given table of integers, generate a table of rolling maximum element found until given moment
-- in the sequence.
-- >>> rolling_max({1, 2, 3, 2, 3, 4, 2})
-- {1, 2, 3, 3, 3, 4, 4}
local function rolling_max(numbers)
    local result = {}
    local current_max = nil

    for i, num in ipairs(numbers) do
        if current_max == nil or num > current_max then
            current_max = num
        end
        result[i] = current_max
    end

    return result
end
lu = require('luaunit')

function test_humaneval()
local candidate = rolling_max
    lu.assertEquals(candidate({}), {})
    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 2, 3, 4})
    lu.assertEquals(candidate({4, 3, 2, 1}), {4, 4, 4, 4})
    lu.assertEquals(candidate({3, 2, 3, 100, 3}), {3, 3, 3, 100, 100})
end

os.exit(lu.LuaUnit.run())

EXECUTION RESULTS:
Exit Code: 0
Status: OK
Timestamp: 1755154465
STDOUT:
.
Ran 1 tests in 0.000 seconds, 1 success, 0 failures
OK
STDERR: (empty)
--------------------
