================================================================================
DETAILED ANALYSIS: UNIVERSAL ZERO ACCURACY CASES - RACKET
================================================================================

These 14 questions achieved 0% accuracy across ALL 5 languages.
Analysis focuses on Racket implementations with generated code examples.
Configuration: RAG

============================================================
QUESTION #1: HumanEval_114_minSubArraySum
============================================================

PROBLEM DESCRIPTION:
--------------------
  #lang racket
  ;; Given a list of integers nums, find the minimum sum of any non-empty sub-list
  ;; of nums.
  ;; Example
  ;; >>> (minSubArraySum (list 2 3 4 1 2 4))
  ;; 1
  ;; >>> (minSubArraySum (list -1 -2 -3))

TEST CASES:
-----------
  (define (test-humaneval)
  (test-humaneval)

FAILURE ANALYSIS:
----------------
  Total attempts: 4
  Successful: 0
  Failed: 4

  Failure patterns:
    - Exception_exit_0: 4 times
  Common error types:
    - Other error: 4 times

EXAMPLE FAILURE #1:
--------------------
Generated Function:
  (define (minSubArraySum nums)
    (define (min-sum-so-far acc rest)
      (if (null? rest)
          acc
          (let ([current (car rest)]
                [remaining (cdr rest)])
            (min-sum-so-far (min acc (+ acc current))
                            remaining))))
    (min-sum-so-far (car nums) (cdr nums)))

Status: Exception
Exit Code: 0

EXAMPLE FAILURE #2:
--------------------
Generated Function:
  (define (minSubArraySum nums)
    (define (min-sum-so-far acc rest)
      (if (null? rest)
          acc
          (let ([current (car rest)])
            (min-sum-so-far (min acc (+ acc current))
                            (cdr rest)))))
    (min-sum-so-far (car nums) (cdr nums)))

Status: Exception
Exit Code: 0


============================================================
QUESTION #2: HumanEval_116_sort_array
============================================================

PROBLEM DESCRIPTION:
--------------------
  #lang racket
  ;; In this Kata, you have to sort a list of non-negative integers according to
  ;; number of ones in their binary representation in ascending order.
  ;; For similar number of ones, sort based on decimal value.
  ;; It must be implemented like this:
  ;; >>> (sort_array (list 1 5 2 3 4))
  ;; (list 1 2 3 4 5)

TEST CASES:
-----------
  (define (test-humaneval)
  (test-humaneval)

FAILURE ANALYSIS:
----------------
  Total attempts: 4
  Successful: 0
  Failed: 4

  Failure patterns:
    - SyntaxError_exit_1: 4 times
  Common error types:
    - Other error: 4 times

EXAMPLE FAILURE #1:
--------------------
Generated Function:
  (define (sort_array arr)
    (cond
      [(null? arr) '()]
      [(all-negative? arr) (sort arr >)]
      [else (sort arr (lambda (a b)
                        (let ([ones-a (count-bits a)]
                              [ones-b (count-bits b)])
                          (if (= ones-a ones-b)
                              (< a b)
                              (< ones-a ones-b))))]))
  
  (define (count-bits n)
  ... (truncated)

Status: SyntaxError
Exit Code: 1

EXAMPLE FAILURE #2:
--------------------
Generated Function:
  (define (sort_array arr)
    (cond
      [(null? arr) '()]
      [(and (null? (cdr arr)) (not (negative? (car arr)))) (list (car arr))]
      [(all-negative? arr) (sort arr >)]
      [else
       (sort arr (lambda (a b)
                   (let ([ones-a (count-bits a)]
                         [ones-b (count-bits b)])
                     (if (equal? ones-a ones-b)
                         (< a b)
                         (< ones-a ones-b))))]))
  ... (truncated)

Status: SyntaxError
Exit Code: 1


============================================================
QUESTION #3: HumanEval_129_minPath
============================================================

PROBLEM DESCRIPTION:
--------------------
  #lang racket
  ;; Given a grid with N rows and N columns (N >= 2) and a positive integer k, 
  ;; each cell of the grid contains a value. Every integer in the range [1, N * N]
  ;; inclusive appears exactly once on the cells of the grid.
  ;; You have to find the minimum path of length k in the grid. You can start
  ;; from any cell, and in each step you can move to any of the neighbor cells,
  ;; in other words, you can go to cells which share an edge with you current

TEST CASES:
-----------
  (define (test-humaneval)
  (test-humaneval)

FAILURE ANALYSIS:
----------------
  Total attempts: 4
  Successful: 0
  Failed: 4

  Failure patterns:
    - Exception_exit_0: 1 times
    - Exception_exit_1: 3 times
  Common error types:
    - Other error: 4 times

EXAMPLE FAILURE #1:
--------------------
Generated Function:
  (define (minPath grid k)
    (define n (length grid))
    (define m (length (car grid)))
    
    ;; Directions: up, down, left, right
    (define dirs (list (list -1 0) (list 1 0) (list 0 -1) (list 0 1)))
    
    ;; BFS-like search with pruning to find lexicographically smallest path
    ;; We'll explore from every starting cell and build paths of length k
    ;; Since we want lexicographically smallest, we can do a greedy search
    ;; with priority: first by value at step 1, then step 2, etc.
    
  ... (truncated)

Status: Exception
Exit Code: 0

EXAMPLE FAILURE #2:
--------------------
Generated Function:
  (define (test-humaneval) 
  
    (let (( candidate minPath))
      (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3) (list 1 2 1) 0.001)
      (check-within (candidate (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1) (list 1) 0.001)
      (check-within (candidate (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12) (list 13 14 15 16)) 4) (list 1 2 1 2) 0.001)
      (check-within (candidate (list (list 6 4 13 10) (list 5 7 12 1) (list 3 16 11 15) (list 8 14 9 2)) 7) (list 1 10 1 10 1 10 1) 0.001)
      (check-within (candidate (list (list 8 14 9 2) (list 6 4 13 15) (list 5 7 1 12) (list 3 10 11 16)) 5) (list 1 7 1 7 1) 0.001)
      (check-within (candidate (list (list 11 8 7 2) (list 5 16 14 4) (list 9 3 15 6) (list 12 13 10 1)) 9) (list 1 6 1 6 1 6 1 6 1) 0.001)
      (check-within (candidate (list (list 12 13 10 1) (list 9 3 15 6) (list 5 16 14 4) (list 11 8 7 2)) 12) (list 1 6 1 6 1 6 1 6 1 6 1 6) 0.001)
      (check-within (candidate (list (list 2 7 4) (list 3 1 5) (list 6 8 9)) 8) (list 1 3 1 3 1 3 1 3) 0.001)
      (check-within (candidate (list (list 6 1 5) (list 3 8 9) (list 2 7 4)) 8) (list 1 5 1 5 1 5 1 5) 0.001)
  ... (truncated)

Status: Exception
Exit Code: 1


============================================================
QUESTION #4: HumanEval_132_is_nested
============================================================

PROBLEM DESCRIPTION:
--------------------
  #lang racket
  ;; Create a function that takes a string as input which contains only square brackets.
  ;; The function should return #t if and only if there is a valid subsequence of brackets 
  ;; where at least one bracket in the subsequence is nested.
  ;; >>> (is_nested "[[]]")
  ;; #t
  ;; >>> (is_nested "[]]]]]]][[[[[]")

TEST CASES:
-----------
  (define (test-humaneval)
  (test-humaneval)

FAILURE ANALYSIS:
----------------
  Total attempts: 4
  Successful: 0
  Failed: 4

  Failure patterns:
    - Exception_exit_0: 3 times
    - SyntaxError_exit_1: 1 times
  Common error types:
    - Other error: 4 times

EXAMPLE FAILURE #1:
--------------------
Generated Function:
  (define (is_nested string)
    (define (is-nested-helper str depth)
      (cond
        [(string=? str "") #f]
        [(string=? (substring str 0 1) "[")
         (let ([new-depth (+ depth 1)])
           (if (> new-depth 1)
               #t ; found a nested bracket
               (is-nested-helper (substring str 1) new-depth)))]
        [(string=? (substring str 0 1) "]")
         (if (= depth 0)
             #f
  ... (truncated)

Status: Exception
Exit Code: 0

EXAMPLE FAILURE #2:
--------------------
Generated Function:
  (define (is_nested string)
    (define (has_nested? str)
      (define depth 0)
      (define max-depth 0)
      (define n (string-length str))
      (for ([i n])
        (cond
          [(char=? (string-ref str i) #\[)
           (set! depth (+ depth 1))
           (set! max-depth (max max-depth depth))]
          [(char=? (string-ref str i) #\])
           (cond
  ... (truncated)

Status: Exception
Exit Code: 0


============================================================
QUESTION #5: HumanEval_135_can_arrange
============================================================

PROBLEM DESCRIPTION:
--------------------
  #lang racket
  ;; Create a function which returns the largest index of an element which
  ;; is not greater than or equal to the element immediately preceding it. If
  ;; no such element exists then return -1. The given list will not contain
  ;; duplicate values.
  ;; Examples:
  ;; >>> (can_arrange (list 1 2 4 3 5))

TEST CASES:
-----------
  (define (test-humaneval)
  (test-humaneval)

FAILURE ANALYSIS:
----------------
  Total attempts: 4
  Successful: 0
  Failed: 4

  Failure patterns:
    - Exception_exit_0: 4 times
  Common error types:
    - Other error: 4 times

EXAMPLE FAILURE #1:
--------------------
Generated Function:
  (define (can_arrange arr)
    (define n (length arr))
    (cond
      [(< n 2) -1]
      [else
       (define (find-largest-descent idx)
         (cond
           [(= idx (sub1 n)) -1]
           [(< (list-ref arr idx) (list-ref arr (sub1 idx)))
            idx]
           [else
            (find-largest-descent (add1 idx))]))
  ... (truncated)

Status: Exception
Exit Code: 0

EXAMPLE FAILURE #2:
--------------------
Generated Function:
  (define (can_arrange arr)
    (define n (length arr))
    (cond
      [(< n 2) -1]  ; Need at least 2 elements to compare
      [else
       (define valid-indices
         (for/list ([i (in-range 1 n)])
           (if (<= (list-ref arr i) (list-ref arr (sub1 i)))
               i
               #f)))
       (if (null? valid-indices)
           -1
  ... (truncated)

Status: Exception
Exit Code: 0


============================================================
QUESTION #6: HumanEval_140_fix_spaces
============================================================

PROBLEM DESCRIPTION:
--------------------
  #lang racket
  ;; Given a string text, replace all spaces in it with underscores, 
  ;; and if a string has more than 2 consecutive spaces, 
  ;; then replace all consecutive spaces with - 
  ;; >>> (fix_spaces " Example")
  ;; "Example"
  ;; >>> (fix_spaces " Example 1")

TEST CASES:
-----------
  (define (test-humaneval)
  (test-humaneval)

FAILURE ANALYSIS:
----------------
  Total attempts: 4
  Successful: 0
  Failed: 4

  Failure patterns:
    - SyntaxError_exit_1: 3 times
    - Exception_exit_1: 1 times
  Common error types:
    - Other error: 4 times

EXAMPLE FAILURE #1:
--------------------
Generated Function:
  (define (fix_spaces text)
    (define (replace-spaces str)
      (define (process-char c)
        (cond
          [(char=? c #\space)
           (if (> (string-length str) 1)
               (let ([count (for/sum ([c (in-string str)]
                                      [i (in-naturals)])
                             (if (char=? c #\space) 1 0))])
                 (if (> count 2)
                     #\-
                     #\_)
  ... (truncated)

Status: SyntaxError
Exit Code: 1

EXAMPLE FAILURE #2:
--------------------
Generated Function:
  (define (fix_spaces text)
    (define (replace-spaces str)
      (define (process-char ch)
        (cond
          [(char=? ch #\space)
           (if (> (string-count-spaces str) 2)
               #\-
               #\_)]
          [else ch]))
      (string-for-each process-char str))
    (string-replace text " " "_"))

Status: Exception
Exit Code: 1


============================================================
QUESTION #7: HumanEval_141_file_name_check
============================================================

PROBLEM DESCRIPTION:
--------------------
  #lang racket
  ;; Create a function which takes a string representing a file's name, and returns
  ;; 'Yes' if the the file's name is valid, and returns 'No' otherwise.
  ;; A file's name is considered to be valid if and only if all the following conditions 
  ;; are met:
  ;; - There should not be more than three digits ('0'-'9') in the file's name.
  ;; - The file's name contains exactly one dot '.'

TEST CASES:
-----------
  (define (test-humaneval)
  (test-humaneval)

FAILURE ANALYSIS:
----------------
  Total attempts: 4
  Successful: 0
  Failed: 4

  Failure patterns:
    - SyntaxError_exit_1: 1 times
    - Exception_exit_1: 3 times
  Common error types:
    - Other error: 4 times

EXAMPLE FAILURE #1:
--------------------
Generated Function:
  (define (file_name_check file_name)
    (define dot-pos (string-index file_name #\.))
    
    ;; Check if there's exactly one dot
    (if (not dot-pos)
        "No"
        (let* ((before-dot (substring file_name 0 dot-pos))
               (after-dot (substring file_name (+ dot-pos 1) (string-length file_name))))
          ;; Check if before-dot is not empty and starts with a letter
          (if (or (string=? before-dot "") 
                  (not (regexp-match? #px"^[a-zA-Z]" before-dot)))
              "No"
  ... (truncated)

Status: SyntaxError
Exit Code: 1

EXAMPLE FAILURE #2:
--------------------
Generated Function:
  (define (file_name_check file_name)
    (define dot-pos (string-index file_name #\.))
    
    ;; Check if there's exactly one dot
    (if (not dot-pos)
        "No"
        (let* ((before-dot (substring file_name 0 dot-pos))
               (after-dot (substring file_name (+ dot-pos 1)))
               (file-name-length (string-length file_name))
               (digit-count (length (filter (lambda (c) (char-in-range? c #\0 #\9)) (string->list file_name))))
               (valid-extensions '( "txt" "exe" "dll" ))
               (extension-match (member after-dot valid-extensions))
  ... (truncated)

Status: Exception
Exit Code: 1


============================================================
QUESTION #8: HumanEval_145_order_by_points
============================================================

PROBLEM DESCRIPTION:
--------------------
  #lang racket
  ;; Write a function which sorts the given list of integers
  ;; in ascending order according to the sum of their digits.
  ;; Note: if there are several items with similar sum of their digits,
  ;; order them based on their index in original list.
  ;; For example:
  ;; >>> (order_by_points (list 1 11 -1 -11 -12))

TEST CASES:
-----------
  (define (test-humaneval)
  (test-humaneval)

FAILURE ANALYSIS:
----------------
  Total attempts: 4
  Successful: 0
  Failed: 4

  Failure patterns:
    - SyntaxError_exit_1: 4 times
  Common error types:
    - Other error: 4 times

EXAMPLE FAILURE #1:
--------------------
Generated Function:
  (define (order_by_points nums)
    (if (null? nums)
        '()
        (let ([sum-digits (lambda (n)
                            (let loop ([d (abs n)] [s 0])
                              (if (= d 0)
                                  s
                                  (loop (quotient d 10) (+ s (remainder d 10))))))])
          (sort nums
                (lambda (a b)
                  (let ([sa (sum-digits a)]
                        [sb (sum-digits b)])
  ... (truncated)

Status: SyntaxError
Exit Code: 1

EXAMPLE FAILURE #2:
--------------------
Generated Function:
  (define (order_by_points nums)
    (if (null? nums)
        '()
        (let ([sum-digits (lambda (n)
                            (let loop ([d (abs n)] [s 0])
                              (if (= d 0)
                                  s
                                  (loop (quotient d 10) (+ s (remainder d 10))))))])
          (sort nums
                (lambda (a b)
                  (let ([sa (sum-digits a)]
                        [sb (sum-digits b)])
  ... (truncated)

Status: SyntaxError
Exit Code: 1


============================================================
QUESTION #9: HumanEval_160_do_algebra
============================================================

PROBLEM DESCRIPTION:
--------------------
  #lang racket
  ;; Given two lists operator, and operand. The first list has basic algebra operations, and 
  ;; the second list is a list of integers. Use the two given lists to build the algebric 
  ;; expression and return the evaluation of this expression.
  ;; The basic algebra operations:
  ;; Addition ( + ) 
  ;; Subtraction ( - ) 

TEST CASES:
-----------
  (define (test-humaneval)
  (test-humaneval)

FAILURE ANALYSIS:
----------------
  Total attempts: 4
  Successful: 0
  Failed: 4

  Failure patterns:
    - Exception_exit_0: 2 times
    - Exception_exit_1: 1 times
    - SyntaxError_exit_1: 1 times
  Common error types:
    - Other error: 4 times

EXAMPLE FAILURE #1:
--------------------
Generated Function:
  (define (do_algebra operator operand)
    (define expr (list->string (map (lambda (x) (number->string x)) operand)))
    (define op-str (list->string (map (lambda (x) 
                                        (case x
                                          [(+) "+"]
                                          [(*) "*"]
                                          [(-) "-"]
                                          [(//) "//"]
                                          [(**) "**"]
                                          [else (error "Unsupported operator: " x)]))
                                    operator)))
    (define full-expr (string-join (append (list (number->string (first operand))) 
  ... (truncated)

Status: Exception
Exit Code: 0

EXAMPLE FAILURE #2:
--------------------
Generated Function:
  (define (do_algebra operator operand)
    (define expr (list->string (map string-append
                                     (map (lambda (op) (string op)) operator)
                                     (map (lambda (x) (number->string x)) operand)))))

Status: Exception
Exit Code: 1


============================================================
QUESTION #10: HumanEval_162_string_to_md5
============================================================

PROBLEM DESCRIPTION:
--------------------
  #lang racket
  ;; Given a string 'text', return its md5 hash equivalent string.
  ;; If 'text' is an empty string, return #f.
  ;; >>> (string_to_md5 "Hello world")
  ;; "3e25960a79dbc69b674cd4ec67a72c62"

TEST CASES:
-----------
  (define (test-humaneval)
  (test-humaneval)

FAILURE ANALYSIS:
----------------
  Total attempts: 4
  Successful: 0
  Failed: 4

  Failure patterns:
    - Exception_exit_0: 3 times
    - Exception_exit_1: 1 times
  Common error types:
    - Other error: 4 times

EXAMPLE FAILURE #1:
--------------------
Generated Function:
  (define (string_to_md5 text)
    (if (string=? text "")
        #f
        (error "MD5 hashing not supported in this reference context")))

Status: Exception
Exit Code: 0

EXAMPLE FAILURE #2:
--------------------
Generated Function:
  (define (string_to_md5 text)
    (if (string? text)
        (if (string=? text "")
            #f
            (error "MD5 hashing not supported in this environment; requires external package"))
        #f))

Status: Exception
Exit Code: 0


============================================================
QUESTION #11: HumanEval_163_generate_integers
============================================================

PROBLEM DESCRIPTION:
--------------------
  #lang racket
  ;; Given two positive integers a and b, return the even digits between a
  ;; and b, in ascending order.
  ;; For example:
  ;; >>> (generate_integers 2 8)
  ;; (list 2 4 6 8)
  ;; >>> (generate_integers 8 2)

TEST CASES:
-----------
  (define (test-humaneval)
  (test-humaneval)

FAILURE ANALYSIS:
----------------
  Total attempts: 4
  Successful: 0
  Failed: 4

  Failure patterns:
    - Exception_exit_0: 3 times
    - Exception_exit_1: 1 times
  Common error types:
    - Other error: 4 times

EXAMPLE FAILURE #1:
--------------------
Generated Function:
  (define (generate_integers a b)
    (let ([start (min a b)]
          [end (max a b)])
      (for/list ([i (in-range start (add1 end))])
        (if (even? i)
            i
            #f))))

Status: Exception
Exit Code: 0

EXAMPLE FAILURE #2:
--------------------
Generated Function:
  (define (generate_integers a b)
    (let ([start (min a b)]
          [end (max a b)])
      (for/list ([i (in-range start (add1 end))])
        (if (even? i)
            i
            #f))))

Status: Exception
Exit Code: 0


============================================================
QUESTION #12: HumanEval_54_same_chars
============================================================

PROBLEM DESCRIPTION:
--------------------
  #lang racket
  ;; Check if two words have the same characters.
  ;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddeddabc")
  ;; #t
  ;; >>> (same_chars "abcd" "dddddddabc")
  ;; #t
  ;; >>> (same_chars "dddddddabc" "abcd")

TEST CASES:
-----------
  (define (test-humaneval)
  (test-humaneval)

FAILURE ANALYSIS:
----------------
  Total attempts: 4
  Successful: 0
  Failed: 4

  Failure patterns:
    - Exception_exit_0: 3 times
    - SyntaxError_exit_1: 1 times
  Common error types:
    - Other error: 4 times

EXAMPLE FAILURE #1:
--------------------
Generated Function:
  (define (same_chars s0 s1)
    (equal? (sort (string->list s0)) (sort (string->list s1))))

Status: Exception
Exit Code: 0

EXAMPLE FAILURE #2:
--------------------
Generated Function:
  (define (same_chars s0 s1)
    (define len0 (string-length s0))
    (define len1 (string-length s1))
    
    ;; If lengths differ, they can't have same characters
    (if (not (= len0 len1))
        #f
        ;; Otherwise, compare character frequencies
        (let loop ([s0 s0] [s1 s1] [freq (make-hash)])
          (cond
            [(string=? s0 "") #t]
            [(string=? s1 "") #f]
  ... (truncated)

Status: SyntaxError
Exit Code: 1


============================================================
QUESTION #13: HumanEval_68_pluck
============================================================

PROBLEM DESCRIPTION:
--------------------
  #lang racket
  ;; "Given a list representing a branch of a tree that has non-negative integer nodes
  ;; your task is to pluck one of the nodes and return it.
  ;; The plucked node should be the node with the smallest even value.
  ;; If multiple nodes with the same smallest even value are found return the node that has smallest index.
  ;; The plucked node should be returned in a list, [ smalest_value, its index ],
  ;; If there are no even values or the given list is empty, return [].

TEST CASES:
-----------
  (define (test-humaneval)
  (test-humaneval)

FAILURE ANALYSIS:
----------------
  Total attempts: 4
  Successful: 0
  Failed: 4

  Failure patterns:
    - SyntaxError_exit_1: 3 times
    - Exception_exit_1: 1 times
  Common error types:
    - Other error: 4 times

EXAMPLE FAILURE #1:
--------------------
Generated Function:
  (define (pluck arr)
    (if (null? arr)
        '()
        (let loop ([lst arr] [idx 0])
          (if (null? lst)
              '()
              (let ([val (car lst)])
                (if (even? val)
                    (let ([result (loop (cdr lst) (+ idx 1))])
                      (if (null? result)
                          (list val idx)
                          result))
  ... (truncated)

Status: SyntaxError
Exit Code: 1

EXAMPLE FAILURE #2:
--------------------
Generated Function:
  (define (pluck arr)
    (if (null? arr)
        '()
        (let loop ([lst arr]
                   [min-even #f]
                   [min-index #f])
          (cond
            [(null? lst) (if min-even (list min-even min-index) '())]
            [else
             (let ([val (car lst)]
                   [idx (cadr (cons (car lst) (cons (car lst) (cdr lst))))])
               (if (even? val)
  ... (truncated)

Status: SyntaxError
Exit Code: 1


============================================================
QUESTION #14: HumanEval_92_any_int
============================================================

PROBLEM DESCRIPTION:
--------------------
  #lang racket
  ;; Create a function that takes 3 numbers.
  ;; Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
  ;; Returns false in any other cases.
  ;; Examples
  ;; >>> (any_int 5 2 7)
  ;; #t

TEST CASES:
-----------
  (define (test-humaneval)
  (test-humaneval)

FAILURE ANALYSIS:
----------------
  Total attempts: 4
  Successful: 0
  Failed: 4

  Failure patterns:
    - Exception_exit_0: 4 times
  Common error types:
    - Other error: 4 times

EXAMPLE FAILURE #1:
--------------------
Generated Function:
  (define (any_int x y z)
    (and (integer? x) (integer? y) (integer? z)
         (or (= x (+ y z)) (= y (+ x z)) (= z (+ x y)))))

Status: Exception
Exit Code: 0

EXAMPLE FAILURE #2:
--------------------
Generated Function:
  (define (any_int x y z)
    (and (integer? x) (integer? y) (integer? z)
         (or (= x (+ y z)) (= y (+ x z)) (= z (+ x y)))))

Status: Exception
Exit Code: 0


================================================================================
OVERALL PATTERNS AND INSIGHTS - RACKET
================================================================================

Common issues observed across these universal failing questions:

1. Racket-specific syntax issues:
   - S-expression and parentheses balancing problems
   - List processing and recursion errors
   - Function definition syntax issues

2. Logic errors:
   - Incorrect algorithm implementation
   - Off-by-one errors in loops
   - Misunderstanding of problem requirements

3. Edge case handling:
   - Poor handling of empty collections
   - Incorrect handling of special input values
   - Missing validation for boundary conditions

These patterns suggest the LLM needs better training on:
- Modern Racket syntax and idioms
- Algorithm implementation in Racket
- Edge case handling and input validation
- Language-specific data structure manipulation