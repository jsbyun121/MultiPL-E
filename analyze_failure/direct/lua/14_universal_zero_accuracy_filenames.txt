Universal Zero Accuracy Cases - Lua (DIRECT)
============================================================

These questions achieved 0% accuracy across ALL 5 languages.

 1. HumanEval_116_sort_array.results.json.gz
    -- In this Kata, you have to sort a table of non-negative integers according to
    -- number of ones in their binary representation in ascending order.
    -- For similar number of ones, sort based on decimal value.
    -- It must be implemented like this:
    -- >>> sort_array({1, 5, 2, 3, 4})
    -- {1, 2, 3, 4, 5}
    -- >>> sort_array({-2, -3, -4, -5, -6})
    -- {-6, -5, -4, -3, -2}
    -- >>> sort_array({1, 0, 2, 3, 4})
    -- {0, 1, 2, 3, 4}
    local function sort_array(arr)
        local function count_ones(n)
            local count = 0
            while n > 0 do
                count = count + (n % 2)
                n = math.floor(n / 2)
            end
            return count
        end

        table.sort(arr, function(a, b)
            local ones_a = count_ones(a)
            local ones_b = count_ones(b)
            
            if ones_a ~= ones_b then
                return ones_a < ones_b
            else
                return a < b
            end
        end)
        
        return arr
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = sort_array
        lu.assertEquals(candidate({1, 5, 2, 3, 4}), {1, 2, 4, 3, 5})
        lu.assertEquals(candidate({-2, -3, -4, -5, -6}), {-4, -2, -6, -5, -3})
        lu.assertEquals(candidate({1, 0, 2, 3, 4}), {0, 1, 2, 4, 3})
        lu.assertEquals(candidate({}), {})
        lu.assertEquals(candidate({2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77})
        lu.assertEquals(candidate({3, 6, 44, 12, 32, 5}), {32, 3, 5, 6, 12, 44})
        lu.assertEquals(candidate({2, 4, 8, 16, 32}), {2, 4, 8, 16, 32})
        lu.assertEquals(candidate({2, 4, 8, 16, 32}), {2, 4, 8, 16, 32})
    end

    os.exit(lu.LuaUnit.run())

-> Wrong Instruction




 2. HumanEval_129_minPath.results.json.gz

-> Insufficient Algorithm (Too elaborative)




 3. HumanEval_130_tri.results.json.gz

-> Insufficient Algorithm




 4. HumanEval_132_is_nested.results.json.gz

 -> Insufficient Algorithm




 5. HumanEval_134_check_if_last_char_is_a_letter.results.json.gz

 -> Slightly Wrong Algorithm

    if len == 1 then
        return false  -- single character - not preceded by space, so not part of a word
    end

    as a context it should use True... But why it used false? is it because just false is negative word as not preceded by space, so not part of a word?

    and for other example it made, slightly wrong algorithm



 6. HumanEval_135_can_arrange.results.json.gz

 -> Slightly Wrong Algorithm

    have to search in reverse order but it didn't

    All 4 examples did it so...



 7. HumanEval_145_order_by_points.results.json.gz

 -> Wrong Test Case...

    order_by_points({1, 11, -1, -11, -12})
    is not {-1, -11, 1, -12, 11}

    {-1, 1, -11, 11, -12}!



 8. HumanEval_160_do_algebra.results.json.gz

 -> Wrong order of operations



 9. HumanEval_162_string_to_md5.results.json.gz

 -> Wrong Lua library use
 -> Test case also wrong



10. HumanEval_163_generate_integers.results.json.gz

-> Wrong Algorithm



11. HumanEval_37_sort_even.results.json.gz

-> Wrong Test Case



12. HumanEval_54_same_chars.results.json.gz

-> Wrong Algorithm



13. HumanEval_68_pluck.results.json.gz

-> Slightly Wrong Algorithm
   (Index difference)



14. HumanEval_84_solve.results.json.gz

-> Slightly Wrong Algorithm
   (Used decimal digits, not binary digits)



15. HumanEval_91_is_bored.results.json.gz

-> Wrong Algorithm
    : string parsing problem, misunderstood the concept of boredom



16. HumanEval_92_any_int.results.json.gz

-> Wrong Algorithm
    if not (is_integer(x) and is_integer(y) and is_integer(z)) then
        return false
    end

    same patterns

Total: 16 universal failure cases
